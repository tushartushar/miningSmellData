Implementation smell,Namespace,Class,File,Method,Description
Long Method,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,The method has 101 lines of code.
Long Method,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The method has 101 lines of code.
Long Method,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The method has 143 lines of code.
Long Method,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The method has 549 lines of code.
Complex Method,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,Cyclomatic complexity of the method is 8
Complex Method,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDoubleClickEvent,Cyclomatic complexity of the method is 8
Complex Method,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,Cyclomatic complexity of the method is 10
Long Parameter List,TypeSystemExplorer.Views,DrawTextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The method has 5 parameters. Parameters: e' start' end' text' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The method has 6 parameters. Parameters: graphics' s' font' brush' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The method has 8 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The method has 6 parameters. Parameters: graphics' s' font' brush' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The method has 8 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The method has 9 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' letterSpace' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The method has 9 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' letterSpace' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The method has 10 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' letterSpace' rotateDegree' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The method has 10 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' letterSpace' rotateDegree' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawTextOnPath,The method has 7 parameters. Parameters: pathdata' text' font' color' fillcolor' letterspacepercentage' vOffset
Long Parameter List,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The method has 7 parameters. Parameters: r' m1' prot1' permeableProtocol' rPoint' source' rootOnly
Long Statement,TypeSystemExplorer.Actions,InitializeMruMenu,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Actions\InitializeMruMenu.cs,EndInit,The length of the statement  "			mruMenu = new MruStripMenuInline(MenuFile' MenuRecentFiles' new MruStripMenu.ClickedHandler(OnMruFile)' mruRegKey + "\\MRU"' true' 9); " is 134.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => View.Location = new Point(state.Single(t => t.Key == "X").Value.to_i()' state.Single(t => t.Key == "Y").Value.to_i())); " is 142.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => View.Size = new Size(state.Single(t => t.Key == "W").Value.to_i()' state.Single(t => t.Key == "H").Value.to_i())); " is 137.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => appletUiContainerForm.Location = new Point(state.Single(t => t.Key == "UIX").Value.to_i()' state.Single(t => t.Key == "UIY").Value.to_i())); " is 163.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => appletUiContainerForm.Size = new Size(state.Single(t => t.Key == "UIW").Value.to_i()' state.Single(t => t.Key == "UIH").Value.to_i())); " is 158.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => appletUiContainerForm.WindowState = state.Single(t => t.Key == "UIWindowState").Value.ToEnum<FormWindowState>()); " is 136.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,AddAppletUI,The length of the statement  "//				GenericDocument gd = AppletUiContainerView.DockPanel.Documents.Cast<GenericDocument>().SingleOrDefault(d => d.ContentMetadata == strLayoutId); " is 148.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,AddAppletUI,The length of the statement  "				// GenericPane gp = AppletUiContainerView.DockPanel.Panes.Cast<GenericPane>().SingleOrDefault(p => p.ContentMetadata == strLayoutId); " is 133.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,CreateTypes,The length of the statement  "							sts.NativeTypes.Add(new Clifton.SemanticTypeSystem.NativeType() { Name = nt.Name' ImplementingType = nt.ImplementingType' Alias = nt.Alias' Ordinality = nt.Ordinality' UniqueField = nt.UniqueField }); " is 200.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,CreateTypes,The length of the statement  "							sts.SemanticElements.Add(new Clifton.SemanticTypeSystem.SemanticElement() { Name = subt.Name' Alias = subt.Alias' UniqueField = subt.UniqueField' Ordinality = subt.Ordinality }); " is 178.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SaveReceptorsInternal,The length of the statement  "			AddAttribute(appletNode' "SurfaceOffset"' visualizerController.View.SurfaceOffset.X + "'" + visualizerController.View.SurfaceOffset.Y); " is 135.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorProtocolStates,The length of the statement  "				XmlNode rpNodes = rNode.OwnerDocument.CreateElement("ixm"' "ReceiveProtocols"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 128.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorProtocolStates,The length of the statement  "						XmlNode rpNode = rNode.OwnerDocument.CreateElement("ixm"' "ReceiveProtocol"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 126.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorProtocolStates,The length of the statement  "				XmlNode epNodes = rNode.OwnerDocument.CreateElement("ixm"' "EmitProtocols"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 125.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorProtocolStates,The length of the statement  "					XmlNode epNode = rNode.OwnerDocument.CreateElement("ixm"' "EmitProtocol"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 123.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorUserConfigurableProperties,The length of the statement  "								XmlNode uiNode = uiConfigs.OwnerDocument.CreateElement("ixm"' "UserConfig"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 125.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,LoadAppletInternal,The length of the statement  "			VisualizerController.View.ShowMembranes = false;		// don't show membranes while we're loading the applet.  Causes problems because the model isn't fully loaded! " is 160.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "							// Kludgy' but we need to cache the emit protocol enable states for receptors that dynamically register emit protocols based on user configuration or other info. " is 161.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "							rec.Instance.GetEmittedProtocols().SingleOrDefault(p => p.Protocol == ep.Protocol).IfNotNull(p => p.Enabled = ep.Enabled); " is 122.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "							// Kludgy' but we need to cache the receive protocol enable states for receptors that dynamically register receive protocols based on user configuration or other info. " is 167.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "							rec.Instance.GetReceiveProtocols().SingleOrDefault(p => p.Protocol == rp.Protocol).IfNotNull(p => p.Enabled = rp.Enabled); " is 122.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "								// TODO: A property name is now invalid.  Is this because the name was changed intentionally or because of an actual fault? " is 123.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "					membrane.ProtocolPermeability[new PermeabilityKey() { Protocol = p.Protocol' Direction = p.Direction }] = new PermeabilityConfiguration() { Permeable = p.Permeable' RootOnly = p.RootOnly }; " is 189.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,LogException,The length of the statement  "			MessageBox.Show(ex.Message + "\r\n" + Assert.ErrorMessage + "\r\n" + ex.StackTrace' "An error has occurred."' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 154.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,GetReceiveProtocols,The length of the statement  "			(new string[] { "SystemMessage"' "CarrierAnimation"' "SystemShowImage"' "HaveImageMetadata" }).ForEach(p => ret.Add(new ReceiveQualifier(p))); " is 142.
Long Statement,TypeSystemExplorer.Controllers,PropertyGridController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\PropertyGridController.cs,OnPropertyValueChanged,The length of the statement  "			// Annoyingly' the property grid change notifier doesn't give us the property name' it gives us the display name for the property being changed. " is 144.
Long Statement,TypeSystemExplorer.Controllers,PropertyGridController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\PropertyGridController.cs,OnPropertyValueChanged,The length of the statement  "			// TODO: We might be better off trying to figure out how to wire up an event for the Name property when instances are created. " is 126.
Long Statement,TypeSystemExplorer.Controllers,ReceptorChooserController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,OnAddReceptors,The length of the statement  "				ApplicationController.VisualizerController.View.ClientDropPoint = ApplicationController.VisualizerController.View.NegativeSurfaceOffsetAdjust(new Point(x' 100)); " is 161.
Long Statement,TypeSystemExplorer.Controllers,ReceptorChooserController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,InitializeReceptorEntriesList,The length of the statement  "			receptors.Add(new ReceptorEntry() { Name = "Carrier List Viewer"' Filename = "CarrierListViewerReceptor.dll" });		// TODO: "Carrier" or "Signal" ?  What's the difference ? " is 171.
Long Statement,TypeSystemExplorer.Controllers,ReceptorChooserController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,InitializeReceptorEntriesList,The length of the statement  "			receptors.Add(new ReceptorEntry() { Name = "Carrier Tree Viewer"' Filename = "CarrierTreeViewerReceptor.dll" });		// TODO: "Carrier" or "Signal" ?  What's the difference ? " is 171.
Long Statement,TypeSystemExplorer.Controllers,ReceptorChooserController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,InitializeReceptorEntriesList,The length of the statement  "			receptors.Add(new ReceptorEntry() { Name = "Tabbed Carrier List Viewer"' Filename = "CarrierTabbedListViewerReceptor.dll" });		// TODO: "Carrier" or "Signal" ?  What's the difference ? " is 184.
Long Statement,TypeSystemExplorer.Controllers,VisualizerController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\VisualizerController.cs,DragDropEvent,The length of the statement  "					else if (fn.ToLower().RightOfRightmostOf('.').ToLower().Contains(new string[] {"jpg"' "png"' "bmp"' "gif"}) != String.Empty) " is 124.
Long Statement,TypeSystemExplorer.Controllers,VisualizerController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\VisualizerController.cs,DragDropEvent,The length of the statement  "						// TODO: We need to figure out how to do computed types' so that I can assign a fully qualified name and set the discrete sub-types Path' Name' and FileExtension. " is 162.
Long Statement,TypeSystemExplorer,ToolWindow,C:\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The length of the statement  "			this.DockAreas = ((WeifenLuo.WinFormsUI.Docking.DockAreas)(((((WeifenLuo.WinFormsUI.Docking.DockAreas.Float | WeifenLuo.WinFormsUI.Docking.DockAreas.DockLeft)  " is 158.
Long Statement,TypeSystemExplorer,ToolWindow,C:\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The length of the statement  "			this.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 149.
Long Statement,TypeSystemExplorer.Models,ImplementingTypeNameConverter,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Models\TypeConverters.cs,GetStandardValues,The length of the statement  "			List<string> names = new List<string>() { "char"' "string"' "bool"' "int"' "long"' "float"' "double"' "decimal"' "DateTime"' "Object"}; " is 135.
Long Statement,TypeSystemExplorer.Views,DrawTextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The length of the statement  "			System.Drawing.RectangleF[] regions = e.Graphics.MeasureString(text' new Font(FontFamily.GenericSansSerif' fontSize' FontStyle.Regular)' new SolidBrush(textColor)' TextPathAlign.Center' TextPathPosition.OverPath' letterSpacing' 0' myPath' vOffset); " is 248.
Long Statement,TypeSystemExplorer.Views,DrawTextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The length of the statement  "			e.Graphics.DrawString(text' new Font(FontFamily.GenericSansSerif' fontSize' FontStyle.Regular)' new SolidBrush(textColor)' TextPathAlign.Center' TextPathPosition.OverPath' letterSpacing' 0' myPath' vOffset); " is 207.
Long Statement,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The length of the statement  "			return MeasureString(graphics' s' font' brush' TextPathAlign.Left' TextPathPosition.CenterPath' 100' graphicsPath' vOffset); " is 124.
Long Statement,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawTextOnPath,The length of the statement  "					if (gp.PathTypes[i + 1] == (byte)PathPointType.Start | (gp.PathTypes[i] & (byte)PathPointType.CloseSubpath) == (byte)PathPointType.CloseSubpath) " is 144.
Long Statement,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The length of the statement  "					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size - VerticalOffset))' stringFormat); " is 145.
Long Statement,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The length of the statement  "					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size / 2))' stringFormat); " is 132.
Long Statement,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The length of the statement  "					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' y + VerticalOffset)' stringFormat); " is 125.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "				// Oops.  The carrier animation has been consumed' but there are more receptors for this carrier' so we need to add another carrier animation now. " is 146.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "				// Get an existing animation for this carrier.  We don't care what carrier we get' because they're all going to be originating from the same receptor. " is 150.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = existing.StartPosition' OnArrivalDo = action' Target = to' Carrier = carrier }); " is 147.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "					// We have a carrier that wasn't registered by our event handler' so we have absolutely no clue where it goes.  Place it randomly. " is 130.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "					// carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' OnArrivalDo = action' Target = to' Carrier = carrier }); " is 129.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "				carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' OnArrivalDo = action' Target = to' Carrier=carrier }); " is 124.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "				carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' OnArrivalDo = action' Target = to' Carrier = carrier }); " is 126.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,ProcessImageMetadata,The length of the statement  "			// Get the the first carousel key-value pair (Receptor' CarouselState) which contains the image for which we received the metadata. " is 131.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,ProcessImageMetadata,The length of the statement  "			var carousel = carousels.FirstOrDefault(kvp => kvp.Value.Images.Count(imeta => Path.GetFileName(imeta.Image.Tag.ToString().Surrounding("-thumbnail")) == fn) > 0); " is 162.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,ProcessImageMetadata,The length of the statement  "				List<MetadataPacket> packets = carousel.Value.Images.First(m => Path.GetFileName(m.Image.Tag.ToString().Surrounding("-thumbnail")) == fn).MetadataPackets; " is 154.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnNewCarrier,The length of the statement  "			// TODO: We need to check if any receptors exist and whether any are hidden or not.  If it's hidden' then we don't create a carrier animation instance. " is 151.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnNewCarrier,The length of the statement  "					p.Offset((int)(ReceptorSize.Width * Math.Cos(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3' (int)(ReceptorSize.Height * Math.Sin(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3); " is 182.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,The length of the statement  "					// Sometimes membranes can contain other membranes where the outer membrane has no receptors' resulting in the nubs being in exactly the same locations. " is 152.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,The length of the statement  "					var selectedMembranes = membraneLocation.Where(kvp => PointInCircle(SurfaceOffsetAdjust(kvp.Value.Center)' MembraneNubRadius' testPoint)); " is 138.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y)); " is 197.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				List<IReceptor> receptors = receptorLocation.Where(kvp => parentMembrane.Receptors.Contains(kvp.Key) && testR.Contains(kvp.Value) && !kvp.Key.Instance.IsHidden).Select(kvp => kvp.Key).ToList(); " is 193.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				List<IMembrane> membranes = membraneLocation.Where(kvp => (kvp.Key.ParentMembrane == parentMembrane) && testR.Contains(CircleToBoundingRectangle(kvp.Value.Center' kvp.Value.Radius))).Select(kvp => kvp.Key).ToList(); " is 215.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				// Get receptors inside the rectangle' ignoring any hidden receptors--a defensive measure if we ever decide to show the system receptor. " is 136.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				// List<IReceptor> receptors = receptorLocation.Where(kvp => testR.Contains(kvp.Value) && !kvp.Key.Instance.IsHidden).Select(kvp => kvp.Key).ToList(); " is 150.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseWheelEvent,The length of the statement  "			var hoverReceptors = receptorLocation.Where(kvp => (new Rectangle(Point.Subtract(kvp.Value' ReceptorHalfSize)' ReceptorSize)).Contains(testPoint)); " is 147.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The length of the statement  "						Rectangle metaRect = new Rectangle(imgArea.Left' imgArea.Bottom + 10 + (MetadataHeight * idx)' imgArea.Width' MetadataHeight); " is 126.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The length of the statement  "									string implementingPropertyName = sts.GetSemanticTypeStruct(meta.ProtocolName).SemanticElements.Single(e => e.Name == meta.PropertyName).GetImplementingName(sts); " is 162.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The length of the statement  "									protocol.AllTypes.Single(e => e.Name == implementingPropertyName).SetValue(Program.SemanticTypeSystem' signal' meta.Value); " is 123.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The length of the statement  "									sts.GetSemanticTypeStruct(meta.ProtocolName).NativeTypes.Single(st => st.Name == meta.PropertyName).SetValue(Program.SemanticTypeSystem' signal' meta.Value); " is 157.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PopulateControls,The length of the statement  "				foreach (PropertyControlEntry pce in ((PropertyControlMap)mp.ObjectCollection["ControlMap"]).Entries)		// TODO: magic name. " is 123.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PopulateControls,The length of the statement  "					PropertyInfo piReceptor = r.Instance.GetType().GetProperty(pce.PropertyName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); " is 147.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PopulateControls,The length of the statement  "					PropertyInfo piControl = control.GetType().GetProperty(pce.ControlPropertyName' BindingFlags.Public | BindingFlags.Instance); " is 125.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,SaveValues,The length of the statement  "				foreach (PropertyControlEntry pce in ((PropertyControlMap)mp.ObjectCollection["ControlMap"]).Entries)		// TODO: magic name. " is 123.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,SaveValues,The length of the statement  "					PropertyInfo piReceptor = r.GetType().GetProperty(pce.PropertyName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); " is 138.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,SaveValues,The length of the statement  "					PropertyInfo piControl = control.GetType().GetProperty(pce.ControlPropertyName' BindingFlags.Public | BindingFlags.Instance); " is 125.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnReceptorConfigOK,The length of the statement  "					MessageBox.Show(ci.Receptor.Instance.ConfigurationError' "Please correct..."' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 122.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "				CarrierAnimationItem item = carrierAnimations.FirstOrDefault(a => a.CurrentRegion.Contains(NegativeSurfaceOffsetAdjust(mousePosition))); " is 136.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "					// The property grid is sort of stupid' so we'll put together an anonymous object for displaying the carrier protocol and signal. " is 129.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "					// new { Protocol = item.Carrier.Protocol.DeclTypeName' from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new {Name = t.Name' Value = t.GetValue(item.Carrier.Signal)}}; " is 232.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "					// var obj = (from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new { Name = t.Name' Value = t.GetValue(item.Carrier.Signal) }).First(); " is 200.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "					var kvpList = (from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new { Name = t.Name' Value = t.GetValue(Program.SemanticTypeSystem' item.Carrier.Signal) }); // .ForEach((item) = " is 242.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CreateReceptorConnections,The length of the statement  "			// The "System" receptor can also be the originator of protocols.  Any protocol that the membrane's receptors receive protocols that aren't mapped to emitting receptors should be mapped to system. " is 196.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CreateReceptorConnections,The length of the statement  "			// However' because carriers are dropped into a particular membrane' we can't just assign the global system receptor to a bunch of receiving receptors' as these could be in different membranes. " is 193.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CreateReceptorConnections,The length of the statement  "			// the master receptor connection list is keyed by receptor instances in particular membranes' so this is ok.  The same cannot be said of the global system receptor.  Therefore' we have to " is 188.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "						// var intersection = kvp2.Key.Instance.GetEnabledReceiveProtocols().Select(rp => rp.Protocol).Intersect(r.Instance.GetEnabledEmittedProtocols().Select(ep => ep.Protocol)); " is 172.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "								trace.AppendLine("Connecting receiver '" + kvp2.Key.Instance.Name + "' with transmitter '" + r.Instance.Name + "' on root only protocol " + prot1 + " permeable via " + permeableProtocol); " is 187.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "								trace.AppendLine("Connecting receiver '" + kvp2.Key.Instance.Name + "' with transmitter '" + r.Instance.Name + "' on protocol " + prot1 + " permeable via " + permeableProtocol); " is 177.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "							// Horrid check for duplicates.  We get duplicates because we scan each receptor (regardless of membrane) and try to find matches. " is 130.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "					trace.AppendLine(level.ToString() + ": Membrane is outbound permeable to " + prot1 + ((rootOnly || pconfig2.RootOnly) ? " root only " : "")); " is 141.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "								trace.AppendLine("Testing receptor '" + r.Instance.Name + "' emit protocol " + prot1A.Protocol); // + "' Root only = " + (rootOnly || pconfig2.RootOnly).ToString()); " is 165.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "							trace.AppendLine(level.ToString() + ": Membrane is inbound permeable to " + prot1 + ((rootOnly || pconfig2.RootOnly) ? " root only " : "")); " is 140.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "								// Get the emitted protocols of this receptor and check them all with receive protocols of receptors in the inner membrane. " is 123.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "										trace.AppendLine("Testing receptor '" + r.Instance.Name + "' emit protocol " + prot1A.Protocol);// + "' Root only = " + (rootOnly || pconfig2.RootOnly).ToString()); " is 164.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,RecalcMembranes,The length of the statement  "					else if (m.ParentMembrane != null) // Obviously' don't remove the Skin membrane (not that it's in the list at the moment anyways.) " is 130.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle))); " is 146.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2)); " is 137.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2 " is 121.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2 " is 121.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again. " is 125.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width))); " is 148.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100 " is 126.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width))); " is 151.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)); " is 142.
Long Statement,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y)); " is 197.
Magic Number,TypeSystemExplorer.Actions,InitializeMruMenu,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Actions\InitializeMruMenu.cs,EndInit,The following statement contains a magic number: mruMenu = new MruStripMenuInline(MenuFile' MenuRecentFiles' new MruStripMenu.ClickedHandler(OnMruFile)' mruRegKey + "\\MRU"' true' 9);
Magic Number,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,FitToScreen,The following statement contains a magic number: if (form != null)  			{  				if (!SystemInformation.VirtualScreen.Contains(form.Location))  				{  					form.Location = new Point(0' 0);  				}    				Size diff = SystemInformation.VirtualScreen.Size - form.Size;    				if ((diff.Width < 0) || (diff.Height < 0))  				{  					Size sz = new Size(SystemInformation.VirtualScreen.Width / 4' SystemInformation.VirtualScreen.Height / 4);  					form.Size = sz;  				}  			}
Magic Number,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,FitToScreen,The following statement contains a magic number: if (form != null)  			{  				if (!SystemInformation.VirtualScreen.Contains(form.Location))  				{  					form.Location = new Point(0' 0);  				}    				Size diff = SystemInformation.VirtualScreen.Size - form.Size;    				if ((diff.Width < 0) || (diff.Height < 0))  				{  					Size sz = new Size(SystemInformation.VirtualScreen.Width / 4' SystemInformation.VirtualScreen.Height / 4);  					form.Size = sz;  				}  			}
Magic Number,TypeSystemExplorer.Controllers,ReceptorChooserController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,OnAddReceptors,The following statement contains a magic number: int x = 100;
Magic Number,TypeSystemExplorer.Controllers,ReceptorChooserController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,OnAddReceptors,The following statement contains a magic number: foreach (ReceptorEntry r in View.ReceptorList.CheckedItems)  			{  				ApplicationController.VisualizerController.View.ClientDropPoint = ApplicationController.VisualizerController.View.NegativeSurfaceOffsetAdjust(new Point(x' 100));  				IReceptor droppedReceptor = dropInto.RegisterReceptor(Path.GetFullPath(r.Filename));  				receptors.Add(droppedReceptor);  				dropInto.LoadReceptors();  				x += 80;  			}
Magic Number,TypeSystemExplorer.Controllers,ReceptorChooserController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,OnAddReceptors,The following statement contains a magic number: foreach (ReceptorEntry r in View.ReceptorList.CheckedItems)  			{  				ApplicationController.VisualizerController.View.ClientDropPoint = ApplicationController.VisualizerController.View.NegativeSurfaceOffsetAdjust(new Point(x' 100));  				IReceptor droppedReceptor = dropInto.RegisterReceptor(Path.GetFullPath(r.Filename));  				receptors.Add(droppedReceptor);  				dropInto.LoadReceptors();  				x += 80;  			}
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,LabeledTextBox,The following statement contains a magic number: tbData.KeyPress += ((object sender' KeyPressEventArgs args) =>  				{  					if (args.KeyChar == 13)  					{  						OnTextChanged();  					}  				});
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.lblTextBox.Location = new System.Drawing.Point(5' 3);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.lblTextBox.Location = new System.Drawing.Point(5' 3);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.lblTextBox.Size = new System.Drawing.Size(78' 23);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.lblTextBox.Size = new System.Drawing.Size(78' 23);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.tbData.Location = new System.Drawing.Point(89' 0);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.tbData.Size = new System.Drawing.Size(245' 20);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.tbData.Size = new System.Drawing.Size(245' 20);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(337' 20);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(337' 20);
Magic Number,TypeSystemExplorer.Controls,OutputControl,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\OutputControl.cs,InitializeProperties,The following statement contains a magic number: properties.Font = new Font("Consolas"' 8' FontStyle.Regular);
Magic Number,TypeSystemExplorer.Controls,OutputControl,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\OutputControl.cs,InitializeProperties,The following statement contains a magic number: properties.TabIndent = 2;
Magic Number,TypeSystemExplorer.Controls,XmlTextEditorControl,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\XmlTextEditorControl.cs,InitializeProperties,The following statement contains a magic number: properties.Font = new Font("Consolas"' 8' FontStyle.Regular);
Magic Number,TypeSystemExplorer.Controls,XmlTextEditorControl,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\XmlTextEditorControl.cs,InitializeProperties,The following statement contains a magic number: properties.TabIndent = 2;
Magic Number,TypeSystemExplorer,ToolWindow,C:\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(292' 266);
Magic Number,TypeSystemExplorer,ToolWindow,C:\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(292' 266);
Magic Number,TypeSystemExplorer,MouseWheelMessageFilter,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Program.cs,PreFilterMessage,The following statement contains a magic number: if (m.Msg == WM_MOUSEWHEEL)  			{  				// LParam contains the location of the mouse pointer  				Point pos = new Point(m.LParam.ToInt32() & 0xffff' m.LParam.ToInt32() >> 16);  				IntPtr hWnd = WindowFromPoint(pos);  				if (hWnd != IntPtr.Zero && hWnd != m.HWnd && Control.FromHandle(hWnd) != null)  				{  					// redirect the message to the correct control  					SendMessage(hWnd' m.Msg' m.WParam' m.LParam);  					return true;  				}  			}
Magic Number,TypeSystemExplorer.Views,DrawTextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The following statement contains a magic number: int fontSize = 10;
Magic Number,TypeSystemExplorer.Views,DrawTextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The following statement contains a magic number: int letterSpacing = 100;
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The following statement contains a magic number: return MeasureString(graphics' s' font' brush' TextPathAlign.Left' TextPathPosition.CenterPath' 100' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The following statement contains a magic number: return MeasureString(graphics' s' font' brush' textPathAlign' textPathPosition' 100' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The following statement contains a magic number: DrawString(graphics' s' font' brush' TextPathAlign.Left' TextPathPosition.CenterPath' 100' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The following statement contains a magic number: DrawString(graphics' s' font' brush' textPathAlign' textPathPosition' 100' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The following statement contains a magic number: return MeasureString(graphics' s' font' brush' textPathAlign' textPathPosition' 100' 0' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The following statement contains a magic number: DrawString(graphics' s' font' brush' textPathAlign' textPathPosition' 100' 0' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawTextOnPath,The following statement contains a magic number: PointF[] points = new PointF[25001];
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawTextOnPath,The following statement contains a magic number: try  			{  				PointF tmpPoint = gp.PathPoints[0];  				int i;  				for (i = 0; i <= gp.PathPoints.Length - 2; i++)  				{  					if (gp.PathTypes[i + 1] == (byte)PathPointType.Start | (gp.PathTypes[i] & (byte)PathPointType.CloseSubpath) == (byte)PathPointType.CloseSubpath)  					{  						tmpPoints = GetLinePoints(gp.PathPoints[i]' tmpPoint' 1);  						Array.ConstrainedCopy(tmpPoints' 0' points' count' tmpPoints.Length);  						count += 1;  						tmpPoint = gp.PathPoints[i + 1];  					}  					else  					{  						tmpPoints = GetLinePoints(gp.PathPoints[i]' gp.PathPoints[i + 1]' 1);  						Array.ConstrainedCopy(tmpPoints' 0' points' count' tmpPoints.Length);  						count += tmpPoints.Length - 1;    					}  				}  				tmpPoints = new PointF[count];  				Array.Copy(points' tmpPoints' count);  				points = CleanPoints(tmpPoints);    				count = points.Length - 1;  				DrawText(points' count);  			}  			catch (Exception ex)  			{  				LastError = ex;      			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: switch (_pathalign)  			{  				case TextPathAlign.Left:  					point1 = points[0];  					count = 0;  					break;  				case TextPathAlign.Center:  					count = (int)((maxPoints - maxWidthText) / 2);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  				case TextPathAlign.Right:  					count = (int)(maxPoints - maxWidthText - (double)StringRegion(g' _text.Length - 1) * LetterSpacePercentage / 100);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: switch (_pathalign)  			{  				case TextPathAlign.Left:  					point1 = points[0];  					count = 0;  					break;  				case TextPathAlign.Center:  					count = (int)((maxPoints - maxWidthText) / 2);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  				case TextPathAlign.Right:  					count = (int)(maxPoints - maxWidthText - (double)StringRegion(g' _text.Length - 1) * LetterSpacePercentage / 100);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: while (!(charStep > _text.Length - 1))  			{  				int lStrWidth = (int)(StringRegion(g' charStep) * LetterSpacePercentage / 100);  				if ((count + lStrWidth / 2) >= 0 & (count + lStrWidth) < maxPoints)  				{  					count += lStrWidth;  					PointF point2 = points[count];  					PointF point = points[count - lStrWidth / 2];  					double angle = GetAngle(point1' point2);  					DrawRotatedText(g' _text[charStep].ToString()' (float)angle' point);  					point1 = points[count];  				}  				else  				{  					count += lStrWidth;  				}  				charStep += 1;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: while (!(charStep > _text.Length - 1))  			{  				int lStrWidth = (int)(StringRegion(g' charStep) * LetterSpacePercentage / 100);  				if ((count + lStrWidth / 2) >= 0 & (count + lStrWidth) < maxPoints)  				{  					count += lStrWidth;  					PointF point2 = points[count];  					PointF point = points[count - lStrWidth / 2];  					double angle = GetAngle(point1' point2);  					DrawRotatedText(g' _text[charStep].ToString()' (float)angle' point);  					point1 = points[count];  				}  				else  				{  					count += lStrWidth;  				}  				charStep += 1;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: while (!(charStep > _text.Length - 1))  			{  				int lStrWidth = (int)(StringRegion(g' charStep) * LetterSpacePercentage / 100);  				if ((count + lStrWidth / 2) >= 0 & (count + lStrWidth) < maxPoints)  				{  					count += lStrWidth;  					PointF point2 = points[count];  					PointF point = points[count - lStrWidth / 2];  					double angle = GetAngle(point1' point2);  					DrawRotatedText(g' _text[charStep].ToString()' (float)angle' point);  					point1 = points[count];  				}  				else  				{  					count += lStrWidth;  				}  				charStep += 1;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,StringRegionValue,The following statement contains a magic number: SizeF size = g.MeasureString(_text' _font' 100);
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: double c = Math.Sqrt(Math.Pow((point2.X - point1.X)' 2) + Math.Pow((point2.Y - point1.Y)' 2));
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: double c = Math.Sqrt(Math.Pow((point2.X - point1.X)' 2) + Math.Pow((point2.Y - point1.Y)' 2));
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: if (point1.X > point2.X)  			{  				//We must change the side where the triangle is  				return Math.Asin((point1.Y - point2.Y) / c) * 180 / Math.PI - 180;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: if (point1.X > point2.X)  			{  				//We must change the side where the triangle is  				return Math.Asin((point1.Y - point2.Y) / c) * 180 / Math.PI - 180;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: return Math.Asin((point2.Y - point1.Y) / c) * 180 / Math.PI;
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The following statement contains a magic number: switch (TextPathPathPosition)  			{  				case TextPathPosition.OverPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size - VerticalOffset))' stringFormat);  					break;  				case TextPathPosition.CenterPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size / 2))' stringFormat);  					break;  				case TextPathPosition.UnderPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' y + VerticalOffset)' stringFormat);  					break;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetLinePoints,The following statement contains a magic number: PointF[] tmpPoints = new PointF[10001];
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VisualizerView,The following statement contains a magic number: font = new Font(FontFamily.GenericSansSerif' 8);
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VisualizerView,The following statement contains a magic number: timer.Interval = 1000 / 30;
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VisualizerView,The following statement contains a magic number: timer.Interval = 1000 / 30;
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,Flyout,The following statement contains a magic number: flyouts.Add(new FlyoutItem() { Text = msg' Location = p' Direction = new Size(5' -3) });
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,Flyout,The following statement contains a magic number: flyouts.Add(new FlyoutItem() { Text = msg' Location = p' Direction = new Size(5' -3) });
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AddImage,The following statement contains a magic number: if (cstate.Images.Count < 100)  			{  				ImageMetadata imeta = new ImageMetadata() { Image = image };  				cstate.Images.Add(imeta);    				// GetImageMetadata(r' imeta);  				Invalidate(true);  			}  			else  			{  				// Disable the receptor -- too many images.  				// TODO: Better way of indicating this to the user.  				// TODO: We want to limit the total number of images across all viewers.  				r.Instance.Enabled = false;  				Invalidate(true);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,GetRandomLocation,The following statement contains a magic number: return new Point(rnd.Next(ClientRectangle.Width - 80) + 40' rnd.Next(ClientRectangle.Height - 80) + 40);
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,GetRandomLocation,The following statement contains a magic number: return new Point(rnd.Next(ClientRectangle.Width - 80) + 40' rnd.Next(ClientRectangle.Height - 80) + 40);
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,GetRandomLocation,The following statement contains a magic number: return new Point(rnd.Next(ClientRectangle.Width - 80) + 40' rnd.Next(ClientRectangle.Height - 80) + 40);
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,GetRandomLocation,The following statement contains a magic number: return new Point(rnd.Next(ClientRectangle.Width - 80) + 40' rnd.Next(ClientRectangle.Height - 80) + 40);
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnNewCarrier,The following statement contains a magic number: if (!ApplicationController.GetReceiveProtocols().Select(rp=>rp.Protocol).Contains(e.Carrier.Protocol.DeclTypeName))  			{  				if (e.From == Program.Skin["DropReceptor"].Instance)  				{  					Point p = dropPoint;  					  					if (!StartDrop)  					{  						// From the system edge receptor' so drop the carriers randomly onto the surface.  						p = GetRandomLocation();  					}    					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' Carrier = e.Carrier });  				}  				else  				{  					Point p;    					try  					{  						p = receptorLocation.Single(kvp => kvp.Key.Instance == e.From).Value;  					}  					catch (Exception ex)  					{  						throw new ApplicationException("Receptor " + e.From.Name + " should exist but it does not." + "\r\n" + ex.Message);  					}    					p.Offset((int)(ReceptorSize.Width * Math.Cos(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3' (int)(ReceptorSize.Height * Math.Sin(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3);  					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' Carrier = e.Carrier });  					orbitCount = (orbitCount + 1) % OrbitCountMax;  				}    				Invalidate(true);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnNewCarrier,The following statement contains a magic number: if (!ApplicationController.GetReceiveProtocols().Select(rp=>rp.Protocol).Contains(e.Carrier.Protocol.DeclTypeName))  			{  				if (e.From == Program.Skin["DropReceptor"].Instance)  				{  					Point p = dropPoint;  					  					if (!StartDrop)  					{  						// From the system edge receptor' so drop the carriers randomly onto the surface.  						p = GetRandomLocation();  					}    					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' Carrier = e.Carrier });  				}  				else  				{  					Point p;    					try  					{  						p = receptorLocation.Single(kvp => kvp.Key.Instance == e.From).Value;  					}  					catch (Exception ex)  					{  						throw new ApplicationException("Receptor " + e.From.Name + " should exist but it does not." + "\r\n" + ex.Message);  					}    					p.Offset((int)(ReceptorSize.Width * Math.Cos(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3' (int)(ReceptorSize.Height * Math.Sin(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3);  					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' Carrier = e.Carrier });  					orbitCount = (orbitCount + 1) % OrbitCountMax;  				}    				Invalidate(true);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnNewCarrier,The following statement contains a magic number: if (!ApplicationController.GetReceiveProtocols().Select(rp=>rp.Protocol).Contains(e.Carrier.Protocol.DeclTypeName))  			{  				if (e.From == Program.Skin["DropReceptor"].Instance)  				{  					Point p = dropPoint;  					  					if (!StartDrop)  					{  						// From the system edge receptor' so drop the carriers randomly onto the surface.  						p = GetRandomLocation();  					}    					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' Carrier = e.Carrier });  				}  				else  				{  					Point p;    					try  					{  						p = receptorLocation.Single(kvp => kvp.Key.Instance == e.From).Value;  					}  					catch (Exception ex)  					{  						throw new ApplicationException("Receptor " + e.From.Name + " should exist but it does not." + "\r\n" + ex.Message);  					}    					p.Offset((int)(ReceptorSize.Width * Math.Cos(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3' (int)(ReceptorSize.Height * Math.Sin(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3);  					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' Carrier = e.Carrier });  					orbitCount = (orbitCount + 1) % OrbitCountMax;  				}    				Invalidate(true);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnNewCarrier,The following statement contains a magic number: if (!ApplicationController.GetReceiveProtocols().Select(rp=>rp.Protocol).Contains(e.Carrier.Protocol.DeclTypeName))  			{  				if (e.From == Program.Skin["DropReceptor"].Instance)  				{  					Point p = dropPoint;  					  					if (!StartDrop)  					{  						// From the system edge receptor' so drop the carriers randomly onto the surface.  						p = GetRandomLocation();  					}    					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' Carrier = e.Carrier });  				}  				else  				{  					Point p;    					try  					{  						p = receptorLocation.Single(kvp => kvp.Key.Instance == e.From).Value;  					}  					catch (Exception ex)  					{  						throw new ApplicationException("Receptor " + e.From.Name + " should exist but it does not." + "\r\n" + ex.Message);  					}    					p.Offset((int)(ReceptorSize.Width * Math.Cos(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3' (int)(ReceptorSize.Height * Math.Sin(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3);  					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' Carrier = e.Carrier });  					orbitCount = (orbitCount + 1) % OrbitCountMax;  				}    				Invalidate(true);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,The following statement contains a magic number: if (args.Button == MouseButtons.Left)  			{  				CheckPlayPauseButtons(args.Location);    				var selectedReceptors = receptorLocation.Where(kvp => PointInCircle(kvp.Value' ReceptorSize.Width/2' testPoint));    				if (selectedReceptors.Count() > 0)  				{  					selectedReceptor = selectedReceptors.First().Key;  					movingReceptor = true;  					mouseStart = args.Location;    					// Setup for vertical shake test.  					shakeStart = DateTime.Now;  					shakeCurrentDirection = 0;  					shakeCount = 0;  					shakeOK = true;  				}  				else  				{  					// We also want to check if the mouse is also on a membrane nub.  This affects certain operations.  					// Sometimes membranes can contain other membranes where the outer membrane has no receptors' resulting in the nubs being in exactly the same locations.  					// We always want to initiate with the innermost membrane in that case.  					selectedMembrane = FindInnermostSelectedMembrane(testPoint' Program.Skin);    					if (selectedMembrane != null)  					{  						// Setup for horizontal shake test.  						shakeStart = DateTime.Now;  						shakeCurrentDirection = 0;  						shakeCount = 0;  						shakeOK = true;  						movingMembrane = true;  						mouseStart = args.Location;  					}  					else  					{  						// If neither membrane nor receptor is selected' then go into rubberband mode.  						selectedReceptor = null;  						rubberBand = true;  						mouseStart = args.Location;  						mousePosition = args.Location;  					}  				}  			}  			else if (args.Button == MouseButtons.Right)  			{  				IReceptor receptor;  				bool match = TestForReceptorAt(testPoint' out receptor);    				if (match)  				{  					// TODO: Move this all out of the visualizer!  					MycroParser mp = new MycroParser();  					Form form = mp.Load<Form>("ReceptorProtocolConfig.xml"' this);  					// form.Tag = new ConfigurationInfo() { Receptor = receptor' Parser = mp };  					// PopulateControls(receptor' mp);    					// Initialize the tables and views:  					DataTable dtReceive = new DataTable();  					dtReceive.Columns.Add(new DataColumn("Protocol"' typeof(string)));  					dtReceive.Columns.Add(new DataColumn("Enabled"' typeof(bool)));    					DataTable dtTransmit = new DataTable();  					dtTransmit.Columns.Add(new DataColumn("Protocol"' typeof(string)));  					dtTransmit.Columns.Add(new DataColumn("Enabled"' typeof(bool)));    					receptor.Instance.GetReceiveProtocols().OrderBy(q => q.Protocol).ForEach(rq =>  					{  						DataRow row = dtReceive.NewRow();  						row[0] = rq.Protocol;  						row[1] = rq.Enabled;  						dtReceive.Rows.Add(row);  					});    					receptor.Instance.GetEmittedProtocols().OrderBy(q => q.Protocol).ForEach(ep =>  					{  						DataRow row = dtTransmit.NewRow();  						row[0] = ep.Protocol;  						row[1] = ep.Enabled;  						dtTransmit.Rows.Add(row);  					});    					// For use in event handler.  					form.Tag = new ReceptorProtocolConfig() { MycroParser = mp' Receptor = receptor };    					// Setup the data source.  					DataView dvReceive = new DataView(dtReceive);  					((DataGridView)mp.ObjectCollection["dgvReceiveProtocols"]).DataSource = dvReceive;    					DataView dvTransmit = new DataView(dtTransmit);  					((DataGridView)mp.ObjectCollection["dgvTransmitProtocols"]).DataSource = dvTransmit;    					((Button)mp.ObjectCollection["btnOK"]).Click += OnReceptorProtocolConfigOK;  					((Button)mp.ObjectCollection["btnCancel"]).Click += OnReceptorProtocolConfigCancel;  					form.ShowDialog();  				}  				else if (args.Button == MouseButtons.Right)  				{  					// If no membrane is selected' move the entire surface.  					var selectedMembranes = membraneLocation.Where(kvp => PointInCircle(SurfaceOffsetAdjust(kvp.Value.Center)' MembraneNubRadius' testPoint));    					// Only move the surface if no membrane is selected.    					// TODO: Do we really need to do this?  					if (selectedMembranes.Count() == 0)  					{  						dragSurface = true;  						mouseStart = NegativeSurfaceOffsetAdjust(args.Location);  						mousePosition = NegativeSurfaceOffsetAdjust(args.Location);  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,HorizontalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.X) > Math.Abs(offset.Y))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.X == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.X) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  					else if (Math.Sign(offset.X) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.X;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,HorizontalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.X) > Math.Abs(offset.Y))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.X == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.X) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  					else if (Math.Sign(offset.X) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.X;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,HorizontalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.X) > Math.Abs(offset.Y))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.X == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.X) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  					else if (Math.Sign(offset.X) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.X;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,HorizontalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.X) > Math.Abs(offset.Y))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.X == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.X) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  					else if (Math.Sign(offset.X) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.X;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,HorizontalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.X) > Math.Abs(offset.Y))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.X == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.X) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  					else if (Math.Sign(offset.X) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.X;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.X;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VerticalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.Y) > Math.Abs(offset.X))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.Y == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.Y) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  					else if (Math.Sign(offset.Y) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.Y;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VerticalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.Y) > Math.Abs(offset.X))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.Y == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.Y) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  					else if (Math.Sign(offset.Y) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.Y;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VerticalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.Y) > Math.Abs(offset.X))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.Y == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.Y) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  					else if (Math.Sign(offset.Y) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.Y;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VerticalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.Y) > Math.Abs(offset.X))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.Y == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.Y) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  					else if (Math.Sign(offset.Y) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.Y;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VerticalShakeTest,The following statement contains a magic number: if (Math.Abs(offset.Y) > Math.Abs(offset.X))  			{  				// If no movement for 1/2 second' then reset.  				if ((offset.Y == 0) && ts.TotalMilliseconds > 500)  				{  					shakeStart = DateTime.Now;  					shakeCount = 0;  					shakeCurrentDirection = 0;  				}  				else  				{  					// Or moving in the same direction' reset again.  					if (Math.Sign(offset.Y) == Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds > 500)  					{  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  					else if (Math.Sign(offset.Y) != Math.Sign(shakeCurrentDirection) && ts.TotalMilliseconds < 500)  					{  						// Changing direction in under 500ms.  Increment the shake counter and reset the timer.  						shakeStart = DateTime.Now;  						++shakeCount;  						shakeCurrentDirection = offset.Y;    						if (shakeCount >= 10)  						{  							// Success.  We have detected left-right shaking.  							ret = true;  						}  					}  					else if (ts.TotalMilliseconds > 500)  					{  						// Same direction for more than 500ms' so reset again.  						shakeStart = DateTime.Now;  						shakeCount = 0;  						shakeCurrentDirection = offset.Y;  					}  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseWheelEvent,The following statement contains a magic number: if (hoverReceptor != null)  			{  				int spin = args.Delta / 120;			// Where does this constant come from?  				CarouselState cstate;    				if (carousels.TryGetValue(hoverReceptor' out cstate))  				{  					cstate.Offset += spin;  					Invalidate(true);  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The following statement contains a magic number: foreach(var kvp in carousels)  				{  					Rectangle imgArea = kvp.Value.ActiveImageLocation;  					int imgidx = kvp.Value.ActiveImageIndex;  					int idx = -1;    					foreach(var meta in kvp.Value.Images[imgidx].MetadataPackets)  					{  						++idx;  						Rectangle metaRect = new Rectangle(imgArea.Left' imgArea.Bottom + 10 + (MetadataHeight * idx)' imgArea.Width' MetadataHeight);  									  						if (metaRect.Contains(p))  						{  							// This is the metadata the user clicked on.  							// Now check if it's semantic data.  In all cases' this should be true' right?  							if (!String.IsNullOrEmpty(meta.ProtocolName))  							{  								// The implementing type is a semantic type requiring a drill into?  								// TODO: This actually needs to be recursive' drilling down to the ST that is a Native Type.   								// See the implemntation in SemanticElement GetValue or SetValue.  We should add a method to the SE  								// to get us the SE that implements the NT!  								if (sts.GetSemanticTypeStruct(meta.Name).SemanticElements.Exists(st => st.Name == meta.PropertyName))  								{  									// Yes it is.  Emit a carrier with with protocol and signal.  									string implementingPropertyName = sts.GetSemanticTypeStruct(meta.ProtocolName).SemanticElements.Single(e => e.Name == meta.PropertyName).GetImplementingName(sts);  									ISemanticTypeStruct protocol = Program.SemanticTypeSystem.GetSemanticTypeStruct(meta.PropertyName);  									dynamic signal = Program.SemanticTypeSystem.Create(meta.PropertyName);  									protocol.AllTypes.Single(e => e.Name == implementingPropertyName).SetValue(Program.SemanticTypeSystem' signal' meta.Value);  									IReceptor r = kvp.Key;  									GetReceptorMembrane(r).CreateCarrier(r.Instance' protocol' signal);  										  									// Ugh' I hate doing this' but it's a lot easier to just exit all these nests.  									return true;  								}  								else if (sts.GetSemanticTypeStruct(meta.Name).NativeTypes.Exists(st => st.Name == meta.PropertyName))  								{  									// No' it's just a native type.  									ISemanticTypeStruct protocol = Program.SemanticTypeSystem.GetSemanticTypeStruct(meta.ProtocolName);  									dynamic signal = Program.SemanticTypeSystem.Create(meta.ProtocolName);  									sts.GetSemanticTypeStruct(meta.ProtocolName).NativeTypes.Single(st => st.Name == meta.PropertyName).SetValue(Program.SemanticTypeSystem' signal' meta.Value);  									IReceptor r = kvp.Key;  									GetReceptorMembrane(r).CreateCarrier(r.Instance' protocol' signal);    									// Ugh' I hate doing this' but it's a lot easier to just exit all these nests.  									return true;  								}  								// else: we don't have anythin we can do with this.  							}  						}  					}  				}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestForReceptorAt,The following statement contains a magic number: foreach (var kvp in receptorLocation)  			{  				Point rp = kvp.Value;  				rp.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  				Rectangle r = new Rectangle(rp' ReceptorSize);    				if (r.Contains(p))  				{  					match = true;  					receptor = kvp.Key;  					break;  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestForReceptorAt,The following statement contains a magic number: foreach (var kvp in receptorLocation)  			{  				Point rp = kvp.Value;  				rp.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  				Rectangle r = new Rectangle(rp' ReceptorSize);    				if (r.Contains(p))  				{  					match = true;  					receptor = kvp.Key;  					break;  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestMembraneDoubleClick,The following statement contains a magic number: if (membrane != null)  			{  				// The grid we present to the user should look like this:  				// Membrane: [name]  				// Emits (outgoing):  				// [emitted protocol name] [permeable Y/N] (outgoing)  				// ...  				// Awaits (incoming):  				// [awaited protocol name] [permable Y/N] (incoming)    				// TODO: Should the membrane's permeability list include protocols not currently part of its receptor list?  				// At the moment' no.    				membraneBeingConfigured = membrane;  				Form form = MycroParser.InstantiateFromFile<Form>("membranePermeability.xml"' null);    				// Create a data table here.  There's probably a better place to do this.  				// TODO: The first two columns are suppposed to be read-only.  				DataTable dt = new DataTable();  				dt.Columns.Add(new DataColumn("Protocol"' typeof(string)));	  				dt.Columns.Add(new DataColumn("Direction"' typeof(string)));  				dt.Columns.Add(new DataColumn("Permeable"' typeof(bool)));  				dt.Columns.Add(new DataColumn("RootOnly"' typeof(bool)));  				membrane.UpdatePermeability();			// Get the current permeability' based on active child "outs" and active parent "ins".  				membrane.ProtocolPermeability.ForEach(kvp =>  					{  						DataRow row = dt.NewRow();  						row[0] = kvp.Key.Protocol;  						row[1] = kvp.Key.Direction;  						row[2] = kvp.Value.Permeable;  						row[3] = kvp.Value.RootOnly;  						dt.Rows.Add(row);  					});      				// Setup the data source.  				DataView dv = new DataView(dt);  				dv.Sort = "Direction'Protocol";  				// TODO: Ugh.  Hardcoded index array.  Replace with the MycroParser object collection.  				((DataGridView)form.Controls[0]).DataSource = dv;  				form.FormClosing += OnPermeabilityFormClosing;  				  				form.ShowDialog();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestMembraneDoubleClick,The following statement contains a magic number: if (membrane != null)  			{  				// The grid we present to the user should look like this:  				// Membrane: [name]  				// Emits (outgoing):  				// [emitted protocol name] [permeable Y/N] (outgoing)  				// ...  				// Awaits (incoming):  				// [awaited protocol name] [permable Y/N] (incoming)    				// TODO: Should the membrane's permeability list include protocols not currently part of its receptor list?  				// At the moment' no.    				membraneBeingConfigured = membrane;  				Form form = MycroParser.InstantiateFromFile<Form>("membranePermeability.xml"' null);    				// Create a data table here.  There's probably a better place to do this.  				// TODO: The first two columns are suppposed to be read-only.  				DataTable dt = new DataTable();  				dt.Columns.Add(new DataColumn("Protocol"' typeof(string)));	  				dt.Columns.Add(new DataColumn("Direction"' typeof(string)));  				dt.Columns.Add(new DataColumn("Permeable"' typeof(bool)));  				dt.Columns.Add(new DataColumn("RootOnly"' typeof(bool)));  				membrane.UpdatePermeability();			// Get the current permeability' based on active child "outs" and active parent "ins".  				membrane.ProtocolPermeability.ForEach(kvp =>  					{  						DataRow row = dt.NewRow();  						row[0] = kvp.Key.Protocol;  						row[1] = kvp.Key.Direction;  						row[2] = kvp.Value.Permeable;  						row[3] = kvp.Value.RootOnly;  						dt.Rows.Add(row);  					});      				// Setup the data source.  				DataView dv = new DataView(dt);  				dv.Sort = "Direction'Protocol";  				// TODO: Ugh.  Hardcoded index array.  Replace with the MycroParser object collection.  				((DataGridView)form.Controls[0]).DataSource = dv;  				form.FormClosing += OnPermeabilityFormClosing;  				  				form.ShowDialog();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnPermeabilityFormClosing,The following statement contains a magic number: dv.ForEach(row =>  				{  					string protocol = (string)row[0];  					PermeabilityDirection pd = ((string)row[1]).ToEnum<PermeabilityDirection>();  					PermeabilityKey pk = new PermeabilityKey() { Protocol = protocol' Direction = pd };  					bool permeable = (bool)row[2];  					bool rootOnly = (bool)row[3];  					membraneBeingConfigured.ProtocolPermeability[pk].Permeable = permeable;  					membraneBeingConfigured.ProtocolPermeability[pk].RootOnly = rootOnly;  				});
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnPermeabilityFormClosing,The following statement contains a magic number: dv.ForEach(row =>  				{  					string protocol = (string)row[0];  					PermeabilityDirection pd = ((string)row[1]).ToEnum<PermeabilityDirection>();  					PermeabilityKey pk = new PermeabilityKey() { Protocol = protocol' Direction = pd };  					bool permeable = (bool)row[2];  					bool rootOnly = (bool)row[3];  					membraneBeingConfigured.ProtocolPermeability[pk].Permeable = permeable;  					membraneBeingConfigured.ProtocolPermeability[pk].RootOnly = rootOnly;  				});
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The following statement contains a magic number: if ((DateTime.Now - mouseHoverStartTime).TotalMilliseconds > 500)  			{  				CarrierAnimationItem item = carrierAnimations.FirstOrDefault(a => a.CurrentRegion.Contains(NegativeSurfaceOffsetAdjust(mousePosition)));    				// Mouse is hovering over a carrier.  				if (item != null)  				{  					// Use the properties window to reveal the carrier contents.  					// The property grid is sort of stupid' so we'll put together an anonymous object for displaying the carrier protocol and signal.    					// new { Protocol = item.Carrier.Protocol.DeclTypeName' from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new {Name = t.Name' Value = t.GetValue(item.Carrier.Signal)}};  					// var obj = (from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new { Name = t.Name' Value = t.GetValue(item.Carrier.Signal) }).First();  					// var obj = new { Protocol = item.Carrier.Protocol.DeclTypeName' Signal = item.Carrier.Signal };  					// var obj = new CarrierProperty(item.Carrier.Protocol.DeclTypeName' item.Carrier.Signal);    					// There probably is a better way to do this:  					IDictionary dict = new Hashtable();  					dict.Add("Protocol"' item.Carrier.Protocol.DeclTypeName);  					var kvpList = (from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new { Name = t.Name' Value = t.GetValue(Program.SemanticTypeSystem' item.Carrier.Signal) }); // .ForEach((item) =  					kvpList.ForEach((kvp) => dict.Add(kvp.Name' kvp.Value));  					ApplicationController.PropertyGridController.ShowObject(new DictionaryPropertyGridAdapter(dict));  				}    				// Reset so that this test is not made again until the mouse is moved.  				mouseHoverStartTime = DateTime.MaxValue;  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,RecalcMembranes,The following statement contains a magic number: if (showMembranes)  			{  #if REMOVE_EMPTY_MEMBRANES  				List<IMembrane> toRemove = new List<IMembrane>();  #endif  				Dictionary<IMembrane' Circle> updates = new Dictionary<IMembrane' Circle>();    				// Get the center of all receptors within a membrane.  				// Can't use ref'd variables in lambda expressions.  				foreach (KeyValuePair<IMembrane' Circle> kvp in membraneLocation)  				{  					IMembrane m = kvp.Key;  #if REMOVE_EMPTY_MEMBRANES  					// Membrane must have receptors and can't be the root (skin) membrane.  					if ((m.Receptors.Count > 0) && (m.ParentMembrane != null))  #else  					// Skin membrane is not rendered.  					if (m.ParentMembrane != null)  #endif  					{  						int cx = 0' cy = 0' count = 0;    						// Much easier than using aggregate with Point structures.  						// Recurse into inner membranes as well.  						GetCenter(m' ref cx' ref cy' ref count);    						if (count != 0)  						{  							// This membrane still has receptors:  							cx /= count;  							cy /= count;    							// Get radius by finding the most distant receptor.  							double radius = 0;  							GetMaxRadius(m' cx' cy' ref radius);    							// Add a factor to the radius  							radius += 50;    							// If this membrane has child membranes' add a factor such that' if the outer membrane  							// has no receptors' it renders visually as a bit bigger so as to prevent exact overlap of   							// the outer membrane with the inner one.  							if (m.Membranes.Count > 0 && m.Receptors.Count == 0)  							{  								radius += 50;  							}    							// Can't even modify the value of a collection being iterated!  							updates[m] = new Circle() { Center = new Point(cx' cy)' Radius = (int)radius };  						}  						else  						{  							// The membrane has no receptors' so just draw the membrane with a fixed radius at   							// whatever it's last position was.  							double radius = 50;    							// If this membrane has child membranes' add a factor such that' if the outer membrane  							// has no receptors' it still renders visually as a bit bigger.  							if (m.Membranes.Count > 0)  							{  								radius += 50;  							}    							updates[m] = new Circle() { Center = kvp.Value.Center' Radius = (int)radius };  						}  					}  #if REMOVE_EMPTY_MEMBRANES  					else if (m.ParentMembrane != null) // Obviously' don't remove the Skin membrane (not that it's in the list at the moment anyways.)  					{  						toRemove.Add(m);  					}  #endif  				}  #if REMOVE_EMPTY_MEMBRANES  				toRemove.ForEach(m => membraneLocation.Remove(m));  #endif  				updates.ForEach(kvp => membraneLocation[kvp.Key] = kvp.Value);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,RecalcMembranes,The following statement contains a magic number: if (showMembranes)  			{  #if REMOVE_EMPTY_MEMBRANES  				List<IMembrane> toRemove = new List<IMembrane>();  #endif  				Dictionary<IMembrane' Circle> updates = new Dictionary<IMembrane' Circle>();    				// Get the center of all receptors within a membrane.  				// Can't use ref'd variables in lambda expressions.  				foreach (KeyValuePair<IMembrane' Circle> kvp in membraneLocation)  				{  					IMembrane m = kvp.Key;  #if REMOVE_EMPTY_MEMBRANES  					// Membrane must have receptors and can't be the root (skin) membrane.  					if ((m.Receptors.Count > 0) && (m.ParentMembrane != null))  #else  					// Skin membrane is not rendered.  					if (m.ParentMembrane != null)  #endif  					{  						int cx = 0' cy = 0' count = 0;    						// Much easier than using aggregate with Point structures.  						// Recurse into inner membranes as well.  						GetCenter(m' ref cx' ref cy' ref count);    						if (count != 0)  						{  							// This membrane still has receptors:  							cx /= count;  							cy /= count;    							// Get radius by finding the most distant receptor.  							double radius = 0;  							GetMaxRadius(m' cx' cy' ref radius);    							// Add a factor to the radius  							radius += 50;    							// If this membrane has child membranes' add a factor such that' if the outer membrane  							// has no receptors' it renders visually as a bit bigger so as to prevent exact overlap of   							// the outer membrane with the inner one.  							if (m.Membranes.Count > 0 && m.Receptors.Count == 0)  							{  								radius += 50;  							}    							// Can't even modify the value of a collection being iterated!  							updates[m] = new Circle() { Center = new Point(cx' cy)' Radius = (int)radius };  						}  						else  						{  							// The membrane has no receptors' so just draw the membrane with a fixed radius at   							// whatever it's last position was.  							double radius = 50;    							// If this membrane has child membranes' add a factor such that' if the outer membrane  							// has no receptors' it still renders visually as a bit bigger.  							if (m.Membranes.Count > 0)  							{  								radius += 50;  							}    							updates[m] = new Circle() { Center = kvp.Value.Center' Radius = (int)radius };  						}  					}  #if REMOVE_EMPTY_MEMBRANES  					else if (m.ParentMembrane != null) // Obviously' don't remove the Skin membrane (not that it's in the list at the moment anyways.)  					{  						toRemove.Add(m);  					}  #endif  				}  #if REMOVE_EMPTY_MEMBRANES  				toRemove.ForEach(m => membraneLocation.Remove(m));  #endif  				updates.ForEach(kvp => membraneLocation[kvp.Key] = kvp.Value);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,RecalcMembranes,The following statement contains a magic number: if (showMembranes)  			{  #if REMOVE_EMPTY_MEMBRANES  				List<IMembrane> toRemove = new List<IMembrane>();  #endif  				Dictionary<IMembrane' Circle> updates = new Dictionary<IMembrane' Circle>();    				// Get the center of all receptors within a membrane.  				// Can't use ref'd variables in lambda expressions.  				foreach (KeyValuePair<IMembrane' Circle> kvp in membraneLocation)  				{  					IMembrane m = kvp.Key;  #if REMOVE_EMPTY_MEMBRANES  					// Membrane must have receptors and can't be the root (skin) membrane.  					if ((m.Receptors.Count > 0) && (m.ParentMembrane != null))  #else  					// Skin membrane is not rendered.  					if (m.ParentMembrane != null)  #endif  					{  						int cx = 0' cy = 0' count = 0;    						// Much easier than using aggregate with Point structures.  						// Recurse into inner membranes as well.  						GetCenter(m' ref cx' ref cy' ref count);    						if (count != 0)  						{  							// This membrane still has receptors:  							cx /= count;  							cy /= count;    							// Get radius by finding the most distant receptor.  							double radius = 0;  							GetMaxRadius(m' cx' cy' ref radius);    							// Add a factor to the radius  							radius += 50;    							// If this membrane has child membranes' add a factor such that' if the outer membrane  							// has no receptors' it renders visually as a bit bigger so as to prevent exact overlap of   							// the outer membrane with the inner one.  							if (m.Membranes.Count > 0 && m.Receptors.Count == 0)  							{  								radius += 50;  							}    							// Can't even modify the value of a collection being iterated!  							updates[m] = new Circle() { Center = new Point(cx' cy)' Radius = (int)radius };  						}  						else  						{  							// The membrane has no receptors' so just draw the membrane with a fixed radius at   							// whatever it's last position was.  							double radius = 50;    							// If this membrane has child membranes' add a factor such that' if the outer membrane  							// has no receptors' it still renders visually as a bit bigger.  							if (m.Membranes.Count > 0)  							{  								radius += 50;  							}    							updates[m] = new Circle() { Center = kvp.Value.Center' Radius = (int)radius };  						}  					}  #if REMOVE_EMPTY_MEMBRANES  					else if (m.ParentMembrane != null) // Obviously' don't remove the Skin membrane (not that it's in the list at the moment anyways.)  					{  						toRemove.Add(m);  					}  #endif  				}  #if REMOVE_EMPTY_MEMBRANES  				toRemove.ForEach(m => membraneLocation.Remove(m));  #endif  				updates.ForEach(kvp => membraneLocation[kvp.Key] = kvp.Value);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,RecalcMembranes,The following statement contains a magic number: if (showMembranes)  			{  #if REMOVE_EMPTY_MEMBRANES  				List<IMembrane> toRemove = new List<IMembrane>();  #endif  				Dictionary<IMembrane' Circle> updates = new Dictionary<IMembrane' Circle>();    				// Get the center of all receptors within a membrane.  				// Can't use ref'd variables in lambda expressions.  				foreach (KeyValuePair<IMembrane' Circle> kvp in membraneLocation)  				{  					IMembrane m = kvp.Key;  #if REMOVE_EMPTY_MEMBRANES  					// Membrane must have receptors and can't be the root (skin) membrane.  					if ((m.Receptors.Count > 0) && (m.ParentMembrane != null))  #else  					// Skin membrane is not rendered.  					if (m.ParentMembrane != null)  #endif  					{  						int cx = 0' cy = 0' count = 0;    						// Much easier than using aggregate with Point structures.  						// Recurse into inner membranes as well.  						GetCenter(m' ref cx' ref cy' ref count);    						if (count != 0)  						{  							// This membrane still has receptors:  							cx /= count;  							cy /= count;    							// Get radius by finding the most distant receptor.  							double radius = 0;  							GetMaxRadius(m' cx' cy' ref radius);    							// Add a factor to the radius  							radius += 50;    							// If this membrane has child membranes' add a factor such that' if the outer membrane  							// has no receptors' it renders visually as a bit bigger so as to prevent exact overlap of   							// the outer membrane with the inner one.  							if (m.Membranes.Count > 0 && m.Receptors.Count == 0)  							{  								radius += 50;  							}    							// Can't even modify the value of a collection being iterated!  							updates[m] = new Circle() { Center = new Point(cx' cy)' Radius = (int)radius };  						}  						else  						{  							// The membrane has no receptors' so just draw the membrane with a fixed radius at   							// whatever it's last position was.  							double radius = 50;    							// If this membrane has child membranes' add a factor such that' if the outer membrane  							// has no receptors' it still renders visually as a bit bigger.  							if (m.Membranes.Count > 0)  							{  								radius += 50;  							}    							updates[m] = new Circle() { Center = kvp.Value.Center' Radius = (int)radius };  						}  					}  #if REMOVE_EMPTY_MEMBRANES  					else if (m.ParentMembrane != null) // Obviously' don't remove the Skin membrane (not that it's in the list at the moment anyways.)  					{  						toRemove.Add(m);  					}  #endif  				}  #if REMOVE_EMPTY_MEMBRANES  				toRemove.ForEach(m => membraneLocation.Remove(m));  #endif  				updates.ForEach(kvp => membraneLocation[kvp.Key] = kvp.Value);  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: try  			{  				Control ctrl = (Control)sender;    				e.Graphics.FillRectangle(surfaceBrush' new Rectangle(Location' Size));  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;    				if (showMembranes)  				{  					// Membranes are first  					membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});  				}    				e.Graphics.DrawImage(playButton' playButtonRect);  				e.Graphics.DrawImage(pauseButton' pauseButtonRect);    				// Draw connecting lines first' everything else is overlayed on top.    				receptorConnections.ForEach(conn =>  				{  /*  					switch (conn.Protocol)  					{  						case "Text":  							pen = receptorLineColor2;  							break;  						case "HW_Player":  						case "HW_MoveTo":  							pen = receptorLineColor3;  							break;  						default:  							pen = receptorLineColor;  							break;  					}  */  #if STRAIGHT_LINE_CONNECTIONS  					ReceptorPair rp1 = new ReceptorPair() { R1 = conn.R1' R2 = conn.R2 };  					ReceptorPair rp2 = new ReceptorPair() { R1 = conn.R2' R2 = conn.R1 };    					if (receptorConnectionList.ContainsKey(rp1))  					{  						// We have an identical forward connection.  						receptorConnectionList[rp1].Add(conn);  					}  					else if (receptorConnectionList.ContainsKey(rp2))  					{  						// We have a reverse connection.  						// TODO: This flag seems pointless.  						conn.Reverse = true;  						receptorConnectionList[rp2].Add(conn);  					}  					else  					{  						receptorConnectionList[rp1]=new List<Connection>();  						receptorConnectionList[rp1].Add(conn);  					}  				});    				// Save current settings  				CompositingQuality cq = e.Graphics.CompositingQuality;  				TextRenderingHint trh = e.Graphics.TextRenderingHint;  				e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  				e.Graphics.CompositingQuality = CompositingQuality.HighQuality;  				e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;    				foreach (KeyValuePair<ReceptorPair' List<Connection>> kvp in receptorConnectionList)  				{  					int protocolLabelOffset = 2;    					foreach (Connection conn in kvp.Value)  					{  						Line line = conn.Line;  						Pen pen = receptorLineColor;    						// Just a straight line:  						// The source starting point of the line should be placed on the edge of the receptor.  						double dx = line.P1.X - line.P2.X;  						double dy = line.P1.Y - line.P2.Y;  						double angle = Math.Atan2(dy' dx);  						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));    						if (showProtocols)  						{  							string protocolName = conn.Protocol;    							if (kvp.Value.Count > 1)  							{  								// TODO: Does the reverse flag actually affect our logic here?  It does not seem so.  								// TODO: There remains an issue when dx==0 and possibly 1 or -1.    								// It also seems like only dx needs to be inspected' not conn.Reverse.  								if (conn.Reverse)  								{  									if (kvp.Key.R1 != conn.R1)  									{  										if (dx > 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--A";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " E-->";  #else  											protocolName = protocolName + " -->";  #endif  										}  									}  									else  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = "<--B " + protocolName;  #else  										protocolName = "<-- " + protocolName;  #endif  									}  								}  								else  								{  									if (kvp.Key.R1 != conn.R1)  									{  #if DEBUG_SEMANTIC_LABELS  										protocolName = protocolName + " C-->";  #else  										protocolName = protocolName + " -->";  #endif  									}  									else  									{  										if (dx < 0)  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = " D-->" + protocolName;  #else  											protocolName = protocolName + " -->";  #endif  										}  										else  										{  #if DEBUG_SEMANTIC_LABELS  											protocolName = protocolName + " <--F";  #else  											protocolName = "<-- " + protocolName;  #endif  										}  									}  								}  							}  							else  							{  								// Orient the directional arrow based on how the text is being drawn' which  								// is determined by whether dx < 1 or > 1' or 1.  								if (dx < 1)  								{  									protocolName = protocolName + " -->";  								}  								else if (dx > 1)  								{  									protocolName = "<-- " + protocolName;  								}  								else  								{  									// A flip along the vertical line occurs at -1 and 0' then corrects itself again at >= 1  									protocolName = protocolName + " -->";  								}  							}    							DrawTextOnPath.Draw(e' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2)' protocolName' protocolLabelOffset);  						}  						else  						{  							e.Graphics.DrawLine(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(line.P2));  						}    						// draw a small numb at the terminating point.  						Point ctr = SurfaceOffsetAdjust(line.P2);  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));    						protocolLabelOffset += 15;  #else  					// The source starting point of the line should be placed on the edge of the receptor.  					double dx = line.P1.X - line.P2.X;  					double dy = line.P1.Y - line.P2.Y;  					double length = Math.Sqrt(dx * dx + dy * dy);    					// Don't bother if the receptors are nearly on top of each other.  					if (length > 2)  					{  						double ratio = 1.0 - (20 / length);  						Point start = new Point((int)(dx * ratio + line.P2.X)' (int)(dy * ratio + line.P2.Y));    						double th = Math.Atan2(dy' dx);  						double th1 = th + 3 * Math.PI / 4;  // 45 degree offset  						double th2 = th + Math.PI / 4;  // 45 degree offset  						Point cp1 = new Point((int)(40 * Math.Cos(th1) + start.X)' ((int)(40 * Math.Sin(th1) + start.Y)));  						Point cp2 = new Point((int)(40 * Math.Cos(th2) + line.P2.X)' ((int)(40 * Math.Sin(th2) + line.P2.Y)));  						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2));    						Point ctr = SurfaceOffsetAdjust(line.P2);  						// draw a small numb at the terminating point.  						e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));  					}  #endif  					}  				}      				// Restore previous settings.  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;  				e.Graphics.CompositingQuality = cq;  				e.Graphics.TextRenderingHint = trh;    				// Draw receptors.    				receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});    				flyouts.ForEach(f =>  					{  						e.Graphics.DrawString(f.Text' font' textBrush' SurfaceOffsetAdjust(f.Location));  					});    				// Show carriers with targets.  				carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});    				// Show carriers without targets.  				carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});  // Rework Idea:  /*  				carousels.ForEach(kvp =>  				{  					Point p = receptorLocation[kvp.Key];  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					//int sizeZ = 40;  					//int idxReal = 0;  					Image img = null;  					//Point ip;  					//double theta = 0;  					//double dx = 0;  					//double dy = 0;    					// The images in the carousel should range from (relative to the receptor center):  					// -80 ... +80  (see sizeZ' which is set to 160.)  					// of course' on the left of the center image' this needs to be the right-edge position.  					// and on the right of the cemter image' this needs to be the left-edge position.  					// It would be easier to work with the center of the images on the carousel' which  					// should be some % of the center width (160)' decreasing as we move up the carousel'   					// to provide a 3D effect.  					// If we assume an image width of 160 for the two edge images' then our offsets from center  					// will be +/- 160.  					// We can therefore compute the starting and ending angles assuming a maximum height of 100  					// angle = acos(160/100)  					// Of course' these angles need to be adjusted because the are in the 3rd and 4th quadrants:  					// (in degrees):  					//     starting angle = 270 - startangle  					//     ending angle = 270 + startangle  					// and we iterate from starting angle backwards to the ending angle.  					// steps = (starting angle + (360 - ending angle)) / num images    					double deg270 = 2 * Math.PI * 3 / 4;  					double angle = Math.Atan(100 / 160);  					double startingAngle = deg270 - angle;  					double endingAngle = deg270 + angle;  					double range = startingAngle + 2 * Math.PI - endingAngle;  					double step = range / imagesCount;  					double imageSizeStep = Math.PI / imagesCount;			// 0 to 180 degrees    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						Point ip = p;  						int idxReal = Math.Abs((idx + offset) % imagesCount);  						img = kvp.Value.Images[idxReal].Image;  						double theta = startingAngle - step * idx;  						double dx = 160 * Math.Cos(theta);  						double dy = -100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							// This is the "selected" image.  							// We also don't want to display this image in the carousel' otherwise it appears twice.  							idx0 = idx;  						}  						else  						{  							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again.  							int sizeZ = (int)((160 - 10) * (1.0 - (0.25 + Math.Sin(imageSizeStep * idx) * 3 / 4)));  							Rectangle rect = new Rectangle(new Point(ip.X - sizeZ/2 ' ip.Y)' new Size(sizeZ' sizeZ * img.Height / img.Width));  							e.Graphics.DrawImage(img' rect);  							e.Graphics.DrawString(idx.ToString()' font' textBrush' rect);  						}  					});    					// Draw idx0 last so it appears on top.  					// The image is centered below the receptor.  					//idxReal = (idx0 + offset) % imagesCount;  					//ip = p;  					//theta = (Math.PI * 0.56) + 2 * Math.PI * idxReal / imagesCount;  					//dx = 200 * Math.Cos(theta);  					//dy = 100 * Math.Sin(theta);  					//ip.Offset((int)dx' (int)dy);  					img = kvp.Value.Images[idx0].Image;  					//sizeZ = 160; //  (idxReal == 0) ? 160 : 10;  					//var posY = ip.Y + 20;  					//var posX = ip.X - 40;     					int sizeZ2 = 160;  					Point rp = receptorLocation[kvp.Key];  					rp.Offset(-sizeZ2 / 2' 172);    					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);  					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					kvp.Value.Images[idx0].MetadataPackets.ForEach(meta =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});  				});  */    #if VIVEK  				carousels.ForEach(kvp =>  				{  					Point p = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					int imagesCount = kvp.Value.Images.Count;  					int offset = kvp.Value.Offset;  					int idx0 = 0;  					int sizeZ = 40;  					int idxReal = 0;  					Image img = null;  					Point ip;  					double theta = 0;  					double dx = 0;  					double dy = 0;    					kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  					{  						img = imeta.Image;  						ip = p;  						idxReal = (idx + offset) % imagesCount;  						theta = (Math.PI * 0.43) + 2 * Math.PI * idxReal / imagesCount;  						dx = 200 * Math.Cos(theta);  						dy = 100 * Math.Sin(theta);  						ip.Offset((int)dx' (int)dy);    						if (idxReal == 0)  						{  							idx0 = idx;  						}  						else  						{  							sizeZ += (90 / imagesCount);    							//e.Graphics.FillRectangle(new SolidBrush(Color.Yellow)' ip.X-20' ip.Y-30' 5' 5); //markers  							if (imagesCount < 10)  								sizeZ = 75;    							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width)));  						}    					});    					img = kvp.Value.Images[idx0].Image;  					int sizeZ2 = 160;  					Point rp = SurfaceOffsetAdjust(receptorLocation[kvp.Key]);  					rp.Offset(-sizeZ2 / 2' 100);		// 100 is some arbitrary vertical offset for testing.  					Rectangle location = new Rectangle(rp' new Size(sizeZ2' sizeZ2 * img.Height / img.Width));  					e.Graphics.DrawImage(img' location);    					kvp.Value.ActiveImageFilename = img.Tag.ToString();  					kvp.Value.ActiveImageLocation = location;  					kvp.Value.ActiveImageIndex = idx0;    					int y = location.Bottom + 10;    					// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  					kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  					{  						Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  						string data = meta.Name + ": " + meta.Value;  						e.Graphics.DrawString(data' font' textBrush' region);  						y += MetadataHeight;  					});    				});    #endif  // Decent.  #if MINE  				carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});  #endif      				if (rubberBand)  				{  					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y));  					e.Graphics.DrawRectangle(rubberBandPen' r);  				}  			}  			catch (Exception ex)  			{  				System.Diagnostics.Debug.WriteLine(ex.Message);  				System.Diagnostics.Debugger.Break();  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PointInCircle,The following statement contains a magic number: if (s.Width + s.Height < r)  			{  				// OK' so far so good' is it actually in the circle  				if ((s.Width ^ 2 + s.Height ^ 2) < (r ^ 2))  				{  					ret = true;  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PointInCircle,The following statement contains a magic number: if (s.Width + s.Height < r)  			{  				// OK' so far so good' is it actually in the circle  				if ((s.Width ^ 2 + s.Height ^ 2) < (r ^ 2))  				{  					ret = true;  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PointInCircle,The following statement contains a magic number: if (s.Width + s.Height < r)  			{  				// OK' so far so good' is it actually in the circle  				if ((s.Width ^ 2 + s.Height ^ 2) < (r ^ 2))  				{  					ret = true;  				}  			}
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CircleToBoundingRectangle,The following statement contains a magic number: return new Rectangle(ctr.X - radius' ctr.Y - radius' radius * 2' radius * 2);
Magic Number,TypeSystemExplorer.Views,VisualizerView,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CircleToBoundingRectangle,The following statement contains a magic number: return new Rectangle(ctr.X - radius' ctr.Y - radius' radius * 2' radius * 2);
Missing Default,TypeSystemExplorer.Controllers,ApplicationFormController,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,ProcessCarrier,The following switch statement is missing a default case: switch (carrier.Protocol.DeclTypeName)  			{  				case "SystemMessage":  					{  						string action = carrier.Signal.Action;  						string data = carrier.Signal.Data;  						IReceptorInstance receptorInstance = carrier.Signal.Source;    						if (action == "Flyout")  						{  							VisualizerController.View.Flyout(data' receptorInstance);  						}    						break;  					}    				case "CarrierAnimation":  					{  						Action action = carrier.Signal.Process;  						IReceptorInstance from = carrier.Signal.From;  						IReceptorInstance to = carrier.Signal.To;  						ICarrier outCarrier = carrier.Signal.Carrier;  						VisualizerController.View.AnimateCarrier(action' from' to' outCarrier);  						break;  					}    				case "SystemShowImage":  					{  						IReceptorInstance target = carrier.Signal.From;  						Bitmap image = carrier.Signal.Image.Value;  						dynamic filename = carrier.Signal.Filename;  						VisualizerController.View.AddImage(target' image' filename);  						break;  					}    				case "HaveImageMetadata":  					{  						VisualizerController.View.ProcessImageMetadata(carrier.Signal);  						break;  					}  			}
Missing Default,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following switch statement is missing a default case: switch (_pathalign)  			{  				case TextPathAlign.Left:  					point1 = points[0];  					count = 0;  					break;  				case TextPathAlign.Center:  					count = (int)((maxPoints - maxWidthText) / 2);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  				case TextPathAlign.Right:  					count = (int)(maxPoints - maxWidthText - (double)StringRegion(g' _text.Length - 1) * LetterSpacePercentage / 100);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  			}
Missing Default,TypeSystemExplorer.Views,TextOnPath,C:\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The following switch statement is missing a default case: switch (TextPathPathPosition)  			{  				case TextPathPosition.OverPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size - VerticalOffset))' stringFormat);  					break;  				case TextPathPosition.CenterPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size / 2))' stringFormat);  					break;  				case TextPathPosition.UnderPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' y + VerticalOffset)' stringFormat);  					break;  			}
