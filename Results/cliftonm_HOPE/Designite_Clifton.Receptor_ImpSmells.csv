Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The method has 5 parameters. Parameters: from' protocol' signal' parentCarrier' emitSubElements
Long Parameter List,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrierIfReceiver,The method has 5 parameters. Parameters: from' protocol' signal' parentCarrier' emitSubElements
Long Parameter List,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrierIfReceiver,The method has 6 parameters. Parameters: from' protocol' protocolPath' signal' parentCarrier' emitSubElements
Long Parameter List,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The method has 9 parameters. Parameters: from' protocol' protocolPath' signal' stopRecursion' isSystemMessage' parentCarrier' emitSubElements' isRoot
Long Parameter List,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarriersForSemanticElements,The method has 6 parameters. Parameters: from' protocol' protocolPath' signal' stopRecursion' parentCarrier
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "			ICarrier carrier = CreateCarrier(from' protocol' protocol.DeclTypeName' signal' false' protocol.DeclTypeName=="SystemMessage" || from.Name=="DropReceptor"' parentCarrier' emitSubElements); " is 188.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrierIfReceiver,The length of the statement  "					// CreateCarrier(IReceptorInstance from' ISemanticTypeStruct protocol' string protocolPath' dynamic signal' bool stopRecursion' bool isSystemMessage = false' ICarrier parentCarrier = null) " is 188.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrierIfReceiver,The length of the statement  "					CreateCarrier(from' protocol' protocolPath' signal' false' false' parentCarrier' emitSubElements' protocol.DeclTypeName == protocolPath); " is 137.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GatherProtocolReceivers,The length of the statement  "						// This is a global receiver.  Attach it to all current carrier receptors' but don't create an instance in the CarrierReceptorMap. " is 130.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "				// The reason this was moved is so that we fire NewCarrier only for actual receptors with protocols enabled for that receptor. " is 126.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "				// TODO: However' this means that we no longer queue protocols for which we have no receptors.  Not sure if we actually want this particular feature. " is 149.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "				// We pass along the stopRecursion flag to prevent wild-card carrier receptor from receiving their own emissions' which would result in a new carrier' " is 150.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "				// The carrier might be null if there's no receiver for the parent carrier.  In this case' we need to create a dummy carrier so we have a parent. " is 145.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarriersForSemanticElements,The length of the statement  "					dynamic subsignal = SemanticTypeSystem.Clone(signal' se); // Clone the contents of the signal's semantic element into the subsignal. " is 132.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,TargetReceptorExistsFor,The length of the statement  "					// In the case of the semantic database' a "from" receptor can have multiple connections with the same semantic database receptor. " is 130.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,TargetReceptorExistsFor,The length of the statement  "					// In other words' the returned list consists of [n] identical instances' where [n] is the number of different protocols from "from" to the target receptor. " is 156.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "				// In the case of the semantic database' a "from" receptor can have multiple connections with the same semantic database receptor. " is 130.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "				// In other words' the returned list consists of [n] identical instances' where [n] is the number of different protocols from "from" to the target receptor. " is 156.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "					// r.Receptor.Instance.GetEnabledReceiveProtocols().Select(rq => rq.Protocol).Contains(protocol.DeclTypeName)).ToList(); " is 120.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "				// Also' if the emitting receptor doesn't declare its protocol' this count will be 0' leading to potentially strange results. " is 125.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "				// For example' comment out the persistence receptors "IDReturn" and run the feed reader example.  You'll see that TWO items " is 124.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "				// are returned as matching "RSSFeed" table name and for reasons unknown at the moment' protocolReceptorMap has two entries that qualify. " is 137.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "						filteredTargets = filteredTargets.Where(r => r.Receptor.Instance.GetReceiveProtocols().Exists(p => p.Protocol == protocol.DeclTypeName && p.Enabled)).ToList(); " is 159.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "						// The PermeableProtocol may be a higher level protocol than the receiver receives' so we need to find the receivers that have sub-protocols of the current protocol enabled. " is 173.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "				// filteredTargets = filteredTargets.Where(t => t.Instance.GetReceiveProtocols().Any(rp => (rp.Protocol == protocol.DeclTypeName) && rp.Qualifier(carrier.Signal))).ToList(); " is 173.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "				// filteredTargets = filteredTargets.Where(t => t.Instance.GetReceiveProtocols().Single(rp => rp.Protocol == protocol.DeclTypeName).Qualifier(carrier.Signal)).ToList(); " is 168.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,ProcessReceptors,The length of the statement  "				// If we have any enabled receptor for this carrier (a mapping of carrier to receptor list exists and receptors actually exist in that map)... " is 142.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,ProcessReceptors,The length of the statement  "					queuedCarriers.Add(new QueuedCarrierAction() { From = ReceptorFromInstance(from)' Carrier = carrier' Action = action }); " is 120.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,ProcessQueuedCarriers,The length of the statement  "				// If we have any enabled receptor for this carrier (a mapping of carrier to receptor list exists and receptors actually exist in that map)... " is 142.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetProcessAction,The length of the statement  "							// Defer the action' such that the visualizer can invoke it when it determines the carrier rendering to the receiving receptor has completed. " is 141.
Long Statement,Clifton.Receptor,ReceptorsContainer,D:\research\architectureSmells\repos\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetProcessAction,The length of the statement  "							CreateCarrier(from' protocol' protocol.DeclTypeName' signal' receptor.Receptor.Instance.GetEnabledReceiveProtocols().Select(rp=>rp.Protocol).Contains("*")' true); " is 162.
