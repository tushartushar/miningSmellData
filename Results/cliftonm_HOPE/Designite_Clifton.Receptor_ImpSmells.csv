Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The method has 5 parameters.
Long Parameter List,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrierIfReceiver,The method has 5 parameters.
Long Parameter List,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrierIfReceiver,The method has 6 parameters.
Long Parameter List,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The method has 9 parameters.
Long Parameter List,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarriersForSemanticElements,The method has 6 parameters.
Long Statement,Clifton.Receptor,Receptor,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptor.cs,Instantiate,The length of the statement  "		impType = assembly.GetTypes ().Where (t => t.IsClass).Where (c => c.GetInterfaces ().Where (i => i.Name == "IReceptorInstance").Count () > 0).Single (); " is 152.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "	ICarrier carrier = CreateCarrier (from' protocol' protocol.DeclTypeName' signal' false' protocol.DeclTypeName == "SystemMessage" || from.Name == "DropReceptor"' parentCarrier' emitSubElements); " is 193.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrierIfReceiver,The length of the statement  "			// CreateCarrier(IReceptorInstance from' ISemanticTypeStruct protocol' string protocolPath' dynamic signal' bool stopRecursion' bool isSystemMessage = false' ICarrier parentCarrier = null) " is 188.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrierIfReceiver,The length of the statement  "			CreateCarrier (from' protocol' protocolPath' signal' false' false' parentCarrier' emitSubElements' protocol.DeclTypeName == protocolPath); " is 138.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GatherProtocolReceivers,The length of the statement  "			// This is a global receiver.  Attach it to all current carrier receptors' but don't create an instance in the CarrierReceptorMap. " is 130.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "		// The reason this was moved is so that we fire NewCarrier only for actual receptors with protocols enabled for that receptor. " is 126.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "		// TODO: However' this means that we no longer queue protocols for which we have no receptors.  Not sure if we actually want this particular feature. " is 149.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "		// We pass along the stopRecursion flag to prevent wild-card carrier receptor from receiving their own emissions' which would result in a new carrier' " is 150.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,CreateCarrier,The length of the statement  "		// The carrier might be null if there's no receiver for the parent carrier.  In this case' we need to create a dummy carrier so we have a parent. " is 145.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,TargetReceptorExistsFor,The length of the statement  "			// In the case of the semantic database' a "from" receptor can have multiple connections with the same semantic database receptor. " is 130.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,TargetReceptorExistsFor,The length of the statement  "			// In other words' the returned list consists of [n] identical instances' where [n] is the number of different protocols from "from" to the target receptor. " is 156.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,TargetReceptorExistsFor,The length of the statement  "			ret = targets.Any (r => r.Receptor != from && r.Receptor.Instance.Enabled && r.PermeabilityProtocol == protocol.DeclTypeName && (!r.RootOnly || isRoot)); " is 153.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,TargetReceptorExistsFor,The length of the statement  "			ret = protocolReceptorMap.Any (kvp => (kvp.Key == protocol.DeclTypeName) && kvp.Value.Any (r => (r.Receptor != from) && r.PermeabilityProtocol == protocol.DeclTypeName && (!r.RootOnly || isRoot) && // root protocol or we don't care if it's not the root. " is 253.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		// In the case of the semantic database' a "from" receptor can have multiple connections with the same semantic database receptor. " is 130.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		// In other words' the returned list consists of [n] identical instances' where [n] is the number of different protocols from "from" to the target receptor. " is 156.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		List<IReceptorConnection> filteredTargets = targets.Where (r => (!r.RootOnly || isRoot) && r.Receptor != from && r.Receptor.Instance.Enabled && r.PermeabilityProtocol == protocol.DeclTypeName).ToList (); " is 203.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		// r.Receptor.Instance.GetEnabledReceiveProtocols().Select(rq => rq.Protocol).Contains(protocol.DeclTypeName)).ToList(); " is 120.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		// Also' if the emitting receptor doesn't declare its protocol' this count will be 0' leading to potentially strange results. " is 125.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		// For example' comment out the persistence receptors "IDReturn" and run the feed reader example.  You'll see that TWO items " is 124.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		// are returned as matching "RSSFeed" table name and for reasons unknown at the moment' protocolReceptorMap has two entries that qualify. " is 137.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "				filteredTargets = filteredTargets.Where (r => r.Receptor.Instance.GetReceiveProtocols ().Exists (p => p.Protocol == protocol.DeclTypeName && p.Enabled)).ToList (); " is 163.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "			// The PermeableProtocol may be a higher level protocol than the receiver receives' so we need to find the receivers that have sub-protocols of the current protocol enabled. " is 173.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		// filteredTargets = filteredTargets.Where(t => t.Instance.GetReceiveProtocols().Any(rp => (rp.Protocol == protocol.DeclTypeName) && rp.Qualifier(carrier.Signal))).ToList(); " is 173.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetTargetReceptorsFor,The length of the statement  "		// filteredTargets = filteredTargets.Where(t => t.Instance.GetReceiveProtocols().Single(rp => rp.Protocol == protocol.DeclTypeName).Qualifier(carrier.Signal)).ToList(); " is 168.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,ProcessReceptors,The length of the statement  "		// If we have any enabled receptor for this carrier (a mapping of carrier to receptor list exists and receptors actually exist in that map)... " is 142.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,ProcessQueuedCarriers,The length of the statement  "		// If we have any enabled receptor for this carrier (a mapping of carrier to receptor list exists and receptors actually exist in that map)... " is 142.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetProcessAction,The length of the statement  "				// Defer the action' such that the visualizer can invoke it when it determines the carrier rendering to the receiving receptor has completed. " is 141.
Long Statement,Clifton.Receptor,ReceptorsContainer,F:\newReposMay17\cliftonm_HOPE\Clifton.Receptor\Receptors.cs,GetProcessAction,The length of the statement  "				CreateCarrier (from' protocol' protocol.DeclTypeName' signal' receptor.Receptor.Instance.GetEnabledReceiveProtocols ().Select (rp => rp.Protocol).Contains ("*")' true); " is 168.
