Implementation smell,Namespace,Class,File,Method,Description
Long Method,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The method has 122 lines of code.
Long Method,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The method has 144 lines of code.
Long Method,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The method has 199 lines of code.
Complex Method,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,Cyclomatic complexity of the method is 10
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "            m.Help = "OVERVIEW\nPort scans typically range from troubleshooting' harmless self-inspection to a preemptive strike for a malicious attack." " is 141.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + "They provide valuable information to attackers when searching for potential avenues for exploitation.  They are' also' not all" " is 130.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + " completely malicious.  Many system administrators port scan themselves when attempting to diagnose issues' perform self-audits' or other various maintenance work." " is 167.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + "whether or not to continue receiving packets from the IP address.  If the user wishes to not be the arbiter of that' a \'block immediately'"  " is 143.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + " option is selectable.  \n\nTECHNICAL\nScan Detector logs how many ports an IP address has touched with a short window of time.  An IP has its ports washed " " is 160.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + " after 30 seconds' and the IP is completely removed after 1 minute of inactivity.  These numbers were chosen based on performance and nmap timings.  nmap at its" " is 164.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + " most paranoid spits out one packet per 15 seconds.  The number of distinct ports touched within this window is 100; this number was chosen based on nmap's " " is 160.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + "-F flag' which runs a scan in \'Fast\' mode' or scan only the top 100 ports.\n\nCLOAKED MODE\nCloaked mode is an attempt to exploit the security-through-obscurity" " is 166.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + " mechanisms behind port scanning/detecting.  It is an adaptation of Jon Erickson's Shroud application in \'The Art of Exploitation\'.  The objective is to " " is 159.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,Help,The length of the statement  "                                    + "disguise real ports within a sea of false positives.  If' for example' an attacker scans 2000 ports on the host system' all 2000 ports will respond as if they" " is 162.
Long Statement,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,timer_Tick,The length of the statement  "                    if ((DateTime.Now.Ticks - tmp.last_access) > (30 * 10000000) && (DateTime.Now.Ticks - tmp.last_access) < (60 * 10000000)) " is 121.
Long Statement,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 64.1129F)); " is 127.
Long Statement,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 35.8871F)); " is 127.
Long Statement,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 85.2018F)); " is 121.
Long Statement,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 14.79821F)); " is 122.
Long Statement,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle4.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle5.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle6.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The length of the statement  "            this.blockedIPList.RowHeadersWidthSizeMode = System.Windows.Forms.DataGridViewRowHeadersWidthSizeMode.AutoSizeToAllHeaders; " is 123.
Complex Conditional,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The conditional expression  "(!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK"  is complex.
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(61' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(61' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(61' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(61' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.addressField.Location = new System.Drawing.Point(164' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.addressField.Location = new System.Drawing.Point(164' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.addressField.Size = new System.Drawing.Size(35' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.addressField.Size = new System.Drawing.Size(35' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(54' 42);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(54' 42);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(68' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(68' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 2;
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.accessField.Location = new System.Drawing.Point(164' 42);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.accessField.Location = new System.Drawing.Point(164' 42);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.accessField.Size = new System.Drawing.Size(35' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.accessField.Size = new System.Drawing.Size(35' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.accessField.TabIndex = 3;
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portBox.Location = new System.Drawing.Point(12' 166);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portBox.Location = new System.Drawing.Point(12' 166);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portBox.Size = new System.Drawing.Size(268' 95);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portBox.Size = new System.Drawing.Size(268' 95);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portBox.TabIndex = 4;
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(12' 147);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(12' 147);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(80' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(80' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 5;
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(9' 72);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(9' 72);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(113' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(113' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 6;
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.averageField.Location = new System.Drawing.Point(164' 72);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.averageField.Location = new System.Drawing.Point(164' 72);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.averageField.Size = new System.Drawing.Size(35' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.averageField.Size = new System.Drawing.Size(35' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.averageField.TabIndex = 7;
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(42' 97);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(42' 97);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(80' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(80' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 8;
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portsField.Location = new System.Drawing.Point(164' 97);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portsField.Location = new System.Drawing.Point(164' 97);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portsField.Size = new System.Drawing.Size(35' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portsField.Size = new System.Drawing.Size(35' 13);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.portsField.TabIndex = 9;
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(292' 273);
Magic Number,ScanDetector,Report,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\Report.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(292' 273);
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,ModuleStart,The following statement contains a magic number: try              {                  data = Load<ScanData>();                  if (null == data)                      data = new ScanData();                    // set our timer to do stuff                  janitor.Elapsed += new ElapsedEventHandler(timer_Tick);                  janitor.Interval = 60000;                  janitor.Enabled = true;                  janitor.Start();              }              catch (Exception e)              {                  LogCenter.Instance.LogException(e);                  data = new ScanData();                  return false;              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,interiorMain,The following statement contains a magic number: if (in_packet.ContainsLayer(Protocol.TCP))              {                  // if we're in cloaked mode' respond with the SYN ACK                  // More information about this in the GUI code and help string                  if (data.cloaked_mode && ((TCPPacket)in_packet).SYN && !((TCPPacket)in_packet).ACK)                  {                      TCPPacket from = (TCPPacket)in_packet;                        EthPacket eth = new EthPacket(60);                      eth.FromMac = Adapter.GetAdapterInformation().InterfaceInformation.GetPhysicalAddress().GetAddressBytes();                      eth.ToMac = from.FromMac;                      eth.Proto = new byte[2] { 0x08' 0x00 };                        IPPacket ip = new IPPacket(eth);                      ip.DestIP = from.SourceIP;                      ip.SourceIP = from.DestIP;                      ip.NextProtocol = 0x06;                      ip.TotalLength = 40;                      ip.HeaderChecksum = ip.GenerateIPChecksum;                        TCPPacket tcp = new TCPPacket(ip);                      tcp.SourcePort = from.DestPort;                      tcp.DestPort = from.SourcePort;                      tcp.SequenceNumber = (uint)new Random().Next();                      tcp.AckNumber = 0;                      tcp.WindowSize = 8192;                      tcp.SYN = true;                      tcp.ACK = true;                      tcp.Checksum = tcp.GenerateChecksum;                      tcp.Outbound = true;                      Adapter.SendPacket(tcp);                  }                    try                  {                      TCPPacket packet = (TCPPacket)in_packet;                        // if the IP is in the blockcache' then return                       if (data.BlockCache == null)                          data.BlockCache = new SerializableDictionary<IPAddr' IPObj>();                      IPAddr source = packet.SourceIP;                      if (data.BlockCache.ContainsKey(source))                      {                          pmr = PacketMainReturnType.Drop;                          return pmr;                      }                        // checking for TTL allows us to rule out the local network                      // Don't check for TCP flags because we can make an educated guess that if 100+ of our ports are                       // fingered with a short window' we're being scanned. this will detect syn' ack' null' xmas' etc. scans.                      if ((!packet.Outbound) && (packet.TTL < 250) && packet.SYN && !packet.ACK)                      {                          IPObj tmp;                          if (ip_table == null) ip_table = new Dictionary<IPAddr' IPObj>();                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            // add the port to the ipobj' set the access time' and update the table                          tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            // if they've touched more than 100 ports in less than 30 seconds and the average                          // packet time was less than 2s' something's wrong                          if (tmp.getTouchedPorts().Count >= 100 && (!tmp.Reported) &&                               tmp.getAverage() < 2000 )                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                                  source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                // set the reported status of the IP address                              ip_table[source].Reported = true;                                // add the address to the potential list of IPs and to the local SESSION-BASED list                              if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              // else we want to block it immediately                              else                                  data.BlockCache.Add(source' ip_table[source]);                                                            return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }              // This will detect UDP knockers.  typically UDP scans are slower' but are combined with SYN scans              // (-sSU in nmap) so we'll be sure to check for these guys too.              else if (in_packet.ContainsLayer(Protocol.UDP))              {                  try                  {                      UDPPacket packet = (UDPPacket)in_packet;                      IPAddr source = packet.SourceIP;                      // if the source addr is in the block cache' return                       if (data.BlockCache.ContainsKey(source))                      {                          return PacketMainReturnType.Drop;                      }                        if ((!packet.Outbound) && (packet.TTL < 250) &&                           (!packet.isDNS()))                      {                          IPObj tmp;                          if (ip_table.ContainsKey(source))                              tmp = (IPObj)ip_table[source];                          else                              tmp = new IPObj(source);                            tmp.addPort(packet.DestPort);                          //tmp.time(packet.PacketTime);                          ip_table[source] = tmp;                          av = tmp.getAverage();                            if ((tmp.getTouchedPorts().Count >= 100) && (!tmp.Reported) &&                                  (tmp.getAverage() < 2000))                          {                              pmr = PacketMainReturnType.Log | PacketMainReturnType.Allow;                              le = new LogEvent(String.Format(multistring.GetString("Touched Ports")'                                          source.ToString()' tmp.getTouchedPorts().Count' tmp.getAverage())' this);                              LogCenter.Instance.LogEvent(le);                                ip_table[source].Reported = true;                                if (!data.blockImmediately)                              {                                  potentials.Add(source' ip_table[source]);                                  detect.addPotential(source);                              }                              else                                  data.BlockCache.Add(source' ip_table[source]);                              return pmr;                          }                      }                  }                  catch (Exception e)                  {                      LogCenter.Instance.LogException(e);                      return PacketMainReturnType.Allow;                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,timer_Tick,The following statement contains a magic number: foreach ( IPAddr ip in list )              {                  IPObj tmp = (IPObj)ip_table[ip];                  if (!tmp.Reported)                  {                      if ((DateTime.Now.Ticks - tmp.last_access) > (30 * 10000000) && (DateTime.Now.Ticks - tmp.last_access) < (60 * 10000000))                      {                          tmp.Touched_Ports = new SerializableList<int>();                      }                      else if ((DateTime.Now.Ticks - tmp.last_access) >= (60 * 10000000))                      {                          ip_table.Remove(ip);                      }                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,timer_Tick,The following statement contains a magic number: foreach ( IPAddr ip in list )              {                  IPObj tmp = (IPObj)ip_table[ip];                  if (!tmp.Reported)                  {                      if ((DateTime.Now.Ticks - tmp.last_access) > (30 * 10000000) && (DateTime.Now.Ticks - tmp.last_access) < (60 * 10000000))                      {                          tmp.Touched_Ports = new SerializableList<int>();                      }                      else if ((DateTime.Now.Ticks - tmp.last_access) >= (60 * 10000000))                      {                          ip_table.Remove(ip);                      }                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,timer_Tick,The following statement contains a magic number: foreach ( IPAddr ip in list )              {                  IPObj tmp = (IPObj)ip_table[ip];                  if (!tmp.Reported)                  {                      if ((DateTime.Now.Ticks - tmp.last_access) > (30 * 10000000) && (DateTime.Now.Ticks - tmp.last_access) < (60 * 10000000))                      {                          tmp.Touched_Ports = new SerializableList<int>();                      }                      else if ((DateTime.Now.Ticks - tmp.last_access) >= (60 * 10000000))                      {                          ip_table.Remove(ip);                      }                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,timer_Tick,The following statement contains a magic number: foreach ( IPAddr ip in list )              {                  IPObj tmp = (IPObj)ip_table[ip];                  if (!tmp.Reported)                  {                      if ((DateTime.Now.Ticks - tmp.last_access) > (30 * 10000000) && (DateTime.Now.Ticks - tmp.last_access) < (60 * 10000000))                      {                          tmp.Touched_Ports = new SerializableList<int>();                      }                      else if ((DateTime.Now.Ticks - tmp.last_access) >= (60 * 10000000))                      {                          ip_table.Remove(ip);                      }                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,timer_Tick,The following statement contains a magic number: foreach ( IPAddr ip in list )              {                  IPObj tmp = (IPObj)ip_table[ip];                  if (!tmp.Reported)                  {                      if ((DateTime.Now.Ticks - tmp.last_access) > (30 * 10000000) && (DateTime.Now.Ticks - tmp.last_access) < (60 * 10000000))                      {                          tmp.Touched_Ports = new SerializableList<int>();                      }                      else if ((DateTime.Now.Ticks - tmp.last_access) >= (60 * 10000000))                      {                          ip_table.Remove(ip);                      }                  }              }
Magic Number,ScanDetector,ScanDetector,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetector.cs,timer_Tick,The following statement contains a magic number: foreach ( IPAddr ip in list )              {                  IPObj tmp = (IPObj)ip_table[ip];                  if (!tmp.Reported)                  {                      if ((DateTime.Now.Ticks - tmp.last_access) > (30 * 10000000) && (DateTime.Now.Ticks - tmp.last_access) < (60 * 10000000))                      {                          tmp.Touched_Ports = new SerializableList<int>();                      }                      else if ((DateTime.Now.Ticks - tmp.last_access) >= (60 * 10000000))                      {                          ip_table.Remove(ip);                      }                  }              }
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.ColumnCount = 2;
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.RowCount = 2;
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(555' 446);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(555' 446);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(358' 3);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(358' 3);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(194' 373);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(194' 373);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.potentialIPBox.Size = new System.Drawing.Size(194' 373);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.potentialIPBox.Size = new System.Drawing.Size(194' 373);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.blockedIPList.Location = new System.Drawing.Point(3' 3);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.blockedIPList.Location = new System.Drawing.Point(3' 3);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.blockedIPList.Size = new System.Drawing.Size(349' 373);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.blockedIPList.Size = new System.Drawing.Size(349' 373);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(358' 382);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(358' 382);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(194' 61);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(194' 61);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel2.TabIndex = 2;
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.skipPotential.Location = new System.Drawing.Point(4' 33);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.skipPotential.Location = new System.Drawing.Point(4' 33);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.skipPotential.Size = new System.Drawing.Size(111' 17);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.skipPotential.Size = new System.Drawing.Size(111' 17);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.skipPotential.TabIndex = 2;
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.blockButton.Location = new System.Drawing.Point(3' 3);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.blockButton.Location = new System.Drawing.Point(3' 3);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.blockButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.blockButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel3.Location = new System.Drawing.Point(3' 382);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel3.Location = new System.Drawing.Point(3' 382);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel3.Size = new System.Drawing.Size(349' 61);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel3.Size = new System.Drawing.Size(349' 61);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.panel3.TabIndex = 3;
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.infoButton.Location = new System.Drawing.Point(4' 32);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.infoButton.Location = new System.Drawing.Point(4' 32);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.infoButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.infoButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.removeBlockedButton.Location = new System.Drawing.Point(4' 2);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.removeBlockedButton.Location = new System.Drawing.Point(4' 2);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.removeBlockedButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.removeBlockedButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.cloakedMode.Location = new System.Drawing.Point(251' 36);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.cloakedMode.Location = new System.Drawing.Point(251' 36);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.cloakedMode.Size = new System.Drawing.Size(95' 17);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.cloakedMode.Size = new System.Drawing.Size(95' 17);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.cloakedMode.TabIndex = 2;
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(555' 446);
Magic Number,ScanDetector,ScanDetectorUI,C:\repos\bwall_fireBwall\fireBwall\ScanDetector\ScanDetectorUI.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(555' 446);
