Implementation smell,Namespace,Class,File,Method,Description
Long Method,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,Upload,The method has 114 lines of code.
Long Method,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The method has 111 lines of code.
Complex Method,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,CalculateState,Cyclomatic complexity of the method is 9
Long Parameter List,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,Upload,The method has 6 parameters. Parameters: md5' path_to_contents' filename' extension' hidden' compressed_mime
Long Parameter List,MonkeyWrench.Database,DBLogin_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLogin_Extensions.cs,LoginUser,The method has 5 parameters. Parameters: db' login' password' ip4' readonly
Long Parameter List,MonkeyWrench.Database,DBLogin_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLogin_Extensions.cs,GitHubLogin,The method has 5 parameters. Parameters: db' response' ip4' userOrgs' gitHubLogin
Long Parameter List,MonkeyWrench.Database,DBLogin_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLogin_Extensions.cs,LoginDB,The method has 5 parameters. Parameters: db' response' username' roles' ip4
Long Parameter List,MonkeyWrench.Database,DBRevisionWorkView_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWorkView_Extensions.cs,Query,The method has 5 parameters. Parameters: db' lane' host' limit' page
Long Parameter List,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,GetNextWork,The method has 6 parameters. Parameters: rw' db' lane' host' revision' multiple_work
Long Parameter List,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,FilterPendingWork,The method has 5 parameters. Parameters: rw' db' steps' result' multiple_work
Long Parameter List,MonkeyWrench.Database,DBWorkFileView_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWorkFileView_Extensions.cs,Find,The method has 5 parameters. Parameters: db' filename' lane' revision' host
Long Parameter List,MonkeyWrench.Database,DBWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWork_Extensions.cs,AddFile,The method has 5 parameters. Parameters: me' db' file' filename' hidden
Long Parameter List,MonkeyWrench.Database,DBWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWork_Extensions.cs,AddFile,The method has 6 parameters. Parameters: me' db' path' filename' hidden' compressed_mime
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,Connect,The length of the statement  "				log.DebugFormat ("DB now: {0:yyyy/MM/dd HH:mm:ss.ffff}' current machine's now: {1:yyyy/MM/dd HH:mm:ss.ffff}' adjusted now: {3}' diff: {2:yyyy/MM/dd HH:mm:ss.ffff} ms"' db_now' machine_now' db_time_difference.TotalMilliseconds' Now); " is 232.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,Download,The length of the statement  "				return new System.IO.Compression.GZipStream (new FileStream (DBFile_Extensions.GetFullPath (file.md5)' FileMode.Open' FileAccess.Read)' System.IO.Compression.CompressionMode.Decompress); " is 186.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,GetHostsForLane,The length of the statement  "				cmd.CommandText = "SELECT *' HostLane.lane_id AS lane_id FROM Host INNER JOIN HostLane ON Host.id = HostLane.host_id WHERE lane_id = @lane_id"; " is 143.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,GetLanesForHost,The length of the statement  "				cmd.CommandText = "SELECT *' HostLane.host_id AS host_id' HostLane.enabled AS lane_enabled FROM Lane INNER JOIN HostLane ON Lane.id = HostLane.lane_id WHERE host_id = @host_id "; " is 178.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,IgnoreWork,The length of the statement  "	Work SET state = 11' summary = DEFAULT' starttime = DEFAULT' endtime = DEFAULT' duration = DEFAULT' logfile = DEFAULT' host_id = DEFAULT " is 136.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,ClearWork,The length of the statement  "	Work SET state = DEFAULT' summary = DEFAULT' starttime = DEFAULT' endtime = DEFAULT' duration = DEFAULT' logfile = DEFAULT' host_id = DEFAULT " is 141.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,DeleteWork,The length of the statement  "				//				cmd.CommandText = "DELETE FROM Work WHERE lane_id = @lane_id AND revision_id = @revision_id AND host_id = @host_id;"; " is 123.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,HasWork,The length of the statement  "				cmd.CommandText = "SELECT Count (*) FROM Work WHERE lane_id = @lane_id AND revision_id = @revision_id AND host_id = @host_id"; " is 126.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,GetNextStep,The length of the statement  "				cmd.CommandText = "SELECT * FROM steps WHERE lane = @lane AND (state = 0 OR state = 1) ORDER BY revision DESC' sequence LIMIT 1"; " is 129.
Long Statement,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,GetHostLane,The length of the statement  "						throw new Exception (string.Format ("Found more than one HostLane with host_id {0} and lane_id {1}"' host_id' lane_id)); " is 120.
Long Statement,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The length of the statement  "							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"' " is 139.
Long Statement,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The length of the statement  "											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match); " is 193.
Long Statement,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The length of the statement  "												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered); " is 151.
Long Statement,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The length of the statement  "												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex); " is 137.
Long Statement,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The length of the statement  "				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"' " is 122.
Long Statement,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The length of the statement  "					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L)); " is 198.
Long Statement,MonkeyWrench.Database,DBCommand_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBCommand_Extensions.cs,Delete,The length of the statement  "					"DELETE FROM WorkFile WHERE EXISTS (SELECT * FROM Work WHERE Work.lane_id = @lane_id AND Work.command_id = @id AND Work.id = WorkFile.work_id); " + " is 147.
Long Statement,MonkeyWrench.Database,DBLaneDeletionDirectiveView_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLaneDeletionDirectiveView_Extensions.cs,Find,The length of the statement  "				cmd.CommandText = @"SELECT * From LaneDeletionDirectiveView WHERE lane_id = @lane_id AND file_deletion_directive_id = @file_deletion_directive_id;"; " is 148.
Long Statement,MonkeyWrench.Database,DBLaneDependency_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLaneDependency_Extensions.cs,IsSuccess,The length of the statement  "				DB.CreateParameter (cmd' "revision"' revision); // Don't join with id here' if the revision comes from another lane' it might have a different id " is 145.
Long Statement,MonkeyWrench.Database,DBLaneDependency_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLaneDependency_Extensions.cs,IsSuccess,The length of the statement  "				log.DebugFormat ("Dependency id {0}: {1} (condition: {2}' revision: {3}' host_id: {4}' filename: {5}' lane: {6})"' me.id' result' me.Condition' revision' me.dependent_host_id.HasValue ? me.dependent_host_id.Value.ToString () : "null"' me.filename' me.dependent_lane_id); " is 270.
Long Statement,MonkeyWrench.Database,DBLanefile_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLanefile_Extensions.cs,GetLanesForFile,The length of the statement  "				cmd.CommandText = "SELECT * FROM Lane WHERE Lane.id IN (SELECT DISTINCT lane_id FROM Lanefiles WHERE lanefile_id = @lanefile_id);"; " is 131.
Long Statement,MonkeyWrench.Database,DBLane_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLane_Extensions.cs,GetFiles,The length of the statement  "				cmd.CommandText = "SELECT Lanefile.* FROM Lanefile INNER JOIN Lanefiles ON Lanefiles.lanefile_id = Lanefile.id WHERE Lanefiles.lane_id = " + me.id.ToString (); " is 159.
Long Statement,MonkeyWrench.Database,DBLane_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLane_Extensions.cs,GetDependentLanes,The length of the statement  "				cmd.CommandText = "SELECT Lane.* FROM Lane INNER JOIN LaneDependency ON LaneDependency.lane_id = Lane.id WHERE LaneDependency.dependent_lane_id = @lane_id ORDER BY Lane.lane;"; " is 176.
Long Statement,MonkeyWrench.Database,DBLogin_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLogin_Extensions.cs,GitHubLogin,The length of the statement  "				throw new Exception (String.Format("No valid organizations or teams available for logging in. Got {0}"' UserOrgsToString(userOrgs))); " is 133.
Long Statement,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,CalculateState,The length of the statement  "				cmd.CommandText = "SELECT state' Command.nonfatal FROM Work INNER JOIN Command ON Work.command_id = Command.id WHERE revisionwork_id = @revisionwork_id ORDER BY sequence"; " is 171.
Long Statement,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,CalculateState,The length of the statement  "			if (ForAny (states' nonfatal' delegate (DBState state' bool nf) { return !nf && (state == DBState.Failed || state == DBState.Timeout); })) " is 138.
Long Statement,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,CalculateState,The length of the statement  "			if (ForAny (states' nonfatal' delegate (DBState state' bool nf) { return nf && (state == DBState.Failed || state == DBState.Timeout || state == DBState.Aborted); })) " is 165.
Long Statement,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,FilterPendingWork,The length of the statement  "					if (!steps [i].nonfatal && (steps [i].State == DBState.Failed || steps [i].State == DBState.Timeout || steps [i].State == DBState.Aborted)) { " is 141.
Long Statement,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,Find,The length of the statement  "						throw new ApplicationException (string.Format ("Found more than one revision work for the specified lane/host/revision ({0}/{1}/{2})"' lane.lane' host == null ? "null" : host.host' revision.revision)); " is 201.
Long Statement,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,SetWorkHost,The length of the statement  "			string update_cmd = string.Format (@"UPDATE RevisionWork SET workhost_id = {0}' assignedtime = NOW() WHERE id = {1} AND workhost_id IS NULL;"' host.id' rw.id); " is 159.
Long Statement,MonkeyWrench.Database,DBWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWork_Extensions.cs,AddFile,The length of the statement  "				cmd.CommandText = "INSERT INTO WorkFile (work_id' file_id' hidden' filename) VALUES (@work_id' @file_id' @hidden' @filename);"; " is 127.
Long Statement,MonkeyWrench.Database,DBWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWork_Extensions.cs,GetFile,The length of the statement  "SELECT File.id' File.md5' File.file_id' File.mime' File.compressed_mime' File.size' File.file_id' File.hidden OR WorkFile.hidden AS hidden' " is 139.
Long Statement,MonkeyWrench.Database,DBWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWork_Extensions.cs,GetFile,The length of the statement  "    WHERE WorkFile.work_id = @work_id AND (WorkFile.filename = @filename OR (WorkFile.filename = '' AND File.filename = @filename)); " is 128.
Long Statement,MonkeyWrench.Database,DBWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWork_Extensions.cs,GetFile,The length of the statement  "						throw new Exception (string.Format ("Found more than one file in work with id {0} whose filename is '{1}'"' work_id' filename)); " is 128.
Long Statement,MonkeyWrench.Database,DBWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWork_Extensions.cs,GetFiles,The length of the statement  "					cmd.CommandText = "SELECT * FROM WorkFileView WHERE work_id = @work_id AND (hidden = false OR filename = 'index.html');"; " is 121.
Complex Conditional,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,CalculateState,The conditional expression  "ForAny (states' nonfatal' delegate (DBState state' bool nf) { return nf && (state == DBState.Failed || state == DBState.Timeout || state == DBState.Aborted); })"  is complex.
Complex Conditional,MonkeyWrench.Database,DBRevisionWork_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBRevisionWork_Extensions.cs,FilterPendingWork,The conditional expression  "!steps [i].nonfatal && (steps [i].State == DBState.Failed || steps [i].State == DBState.Timeout || steps [i].State == DBState.Aborted)"  is complex.
Magic Number,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,CreateCommand,The following statement contains a magic number: return CreateCommand (TimeSpan.FromSeconds (300));
Magic Number,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,Upload,The following statement contains a magic number: try {  				filesize = new FileInfo (path_to_contents).Length;  				if (filesize > 1024 * 1024 * 500)  					throw new Exception ("Max file size is 500 MB");    				using (IDbCommand cmd = CreateCommand ()) {  					cmd.CommandText = "SELECT * FROM File WHERE md5 = '" + md5 + "'";  					using (IDataReader reader = cmd.ExecuteReader ()) {  						if (reader.Read ())  							return new DBFile (reader);  					}  				}    				//Console.WriteLine ("Uploading {0} {1} with compressed mime: {2}"' Filename' md5' compressed_mime);    				// The file is not in the database  				// Note: there is a race condition here'  				// the same file might get added to the db before we do it here.  				// not quite sure how to deal with that except retrying the above if the insert below fails.    				if (compressed_mime == MimeTypes.GZ) {  					gzFilename = path_to_contents;  				} else {  					gzFilename = FileUtilities.GZCompress (path_to_contents);  					compressed_mime = MimeTypes.GZ;  				}    				transaction = BeginTransaction ();    				if (Configuration.StoreFilesInDB) {  					manager = new LargeObjectManager (this.dbcon);  					oid = manager.Create (LargeObjectManager.READWRITE);  					obj = manager.Open (oid.Value' LargeObjectManager.READWRITE);    					using (FileStream st = new FileStream (gzFilename' FileMode.Open' FileAccess.Read' FileShare.Read)) {  						byte [] buffer = new byte [1024];  						int read = -1;  						while (read != 0) {  							read = st.Read (buffer' 0' buffer.Length);  							obj.Write (buffer' 0' read);  						}  					}  					obj.Close ();  				} else {  					oid = null;  					string fn = FileUtilities.CreateFilename (md5' true' true);    					File.Copy (gzFilename' fn' true);  					log.DebugFormat ("Saved file to: {0}"' fn);  				}    				result = new DBFile ();  				result.file_id = oid;  				result.filename = Path.GetFileName (filename);  				result.md5 = md5;  				result.size = (int) filesize;  				result.hidden = hidden;  				switch (extension.ToLower ()) {  				case ".log":  				case ".stdout":  				case ".stderr":  					result.mime = MimeTypes.LOG;  					break;  				case ".txt":  					result.mime = MimeTypes.TXT;  					break;  				case ".htm":  				case ".html":  					result.mime = MimeTypes.HTML;  					break;  				case ".png":  					result.mime = MimeTypes.PNG;  					break;  				case ".jpg":  					result.mime = MimeTypes.JPG;  					break;  				case ".bmp":  					result.mime = MimeTypes.BMP;  					break;  				case ".tar":  					result.mime = MimeTypes.TAR;  					break;  				case ".bz":  					result.mime = MimeTypes.BZ;  					break;  				case ".bz2":  					result.mime = MimeTypes.BZ2;  					break;  				case ".zip":  					result.mime = MimeTypes.ZIP; ;  					break;  				case ".gz":  					result.mime = MimeTypes.GZ;  					break;  				case ".xpi":  					result.mime = MimeTypes.XPI;  					break;  				case ".crx":  					result.mime = MimeTypes.CRX;  					break;  				default:  					result.mime = MimeTypes.OCTET_STREAM;  					break;  				}  				result.compressed_mime = compressed_mime;  				result.Save (this);    				transaction.Commit ();  				transaction = null;    				return result;  			} finally {  				FileUtilities.TryDeleteFile (gzFilename);    				if (transaction != null)  					transaction.Rollback ();  			}
Magic Number,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,Upload,The following statement contains a magic number: try {  				filesize = new FileInfo (path_to_contents).Length;  				if (filesize > 1024 * 1024 * 500)  					throw new Exception ("Max file size is 500 MB");    				using (IDbCommand cmd = CreateCommand ()) {  					cmd.CommandText = "SELECT * FROM File WHERE md5 = '" + md5 + "'";  					using (IDataReader reader = cmd.ExecuteReader ()) {  						if (reader.Read ())  							return new DBFile (reader);  					}  				}    				//Console.WriteLine ("Uploading {0} {1} with compressed mime: {2}"' Filename' md5' compressed_mime);    				// The file is not in the database  				// Note: there is a race condition here'  				// the same file might get added to the db before we do it here.  				// not quite sure how to deal with that except retrying the above if the insert below fails.    				if (compressed_mime == MimeTypes.GZ) {  					gzFilename = path_to_contents;  				} else {  					gzFilename = FileUtilities.GZCompress (path_to_contents);  					compressed_mime = MimeTypes.GZ;  				}    				transaction = BeginTransaction ();    				if (Configuration.StoreFilesInDB) {  					manager = new LargeObjectManager (this.dbcon);  					oid = manager.Create (LargeObjectManager.READWRITE);  					obj = manager.Open (oid.Value' LargeObjectManager.READWRITE);    					using (FileStream st = new FileStream (gzFilename' FileMode.Open' FileAccess.Read' FileShare.Read)) {  						byte [] buffer = new byte [1024];  						int read = -1;  						while (read != 0) {  							read = st.Read (buffer' 0' buffer.Length);  							obj.Write (buffer' 0' read);  						}  					}  					obj.Close ();  				} else {  					oid = null;  					string fn = FileUtilities.CreateFilename (md5' true' true);    					File.Copy (gzFilename' fn' true);  					log.DebugFormat ("Saved file to: {0}"' fn);  				}    				result = new DBFile ();  				result.file_id = oid;  				result.filename = Path.GetFileName (filename);  				result.md5 = md5;  				result.size = (int) filesize;  				result.hidden = hidden;  				switch (extension.ToLower ()) {  				case ".log":  				case ".stdout":  				case ".stderr":  					result.mime = MimeTypes.LOG;  					break;  				case ".txt":  					result.mime = MimeTypes.TXT;  					break;  				case ".htm":  				case ".html":  					result.mime = MimeTypes.HTML;  					break;  				case ".png":  					result.mime = MimeTypes.PNG;  					break;  				case ".jpg":  					result.mime = MimeTypes.JPG;  					break;  				case ".bmp":  					result.mime = MimeTypes.BMP;  					break;  				case ".tar":  					result.mime = MimeTypes.TAR;  					break;  				case ".bz":  					result.mime = MimeTypes.BZ;  					break;  				case ".bz2":  					result.mime = MimeTypes.BZ2;  					break;  				case ".zip":  					result.mime = MimeTypes.ZIP; ;  					break;  				case ".gz":  					result.mime = MimeTypes.GZ;  					break;  				case ".xpi":  					result.mime = MimeTypes.XPI;  					break;  				case ".crx":  					result.mime = MimeTypes.CRX;  					break;  				default:  					result.mime = MimeTypes.OCTET_STREAM;  					break;  				}  				result.compressed_mime = compressed_mime;  				result.Save (this);    				transaction.Commit ();  				transaction = null;    				return result;  			} finally {  				FileUtilities.TryDeleteFile (gzFilename);    				if (transaction != null)  					transaction.Rollback ();  			}
Magic Number,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,Upload,The following statement contains a magic number: try {  				filesize = new FileInfo (path_to_contents).Length;  				if (filesize > 1024 * 1024 * 500)  					throw new Exception ("Max file size is 500 MB");    				using (IDbCommand cmd = CreateCommand ()) {  					cmd.CommandText = "SELECT * FROM File WHERE md5 = '" + md5 + "'";  					using (IDataReader reader = cmd.ExecuteReader ()) {  						if (reader.Read ())  							return new DBFile (reader);  					}  				}    				//Console.WriteLine ("Uploading {0} {1} with compressed mime: {2}"' Filename' md5' compressed_mime);    				// The file is not in the database  				// Note: there is a race condition here'  				// the same file might get added to the db before we do it here.  				// not quite sure how to deal with that except retrying the above if the insert below fails.    				if (compressed_mime == MimeTypes.GZ) {  					gzFilename = path_to_contents;  				} else {  					gzFilename = FileUtilities.GZCompress (path_to_contents);  					compressed_mime = MimeTypes.GZ;  				}    				transaction = BeginTransaction ();    				if (Configuration.StoreFilesInDB) {  					manager = new LargeObjectManager (this.dbcon);  					oid = manager.Create (LargeObjectManager.READWRITE);  					obj = manager.Open (oid.Value' LargeObjectManager.READWRITE);    					using (FileStream st = new FileStream (gzFilename' FileMode.Open' FileAccess.Read' FileShare.Read)) {  						byte [] buffer = new byte [1024];  						int read = -1;  						while (read != 0) {  							read = st.Read (buffer' 0' buffer.Length);  							obj.Write (buffer' 0' read);  						}  					}  					obj.Close ();  				} else {  					oid = null;  					string fn = FileUtilities.CreateFilename (md5' true' true);    					File.Copy (gzFilename' fn' true);  					log.DebugFormat ("Saved file to: {0}"' fn);  				}    				result = new DBFile ();  				result.file_id = oid;  				result.filename = Path.GetFileName (filename);  				result.md5 = md5;  				result.size = (int) filesize;  				result.hidden = hidden;  				switch (extension.ToLower ()) {  				case ".log":  				case ".stdout":  				case ".stderr":  					result.mime = MimeTypes.LOG;  					break;  				case ".txt":  					result.mime = MimeTypes.TXT;  					break;  				case ".htm":  				case ".html":  					result.mime = MimeTypes.HTML;  					break;  				case ".png":  					result.mime = MimeTypes.PNG;  					break;  				case ".jpg":  					result.mime = MimeTypes.JPG;  					break;  				case ".bmp":  					result.mime = MimeTypes.BMP;  					break;  				case ".tar":  					result.mime = MimeTypes.TAR;  					break;  				case ".bz":  					result.mime = MimeTypes.BZ;  					break;  				case ".bz2":  					result.mime = MimeTypes.BZ2;  					break;  				case ".zip":  					result.mime = MimeTypes.ZIP; ;  					break;  				case ".gz":  					result.mime = MimeTypes.GZ;  					break;  				case ".xpi":  					result.mime = MimeTypes.XPI;  					break;  				case ".crx":  					result.mime = MimeTypes.CRX;  					break;  				default:  					result.mime = MimeTypes.OCTET_STREAM;  					break;  				}  				result.compressed_mime = compressed_mime;  				result.Save (this);    				transaction.Commit ();  				transaction = null;    				return result;  			} finally {  				FileUtilities.TryDeleteFile (gzFilename);    				if (transaction != null)  					transaction.Rollback ();  			}
Magic Number,MonkeyWrench,DB,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DB.cs,Upload,The following statement contains a magic number: try {  				filesize = new FileInfo (path_to_contents).Length;  				if (filesize > 1024 * 1024 * 500)  					throw new Exception ("Max file size is 500 MB");    				using (IDbCommand cmd = CreateCommand ()) {  					cmd.CommandText = "SELECT * FROM File WHERE md5 = '" + md5 + "'";  					using (IDataReader reader = cmd.ExecuteReader ()) {  						if (reader.Read ())  							return new DBFile (reader);  					}  				}    				//Console.WriteLine ("Uploading {0} {1} with compressed mime: {2}"' Filename' md5' compressed_mime);    				// The file is not in the database  				// Note: there is a race condition here'  				// the same file might get added to the db before we do it here.  				// not quite sure how to deal with that except retrying the above if the insert below fails.    				if (compressed_mime == MimeTypes.GZ) {  					gzFilename = path_to_contents;  				} else {  					gzFilename = FileUtilities.GZCompress (path_to_contents);  					compressed_mime = MimeTypes.GZ;  				}    				transaction = BeginTransaction ();    				if (Configuration.StoreFilesInDB) {  					manager = new LargeObjectManager (this.dbcon);  					oid = manager.Create (LargeObjectManager.READWRITE);  					obj = manager.Open (oid.Value' LargeObjectManager.READWRITE);    					using (FileStream st = new FileStream (gzFilename' FileMode.Open' FileAccess.Read' FileShare.Read)) {  						byte [] buffer = new byte [1024];  						int read = -1;  						while (read != 0) {  							read = st.Read (buffer' 0' buffer.Length);  							obj.Write (buffer' 0' read);  						}  					}  					obj.Close ();  				} else {  					oid = null;  					string fn = FileUtilities.CreateFilename (md5' true' true);    					File.Copy (gzFilename' fn' true);  					log.DebugFormat ("Saved file to: {0}"' fn);  				}    				result = new DBFile ();  				result.file_id = oid;  				result.filename = Path.GetFileName (filename);  				result.md5 = md5;  				result.size = (int) filesize;  				result.hidden = hidden;  				switch (extension.ToLower ()) {  				case ".log":  				case ".stdout":  				case ".stderr":  					result.mime = MimeTypes.LOG;  					break;  				case ".txt":  					result.mime = MimeTypes.TXT;  					break;  				case ".htm":  				case ".html":  					result.mime = MimeTypes.HTML;  					break;  				case ".png":  					result.mime = MimeTypes.PNG;  					break;  				case ".jpg":  					result.mime = MimeTypes.JPG;  					break;  				case ".bmp":  					result.mime = MimeTypes.BMP;  					break;  				case ".tar":  					result.mime = MimeTypes.TAR;  					break;  				case ".bz":  					result.mime = MimeTypes.BZ;  					break;  				case ".bz2":  					result.mime = MimeTypes.BZ2;  					break;  				case ".zip":  					result.mime = MimeTypes.ZIP; ;  					break;  				case ".gz":  					result.mime = MimeTypes.GZ;  					break;  				case ".xpi":  					result.mime = MimeTypes.XPI;  					break;  				case ".crx":  					result.mime = MimeTypes.CRX;  					break;  				default:  					result.mime = MimeTypes.OCTET_STREAM;  					break;  				}  				result.compressed_mime = compressed_mime;  				result.Save (this);    				transaction.Commit ();  				transaction = null;    				return result;  			} finally {  				FileUtilities.TryDeleteFile (gzFilename);    				if (transaction != null)  					transaction.Rollback ();  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DeletionDirectives,C:\repos\mono_monkeywrench\MonkeyWrench.Database\DeletionDirectives.cs,Execute,The following statement contains a magic number: try {  				log.Debug ("ExecuteDeletionDirectives: Start");  				  				is_executing = true;    				using (DB db = new DB (true)) {  					List<DBLane> lanes = db.GetAllLanes ();  					foreach (DBLane lane in lanes) {  						log.DebugFormat ("ExecuteDeletionDirectives: Lane = {0} {1}"' lane.id' lane.lane);  						List<DBLaneDeletionDirectiveView> directives = DBLaneDeletionDirectiveView_Extensions.Find (db' lane);  						foreach (DBLaneDeletionDirectiveView directive in directives) {  							log.DebugFormat ("ExecuteDeletionDirectives: Found directive: '{0}' Enabled: {1}' Condition: {2}' Filename: '{3}'' MatchMode: {4}' X: {5}"'  								directive.name' directive.enabled' directive.Condition' directive.filename' directive.MatchMode' directive.x);    							if (!directive.enabled)  								continue;    							string sql = @"  SELECT   	WorkFile.id AS workfile_id'  	WorkFile.filename AS workfile_filename'  	File.id AS file_id'  	File.file_id AS file_file_id'  	File.md5'  	File.size'  	Revision.revision  FROM   	WorkFile  INNER JOIN Work ON Work.id = WorkFile.work_id  INNER JOIN File ON WorkFile.file_id = File.id	  INNER JOIN RevisionWork ON RevisionWork.id = Work.revisionwork_id  INNER JOIN Revision ON Revision.id = RevisionWork.revision_id  WHERE  	RevisionWork.lane_id = @lane_id  	AND RevisionWork.completed = TRUE  ";  							switch (directive.Condition) {  							case DBDeleteCondition.AfterXBuiltRevisions:  								sql += string.Format (@"   AND Revision.id NOT IN (  	SELECT Revision.id  	FROM Revision  	INNER JOIN RevisionWork ON Revision.id = RevisionWork.revision_id  	WHERE   		RevisionWork.lane_id = @lane_id   		AND Revision.lane_id = @lane_id  		AND RevisionWork.completed = TRUE  	ORDER BY Revision.date DESC  	LIMIT {0}  )  "' (int) directive.x);  								break;  							case DBDeleteCondition.AfterXDays:  								sql += string.Format (@"  AND Work.endtime + interval '{0} days' < now ();  "' (int) directive.x);  								break;  							default:  								continue;  							}    							using (IDbCommand cmd = db.CreateCommand (TimeSpan.FromHours (1 /* this is a slow query' have a big timeout */))) {  								cmd.CommandText = sql;  								DB.CreateParameter (cmd' "lane_id"' lane.id);  								using (IDataReader reader = cmd.ExecuteReader ()) {  									using (DB write_db = new DB (true)) {  										while (reader.Read ()) {  											int index;  											string workfile_filename;  											int workfile_id;  											int? file_file_id = null;  											int file_id;  											int size;  											string md5;  											bool match;    											workfile_filename = reader.GetString (reader.GetOrdinal ("workfile_filename"));  											match = directive.IsFileNameMatch (workfile_filename);    											if (!match)  												continue;    											index = reader.GetOrdinal ("file_file_id");  											if (!reader.IsDBNull (index))  												file_file_id = reader.GetInt32 (reader.GetOrdinal ("file_file_id"));  											file_id = reader.GetInt32 (reader.GetOrdinal ("file_id"));  											size = reader.GetInt32 (reader.GetOrdinal ("size"));  											md5 = reader.GetString (reader.GetOrdinal ("md5"));  											workfile_id = reader.GetInt32 (reader.GetOrdinal ("workfile_id"));    											log.DebugFormat ("ExecuteDeletionDirectives:  >Processing: workfile_id: {0}' workfile_filename: '{1}'' file_id: {2}' md5: {3}' match: {4}"' workfile_id' workfile_filename' file_id' md5' match);    											// delete the work file  											DBRecord_Extensions.Delete (write_db' workfile_id' DBWorkFile.TableName);  											log.InfoFormat ("ExecuteDeletionDirectives:  >>WorkFile {0} deleted succesfully."' workfile_id);    											// try to delete the file too  											try {  												DBFile_Extensions.Delete (write_db' file_id' file_file_id' md5);  												space_recovered += size;  												log.InfoFormat ("ExecuteDeletionDirectives:  >>File {0} deleted successfully. Recovered {1} bytes (total {2} bytes)."' file_id' size' space_recovered);  											} catch (Exception ex) {  												log.ErrorFormat ("ExecuteDeletionDirectives:  >>Could not delete File (since the File is used somewhere else' this is normal): {0}"' ex);  											}  										}  									}  								}  							}  						}  					}  				}    				log.InfoFormat ("ExecuteDeletionDirectives: Deleted {0} bytes ({1:#0.0} Kb' {2:#0.00} Mb' {3:#0.000} Gb' {4:#0.0000} Tb)"'  					space_recovered' space_recovered / (double) 1024' space_recovered / (double) (1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024)' space_recovered / (double) (1024 * 1024 * 1024 * 1024L));  			} catch (Exception ex) {  				log.ErrorFormat ("ExecuteDeletionDirectives: Exception: {0}"' ex);  			} finally {  				is_executing = false;  			}
Magic Number,MonkeyWrench.Database,DBLogin_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLogin_Extensions.cs,Login,The following statement contains a magic number: foreach (var spec in specs) {  				// org:role1'role2  				// email:role1'role2  				string [] split = spec.Split (':');  				if (split.Length != 2) {  					log.ErrorFormat ("AuthenticateLogin: Invalid role spec: {0}"' spec);  					continue;  				}    				if (string.IsNullOrEmpty (split [1])) {  					log.ErrorFormat ("AuthenticateLogin: No roles specified for {0}"' split [0]);  					continue;  				}    				var roleSpecCheck = split[0];  				var roles = split[1];    				if (!Regex.IsMatch (email' roleSpecCheck))  					continue;    				LoginDB (db' response' username' roles' ip4);    				return;  			}
Magic Number,MonkeyWrench.Database,DBLogin_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBLogin_Extensions.cs,CreateCookie,The following statement contains a magic number: byte [] data = new byte [32];
Magic Number,MonkeyWrench.Database,DBWorkFile_Extensions,C:\repos\mono_monkeywrench\MonkeyWrench.Database\Extensions\DBWorkFile_Extensions.cs,WriteToDisk,The following statement contains a magic number: byte [] buffer = new byte [1024];
