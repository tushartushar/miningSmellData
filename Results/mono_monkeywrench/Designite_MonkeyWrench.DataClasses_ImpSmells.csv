Implementation smell,Namespace,Class,File,Method,Description
Long Method,MonkeyWrench.DataClasses,SqlToCSharp,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\SqlToCSharp.cs,ParseView,The method has 202 lines of code.
Long Method,MonkeyWrench.DataClasses,SqlToCSharp,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\SqlToCSharp.cs,ParseTable,The method has 164 lines of code.
Long Method,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The method has 178 lines of code.
Complex Method,MonkeyWrench.DataClasses,DBRecord,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\Database\DBRecord.cs,SaveInternal,Cyclomatic complexity of the method is 9
Complex Method,MonkeyWrench.DataClasses,DBWork,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\Database\DBWork.cs,CalculateSummary,Cyclomatic complexity of the method is 11
Complex Method,MonkeyWrench.DataClasses,SqlToCSharp,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\SqlToCSharp.cs,ParseView,Cyclomatic complexity of the method is 21
Complex Method,MonkeyWrench.DataClasses,SqlToCSharp,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\SqlToCSharp.cs,ParseTable,Cyclomatic complexity of the method is 15
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginLoginOpenId,The method has 5 parameters. Parameters: login' email' ip4' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginCreateLanefile,The method has 5 parameters. Parameters: login' lane_id' filename' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAttachFileToLane,The method has 5 parameters. Parameters: login' lane_id' lanefile_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginDeattachFileFromLane,The method has 5 parameters. Parameters: login' lane_id' lanefile_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditCommandFilename,The method has 5 parameters. Parameters: login' command_id' filename' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditCommandSequence,The method has 5 parameters. Parameters: login' command_id' sequence' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditCommandArguments,The method has 5 parameters. Parameters: login' command_id' arguments' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditCommandTimeout,The method has 5 parameters. Parameters: login' command_id' timeout' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditCommandWorkingDirectory,The method has 5 parameters. Parameters: login' command_id' working_directory' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditCommandUploadFiles,The method has 5 parameters. Parameters: login' command_id' upload_files' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,AddCommand,The method has 7 parameters. Parameters: login' lane_id' command' always_execute' nonfatal' timeout' sequence
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddCommand,The method has 9 parameters. Parameters: login' lane_id' command' always_execute' nonfatal' timeout' sequence' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginSwitchHostEnabledForLane,The method has 5 parameters. Parameters: login' lane_id' host_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginSwitchHostHiddenForLane,The method has 5 parameters. Parameters: login' lane_id' host_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginRemoveHostForLane,The method has 5 parameters. Parameters: login' lane_id' host_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddHostToLane,The method has 5 parameters. Parameters: login' lane_id' host_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,AddDependencyToLane,The method has 5 parameters. Parameters: login' lane_id' dependent_lane_id' host_id' condition
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddDependencyToLane,The method has 7 parameters. Parameters: login' lane_id' dependent_lane_id' host_id' condition' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditLaneDependencyFilename,The method has 5 parameters. Parameters: login' lanedependency_id' filename' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditLaneDependencyDownloads,The method has 5 parameters. Parameters: login' lanedependency_id' downloads' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginDeleteDeletionDirective,The method has 5 parameters. Parameters: login' lane_directive_id' file_directive_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEnableDeletionDirective,The method has 5 parameters. Parameters: login' lane_deletion_directive_id' enabled' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,AddFileDeletionDirective,The method has 6 parameters. Parameters: login' filename' name' match_mode' x' condition
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddFileDeletionDirective,The method has 8 parameters. Parameters: login' filename' name' match_mode' x' condition' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddLaneDeletionDirective,The method has 5 parameters. Parameters: login' file_deletion_directive_id' lane_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginFindLaneDeletionDirective,The method has 5 parameters. Parameters: login' file_deletion_directive_id' lane_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetWorkHostHistory,The method has 5 parameters. Parameters: login' host_id' host' limit' offset
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetWorkHostHistory,The method has 7 parameters. Parameters: login' host_id' host' limit' offset' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetHostForEdit,The method has 5 parameters. Parameters: login' host_id' host' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddMasterHost,The method has 5 parameters. Parameters: login' host_id' masterhost_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginRemoveMasterHost,The method has 5 parameters. Parameters: login' host_id' masterhost_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetLaneForEdit,The method has 5 parameters. Parameters: login' lane_id' lane' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginFindHost,The method has 5 parameters. Parameters: login' host_id' host' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,FindRevisionForLane,The method has 5 parameters. Parameters: login' revision_id' revision' lane_id' lane
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginFindRevisionForLane,The method has 7 parameters. Parameters: login' revision_id' revision' lane_id' lane' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginFindRevision,The method has 5 parameters. Parameters: login' revision_id' revision' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginFindLane,The method has 5 parameters. Parameters: login' lane_id' lane' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginFindLaneWithDependencies,The method has 5 parameters. Parameters: login' lane_id' lane' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditLaneWithTags,The method has 5 parameters. Parameters: login' lane' tags' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditHostWithPassword,The method has 5 parameters. Parameters: login' host' password' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetViewLaneData,The method has 7 parameters. Parameters: login' lane_id' lane' host_id' host' revision_id' revision
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetViewLaneData,The method has 9 parameters. Parameters: login' lane_id' lane' host_id' host' revision_id' revision' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetViewLaneData2,The method has 8 parameters. Parameters: login' lane_id' lane' host_id' host' revision_id' revision' include_hidden_files
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetViewLaneData2,The method has 10 parameters. Parameters: login' lane_id' lane' host_id' host' revision_id' revision' include_hidden_files' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetFrontPageData,The method has 6 parameters. Parameters: login' limit' lane' lane_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetFrontPageData2,The method has 6 parameters. Parameters: login' limit' lanes' lane_ids' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetFrontPageData3,The method has 5 parameters. Parameters: login' page_size' page' lanes' lane_ids
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetFrontPageData3,The method has 7 parameters. Parameters: login' page_size' page' lanes' lane_ids' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetFrontPageData4,The method has 6 parameters. Parameters: login' page_size' page' lanes' lane_ids' latest_days
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetFrontPageData4,The method has 8 parameters. Parameters: login' page_size' page' lanes' lane_ids' latest_days' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetFrontPageDataWithTags,The method has 7 parameters. Parameters: login' page_size' page' lanes' lane_ids' latest_days' tags
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetFrontPageDataWithTags,The method has 9 parameters. Parameters: login' page_size' page' lanes' lane_ids' latest_days' tags' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetRevisions,The method has 5 parameters. Parameters: login' lane_id' lane' limit' offset
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetRevisions,The method has 7 parameters. Parameters: login' lane_id' lane' limit' offset' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginCloneLane,The method has 6 parameters. Parameters: login' lane_id' new_name' copy_files' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginIgnoreRevision,The method has 6 parameters. Parameters: login' lane_id' host_id' revision_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginClearRevision,The method has 6 parameters. Parameters: login' lane_id' host_id' revision_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginRescheduleRevision,The method has 6 parameters. Parameters: login' lane_id' host_id' revision_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAbortRevision,The method has 6 parameters. Parameters: login' lane_id' host_id' revision_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetViewTableData,The method has 7 parameters. Parameters: login' lane_id' lane' host_id' host' page' page_size
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetViewTableData,The method has 9 parameters. Parameters: login' lane_id' lane' host_id' host' page' page_size' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,GetViewWorkTableData,The method has 7 parameters. Parameters: login' lane_id' lane' host_id' host' command_id' command
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetViewWorkTableData,The method has 9 parameters. Parameters: login' lane_id' lane' host_id' host' command_id' command' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddUserEmail,The method has 6 parameters. Parameters: login' id' username' email' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginRemoveUserEmail,The method has 6 parameters. Parameters: login' id' username' email' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetUser,The method has 5 parameters. Parameters: login' id' username' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,AddEnvironmentVariable,The method has 5 parameters. Parameters: login' lane_id' host_id' name' value
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddEnvironmentVariable,The method has 7 parameters. Parameters: login' lane_id' host_id' name' value' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadCompressedFile,The method has 6 parameters. Parameters: login' work' filename' contents' hidden' compressed_mime
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginUploadCompressedFile,The method has 8 parameters. Parameters: login' work' filename' contents' hidden' compressed_mime' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginUploadLinks,The method has 5 parameters. Parameters: login' work' links' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFile,The method has 5 parameters. Parameters: login' work' filename' contents' hidden
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginUploadFile,The method has 7 parameters. Parameters: login' work' filename' contents' hidden' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetFilesForWork,The method has 6 parameters. Parameters: login' revisionwork_id' command_id' filename' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetRevisionWorkForLane,The method has 6 parameters. Parameters: login' lane_id' revision_id' host_id' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginGetBuildInfoMultiple,The method has 5 parameters. Parameters: login' host' multiple_work' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,FindLatestWorkFileId,The method has 6 parameters. Parameters: login' lane_id' lane' filename' completed' successful
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginFindLatestWorkFileId,The method has 8 parameters. Parameters: login' lane_id' lane' filename' completed' successful' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginEditIdentity,The method has 5 parameters. Parameters: login' irc_identity' email_identity' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginRemoveIdentity,The method has 5 parameters. Parameters: login' irc_identity' email_identity' callback' asyncState
Long Parameter List,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,BeginAddLaneNotification,The method has 5 parameters. Parameters: login' lane_id' notification_id' callback' asyncState
Long Statement,MonkeyWrench.DataClasses,SqlToCSharp,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\SqlToCSharp.cs,ParseView,The length of the statement  "								Console.WriteLine ("Couldn't find type for column: '{0}' (type: {1} aliased table: {2}={3})"' column' type' tbl' tbl_alias);" is 124.
Long Statement,MonkeyWrench.DataClasses,SqlToCSharp,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\SqlToCSharp.cs,ParseView,The length of the statement  "				writer.WriteLine ("\t\tpublic const string SQL = \n@\"{0}\";"' sql.Replace ("\""' "\\\"").Replace ("\t\t"' "\t    ").Replace ("\t"' "\n\t").Replace ("\t    "' "\t\t"));" is 168.
Long Statement,MonkeyWrench.DataClasses,SqlToCSharp,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\SqlToCSharp.cs,ParseTable,The length of the statement  "					builder.AppendFormat ("\t\tpublic {0} @{1} {{ get {{ return _{2}; }} set {{ _{2} = value; }} }}\n"' mtype' column' column);" is 123.
Long Statement,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,ReadResponse,The length of the statement  "				throw new ApplicationException (string.Format ("Got unexpected response version from server' expected version = 1' got version = {0} and type = {1}"' version' type));" is 166.
Long Statement,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The length of the statement  "							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents);" is 136.
Long Statement,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The length of the statement  "									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename));" is 168.
Long Statement,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFileSafe,The length of the statement  "					log.WarnFormat ("Not uploading {0} ({2}): filesize is > 200MB (it is: {1} MB)"' file_to_upload' length / (1024.0 * 1024.0)' filename);" is 134.
Long Statement,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFileSafe,The length of the statement  "					this.UploadCompressedFile (WebServiceLogin' work' Path.GetFileName (filename)' File.ReadAllBytes (file_to_upload)' hidden' compressed_mime);" is 140.
Virtual Method Call from Constructor,MonkeyWrench.DataClasses,DBRecord,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\Database\DBRecord.cs,DBRecord,The constructor "DBRecord" calls a virtual method "Load".
Empty Catch Block,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,DownloadString,The method has an empty catch block.
Magic Number,MonkeyWrench.DataClasses,DBEnvironmentVariable,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\Database\DBEnvironmentVariable.cs,Evaluate,The following statement contains a magic number: end = var.IndexOf ('}'' start + 2);
Magic Number,MonkeyWrench.DataClasses,DBEnvironmentVariable,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\Database\DBEnvironmentVariable.cs,Evaluate,The following statement contains a magic number: string n = var.Substring (start + 2' end - start - 2);
Magic Number,MonkeyWrench.DataClasses,DBEnvironmentVariable,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\Database\DBEnvironmentVariable.cs,Evaluate,The following statement contains a magic number: string n = var.Substring (start + 2' end - start - 2);
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,ReadResponse,The following statement contains a magic number: switch (type) { 			case 3: 				/* error */ 				message_length = reader.ReadUInt16 (); 				buffer = new byte [message_length]; 				message = ReadString (reader' buffer' message_length); 				throw new ApplicationException (string.Format ("Got error from server: {0}"' message)); 			}
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following statement contains a magic number: ExecuteSafe ("Upload files safe"' () => 			{ 				byte version; 				byte type; 				int port; 				string gz = null; 				BinaryReader reader = null; 				BinaryWriter writer = null; 				NetworkStream stream = null; 				byte [] buffer = new byte [1024]; 				TcpClient client = null;  				if (files.Count == 0) 					return;  				log.InfoFormat ("UploadFilesSafe () trying to upload {0} files..."' files.Count);  				port = this.GetUploadPort ();  				try { 					client = new TcpClient (); 					client.Connect (new Uri (this.Url' UriKind.Absolute).Host' port); 					stream = client.GetStream (); 					stream.ReadTimeout = (int) TimeSpan.FromMinutes (5).TotalMilliseconds; 					stream.WriteTimeout = stream.ReadTimeout; 					reader = new BinaryReader (stream); 					writer = new BinaryWriter (stream);  					writer.Write ((byte) 1); // version 					WriteStringByte (writer' WebServiceLogin.User); // name_length + name 					WriteStringByte (writer' WebServiceLogin.Password); // password_length + password 					writer.Write ((int) work.id); // work_id 					writer.Write ((ushort) filenames.Length); // file_count 					writer.Write ((ulong) 0); // reserved 					 					const string NotFoundMessage = "*** COULD NOT FIND THIS FILE' UPLOADED THIS ERROR MESSAGE INSTEAD ***"; 					byte [] NotFoundMessageBytes = null;  					while (files.Count > 0) { 						string path_to_contents = files.Peek (); 						string filename = Path.GetFileName (path_to_contents); 						string compressed_mime; 						bool hidden = hiddens.Peek (); 						byte [] md5; 						FileInfo fi; 						bool exists = File.Exists (path_to_contents);  						if (!exists && NotFoundMessageBytes == null) 							NotFoundMessageBytes = Encoding.UTF8.GetBytes (NotFoundMessage); 						 						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}' to port {1}"' filename' port);  						if (exists) { 							using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) 								md5 = FileUtilities.CalculateMD5_Bytes (fs); 						} else { 							log.ErrorFormat ("WebServices.UploadFilesSafe (): the file '{0}' does not exist' uploading an error message instead"' path_to_contents); 							using (var str = new MemoryStream (NotFoundMessageBytes)) 								md5 = FileUtilities.CalculateMD5_Bytes (str); 						}  						writer.Write ("MonkeyWrench".ToCharArray ()); // marker 						writer.Write (md5' 0' md5.Length); // md5 						writer.Write ((byte) (hidden ? 3 : 1)); // flags 						WriteStringByte (writer' filename); // filename_length + filename 						writer.Flush ();  						ReadResponse (reader' out version' out type);  						log.DebugFormat ("WebServices.UploadFilesSafe (): uploading '{0}'' got response type {1}"' filename' type);  						// 1 = everything OK' 2 = file received OK' 3 = error' 4 = send file 						switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}  						files.Dequeue (); 						hiddens.Dequeue (); 					} 					ReadResponse (reader' out version' out type); 					if (type == 4) { 						log.Info ("UploadFilesSafe (): all files uploaded successfully"); 					} 				} finally { 					FileUtilities.TryDeleteFile (gz); 					try { 						stream.Close (); 						reader.Close (); 						writer.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing streams: {0}"' ex); 					} 					try { 						client.Close (); 					} catch (Exception ex) { 						log.ErrorFormat("Error closing client: {0}"' ex); 					} 				} 			});
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFileSafe,The following statement contains a magic number: log.WarnFormat ("Not uploading {0} ({2}): filesize is > 200MB (it is: {1} MB)"' file_to_upload' length / (1024.0 * 1024.0)' filename);
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFileSafe,The following statement contains a magic number: log.WarnFormat ("Not uploading {0} ({2}): filesize is > 200MB (it is: {1} MB)"' file_to_upload' length / (1024.0 * 1024.0)' filename);
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFileSafe,The following statement contains a magic number: length > 1024 * 1024 * 200
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFileSafe,The following statement contains a magic number: length > 1024 * 1024 * 200
Magic Number,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFileSafe,The following statement contains a magic number: length > 1024 * 1024 * 200
Missing Default,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,ReadResponse,The following switch statement is missing a default case: switch (type) { 			case 3: 				/* error */ 				message_length = reader.ReadUInt16 (); 				buffer = new byte [message_length]; 				message = ReadString (reader' buffer' message_length); 				throw new ApplicationException (string.Format ("Got error from server: {0}"' message)); 			}
Missing Default,MonkeyWrench.Web.WebServices,WebServices,C:\research\architectureSmells\repos\mono_monkeywrench\MonkeyWrench.DataClasses\WebServices.cs,UploadFilesSafe,The following switch statement is missing a default case: switch (type) { 						case 2: 							/* No need to send file */ 							break; 						case 4: 							/* Send file */ 							int read; 							int total = 0;  							// try to compress the file 							if (exists) { 								string original_contents = path_to_contents; 								try { 									gz = FileUtilities.GZCompress (path_to_contents); 									if (gz != null) { 										path_to_contents = gz; 										compressed_mime = MimeTypes.GZ; 									} else { 										path_to_contents = filename; 										compressed_mime = null; 									} 									log.DebugFormat ("Compressed {0} to {1}."' original_contents' gz); 								} catch (Exception ex) { 									path_to_contents = filename; 									compressed_mime = null; 									log.WarnFormat ("Could not compress the file {0}: {1}' uploading uncompressed."' filename' ex); 								}  								fi = new FileInfo (path_to_contents);  								long length = fi.Length; 								if (length > 1024 * 1024 * 250) { 									files.Dequeue (); 									hiddens.Dequeue (); 									throw new ApplicationException (string.Format ("Not uploading {0} ({2}): filesize is > 250MB (it is: {1} MB)"' path_to_contents' length / (1024.0 * 1024.0)' filename)); 								}  								if (compressed_mime == null) { 									writer.Write ((byte) 0); 								} else { 									WriteStringByte (writer' compressed_mime); // compressed_mime_length + compressed_mime 								} 								writer.Write ((uint) fi.Length); // content_length  								using (FileStream fs = new FileStream (path_to_contents' FileMode.Open' FileAccess.Read' FileShare.Read)) { 									while ((read = fs.Read (buffer' 0' buffer.Length)) != 0) { 										total += read; 										writer.Write (buffer' 0' read); 									} 									writer.Flush (); 								} 							} else { 								writer.Write ((byte) 0); 								writer.Write ((uint) NotFoundMessageBytes.Length); 								writer.Write (NotFoundMessageBytes' 0' NotFoundMessageBytes.Length); 								writer.Flush (); 								total += NotFoundMessageBytes.Length; 							}  							log.DebugFormat ("UploadFilesSafe (): uploaded '{0}'' {1} bytes"' filename' total);  							ReadResponse (reader' out version' out type); 							if (type == 2) { 								log.InfoFormat ("UploadFilesSafe (): uploaded '{0}' successfully"' filename); 							} 							break; 						}
