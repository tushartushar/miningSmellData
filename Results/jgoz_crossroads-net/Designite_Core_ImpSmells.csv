Implementation smell,Namespace,Class,File,Method,Description
Long Statement,CrossroadsIO,SendReceiveExtensions,C:\repos\jgoz_crossroads-net\src\Core\SendReceiveExtensions.cs,SendMessage,The length of the statement  "                throw new ArgumentException("Unable to send an incomplete message. Ensure HasMore on the last Frame is set to 'false'."' "message"); " is 132.
Long Statement,CrossroadsIO,Socket,C:\repos\jgoz_crossroads-net\src\Core\Socket.cs,Send,The length of the statement  "                throw new ArgumentOutOfRangeException("size"' "Expected a non-negative value less than or equal to the buffer length."); " is 120.
Long Statement,CrossroadsIO.Interop,SocketProxy,C:\repos\jgoz_crossroads-net\src\Core\Interop\SocketProxy.cs,Forward,The length of the statement  "                if ((bytesSent = LibXs.xs_sendmsg(destinationHandle' _message' receiveMore == 1 ? (int)SocketFlags.SendMore : 0)) == -1) " is 120.
Magic Number,CrossroadsIO,Socket,C:\repos\jgoz_crossroads-net\src\Core\Socket.cs,ExecuteWithTimeout,The following statement contains a magic number: do              {                  receiveResult = method();                    if (ReceiveStatus != ReceiveStatus.TryAgain || timeoutMilliseconds <= 1)                  {                      break;                  }                    if (iterations < 20 && ProcessorCount > 1)                  {                      // If we have a short wait (< 20 iterations) we SpinWait to allow other threads                      // on HyperThreaded CPUs to use the CPU. The more CPUs we have' the longer it's                      // acceptable to SpinWait since we stall the overall system less.                      Thread.SpinWait(100 * ProcessorCount);                  }                  else                  {                      Thread.Yield();                  }                    ++iterations;              }              while (timer.Elapsed < timeout);
Magic Number,CrossroadsIO,Socket,C:\repos\jgoz_crossroads-net\src\Core\Socket.cs,ExecuteWithTimeout,The following statement contains a magic number: do              {                  receiveResult = method();                    if (ReceiveStatus != ReceiveStatus.TryAgain || timeoutMilliseconds <= 1)                  {                      break;                  }                    if (iterations < 20 && ProcessorCount > 1)                  {                      // If we have a short wait (< 20 iterations) we SpinWait to allow other threads                      // on HyperThreaded CPUs to use the CPU. The more CPUs we have' the longer it's                      // acceptable to SpinWait since we stall the overall system less.                      Thread.SpinWait(100 * ProcessorCount);                  }                  else                  {                      Thread.Yield();                  }                    ++iterations;              }              while (timer.Elapsed < timeout);
Magic Number,CrossroadsIO.Devices,Device,C:\repos\jgoz_crossroads-net\src\Core\Devices\Device.cs,Close,The following statement contains a magic number: if (IsRunning)              {                  Stop();                  Join(TimeSpan.FromMilliseconds(PollingIntervalMsec * 2));              }
Magic Number,CrossroadsIO.Devices,Device,C:\repos\jgoz_crossroads-net\src\Core\Devices\Device.cs,Dispose,The following statement contains a magic number: if (IsRunning)              {                  Stop();                  Join(TimeSpan.FromMilliseconds(PollingIntervalMsec * 2));              }
Magic Number,CrossroadsIO.Interop,SocketProxy,C:\repos\jgoz_crossroads-net\src\Core\Interop\SocketProxy.cs,GetReceiveMore,The following statement contains a magic number: if (LibXs.MajorVersion >= 3)              {                  return GetSocketOption((int)SocketOption.RCVMORE' out receiveMore);              }
Missing Default,CrossroadsIO,Context,C:\repos\jgoz_crossroads-net\src\Core\Context.cs,CreateSocket,The following switch statement is missing a default case: switch (socketType)              {                  case SocketType.REQ:                  case SocketType.REP:                  case SocketType.XREQ:                  case SocketType.XREP:                  case SocketType.XPUB:                  case SocketType.PAIR:                      return CreateSocket(sp => new DuplexSocket(sp' socketType)' socketType);                    case SocketType.PUSH:                  case SocketType.PUB:                      return CreateSocket(sp => new SendSocket(sp' socketType)' socketType);                    case SocketType.PULL:                      return CreateSocket(sp => new ReceiveSocket(sp' socketType)' socketType);                    case SocketType.SUB:                      return CreateSocket(sp => new SubscribeSocket(sp' socketType)' socketType);                    case SocketType.XSUB:                      return CreateSocket(sp => new SubscribeExtSocket(sp' socketType)' socketType);              }
