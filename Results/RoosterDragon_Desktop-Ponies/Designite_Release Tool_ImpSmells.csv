Implementation smell,Namespace,Class,File,Method,Description
Long Method,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The method has 119 lines of code.
Complex Method,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CropImages,Cyclomatic complexity of the method is 9
Complex Method,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,Cyclomatic complexity of the method is 10
Long Identifier,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CleanPdbFiles,The length of the parameter solutionParentDirectoryUpperEncoded is 35.
Long Identifier,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CleanPdbFiles,The length of the parameter solutionParentDirectoryLowerEncoded is 35.
Long Statement,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,Main,The length of the statement  "            string dpVersion = FileVersionInfo.GetVersionInfo(Assembly.GetAssembly(typeof(DesktopPonies.Direction)).Location).FileVersion; " is 126.
Long Statement,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CropImages,The length of the statement  "                // Ignore any images involved in effects or behavior chains when set up by follow targets' as the transparent borders may " is 121.
Long Statement,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CropImages,The length of the statement  "                // For effects' each side could be considered individually and the minimum of any shared padding between the behavior and " is 121.
Long Statement,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CropImages,The length of the statement  "                // For images in sequences' the union of the minimums for each image in the sequences for both the follower and followee " is 120.
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The following statement contains a magic number: foreach (var sourceBitmap in bitmaps)              {                  var bitmap = sourceBitmap.Clone(area' PixelFormat.Format32bppArgb);                  Rectangle srcRect;                  BitmapData data = null;                  try                  {                      #region Determine Bitmap Crop Area                      data = bitmap.LockBits(area' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);                      byte[] buffer = new byte[data.Height * data.Stride];                      Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                        int xMin = int.MaxValue'                          xMax = int.MinValue'                          yMin = int.MaxValue'                          yMax = int.MinValue;                        bool foundPixel = false;                        // Find xMin                      for (int x = 0; x < data.Width; x++)                      {                          bool stop = false;                          for (int y = 0; y < data.Height; y++)                          {                              byte alpha = buffer[y * data.Stride + 4 * x + 3];                              if (alpha != 0)                              {                                  xMin = x;                                  stop = true;                                  foundPixel = true;                                  break;                              }                          }                          if (stop)                              break;                      }                        // Image is empty...                      if (!foundPixel)                      {                          srcRect = Rectangle.Empty;                      }                      else                      {                          // Find yMin                          for (int y = 0; y < data.Height; y++)                          {                              bool stop = false;                              for (int x = xMin; x < data.Width; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMin = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find xMax                          for (int x = data.Width - 1; x >= xMin; x--)                          {                              bool stop = false;                              for (int y = yMin; y < data.Height; y++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      xMax = x;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find yMax                          for (int y = data.Height - 1; y >= yMin; y--)                          {                              bool stop = false;                              for (int x = xMin; x <= xMax; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMax = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            srcRect = Rectangle.FromLTRB(xMin' yMin' xMax + 1' yMax + 1);                      }                      #endregion                  }                  finally                  {                      if (data != null)                          bitmap.UnlockBits(data);                  }                  if (cropLimits == null)                      cropLimits = srcRect;                  else                      cropLimits = Rectangle.Union(cropLimits.Value' srcRect);              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The following statement contains a magic number: foreach (var sourceBitmap in bitmaps)              {                  var bitmap = sourceBitmap.Clone(area' PixelFormat.Format32bppArgb);                  Rectangle srcRect;                  BitmapData data = null;                  try                  {                      #region Determine Bitmap Crop Area                      data = bitmap.LockBits(area' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);                      byte[] buffer = new byte[data.Height * data.Stride];                      Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                        int xMin = int.MaxValue'                          xMax = int.MinValue'                          yMin = int.MaxValue'                          yMax = int.MinValue;                        bool foundPixel = false;                        // Find xMin                      for (int x = 0; x < data.Width; x++)                      {                          bool stop = false;                          for (int y = 0; y < data.Height; y++)                          {                              byte alpha = buffer[y * data.Stride + 4 * x + 3];                              if (alpha != 0)                              {                                  xMin = x;                                  stop = true;                                  foundPixel = true;                                  break;                              }                          }                          if (stop)                              break;                      }                        // Image is empty...                      if (!foundPixel)                      {                          srcRect = Rectangle.Empty;                      }                      else                      {                          // Find yMin                          for (int y = 0; y < data.Height; y++)                          {                              bool stop = false;                              for (int x = xMin; x < data.Width; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMin = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find xMax                          for (int x = data.Width - 1; x >= xMin; x--)                          {                              bool stop = false;                              for (int y = yMin; y < data.Height; y++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      xMax = x;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find yMax                          for (int y = data.Height - 1; y >= yMin; y--)                          {                              bool stop = false;                              for (int x = xMin; x <= xMax; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMax = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            srcRect = Rectangle.FromLTRB(xMin' yMin' xMax + 1' yMax + 1);                      }                      #endregion                  }                  finally                  {                      if (data != null)                          bitmap.UnlockBits(data);                  }                  if (cropLimits == null)                      cropLimits = srcRect;                  else                      cropLimits = Rectangle.Union(cropLimits.Value' srcRect);              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The following statement contains a magic number: foreach (var sourceBitmap in bitmaps)              {                  var bitmap = sourceBitmap.Clone(area' PixelFormat.Format32bppArgb);                  Rectangle srcRect;                  BitmapData data = null;                  try                  {                      #region Determine Bitmap Crop Area                      data = bitmap.LockBits(area' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);                      byte[] buffer = new byte[data.Height * data.Stride];                      Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                        int xMin = int.MaxValue'                          xMax = int.MinValue'                          yMin = int.MaxValue'                          yMax = int.MinValue;                        bool foundPixel = false;                        // Find xMin                      for (int x = 0; x < data.Width; x++)                      {                          bool stop = false;                          for (int y = 0; y < data.Height; y++)                          {                              byte alpha = buffer[y * data.Stride + 4 * x + 3];                              if (alpha != 0)                              {                                  xMin = x;                                  stop = true;                                  foundPixel = true;                                  break;                              }                          }                          if (stop)                              break;                      }                        // Image is empty...                      if (!foundPixel)                      {                          srcRect = Rectangle.Empty;                      }                      else                      {                          // Find yMin                          for (int y = 0; y < data.Height; y++)                          {                              bool stop = false;                              for (int x = xMin; x < data.Width; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMin = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find xMax                          for (int x = data.Width - 1; x >= xMin; x--)                          {                              bool stop = false;                              for (int y = yMin; y < data.Height; y++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      xMax = x;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find yMax                          for (int y = data.Height - 1; y >= yMin; y--)                          {                              bool stop = false;                              for (int x = xMin; x <= xMax; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMax = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            srcRect = Rectangle.FromLTRB(xMin' yMin' xMax + 1' yMax + 1);                      }                      #endregion                  }                  finally                  {                      if (data != null)                          bitmap.UnlockBits(data);                  }                  if (cropLimits == null)                      cropLimits = srcRect;                  else                      cropLimits = Rectangle.Union(cropLimits.Value' srcRect);              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The following statement contains a magic number: foreach (var sourceBitmap in bitmaps)              {                  var bitmap = sourceBitmap.Clone(area' PixelFormat.Format32bppArgb);                  Rectangle srcRect;                  BitmapData data = null;                  try                  {                      #region Determine Bitmap Crop Area                      data = bitmap.LockBits(area' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);                      byte[] buffer = new byte[data.Height * data.Stride];                      Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                        int xMin = int.MaxValue'                          xMax = int.MinValue'                          yMin = int.MaxValue'                          yMax = int.MinValue;                        bool foundPixel = false;                        // Find xMin                      for (int x = 0; x < data.Width; x++)                      {                          bool stop = false;                          for (int y = 0; y < data.Height; y++)                          {                              byte alpha = buffer[y * data.Stride + 4 * x + 3];                              if (alpha != 0)                              {                                  xMin = x;                                  stop = true;                                  foundPixel = true;                                  break;                              }                          }                          if (stop)                              break;                      }                        // Image is empty...                      if (!foundPixel)                      {                          srcRect = Rectangle.Empty;                      }                      else                      {                          // Find yMin                          for (int y = 0; y < data.Height; y++)                          {                              bool stop = false;                              for (int x = xMin; x < data.Width; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMin = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find xMax                          for (int x = data.Width - 1; x >= xMin; x--)                          {                              bool stop = false;                              for (int y = yMin; y < data.Height; y++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      xMax = x;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find yMax                          for (int y = data.Height - 1; y >= yMin; y--)                          {                              bool stop = false;                              for (int x = xMin; x <= xMax; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMax = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            srcRect = Rectangle.FromLTRB(xMin' yMin' xMax + 1' yMax + 1);                      }                      #endregion                  }                  finally                  {                      if (data != null)                          bitmap.UnlockBits(data);                  }                  if (cropLimits == null)                      cropLimits = srcRect;                  else                      cropLimits = Rectangle.Union(cropLimits.Value' srcRect);              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The following statement contains a magic number: foreach (var sourceBitmap in bitmaps)              {                  var bitmap = sourceBitmap.Clone(area' PixelFormat.Format32bppArgb);                  Rectangle srcRect;                  BitmapData data = null;                  try                  {                      #region Determine Bitmap Crop Area                      data = bitmap.LockBits(area' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);                      byte[] buffer = new byte[data.Height * data.Stride];                      Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                        int xMin = int.MaxValue'                          xMax = int.MinValue'                          yMin = int.MaxValue'                          yMax = int.MinValue;                        bool foundPixel = false;                        // Find xMin                      for (int x = 0; x < data.Width; x++)                      {                          bool stop = false;                          for (int y = 0; y < data.Height; y++)                          {                              byte alpha = buffer[y * data.Stride + 4 * x + 3];                              if (alpha != 0)                              {                                  xMin = x;                                  stop = true;                                  foundPixel = true;                                  break;                              }                          }                          if (stop)                              break;                      }                        // Image is empty...                      if (!foundPixel)                      {                          srcRect = Rectangle.Empty;                      }                      else                      {                          // Find yMin                          for (int y = 0; y < data.Height; y++)                          {                              bool stop = false;                              for (int x = xMin; x < data.Width; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMin = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find xMax                          for (int x = data.Width - 1; x >= xMin; x--)                          {                              bool stop = false;                              for (int y = yMin; y < data.Height; y++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      xMax = x;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find yMax                          for (int y = data.Height - 1; y >= yMin; y--)                          {                              bool stop = false;                              for (int x = xMin; x <= xMax; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMax = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            srcRect = Rectangle.FromLTRB(xMin' yMin' xMax + 1' yMax + 1);                      }                      #endregion                  }                  finally                  {                      if (data != null)                          bitmap.UnlockBits(data);                  }                  if (cropLimits == null)                      cropLimits = srcRect;                  else                      cropLimits = Rectangle.Union(cropLimits.Value' srcRect);              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The following statement contains a magic number: foreach (var sourceBitmap in bitmaps)              {                  var bitmap = sourceBitmap.Clone(area' PixelFormat.Format32bppArgb);                  Rectangle srcRect;                  BitmapData data = null;                  try                  {                      #region Determine Bitmap Crop Area                      data = bitmap.LockBits(area' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);                      byte[] buffer = new byte[data.Height * data.Stride];                      Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                        int xMin = int.MaxValue'                          xMax = int.MinValue'                          yMin = int.MaxValue'                          yMax = int.MinValue;                        bool foundPixel = false;                        // Find xMin                      for (int x = 0; x < data.Width; x++)                      {                          bool stop = false;                          for (int y = 0; y < data.Height; y++)                          {                              byte alpha = buffer[y * data.Stride + 4 * x + 3];                              if (alpha != 0)                              {                                  xMin = x;                                  stop = true;                                  foundPixel = true;                                  break;                              }                          }                          if (stop)                              break;                      }                        // Image is empty...                      if (!foundPixel)                      {                          srcRect = Rectangle.Empty;                      }                      else                      {                          // Find yMin                          for (int y = 0; y < data.Height; y++)                          {                              bool stop = false;                              for (int x = xMin; x < data.Width; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMin = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find xMax                          for (int x = data.Width - 1; x >= xMin; x--)                          {                              bool stop = false;                              for (int y = yMin; y < data.Height; y++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      xMax = x;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find yMax                          for (int y = data.Height - 1; y >= yMin; y--)                          {                              bool stop = false;                              for (int x = xMin; x <= xMax; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMax = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            srcRect = Rectangle.FromLTRB(xMin' yMin' xMax + 1' yMax + 1);                      }                      #endregion                  }                  finally                  {                      if (data != null)                          bitmap.UnlockBits(data);                  }                  if (cropLimits == null)                      cropLimits = srcRect;                  else                      cropLimits = Rectangle.Union(cropLimits.Value' srcRect);              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The following statement contains a magic number: foreach (var sourceBitmap in bitmaps)              {                  var bitmap = sourceBitmap.Clone(area' PixelFormat.Format32bppArgb);                  Rectangle srcRect;                  BitmapData data = null;                  try                  {                      #region Determine Bitmap Crop Area                      data = bitmap.LockBits(area' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);                      byte[] buffer = new byte[data.Height * data.Stride];                      Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                        int xMin = int.MaxValue'                          xMax = int.MinValue'                          yMin = int.MaxValue'                          yMax = int.MinValue;                        bool foundPixel = false;                        // Find xMin                      for (int x = 0; x < data.Width; x++)                      {                          bool stop = false;                          for (int y = 0; y < data.Height; y++)                          {                              byte alpha = buffer[y * data.Stride + 4 * x + 3];                              if (alpha != 0)                              {                                  xMin = x;                                  stop = true;                                  foundPixel = true;                                  break;                              }                          }                          if (stop)                              break;                      }                        // Image is empty...                      if (!foundPixel)                      {                          srcRect = Rectangle.Empty;                      }                      else                      {                          // Find yMin                          for (int y = 0; y < data.Height; y++)                          {                              bool stop = false;                              for (int x = xMin; x < data.Width; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMin = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find xMax                          for (int x = data.Width - 1; x >= xMin; x--)                          {                              bool stop = false;                              for (int y = yMin; y < data.Height; y++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      xMax = x;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find yMax                          for (int y = data.Height - 1; y >= yMin; y--)                          {                              bool stop = false;                              for (int x = xMin; x <= xMax; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMax = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            srcRect = Rectangle.FromLTRB(xMin' yMin' xMax + 1' yMax + 1);                      }                      #endregion                  }                  finally                  {                      if (data != null)                          bitmap.UnlockBits(data);                  }                  if (cropLimits == null)                      cropLimits = srcRect;                  else                      cropLimits = Rectangle.Union(cropLimits.Value' srcRect);              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,GetCroppedRegion,The following statement contains a magic number: foreach (var sourceBitmap in bitmaps)              {                  var bitmap = sourceBitmap.Clone(area' PixelFormat.Format32bppArgb);                  Rectangle srcRect;                  BitmapData data = null;                  try                  {                      #region Determine Bitmap Crop Area                      data = bitmap.LockBits(area' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);                      byte[] buffer = new byte[data.Height * data.Stride];                      Marshal.Copy(data.Scan0' buffer' 0' buffer.Length);                        int xMin = int.MaxValue'                          xMax = int.MinValue'                          yMin = int.MaxValue'                          yMax = int.MinValue;                        bool foundPixel = false;                        // Find xMin                      for (int x = 0; x < data.Width; x++)                      {                          bool stop = false;                          for (int y = 0; y < data.Height; y++)                          {                              byte alpha = buffer[y * data.Stride + 4 * x + 3];                              if (alpha != 0)                              {                                  xMin = x;                                  stop = true;                                  foundPixel = true;                                  break;                              }                          }                          if (stop)                              break;                      }                        // Image is empty...                      if (!foundPixel)                      {                          srcRect = Rectangle.Empty;                      }                      else                      {                          // Find yMin                          for (int y = 0; y < data.Height; y++)                          {                              bool stop = false;                              for (int x = xMin; x < data.Width; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMin = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find xMax                          for (int x = data.Width - 1; x >= xMin; x--)                          {                              bool stop = false;                              for (int y = yMin; y < data.Height; y++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      xMax = x;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            // Find yMax                          for (int y = data.Height - 1; y >= yMin; y--)                          {                              bool stop = false;                              for (int x = xMin; x <= xMax; x++)                              {                                  byte alpha = buffer[y * data.Stride + 4 * x + 3];                                  if (alpha != 0)                                  {                                      yMax = y;                                      stop = true;                                      break;                                  }                              }                              if (stop)                                  break;                          }                            srcRect = Rectangle.FromLTRB(xMin' yMin' xMax + 1' yMax + 1);                      }                      #endregion                  }                  finally                  {                      if (data != null)                          bitmap.UnlockBits(data);                  }                  if (cropLimits == null)                      cropLimits = srcRect;                  else                      cropLimits = Rectangle.Union(cropLimits.Value' srcRect);              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CropGifImage,The following statement contains a magic number: using (var process = new Process())              {                  process.StartInfo.CreateNoWindow = true;                  process.StartInfo.UseShellExecute = false;                    process.StartInfo.FileName = Path.Combine(toolDirectory' "gifsicle.exe");                  if (!File.Exists(process.StartInfo.FileName))                  {                      Console.WriteLine("Missing gifsicle.exe in current directory.");                      return;                  }                  string trimmedSourcePath = filePath.Replace(contentDirectory' "");                  Console.WriteLine("Cropping " + trimmedSourcePath);                  File.Copy(filePath' tempFilePath' true);                  process.StartInfo.Arguments = "-b --crop {1}'{2}+{3}x{4} \"{0}\"".FormatWith(                      tempFilePath' cropArea.X' cropArea.Y' cropArea.Width' cropArea.Height);                  process.Start();                  process.WaitForExit();                  if (process.ExitCode != 0)                      Console.WriteLine("gifsicle exited with code " + process.ExitCode + " for " + trimmedSourcePath);                  else                      RetryActionWithDelay(() => File.Replace(tempFilePath' filePath' null)' 3' TimeSpan.FromSeconds(0.5));              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CropGifImage,The following statement contains a magic number: using (var process = new Process())              {                  process.StartInfo.CreateNoWindow = true;                  process.StartInfo.UseShellExecute = false;                    process.StartInfo.FileName = Path.Combine(toolDirectory' "gifsicle.exe");                  if (!File.Exists(process.StartInfo.FileName))                  {                      Console.WriteLine("Missing gifsicle.exe in current directory.");                      return;                  }                  string trimmedSourcePath = filePath.Replace(contentDirectory' "");                  Console.WriteLine("Cropping " + trimmedSourcePath);                  File.Copy(filePath' tempFilePath' true);                  process.StartInfo.Arguments = "-b --crop {1}'{2}+{3}x{4} \"{0}\"".FormatWith(                      tempFilePath' cropArea.X' cropArea.Y' cropArea.Width' cropArea.Height);                  process.Start();                  process.WaitForExit();                  if (process.ExitCode != 0)                      Console.WriteLine("gifsicle exited with code " + process.ExitCode + " for " + trimmedSourcePath);                  else                      RetryActionWithDelay(() => File.Replace(tempFilePath' filePath' null)' 3' TimeSpan.FromSeconds(0.5));              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CompressGifs,The following statement contains a magic number: using (var process = new Process())              {                  process.StartInfo.CreateNoWindow = true;                  process.StartInfo.UseShellExecute = false;                    int gifsOptimized = 0;                  process.StartInfo.FileName = Path.Combine(toolDirectory' "gifsicle.exe");                  if (!File.Exists(process.StartInfo.FileName))                  {                      Console.WriteLine("Missing gifsicle.exe in current directory.");                      return 0;                  }                  Console.WriteLine();                  foreach (var sourceFilePath in Directory.EnumerateFiles(sourceDirectory' "*.gif"' SearchOption.AllDirectories))                  {                      string trimmedSourcePath = sourceFilePath.Replace(sourceDirectory' "");                      ConsoleReplacePreviousLine("Optimizing " + trimmedSourcePath);                      bool optimized = false;                      bool optimizedOnPass;                      do                      {                          optimizedOnPass = false;                          FileInfo sourceFile = new FileInfo(sourceFilePath);                          sourceFile.CopyTo(tempFilePath' true);                          process.StartInfo.Arguments =                              "-b -O3 --no-comments --no-extensions --no-names \"" + tempFilePath + "\"";                          process.Start();                          process.WaitForExit();                          if (process.ExitCode != 0)                          {                              Console.WriteLine("gifsicle exited with code " + process.ExitCode + " for " + trimmedSourcePath);                              Console.WriteLine();                          }                          else                          {                              FileInfo tempFile = new FileInfo(tempFilePath);                              if (tempFile.Length < sourceFile.Length)                              {                                  Console.WriteLine(                                      "Optimized " + sourceFile.Length + " to " + tempFile.Length + " for " + trimmedSourcePath);                                  RetryActionWithDelay(() => tempFile.Replace(sourceFilePath' null)' 3' TimeSpan.FromSeconds(0.5));                                  optimizedOnPass = true;                                  optimized = true;                              }                          }                      } while (optimizedOnPass);                      if (optimized)                      {                          Console.WriteLine();                          gifsOptimized++;                      }                  }                  if (File.Exists(tempFilePath))                      File.Delete(tempFilePath);                  ConsoleReplacePreviousLine(gifsOptimized + " GIFs optimized.");                  return gifsOptimized;              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CompressGifs,The following statement contains a magic number: using (var process = new Process())              {                  process.StartInfo.CreateNoWindow = true;                  process.StartInfo.UseShellExecute = false;                    int gifsOptimized = 0;                  process.StartInfo.FileName = Path.Combine(toolDirectory' "gifsicle.exe");                  if (!File.Exists(process.StartInfo.FileName))                  {                      Console.WriteLine("Missing gifsicle.exe in current directory.");                      return 0;                  }                  Console.WriteLine();                  foreach (var sourceFilePath in Directory.EnumerateFiles(sourceDirectory' "*.gif"' SearchOption.AllDirectories))                  {                      string trimmedSourcePath = sourceFilePath.Replace(sourceDirectory' "");                      ConsoleReplacePreviousLine("Optimizing " + trimmedSourcePath);                      bool optimized = false;                      bool optimizedOnPass;                      do                      {                          optimizedOnPass = false;                          FileInfo sourceFile = new FileInfo(sourceFilePath);                          sourceFile.CopyTo(tempFilePath' true);                          process.StartInfo.Arguments =                              "-b -O3 --no-comments --no-extensions --no-names \"" + tempFilePath + "\"";                          process.Start();                          process.WaitForExit();                          if (process.ExitCode != 0)                          {                              Console.WriteLine("gifsicle exited with code " + process.ExitCode + " for " + trimmedSourcePath);                              Console.WriteLine();                          }                          else                          {                              FileInfo tempFile = new FileInfo(tempFilePath);                              if (tempFile.Length < sourceFile.Length)                              {                                  Console.WriteLine(                                      "Optimized " + sourceFile.Length + " to " + tempFile.Length + " for " + trimmedSourcePath);                                  RetryActionWithDelay(() => tempFile.Replace(sourceFilePath' null)' 3' TimeSpan.FromSeconds(0.5));                                  optimizedOnPass = true;                                  optimized = true;                              }                          }                      } while (optimizedOnPass);                      if (optimized)                      {                          Console.WriteLine();                          gifsOptimized++;                      }                  }                  if (File.Exists(tempFilePath))                      File.Delete(tempFilePath);                  ConsoleReplacePreviousLine(gifsOptimized + " GIFs optimized.");                  return gifsOptimized;              }
Magic Number,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,CompressPngs,The following statement contains a magic number: using (var process = new Process())              {                  process.StartInfo.CreateNoWindow = true;                  process.StartInfo.UseShellExecute = false;                    process.StartInfo.FileName = Path.Combine(toolDirectory' "pngout.exe");                  if (!File.Exists(process.StartInfo.FileName))                  {                      Console.WriteLine("Missing pngout.exe in current directory.");                      return;                  }                  Console.WriteLine();                  foreach (var sourceFilePath in Directory.EnumerateFiles(sourceDirectory' "*.png"' SearchOption.AllDirectories))                  {                      string trimmedSourcePath = sourceFilePath.Replace(sourceDirectory' "");                      ConsoleReplacePreviousLine("Optimizing " + trimmedSourcePath);                        process.StartInfo.Arguments = "\"" + sourceFilePath + "\" /q";                      process.Start();                      process.WaitForExit();                      if (process.ExitCode != 0 && process.ExitCode != 2)                      {                          Console.WriteLine("pngout exited with code " + process.ExitCode + " for " + trimmedSourcePath);                          Console.WriteLine();                      }                  }                  ConsoleReplacePreviousLine("PNGs optimized");              }
Missing Default,ReleaseTool,Program,C:\repos\RoosterDragon_Desktop-Ponies\Release Tool\Program.cs,ConsoleReadYesNoQuit,The following switch statement is missing a default case: switch (Console.ReadLine())                  {                      case "y": return true;                      case "n": return false;                      case "q": Environment.Exit(0); break;                  }
