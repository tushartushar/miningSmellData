Implementation smell,Namespace,Class,File,Method,Description
Long Method,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The method has 166 lines of code.
Long Method,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The method has 116 lines of code.
Long Method,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageSelector_SelectedIndexChanged,The method has 118 lines of code.
Long Method,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The method has 346 lines of code.
Long Method,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The method has 127 lines of code.
Complex Method,DesktopSprites.Core,StringExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\StringExtensions.cs,SplitQualified,Cyclomatic complexity of the method is 14
Complex Method,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageSelector_SelectedIndexChanged,Cyclomatic complexity of the method is 14
Complex Method,DesktopSprites.SpriteManagement,AnimationLoopBase,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AdjustForChangedColorTable,Cyclomatic complexity of the method is 8
Complex Method,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,FillBuffer,Cyclomatic complexity of the method is 8
Complex Method,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,Cyclomatic complexity of the method is 10
Long Parameter List,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,Show,The method has 5 parameters. Parameters: owner' ex' text' caption' fatal
Long Parameter List,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,ExceptionDialog,The method has 5 parameters. Parameters: ex' text' caption' fatal' owner
Long Parameter List,DesktopSprites.SpriteManagement,GifImage,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,GetHash,The method has 5 parameters. Parameters: buffer' palette' transparentIndex' width' height
Long Parameter List,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,BufferBits,The method has 5 parameters. Parameters: codeSize' bitsBuffered' bitBuffer' bytesLeftInBlock' blockIndex
Long Parameter List,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The method has 9 parameters. Parameters: pixelStack' stackIndex' imageDescriptor' left' top' interlacePass' yIncrement' iterator' transparentIndex
Long Parameter List,DesktopSprites.SpriteManagement,LogicalScreenDescriptor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,LogicalScreenDescriptor,The method has 8 parameters. Parameters: logicalScreenWidth' logicalScreenHeight' globalColorTableFlag' colorResolution' sortFlag' sizeOfGlobalColorTable' backgroundColorIndex' pixelAspectRatio
Long Parameter List,DesktopSprites.SpriteManagement,GraphicControlExtension,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,GraphicControlExtension,The method has 5 parameters. Parameters: disposalMethod' userInputFlag' transparencyFlag' delayTime' transparentColorIndex
Long Parameter List,DesktopSprites.SpriteManagement,ImageDescriptor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ImageDescriptor,The method has 8 parameters. Parameters: imageLeftPosition' imageTopPosition' imageWidth' imageHeight' localColorTableFlag' interlaceFlag' sortFlag' sizeOfLocalColorTable
Long Parameter List,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,GtkFrameFromBuffer,The method has 8 parameters. Parameters: buffer' palette' transparentIndex' stride' width' height' depth' fileName
Long Parameter List,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The method has 8 parameters. Parameters: gtkSpriteInterface' buffer' palette' transparentIndex' stride' width' height' depth
Long Parameter List,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,ImageFrameFromBuffer,The method has 8 parameters. Parameters: buffer' palette' transparentIndex' stride' width' height' depth' fileName
Long Parameter List,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend,The method has 5 parameters. Parameters: image' area' mirror' section' sectionCount
Long Parameter List,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendInitialize,The method has 12 parameters. Parameters: location' size' mirror' section' sectionCount' xMin' xMax' yMin' yMax' backgroundIndex' backgroundIndexChange' backgroundIndexRowChange
Long Parameter List,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendScalingInitialize,The method has 12 parameters. Parameters: image' area' xMin' xMax' yMin' yMax' xShift' yShift' xScaleFixedPoint' yScaleFixedPoint' dataRowIndexFixedPoint' dataColumnIndexFixedPointInitial
Long Parameter List,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend8bbpUnscaled,The method has 5 parameters. Parameters: image' location' mirror' section' sectionCount
Long Parameter List,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbpUnscaled,The method has 5 parameters. Parameters: image' location' mirror' section' sectionCount
Long Parameter List,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend8bbp,The method has 5 parameters. Parameters: image' area' mirror' section' sectionCount
Long Parameter List,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbp,The method has 5 parameters. Parameters: image' area' mirror' section' sectionCount
Long Parameter List,DesktopSprites.SpriteManagement,ImageData,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,ImageData,The method has 7 parameters. Parameters: data' palette' transparentIndex' stride' width' height' depth
Long Parameter List,DesktopSprites.Interop.Win32,BITMAPINFOHEADER,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Interop\Win32.cs,BITMAPINFOHEADER,The method has 9 parameters. Parameters: width' height' bitCount' compression' sizeImage' xPelsPerMeter' yPelsPerMeter' clrUsed' clrImportant
Long Parameter List,DesktopSprites.Interop.Win32,NativeMethods,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Interop\Win32.cs,CreateDIBSection,The method has 6 parameters. Parameters: hdc' pbmi' iUsage' ppvBits' hSection' dwOffset
Long Parameter List,DesktopSprites.Interop.Win32,NativeMethods,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Interop\Win32.cs,UpdateLayeredWindow,The method has 9 parameters. Parameters: hwnd' hdcDst' pptDst' psize' hdcSrc' pptSrc' crKey' pblend' dwFlags
Long Identifier,DesktopSprites.SpriteManagement,DebugView,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DebugView,The length of the parameter concurrentReadOnlySpriteCollection is 34.
Long Identifier,DesktopSprites.SpriteManagement,DebugView,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,,The length of the parameter concurrentReadOnlySpriteCollection is 34.
Long Identifier,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendScalingInitialize,The length of the parameter dataColumnIndexFixedPointInitial is 32.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,TryInvoke,The length of the statement  "            // When creating or recreating its handle' a control locks on itself. We'll lock on the control to prevent race conditions " is 122.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,TryInvoke,The length of the statement  "            // where the handle is swapped out from under us whilst we are determining if we are in a cross-thread call or not. This is " is 123.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,TryInvoke,The length of the statement  "            // required because InvokeRequired returns false if the handle has yet to be created' as well as if we are on the UI thread. " is 124.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,TryInvoke,The length of the statement  "            // If invoking is not required' we know we are on the UI thread with a valid control' so we can execute the specified actions " is 125.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,CrossThreadInvoke,The length of the statement  "            // On entering this method' we know implicitly the control has a valid window handle and a cross-thread call is required. " is 121.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,CrossThreadInvoke,The length of the statement  "                // We use BeginInvoke so we can get access to the wait handle being used. The normal Invoke also uses a wait handle whilst " is 122.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,CrossThreadInvoke,The length of the statement  "                // it waits for the message to be processed but fails to release it' requiring that the handle be finalized. We'll step in " is 122.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,CrossThreadInvoke,The length of the statement  "                // attempt to cast to this delegate (and several others) and invoke them directly which is faster than having to invoke a " is 121.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,CrossThreadInvoke,The length of the statement  "                // dynamic delegate. Despite having the same signature' an Action delegate cannot be cast to the MethodInvoker delegate. " is 120.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,CrossThreadInvoke,The length of the statement  "                // The control can be disposed before we are able to wait on the result. We can ignore this as we have our flag to see if " is 121.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,CrossThreadInvoke,The length of the statement  "            // If we get this far' we know our wrapper method was executed but we need to use this flag in case we bailed from executing " is 124.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,EnableWaitCursor,The length of the statement  "            // Set the cursor directly. This is required when the method is called from the UI thread before a blocking operation occurs. " is 125.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,EnableWaitCursor,The length of the statement  "            // As soon the UI thread is freed it will reassess the cursor and revert back to the default. However whilst the UI thread is " is 125.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,EnableWaitCursor,The length of the statement  "            // Enable the wait cursor. This is required when the UI will be freed but a background thread is working. The wait cursor does " is 126.
Long Statement,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,EnableWaitCursor,The length of the statement  "            // Force an update to the control' which ensures the cursor appears' and also handily repaints ensuring the disabled UI is " is 122.
Long Statement,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The length of the statement  "            this.CopyTextButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 150.
Long Statement,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The length of the statement  "            this.CloseButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,DesktopSprites.Core,Number,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\Number.cs,TryParseDoubleInvariant,The length of the statement  "            return double.TryParse(s' NumberStyles.Float | NumberStyles.AllowThousands' NumberFormatInfo.InvariantInfo' out result); " is 120.
Long Statement,DesktopSprites.Core,General,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\General.cs,FullCollect,The length of the statement  "            // multi-threaded calls' however other threads are still free to call for collections outside of this method' so this cannot be " is 127.
Long Statement,DesktopSprites.Core,Argument,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\Argument.cs,NewInvalidEnumArgumentException,The length of the statement  "            if (underlyingTypeCode == TypeCode.Int64 || underlyingTypeCode == TypeCode.UInt64 || underlyingTypeCode == TypeCode.UInt32) " is 123.
Long Statement,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The length of the statement  "            this.PreviousCommand.Font = new System.Drawing.Font("Microsoft Sans Serif"' 6F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 162.
Long Statement,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The length of the statement  "            this.NextCommand.Font = new System.Drawing.Font("Microsoft Sans Serif"' 6F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 158.
Long Statement,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The length of the statement  "            this.PlayCommand.Font = new System.Drawing.Font("Microsoft Sans Serif"' 6F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 158.
Long Statement,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The length of the statement  "            this.TimeSelectorSections.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)  " is 156.
Long Statement,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The length of the statement  "            this.TimeSelector.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)  " is 148.
Long Statement,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The length of the statement  "            this.FrameLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 143.
Long Statement,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The length of the statement  "            this.FrameSelector.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 146.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImageSelector.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 146.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImageComparison.Panel1.MouseClick += new System.Windows.Forms.MouseEventHandler(this.ImageComparison_Panel_MouseClick); " is 124.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImageComparison.Panel2.MouseClick += new System.Windows.Forms.MouseEventHandler(this.ImageComparison_Panel_MouseClick); " is 124.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.BackgroundColorCommand.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 161.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImageSourcePalette.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 151.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImageDesiredPalette.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)  " is 155.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.DesiredColorCode.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 154.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.DesiredColorCode.Font = new System.Drawing.Font("Segoe UI Mono"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 159.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.DesiredAlphaCode.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 154.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.DesiredAlphaCode.Font = new System.Drawing.Font("Segoe UI Mono"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 159.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.SaveCommand.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImageNameLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 147.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ColorControls.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 146.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ResetCommand.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 148.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImageSourceColor.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 151.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImageDesiredColor.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 152.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.SourceColorCode.Font = new System.Drawing.Font("Segoe UI Mono"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 158.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.SourceAlphaCode.Font = new System.Drawing.Font("Segoe UI Mono"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 158.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.PaletteControls.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 148.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.DesiredPaletteLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)  " is 155.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.SourcePaletteLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 151.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ErrorLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 143.
Long Statement,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The length of the statement  "            this.ImagePanel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 146.
Long Statement,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The length of the statement  "            this.FramesDisplayPanel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 154.
Long Statement,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The length of the statement  "            this.ImageSelector.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 146.
Long Statement,DesktopSprites.SpriteManagement,AlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AlphaForm.cs,UpdateBackgroundGraphics,The length of the statement  "            if (!NativeMethods.UpdateLayeredWindow(new HandleRef(this' Handle)' new HandleRef(this' hdcScreen)' ref dstPos' ref dstSize' " is 124.
Long Statement,DesktopSprites.SpriteManagement,AnimationLoopBase,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,QueueAddAndStart,The length of the statement  "                SpritesAdded.Raise(this' () => new CollectionItemsChangedEventArgs<ISprite>(new ISprite[] { sprite }.ToImmutableArray())); " is 122.
Long Statement,DesktopSprites.SpriteManagement,AnimationLoopBase,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,StartInternal,The length of the statement  "            // Force a collection now' to clear the heap of any memory from loading. Assuming the loop makes little to no allocations' this " is 127.
Long Statement,DesktopSprites.SpriteManagement,GifImage,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,GetHash,The length of the statement  "            // Generate a quick hash just using the raw buffer values. This means some visually identical frames could hash differently if " is 126.
Long Statement,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,DetermineTransparentIndexes,The length of the statement  "            // Start from the end of the table' since that's usually where all the uninitialized values live. Usually this means the loop " is 125.
Long Statement,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,DetermineTransparentIndexes,The length of the statement  "                // Use the last index in the new table' or if there was no room to expand the table' use the last index and just hope that " is 122.
Long Statement,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadImageData,The length of the statement  "            int transparentIndex = graphicControl != null && graphicControl.TransparencyUsed ? graphicControl.TransparentIndex : -1; " is 120.
Long Statement,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadImageData,The length of the statement  "                // If the length of the codewords was stored' then the index into the frame buffer could be advanced by the length of the " is 121.
Long Statement,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,GtkFrameFromFile,The length of the statement  "            return Disposable.SetupSafely(new GtkFrame(this' fileName)' frame => AlterPixbufForTransparency(fileName' frame.Image.Image)); " is 126.
Long Statement,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The length of the statement  "                if (leftFrame.Depth != rightFrame.Depth || leftFrame.Width != rightFrame.Width || leftFrame.Height != rightFrame.Height) " is 120.
Long Statement,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Show,The length of the statement  "                // TopMost interferes with initial window focus. To workaround this' we will only set it once the form has become visible. " is 122.
Long Statement,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The length of the statement  "                // Determine and apply the clipping area' this is only beneficial when there are few sprites on screen. As more are added " is 121.
Long Statement,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The length of the statement  "                // the cost of hit testing that combined area becomes larger' and so it's just cheaper to redraw everything than to perform " is 123.
Long Statement,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Close,The length of the statement  "            // Remove the handler that cancels closing since this is an external call to close so we want to proceed regardless of the " is 122.
Complex Conditional,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,TimeSelectorSections_Paint,The conditional expression  "currentValue >= min && (currentValue < max || (currentValue == 1 && currentValue == max))"  is complex.
Complex Conditional,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageComparison_Panel_MouseClick,The conditional expression  "location.X >= 0 && location.Y >= 0 && location.X < imageWidth && location.Y < imageHeight"  is complex.
Complex Conditional,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageComparison_Panel_MouseClick,The conditional expression  "pixel.A == 255 && color.R == pixel.R && color.G == pixel.G && color.B == pixel.B"  is complex.
Complex Conditional,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,DataBuffer,The conditional expression  "bitsPerValue != 1 && bitsPerValue != 2 && bitsPerValue != 4 && bitsPerValue != 8"  is complex.
Complex Conditional,DesktopSprites.SpriteManagement,GraphicsWindow,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,SetClip,The conditional expression  "x < 0 || y < 0 || x > width || y > height"  is complex.
Complex Conditional,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,CreatePair,The conditional expression  "(leftFound = images.TryGetValue(paths.Left' out leftImage)) && leftImage == null &&                      (badPaths != null && !(badPath = badPaths.Contains(paths.Left)))"  is complex.
Complex Conditional,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,CreatePair,The conditional expression  "(rightFound = images.TryGetValue(paths.Right' out rightImage)) && rightImage == null &&                      (badPaths != null && !(badPath = badPaths.Contains(paths.Right)))"  is complex.
Complex Conditional,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,CreatePair,The conditional expression  "(rightFound = images.TryGetValue(paths.Right' out rightImage)) && rightImage == null &&                              (badPaths != null && !(badPath = badPaths.Contains(paths.Right)))"  is complex.
Complex Conditional,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The conditional expression  "left.Size != right.Size || left.LoopCount != right.LoopCount ||                  left.ImageDuration != right.ImageDuration || left.FrameCount != right.FrameCount ||                  left[0].Image.Bitmap != null || right[0].Image.Bitmap != null"  is complex.
Empty Catch Block,DesktopSprites.Core,ControlExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ControlExtensions.cs,CrossThreadInvoke,The method has an empty catch block.
Empty Catch Block,DesktopSprites.Core,OperatingSystemInfo,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\OperatingSystemInfo.cs,OnMacOSX,The method has an empty catch block.
Magic Number,DesktopSprites.Collections,ReadOnlyCollection,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Collections\ReadOnlyCollection.cs,GetHashCode,The following statement contains a magic number: return unchecked(collection.GetHashCode() * 7);
Magic Number,DesktopSprites.Collections,ReadOnlyDictionary,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Collections\ReadOnlyDictionary.cs,GetHashCode,The following statement contains a magic number: return unchecked(dictionary.GetHashCode() * 7);
Magic Number,DesktopSprites.Collections,ReadOnlyList,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Collections\ReadOnlyList.cs,GetHashCode,The following statement contains a magic number: return unchecked(list.GetHashCode() * 7);
Magic Number,DesktopSprites.Collections,LinkedListExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Collections\LinkedListExtensions.cs,MergeSort,The following statement contains a magic number: do              {                  // Keep a count of the merges done this pass' if none were done then the list is sorted.                  merges = 0;                    // Set the initial positions of the list sections to sort.                  leftHead = list.First;                  rightHead = preNextRightHead.Next;                    // Perform a series of merges considering mergeSize elements from each side' do this whilst a second list exists.                  while (rightHead != null)                  {                      // Perform a merge on the next pair of lists.                      merges++;                      int leftSize = mergeSize;                      int rightSize = mergeSize;                        // Merge whilst there are elements remaining in either list.                      while (leftSize > 0 && rightSize > 0 && rightHead != null)                      {                          if (comparison(leftHead.Value' rightHead.Value) <= 0)                          {                              // The elements were already in the correct order' so just advance on the left list.                              // We also advance in the case of equality' in order to create a stable sort.                              leftHead = leftHead.Next;                              leftSize--;                          }                          else                          {                              // The elements are in the wrong order' we must swap them.                              LinkedListNode<T> nextRightHead = rightHead.Next;                              rightSize--;                              list.Remove(rightHead);                              list.AddBefore(leftHead' rightHead);                              rightHead = nextRightHead;                          }                      }                        // Advance the right head to the start of the next pair of lists.                      while (rightSize > 0 && rightHead != null)                      {                          rightSize--;                          rightHead = rightHead.Next;                      }                        // Set up the start positions for the next pair of lists.                      leftHead = rightHead;                      for (int i = 0; i < mergeSize && rightHead != null; i++)                          rightHead = rightHead.Next;                        // After the first merge' the left head will be positioned at the index where the right head for the next pass should                      // begin. We'll note the previous element so when the next pass begins it can simply use the next element for the head                      // of the right list' as opposed to enumerating over mergeSize elements to get to the same location. We must note down                      // the previous element' as the current marker to the left head may get swapped and thus would change index.                      if (merges == 1)                          if (leftHead != null)                              preNextRightHead = leftHead.Previous;                          else                              preNextRightHead = list.Last;                  }                  // Double the size of the lists we are merging.                  mergeSize *= 2;              }              while (merges > 0);
Magic Number,DesktopSprites.Core,ColorExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ColorExtensions.cs,PremultipliedAlpha,The following statement contains a magic number: return Color.FromArgb(color.A' color.R * color.A / 255' color.G * color.A / 255' color.B * color.A / 255);
Magic Number,DesktopSprites.Core,ColorExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ColorExtensions.cs,PremultipliedAlpha,The following statement contains a magic number: return Color.FromArgb(color.A' color.R * color.A / 255' color.G * color.A / 255' color.B * color.A / 255);
Magic Number,DesktopSprites.Core,ColorExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ColorExtensions.cs,PremultipliedAlpha,The following statement contains a magic number: return Color.FromArgb(color.A' color.R * color.A / 255' color.G * color.A / 255' color.B * color.A / 255);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,ExceptionDialog,The following statement contains a magic number: if (!Runtime.IsMono)              {                  Size oldSize = Size.Empty;                  Size preferredSize = ExceptionText.GetPreferredSize(Size.Empty);                  while (oldSize != ExceptionText.Size && preferredSize != ExceptionText.Size)                  {                      oldSize = ExceptionText.Size;                      ExceptionText.Size = preferredSize;                      preferredSize = ExceptionText.GetPreferredSize(ExceptionText.Size);                  }              }              else              {                  ExceptionText.Size = new Size(750' 350);              }
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,ExceptionDialog,The following statement contains a magic number: if (!Runtime.IsMono)              {                  Size oldSize = Size.Empty;                  Size preferredSize = ExceptionText.GetPreferredSize(Size.Empty);                  while (oldSize != ExceptionText.Size && preferredSize != ExceptionText.Size)                  {                      oldSize = ExceptionText.Size;                      ExceptionText.Size = preferredSize;                      preferredSize = ExceptionText.GetPreferredSize(ExceptionText.Size);                  }              }              else              {                  ExceptionText.Size = new Size(750' 350);              }
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.IconBox.Location = new System.Drawing.Point(3' 3);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.IconBox.Location = new System.Drawing.Point(3' 3);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.IconBox.Size = new System.Drawing.Size(32' 32);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.IconBox.Size = new System.Drawing.Size(32' 32);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ExceptionText.Location = new System.Drawing.Point(3' 47);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ExceptionText.Location = new System.Drawing.Point(3' 47);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ExceptionText.Size = new System.Drawing.Size(254' 153);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ExceptionText.Size = new System.Drawing.Size(254' 153);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageLabel.Location = new System.Drawing.Point(41' 3);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageLabel.Location = new System.Drawing.Point(41' 3);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageLabel.Size = new System.Drawing.Size(0' 13);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CopyTextButton.Location = new System.Drawing.Point(122' 6);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CopyTextButton.Location = new System.Drawing.Point(122' 6);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CopyTextButton.Size = new System.Drawing.Size(75' 23);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CopyTextButton.Size = new System.Drawing.Size(75' 23);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CloseButton.Location = new System.Drawing.Point(203' 6);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CloseButton.Location = new System.Drawing.Point(203' 6);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CloseButton.Size = new System.Drawing.Size(75' 23);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CloseButton.Size = new System.Drawing.Size(75' 23);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.CloseButton.TabIndex = 2;
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.LayoutTable.RowCount = 2;
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.LayoutTable.Size = new System.Drawing.Size(284' 262);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.LayoutTable.Size = new System.Drawing.Size(284' 262);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageTable.Location = new System.Drawing.Point(12' 12);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageTable.Location = new System.Drawing.Point(12' 12);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageTable.Margin = new System.Windows.Forms.Padding(12);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageTable.RowCount = 2;
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageTable.Size = new System.Drawing.Size(260' 203);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessageTable.Size = new System.Drawing.Size(260' 203);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessagePanel.Location = new System.Drawing.Point(3' 3);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessagePanel.Location = new System.Drawing.Point(3' 3);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessagePanel.Size = new System.Drawing.Size(254' 38);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.MessagePanel.Size = new System.Drawing.Size(254' 38);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ButtonPanel.Location = new System.Drawing.Point(0' 227);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ButtonPanel.Padding = new System.Windows.Forms.Padding(3);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ButtonPanel.Size = new System.Drawing.Size(284' 35);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ButtonPanel.Size = new System.Drawing.Size(284' 35);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.TimeLabel.Location = new System.Drawing.Point(12' 11);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.TimeLabel.Location = new System.Drawing.Point(12' 11);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.TimeLabel.Size = new System.Drawing.Size(0' 13);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(284' 262);
Magic Number,DesktopSprites.Core,ExceptionDialog,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ExceptionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(284' 262);
Magic Number,DesktopSprites.Core,Hash,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\Hash.cs,Fnv1A32,The following statement contains a magic number: const int Fnv1AOffsetBasis32 = unchecked((int)2166136261);
Magic Number,DesktopSprites.Core,Hash,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\Hash.cs,Fnv1A32,The following statement contains a magic number: const int FnvPrime32 = 16777619;
Magic Number,DesktopSprites.Core,Linq,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\Linq.cs,OnlyOrDefault,The following statement contains a magic number: foreach (var element in source)                  if (predicate(element))                  {                      if (++count >= 2)                          return default(TSource);                      result = element;                  }
Magic Number,DesktopSprites.Core,VersionExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\VersionExtensions.cs,ToDisplayString,The following statement contains a magic number: if (v.Revision > 0)                  fieldCount = 4;              else if (v.Build > 0)                  fieldCount = 3;              else if (v.Minor > 0)                  fieldCount = 2;
Magic Number,DesktopSprites.Core,VersionExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\VersionExtensions.cs,ToDisplayString,The following statement contains a magic number: if (v.Revision > 0)                  fieldCount = 4;              else if (v.Build > 0)                  fieldCount = 3;              else if (v.Minor > 0)                  fieldCount = 2;
Magic Number,DesktopSprites.Core,VersionExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\VersionExtensions.cs,ToDisplayString,The following statement contains a magic number: if (v.Revision > 0)                  fieldCount = 4;              else if (v.Build > 0)                  fieldCount = 3;              else if (v.Minor > 0)                  fieldCount = 2;
Magic Number,DesktopSprites.Core,General,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\General.cs,ConsoleWriteLineLong,The following statement contains a magic number: do              {                  ulong original = v;                  v /= 10;                  ulong digit = original - (v * 10);                  Buffer[bufferIndex--] = (char)('0' + digit);              }              while (v > 0);
Magic Number,DesktopSprites.Core,General,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\General.cs,ConsoleWriteLineLong,The following statement contains a magic number: do              {                  ulong original = v;                  v /= 10;                  ulong digit = original - (v * 10);                  Buffer[bufferIndex--] = (char)('0' + digit);              }              while (v > 0);
Magic Number,DesktopSprites.Core,ImageSize,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ImageSize.cs,GetSize,The following statement contains a magic number: using (FileStream stream =                  new FileStream(path' FileMode.Open' FileAccess.Read' FileShare.Read' 32' FileOptions.SequentialScan))              using (BinaryReader reader = new BinaryReader(stream))              {                  try                  {                      return GetSize(reader);                  }                  catch (ArgumentException ex)                  {                      if (ex.Message.StartsWith(ErrorMessage' StringComparison.Ordinal))                          throw new ArgumentException(ErrorMessage' "path"' ex);                      else                          throw;                  }              }
Magic Number,DesktopSprites.Core,ImageSize,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ImageSize.cs,DecodeBitmap,The following statement contains a magic number: binaryReader.ReadBytesExact(16);
Magic Number,DesktopSprites.Core,ImageSize,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ImageSize.cs,DecodePng,The following statement contains a magic number: binaryReader.ReadBytesExact(8);
Magic Number,DesktopSprites.Core,ImageSize,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ImageSize.cs,DecodeJfif,The following statement contains a magic number: while (binaryReader.ReadByte() == 0xFF)              {                  byte marker = binaryReader.ReadByte();                  short chunkLength = binaryReader.ReadLittleEndianInt16();                  if (marker == 0xC0)                  {                      binaryReader.ReadByte();                      return new Size(binaryReader.ReadLittleEndianInt16()' binaryReader.ReadLittleEndianInt16());                  }                    if (chunkLength < 0)                  {                      ushort uchunkLength = (ushort)chunkLength;                      binaryReader.ReadBytesExact(uchunkLength - 2);                  }                  else                  {                      binaryReader.ReadBytesExact(chunkLength - 2);                  }              }
Magic Number,DesktopSprites.Core,ImageSize,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\ImageSize.cs,DecodeJfif,The following statement contains a magic number: while (binaryReader.ReadByte() == 0xFF)              {                  byte marker = binaryReader.ReadByte();                  short chunkLength = binaryReader.ReadLittleEndianInt16();                  if (marker == 0xC0)                  {                      binaryReader.ReadByte();                      return new Size(binaryReader.ReadLittleEndianInt16()' binaryReader.ReadLittleEndianInt16());                  }                    if (chunkLength < 0)                  {                      ushort uchunkLength = (ushort)chunkLength;                      binaryReader.ReadBytesExact(uchunkLength - 2);                  }                  else                  {                      binaryReader.ReadBytesExact(chunkLength - 2);                  }              }
Magic Number,DesktopSprites.Core,OperatingSystemInfo,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\OperatingSystemInfo.cs,OnMacOSX,The following statement contains a magic number: try              {                  buffer = Marshal.AllocHGlobal(8196);                  if (Interop.Unix.NativeMethods.uname(buffer) == 0)                  {                      // The buffer contains 5 or 6 null-terminated char arrays' we will marshal the first one' containing the system name.                      string osName = Marshal.PtrToStringAnsi(buffer);                      return osName == "Darwin";                  }              }              catch (Exception)              {                  // Assume an exception indicates we are not on the MacOSX platform.              }              finally              {                  if (buffer != IntPtr.Zero)                      Marshal.FreeHGlobal(buffer);              }
Magic Number,DesktopSprites.Core,StringExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\StringExtensions.cs,SplitQualified,The following statement contains a magic number: if (qualifiers == null)                  qualifiers = new char[0' 2];
Magic Number,DesktopSprites.Core,StringExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\StringExtensions.cs,SplitQualified,The following statement contains a magic number: if (qualifiers.GetLength(1) != 2)                  throw new ArgumentException("The dimensions of the qualifiers array must be [n'2]. " +                      "The two characters are the opening and closing qualifier pair. You may have n pairs of qualifiers."' "qualifiers");
Magic Number,DesktopSprites.Core,StringExtensions,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Core\StringExtensions.cs,SplitQualified,The following statement contains a magic number: int capacity = Math.Min(source.Length' Math.Max(16' (int)Math.Ceiling(source.Length / 8f)));
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PreviousCommand.Location = new System.Drawing.Point(51' 52);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PreviousCommand.Location = new System.Drawing.Point(51' 52);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PreviousCommand.Size = new System.Drawing.Size(25' 16);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PreviousCommand.Size = new System.Drawing.Size(25' 16);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PreviousCommand.TabIndex = 9;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.NextCommand.Location = new System.Drawing.Point(138' 52);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.NextCommand.Location = new System.Drawing.Point(138' 52);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.NextCommand.Size = new System.Drawing.Size(25' 16);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.NextCommand.Size = new System.Drawing.Size(25' 16);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.NextCommand.TabIndex = 11;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PlayCommand.Location = new System.Drawing.Point(82' 52);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PlayCommand.Location = new System.Drawing.Point(82' 52);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PlayCommand.Size = new System.Drawing.Size(50' 16);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PlayCommand.Size = new System.Drawing.Size(50' 16);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PlayCommand.TabIndex = 10;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelectorSections.Location = new System.Drawing.Point(17' 88);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelectorSections.Location = new System.Drawing.Point(17' 88);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelectorSections.Size = new System.Drawing.Size(180' 4);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelectorSections.Size = new System.Drawing.Size(180' 4);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelectorSections.TabIndex = 13;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelector.LargeChange = 5000;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelector.Location = new System.Drawing.Point(3' 66);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelector.Location = new System.Drawing.Point(3' 66);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelector.Size = new System.Drawing.Size(208' 45);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelector.Size = new System.Drawing.Size(208' 45);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelector.SmallChange = 1000;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.TimeSelector.TabIndex = 12;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameLabel.Location = new System.Drawing.Point(3' 33);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameLabel.Location = new System.Drawing.Point(3' 33);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameLabel.Size = new System.Drawing.Size(208' 16);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameLabel.Size = new System.Drawing.Size(208' 16);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameLabel.TabIndex = 8;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameSelector.Location = new System.Drawing.Point(3' 3);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameSelector.Location = new System.Drawing.Point(3' 3);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameSelector.Size = new System.Drawing.Size(208' 45);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameSelector.Size = new System.Drawing.Size(208' 45);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.FrameSelector.TabIndex = 7;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.PlaybackTimer.Interval = 50;
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(214' 114);
Magic Number,DesktopSprites.Forms,AnimatedImageIndexer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\AnimatedImageIndexer.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(214' 114);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageSelector_SelectedIndexChanged,The following statement contains a magic number: int swatchSize = ImageSourcePalette.Height - 2;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,BuildColorMap,The following statement contains a magic number: foreach (ArgbColor sourceArgbColor in colorTable)                  if (sourceArgbColor.A == 255)                  {                      RgbColor sourceRgbColor = (RgbColor)sourceArgbColor;                      Color sourceColor = Color.FromArgb(sourceRgbColor.ToArgb());                      if (!colorMappingTable.ContainsKey(sourceColor))                      {                          ArgbColor desiredArgbColor;                          if (!alphaMap.TryGetMapping(sourceRgbColor' out desiredArgbColor))                              desiredArgbColor = sourceArgbColor;                          colorMappingTable.Add(sourceColor' Color.FromArgb(desiredArgbColor.ToArgb()));                      }                  }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,UpdateSelectedFrame,The following statement contains a magic number: if (frameIndex != newFrameIndex)              {                  frameIndex = newFrameIndex;                  var sourceImage = gifImage.Frames[newFrameIndex].Image;                  var desiredImage = desiredFrames[newFrameIndex];                  ImageComparison.Panel1.BackgroundImage = sourceImage;                  ImageComparison.Panel2.BackgroundImage = desiredImage;                  const int Padding = 8;                  ImageComparison.Size = new Size(                      sourceImage.Width + desiredImage.Width + ImageComparison.SplitterWidth + 2 * Padding'                      Math.Max(sourceImage.Height' desiredImage.Height) + 2 * Padding);                  ImageComparison.SplitterDistance = sourceImage.Width + Padding;                  ImageComparison.Left = ImagePanel.Width / 2 - ImageComparison.Width / 2 + Padding;                  ImageComparison.Panel1.Invalidate();                  ImageComparison.Panel2.Invalidate();              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,UpdateSelectedFrame,The following statement contains a magic number: if (frameIndex != newFrameIndex)              {                  frameIndex = newFrameIndex;                  var sourceImage = gifImage.Frames[newFrameIndex].Image;                  var desiredImage = desiredFrames[newFrameIndex];                  ImageComparison.Panel1.BackgroundImage = sourceImage;                  ImageComparison.Panel2.BackgroundImage = desiredImage;                  const int Padding = 8;                  ImageComparison.Size = new Size(                      sourceImage.Width + desiredImage.Width + ImageComparison.SplitterWidth + 2 * Padding'                      Math.Max(sourceImage.Height' desiredImage.Height) + 2 * Padding);                  ImageComparison.SplitterDistance = sourceImage.Width + Padding;                  ImageComparison.Left = ImagePanel.Width / 2 - ImageComparison.Width / 2 + Padding;                  ImageComparison.Panel1.Invalidate();                  ImageComparison.Panel2.Invalidate();              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,UpdateSelectedFrame,The following statement contains a magic number: if (frameIndex != newFrameIndex)              {                  frameIndex = newFrameIndex;                  var sourceImage = gifImage.Frames[newFrameIndex].Image;                  var desiredImage = desiredFrames[newFrameIndex];                  ImageComparison.Panel1.BackgroundImage = sourceImage;                  ImageComparison.Panel2.BackgroundImage = desiredImage;                  const int Padding = 8;                  ImageComparison.Size = new Size(                      sourceImage.Width + desiredImage.Width + ImageComparison.SplitterWidth + 2 * Padding'                      Math.Max(sourceImage.Height' desiredImage.Height) + 2 * Padding);                  ImageComparison.SplitterDistance = sourceImage.Width + Padding;                  ImageComparison.Left = ImagePanel.Width / 2 - ImageComparison.Width / 2 + Padding;                  ImageComparison.Panel1.Invalidate();                  ImageComparison.Panel2.Invalidate();              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,UpdateSelectedFrame,The following statement contains a magic number: if (frameIndex != newFrameIndex)              {                  frameIndex = newFrameIndex;                  var sourceImage = gifImage.Frames[newFrameIndex].Image;                  var desiredImage = desiredFrames[newFrameIndex];                  ImageComparison.Panel1.BackgroundImage = sourceImage;                  ImageComparison.Panel2.BackgroundImage = desiredImage;                  const int Padding = 8;                  ImageComparison.Size = new Size(                      sourceImage.Width + desiredImage.Width + ImageComparison.SplitterWidth + 2 * Padding'                      Math.Max(sourceImage.Height' desiredImage.Height) + 2 * Padding);                  ImageComparison.SplitterDistance = sourceImage.Width + Padding;                  ImageComparison.Left = ImagePanel.Width / 2 - ImageComparison.Width / 2 + Padding;                  ImageComparison.Panel1.Invalidate();                  ImageComparison.Panel2.Invalidate();              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,UpdateSelectedFrame,The following statement contains a magic number: if (frameIndex != newFrameIndex)              {                  frameIndex = newFrameIndex;                  var sourceImage = gifImage.Frames[newFrameIndex].Image;                  var desiredImage = desiredFrames[newFrameIndex];                  ImageComparison.Panel1.BackgroundImage = sourceImage;                  ImageComparison.Panel2.BackgroundImage = desiredImage;                  const int Padding = 8;                  ImageComparison.Size = new Size(                      sourceImage.Width + desiredImage.Width + ImageComparison.SplitterWidth + 2 * Padding'                      Math.Max(sourceImage.Height' desiredImage.Height) + 2 * Padding);                  ImageComparison.SplitterDistance = sourceImage.Width + Padding;                  ImageComparison.Left = ImagePanel.Width / 2 - ImageComparison.Width / 2 + Padding;                  ImageComparison.Panel1.Invalidate();                  ImageComparison.Panel2.Invalidate();              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,DesiredColorCode_TextChanged,The following statement contains a magic number: if (int.TryParse(DesiredColorCode.Text' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out value))              {                  DesiredColorCode.ForeColor = Color.Black;                  Color newColor = Color.FromArgb(colorMappingTable[currentColor].A' value >> 16' value >> 8 & 0xFF' value & 0xFF);                  if (colorMappingTable[currentColor] != newColor)                  {                      colorMappingTable[currentColor] = newColor;                      changed = true;                  }                  foreach (Panel sourcePanel in ImageSourcePalette.Controls)                      if (sourcePanel.BackColor == currentColor && sourcePanel.Tag != null)                      {                          ((Panel)sourcePanel.Tag).BackColor = colorMappingTable[currentColor];                          break;                      }                  UpdateColorDisplay();                  UpdateDesiredFrames();                  ImageComparison.Panel2.Invalidate();              }              else              {                  DesiredColorCode.ForeColor = Color.DarkRed;              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,DesiredColorCode_TextChanged,The following statement contains a magic number: if (int.TryParse(DesiredColorCode.Text' NumberStyles.HexNumber' CultureInfo.CurrentCulture' out value))              {                  DesiredColorCode.ForeColor = Color.Black;                  Color newColor = Color.FromArgb(colorMappingTable[currentColor].A' value >> 16' value >> 8 & 0xFF' value & 0xFF);                  if (colorMappingTable[currentColor] != newColor)                  {                      colorMappingTable[currentColor] = newColor;                      changed = true;                  }                  foreach (Panel sourcePanel in ImageSourcePalette.Controls)                      if (sourcePanel.BackColor == currentColor && sourcePanel.Tag != null)                      {                          ((Panel)sourcePanel.Tag).BackColor = colorMappingTable[currentColor];                          break;                      }                  UpdateColorDisplay();                  UpdateDesiredFrames();                  ImageComparison.Panel2.Invalidate();              }              else              {                  DesiredColorCode.ForeColor = Color.DarkRed;              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,UpdateDesiredFrames,The following statement contains a magic number: for (int frame = 0; frame < gifImage.Frames.Length; frame++)              {                  int tableSize = gifImage.Frames[frame].ColorTableSize;                  ColorPalette palette = gifImage.Frames[frame].Image.Palette;                  for (int i = 0; i < tableSize; i++)                      if (palette.Entries[i].A == 255)                          palette.Entries[i] = colorMappingTable[palette.Entries[i]];                  desiredFrames[frame].Palette = palette;                  desiredFrames[frame].PremultiplyAlpha();              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ResetCommand_Click,The following statement contains a magic number: if (nonEmptyMap &&                  MessageBox.Show(this'                      "Are you sure you want to reset the mapping? You can still decline to save later."' "Confirm"'                      MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation' MessageBoxDefaultButton.Button1) == DialogResult.Yes)              {                  Color[] keys = new Color[colorMappingTable.Keys.Count];                  colorMappingTable.Keys.CopyTo(keys' 0);                  foreach (Color color in keys)                      colorMappingTable[color] = Color.FromArgb(255' color);                  changed = true;              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageComparison_Panel_MouseClick,The following statement contains a magic number: location -= new Size(panel.Width / 2' panel.Height / 2);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageComparison_Panel_MouseClick,The following statement contains a magic number: location -= new Size(panel.Width / 2' panel.Height / 2);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageComparison_Panel_MouseClick,The following statement contains a magic number: location += new Size(imageWidth / 2' imageHeight / 2);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageComparison_Panel_MouseClick,The following statement contains a magic number: location += new Size(imageWidth / 2' imageHeight / 2);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,ImageComparison_Panel_MouseClick,The following statement contains a magic number: if (location.X >= 0 && location.Y >= 0 && location.X < imageWidth && location.Y < imageHeight)              {                  IEnumerable<Color> colors;                  if (sender == ImageComparison.Panel1)                      colors = colorMappingTable.Keys;                  else                      colors = colorMappingTable.Values;                    Color pixel = gifImage.Frames[Indexer.FrameIndex].Image.GetPixel(location.X' location.Y);                  foreach (Color color in colors)                      // GetPixel always returns a color with binary alpha. This comparison relaxes the alpha comparison to work around this'                      // but can lead to incorrect picks when two desired colors have the same RGB values but different alpha.                      if (pixel.A == 255 && color.R == pixel.R && color.G == pixel.G && color.B == pixel.B)                      {                          currentColor = pixel;                          UpdateColorHex();                          UpdateColorDisplay();                          break;                      }              }
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSelector.Location = new System.Drawing.Point(73' 12);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSelector.Location = new System.Drawing.Point(73' 12);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSelector.Size = new System.Drawing.Size(649' 21);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSelector.Size = new System.Drawing.Size(649' 21);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageComparison.Location = new System.Drawing.Point(-36' 0);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageComparison.Size = new System.Drawing.Size(746' 322);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageComparison.Size = new System.Drawing.Size(746' 322);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageComparison.SplitterDistance = 369;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.BackgroundColorCommand.Location = new System.Drawing.Point(223' 25);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.BackgroundColorCommand.Location = new System.Drawing.Point(223' 25);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.BackgroundColorCommand.Size = new System.Drawing.Size(128' 23);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.BackgroundColorCommand.Size = new System.Drawing.Size(128' 23);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.BackgroundColorCommand.TabIndex = 6;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSourcePalette.Location = new System.Drawing.Point(55' 16);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSourcePalette.Location = new System.Drawing.Point(55' 16);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSourcePalette.Size = new System.Drawing.Size(351' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSourcePalette.Size = new System.Drawing.Size(351' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredPalette.Location = new System.Drawing.Point(55' 38);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredPalette.Location = new System.Drawing.Point(55' 38);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredPalette.Size = new System.Drawing.Size(351' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredPalette.Size = new System.Drawing.Size(351' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredPalette.TabIndex = 3;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredColorCode.Location = new System.Drawing.Point(125' 41);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredColorCode.Location = new System.Drawing.Point(125' 41);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredColorCode.MaxLength = 6;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredColorCode.Size = new System.Drawing.Size(56' 22);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredColorCode.Size = new System.Drawing.Size(56' 22);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredColorCode.TabIndex = 4;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredAlphaCode.Location = new System.Drawing.Point(99' 41);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredAlphaCode.Location = new System.Drawing.Point(99' 41);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredAlphaCode.MaxLength = 2;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredAlphaCode.Size = new System.Drawing.Size(24' 22);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredAlphaCode.Size = new System.Drawing.Size(24' 22);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredAlphaCode.TabIndex = 3;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SaveCommand.Location = new System.Drawing.Point(380' 37);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SaveCommand.Location = new System.Drawing.Point(380' 37);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SaveCommand.Size = new System.Drawing.Size(98' 23);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SaveCommand.Size = new System.Drawing.Size(98' 23);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SaveCommand.TabIndex = 5;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.FrameControls.Location = new System.Drawing.Point(12' 39);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.FrameControls.Location = new System.Drawing.Point(12' 39);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.FrameControls.Size = new System.Drawing.Size(220' 133);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.FrameControls.Size = new System.Drawing.Size(220' 133);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.FrameControls.TabIndex = 2;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageNameLabel.Location = new System.Drawing.Point(12' 15);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageNameLabel.Location = new System.Drawing.Point(12' 15);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageNameLabel.Size = new System.Drawing.Size(55' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageNameLabel.Size = new System.Drawing.Size(55' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ColorControls.Location = new System.Drawing.Point(238' 105);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ColorControls.Location = new System.Drawing.Point(238' 105);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ColorControls.Size = new System.Drawing.Size(484' 67);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ColorControls.Size = new System.Drawing.Size(484' 67);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ColorControls.TabIndex = 4;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ResetCommand.Location = new System.Drawing.Point(380' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ResetCommand.Location = new System.Drawing.Point(380' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ResetCommand.Size = new System.Drawing.Size(98' 23);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ResetCommand.Size = new System.Drawing.Size(98' 23);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ResetCommand.TabIndex = 7;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageColors.Location = new System.Drawing.Point(6' 17);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageColors.Location = new System.Drawing.Point(6' 17);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageColors.Size = new System.Drawing.Size(89' 46);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageColors.Size = new System.Drawing.Size(89' 46);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSourceColor.Location = new System.Drawing.Point(3' 3);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSourceColor.Location = new System.Drawing.Point(3' 3);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSourceColor.Size = new System.Drawing.Size(40' 40);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSourceColor.Size = new System.Drawing.Size(40' 40);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredColor.Location = new System.Drawing.Point(46' 3);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredColor.Location = new System.Drawing.Point(46' 3);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredColor.Size = new System.Drawing.Size(40' 40);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageDesiredColor.Size = new System.Drawing.Size(40' 40);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceColorCode.Location = new System.Drawing.Point(125' 17);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceColorCode.Location = new System.Drawing.Point(125' 17);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceColorCode.MaxLength = 6;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceColorCode.Size = new System.Drawing.Size(56' 22);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceColorCode.Size = new System.Drawing.Size(56' 22);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceColorCode.TabIndex = 2;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceAlphaCode.Location = new System.Drawing.Point(99' 17);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceAlphaCode.Location = new System.Drawing.Point(99' 17);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceAlphaCode.MaxLength = 2;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceAlphaCode.Size = new System.Drawing.Size(24' 22);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourceAlphaCode.Size = new System.Drawing.Size(24' 22);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.PaletteControls.Location = new System.Drawing.Point(238' 39);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.PaletteControls.Location = new System.Drawing.Point(238' 39);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.PaletteControls.Size = new System.Drawing.Size(484' 60);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.PaletteControls.Size = new System.Drawing.Size(484' 60);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.PaletteControls.TabIndex = 3;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredPaletteLabel.Location = new System.Drawing.Point(6' 38);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredPaletteLabel.Location = new System.Drawing.Point(6' 38);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredPaletteLabel.Size = new System.Drawing.Size(43' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredPaletteLabel.Size = new System.Drawing.Size(43' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.DesiredPaletteLabel.TabIndex = 2;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourcePaletteLabel.Location = new System.Drawing.Point(6' 16);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourcePaletteLabel.Location = new System.Drawing.Point(6' 16);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourcePaletteLabel.Size = new System.Drawing.Size(41' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.SourcePaletteLabel.Size = new System.Drawing.Size(41' 13);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ErrorLabel.Size = new System.Drawing.Size(710' 100);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ErrorLabel.Size = new System.Drawing.Size(710' 100);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImagePanel.Location = new System.Drawing.Point(12' 178);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImagePanel.Location = new System.Drawing.Point(12' 178);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImagePanel.Size = new System.Drawing.Size(710' 322);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImagePanel.Size = new System.Drawing.Size(710' 322);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ImagePanel.TabIndex = 5;
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.Indexer.Location = new System.Drawing.Point(3' 16);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.Indexer.Location = new System.Drawing.Point(3' 16);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.Indexer.Size = new System.Drawing.Size(214' 114);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.Indexer.Size = new System.Drawing.Size(214' 114);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(734' 512);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(734' 512);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(725' 400);
Magic Number,DesktopSprites.Forms,GifAlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifAlphaForm.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(725' 400);
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,GifControl,The following statement contains a magic number: Width = Math.Max(frame.Image.Width + 8' FrameInfo.Width) + Padding.Horizontal;
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,GifControl,The following statement contains a magic number: Height = frame.Image.Height + FrameInfo.Height + Padding.Vertical + 4;
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,GifControl_Paint,The following statement contains a magic number: e.Graphics.DrawImageUnscaled(frame.Image.Image' 3' 3);
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,GifControl_Paint,The following statement contains a magic number: e.Graphics.DrawImageUnscaled(frame.Image.Image' 3' 3);
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,GifControl_Paint,The following statement contains a magic number: e.Graphics.DrawRectangle(Pens.Black' 2' 2' frame.Image.Width + 1' frame.Image.Height + 1);
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,GifControl_Paint,The following statement contains a magic number: e.Graphics.DrawRectangle(Pens.Black' 2' 2' frame.Image.Width + 1' frame.Image.Height + 1);
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,InitializeComponent,The following statement contains a magic number: this.FrameInfo.Location = new System.Drawing.Point(0' 135);
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,InitializeComponent,The following statement contains a magic number: this.FrameInfo.Size = new System.Drawing.Size(2' 15);
Magic Number,DesktopSprites.Forms,GifControl,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifControl.cs,InitializeComponent,The following statement contains a magic number: this.FrameInfo.Size = new System.Drawing.Size(2' 15);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.FramesDisplayPanel.Location = new System.Drawing.Point(12' 55);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.FramesDisplayPanel.Location = new System.Drawing.Point(12' 55);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.FramesDisplayPanel.Size = new System.Drawing.Size(710' 445);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.FramesDisplayPanel.Size = new System.Drawing.Size(710' 445);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSelector.Location = new System.Drawing.Point(15' 10);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSelector.Location = new System.Drawing.Point(15' 10);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSelector.Size = new System.Drawing.Size(707' 21);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageSelector.Size = new System.Drawing.Size(707' 21);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ControlsContainer.Size = new System.Drawing.Size(734' 49);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ControlsContainer.Size = new System.Drawing.Size(734' 49);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageInfo.Location = new System.Drawing.Point(12' 32);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageInfo.Location = new System.Drawing.Point(12' 32);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageInfo.Size = new System.Drawing.Size(0' 13);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ImageInfo.TabIndex = 2;
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(734' 512);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(734' 512);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(600' 400);
Magic Number,DesktopSprites.Forms,GifFramesForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\Forms\GifFramesForm.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(600' 400);
Magic Number,DesktopSprites.SpriteManagement,AlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AlphaForm.cs,InitializeBuffer,The following statement contains a magic number: var bitmapInfo = new BITMAPINFO(new BITMAPINFOHEADER(                  Width' -Height' 32' BiFlags.BI_RGB' (uint)(Width * Height * 4)' 0' 0' 0' 0));
Magic Number,DesktopSprites.SpriteManagement,AlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AlphaForm.cs,InitializeBuffer,The following statement contains a magic number: var bitmapInfo = new BITMAPINFO(new BITMAPINFOHEADER(                  Width' -Height' 32' BiFlags.BI_RGB' (uint)(Width * Height * 4)' 0' 0' 0' 0));
Magic Number,DesktopSprites.SpriteManagement,AlphaForm,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AlphaForm.cs,UpdateBackgroundGraphics,The following statement contains a magic number: UpdateBackgroundGraphics(255);
Magic Number,DesktopSprites.SpriteManagement,AnimationLoopBase,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,Run,The following statement contains a magic number: while (!Disposed && running.WaitOne() && !Stopped)              {                  // Run an update and draw cycle for one frame.                  Viewer.PreventSelfClose = true;                  if (!Viewer.Disposed)                  {                      if (!Started)                          StartInternal(startSync);                      else                          Update();                      if (!Disposed)                          Draw();                  }                  Viewer.PreventSelfClose = false;                  if (Viewer.Disposed)                      Finish();    #if DEBUG                  // When debugging' assume long delays are due to hitting breakpoints.                  TimeSpan tickElapsed = elapsedWatch.Elapsed - elapsedTime;                  float frameTime;                  if (tickElapsed.TotalMilliseconds < 2000)                  {                      frameTime = (float)tickElapsed.TotalMilliseconds;                  }                  else                  {                      frameTime = minimumTickInterval;                      frameLostTime += tickElapsed - TimeSpan.FromMilliseconds(frameTime);                  }  #else                  float frameTime = (float)(elapsedWatch.Elapsed - ElapsedTime).TotalMilliseconds;  #endif                    // Sleep until the next tick should start.                  float nextInterval = minimumTickInterval - frameTime;                  if (nextInterval > 0)                      Thread.Sleep((int)Math.Ceiling(nextInterval));                    // Track interval timings.                  float intervalTime = (float)intervalWatch.Elapsed.TotalMilliseconds;                  intervalWatch.Restart();                    // Record the timings and display performance summary occasionally.                  performanceRecorder.Record(minimumTickInterval' frameTime' intervalTime);                  if (++performanceDelayCount >= MaximumFramesPerSecond * 10)                  {                      performanceDelayCount = 0;                      Console.WriteLine(performanceRecorder.GetSummary());                  }              }
Magic Number,DesktopSprites.SpriteManagement,AnimationLoopBase,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,Run,The following statement contains a magic number: while (!Disposed && running.WaitOne() && !Stopped)              {                  // Run an update and draw cycle for one frame.                  Viewer.PreventSelfClose = true;                  if (!Viewer.Disposed)                  {                      if (!Started)                          StartInternal(startSync);                      else                          Update();                      if (!Disposed)                          Draw();                  }                  Viewer.PreventSelfClose = false;                  if (Viewer.Disposed)                      Finish();    #if DEBUG                  // When debugging' assume long delays are due to hitting breakpoints.                  TimeSpan tickElapsed = elapsedWatch.Elapsed - elapsedTime;                  float frameTime;                  if (tickElapsed.TotalMilliseconds < 2000)                  {                      frameTime = (float)tickElapsed.TotalMilliseconds;                  }                  else                  {                      frameTime = minimumTickInterval;                      frameLostTime += tickElapsed - TimeSpan.FromMilliseconds(frameTime);                  }  #else                  float frameTime = (float)(elapsedWatch.Elapsed - ElapsedTime).TotalMilliseconds;  #endif                    // Sleep until the next tick should start.                  float nextInterval = minimumTickInterval - frameTime;                  if (nextInterval > 0)                      Thread.Sleep((int)Math.Ceiling(nextInterval));                    // Track interval timings.                  float intervalTime = (float)intervalWatch.Elapsed.TotalMilliseconds;                  intervalWatch.Restart();                    // Record the timings and display performance summary occasionally.                  performanceRecorder.Record(minimumTickInterval' frameTime' intervalTime);                  if (++performanceDelayCount >= MaximumFramesPerSecond * 10)                  {                      performanceDelayCount = 0;                      Console.WriteLine(performanceRecorder.GetSummary());                  }              }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,FrameRecordCollector,The following statement contains a magic number: SetGraphingAttributes(Point.Empty' 100' 1' 1f);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,SetGraphingAttributes,The following statement contains a magic number: graphArea.Width = individualBarWidth * frameRecords.Length + 2;
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: float height = graphArea.Height - 2;
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: surface.DrawLine(Pens.DarkGray' graphArea.Left + 1' meanIntervalHeight' graphArea.Right - 2' meanIntervalHeight);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: surface.DrawLine(Pens.LightGray' graphArea.Left + 1' meanTimeHeight' graphArea.Right - 2' meanTimeHeight);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: int markerThickness = barHeightScale < .5f ? 1 : 2;
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i <= (graphArea.Height - 1) / barHeightScale; i += 10)                  {                      int markerLineHeight = graphArea.Bottom - 1 - (int)(i * barHeightScale);                      int markerWidth = i % 50 == 0 ? 12 : 4;                      surface.FillRectangle(Brushes.Cyan' graphArea.Left + 1' markerLineHeight - 1' markerWidth' markerThickness);                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i <= (graphArea.Height - 1) / barHeightScale; i += 10)                  {                      int markerLineHeight = graphArea.Bottom - 1 - (int)(i * barHeightScale);                      int markerWidth = i % 50 == 0 ? 12 : 4;                      surface.FillRectangle(Brushes.Cyan' graphArea.Left + 1' markerLineHeight - 1' markerWidth' markerThickness);                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i <= (graphArea.Height - 1) / barHeightScale; i += 10)                  {                      int markerLineHeight = graphArea.Bottom - 1 - (int)(i * barHeightScale);                      int markerWidth = i % 50 == 0 ? 12 : 4;                      surface.FillRectangle(Brushes.Cyan' graphArea.Left + 1' markerLineHeight - 1' markerWidth' markerThickness);                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i <= (graphArea.Height - 1) / barHeightScale; i += 10)                  {                      int markerLineHeight = graphArea.Bottom - 1 - (int)(i * barHeightScale);                      int markerWidth = i % 50 == 0 ? 12 : 4;                      surface.FillRectangle(Brushes.Cyan' graphArea.Left + 1' markerLineHeight - 1' markerWidth' markerThickness);                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: float height = graphArea.Height - 2;
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i < Count; i++)                  {                      // Determine bar color by comparing this record with the previous record.                      // The first bar has no previous record' so just get the default color.                      // The records array is circular' so we must join the first and last elements when required.                      int timeBarNumber;                      if (i == 0)                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m]);                      else                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m != 0 ? m - 1 : Count - 1]);                        // Determine bar sizes.                      float targetHeight = frameRecords[m].Target * barHeightScale;                      float timeHeight = frameRecords[m].Time * barHeightScale;                      float intervalHeight = frameRecords[m].Interval * barHeightScale;                      int barLeft = graphArea.Left + 1 + barOffset + i * barWidth;                        // Draw the bars.                      context.SetSourceRGB(0.5' 0.5' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(                          barLeft' graphArea.Bottom - 1 - intervalHeight' barWidth' intervalHeight - timeHeight));                      context.Fill();                        if (timeBarNumber == 0)                          context.SetSourceRGB(1' 0' 0);                      else if (timeBarNumber == 1)                          context.SetSourceRGB(0' 1' 0);                      else if (timeBarNumber == 2)                          context.SetSourceRGB(0' 0' 1);                      else                          context.SetSourceRGB(1' 1' 1);                        context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - timeHeight' barWidth' timeHeight));                      context.Fill();                        context.SetSourceRGB(0.2' 0.2' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - targetHeight' barWidth' 1));                      context.Fill();                        // Move to the next record.                      if (++m >= Count)                          m = 0;                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i < Count; i++)                  {                      // Determine bar color by comparing this record with the previous record.                      // The first bar has no previous record' so just get the default color.                      // The records array is circular' so we must join the first and last elements when required.                      int timeBarNumber;                      if (i == 0)                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m]);                      else                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m != 0 ? m - 1 : Count - 1]);                        // Determine bar sizes.                      float targetHeight = frameRecords[m].Target * barHeightScale;                      float timeHeight = frameRecords[m].Time * barHeightScale;                      float intervalHeight = frameRecords[m].Interval * barHeightScale;                      int barLeft = graphArea.Left + 1 + barOffset + i * barWidth;                        // Draw the bars.                      context.SetSourceRGB(0.5' 0.5' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(                          barLeft' graphArea.Bottom - 1 - intervalHeight' barWidth' intervalHeight - timeHeight));                      context.Fill();                        if (timeBarNumber == 0)                          context.SetSourceRGB(1' 0' 0);                      else if (timeBarNumber == 1)                          context.SetSourceRGB(0' 1' 0);                      else if (timeBarNumber == 2)                          context.SetSourceRGB(0' 0' 1);                      else                          context.SetSourceRGB(1' 1' 1);                        context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - timeHeight' barWidth' timeHeight));                      context.Fill();                        context.SetSourceRGB(0.2' 0.2' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - targetHeight' barWidth' 1));                      context.Fill();                        // Move to the next record.                      if (++m >= Count)                          m = 0;                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i < Count; i++)                  {                      // Determine bar color by comparing this record with the previous record.                      // The first bar has no previous record' so just get the default color.                      // The records array is circular' so we must join the first and last elements when required.                      int timeBarNumber;                      if (i == 0)                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m]);                      else                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m != 0 ? m - 1 : Count - 1]);                        // Determine bar sizes.                      float targetHeight = frameRecords[m].Target * barHeightScale;                      float timeHeight = frameRecords[m].Time * barHeightScale;                      float intervalHeight = frameRecords[m].Interval * barHeightScale;                      int barLeft = graphArea.Left + 1 + barOffset + i * barWidth;                        // Draw the bars.                      context.SetSourceRGB(0.5' 0.5' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(                          barLeft' graphArea.Bottom - 1 - intervalHeight' barWidth' intervalHeight - timeHeight));                      context.Fill();                        if (timeBarNumber == 0)                          context.SetSourceRGB(1' 0' 0);                      else if (timeBarNumber == 1)                          context.SetSourceRGB(0' 1' 0);                      else if (timeBarNumber == 2)                          context.SetSourceRGB(0' 0' 1);                      else                          context.SetSourceRGB(1' 1' 1);                        context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - timeHeight' barWidth' timeHeight));                      context.Fill();                        context.SetSourceRGB(0.2' 0.2' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - targetHeight' barWidth' 1));                      context.Fill();                        // Move to the next record.                      if (++m >= Count)                          m = 0;                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i < Count; i++)                  {                      // Determine bar color by comparing this record with the previous record.                      // The first bar has no previous record' so just get the default color.                      // The records array is circular' so we must join the first and last elements when required.                      int timeBarNumber;                      if (i == 0)                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m]);                      else                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m != 0 ? m - 1 : Count - 1]);                        // Determine bar sizes.                      float targetHeight = frameRecords[m].Target * barHeightScale;                      float timeHeight = frameRecords[m].Time * barHeightScale;                      float intervalHeight = frameRecords[m].Interval * barHeightScale;                      int barLeft = graphArea.Left + 1 + barOffset + i * barWidth;                        // Draw the bars.                      context.SetSourceRGB(0.5' 0.5' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(                          barLeft' graphArea.Bottom - 1 - intervalHeight' barWidth' intervalHeight - timeHeight));                      context.Fill();                        if (timeBarNumber == 0)                          context.SetSourceRGB(1' 0' 0);                      else if (timeBarNumber == 1)                          context.SetSourceRGB(0' 1' 0);                      else if (timeBarNumber == 2)                          context.SetSourceRGB(0' 0' 1);                      else                          context.SetSourceRGB(1' 1' 1);                        context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - timeHeight' barWidth' timeHeight));                      context.Fill();                        context.SetSourceRGB(0.2' 0.2' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - targetHeight' barWidth' 1));                      context.Fill();                        // Move to the next record.                      if (++m >= Count)                          m = 0;                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i < Count; i++)                  {                      // Determine bar color by comparing this record with the previous record.                      // The first bar has no previous record' so just get the default color.                      // The records array is circular' so we must join the first and last elements when required.                      int timeBarNumber;                      if (i == 0)                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m]);                      else                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m != 0 ? m - 1 : Count - 1]);                        // Determine bar sizes.                      float targetHeight = frameRecords[m].Target * barHeightScale;                      float timeHeight = frameRecords[m].Time * barHeightScale;                      float intervalHeight = frameRecords[m].Interval * barHeightScale;                      int barLeft = graphArea.Left + 1 + barOffset + i * barWidth;                        // Draw the bars.                      context.SetSourceRGB(0.5' 0.5' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(                          barLeft' graphArea.Bottom - 1 - intervalHeight' barWidth' intervalHeight - timeHeight));                      context.Fill();                        if (timeBarNumber == 0)                          context.SetSourceRGB(1' 0' 0);                      else if (timeBarNumber == 1)                          context.SetSourceRGB(0' 1' 0);                      else if (timeBarNumber == 2)                          context.SetSourceRGB(0' 0' 1);                      else                          context.SetSourceRGB(1' 1' 1);                        context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - timeHeight' barWidth' timeHeight));                      context.Fill();                        context.SetSourceRGB(0.2' 0.2' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - targetHeight' barWidth' 1));                      context.Fill();                        // Move to the next record.                      if (++m >= Count)                          m = 0;                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i < Count; i++)                  {                      // Determine bar color by comparing this record with the previous record.                      // The first bar has no previous record' so just get the default color.                      // The records array is circular' so we must join the first and last elements when required.                      int timeBarNumber;                      if (i == 0)                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m]);                      else                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m != 0 ? m - 1 : Count - 1]);                        // Determine bar sizes.                      float targetHeight = frameRecords[m].Target * barHeightScale;                      float timeHeight = frameRecords[m].Time * barHeightScale;                      float intervalHeight = frameRecords[m].Interval * barHeightScale;                      int barLeft = graphArea.Left + 1 + barOffset + i * barWidth;                        // Draw the bars.                      context.SetSourceRGB(0.5' 0.5' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(                          barLeft' graphArea.Bottom - 1 - intervalHeight' barWidth' intervalHeight - timeHeight));                      context.Fill();                        if (timeBarNumber == 0)                          context.SetSourceRGB(1' 0' 0);                      else if (timeBarNumber == 1)                          context.SetSourceRGB(0' 1' 0);                      else if (timeBarNumber == 2)                          context.SetSourceRGB(0' 0' 1);                      else                          context.SetSourceRGB(1' 1' 1);                        context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - timeHeight' barWidth' timeHeight));                      context.Fill();                        context.SetSourceRGB(0.2' 0.2' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - targetHeight' barWidth' 1));                      context.Fill();                        // Move to the next record.                      if (++m >= Count)                          m = 0;                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i < Count; i++)                  {                      // Determine bar color by comparing this record with the previous record.                      // The first bar has no previous record' so just get the default color.                      // The records array is circular' so we must join the first and last elements when required.                      int timeBarNumber;                      if (i == 0)                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m]);                      else                          timeBarNumber = FrameRecord.CollectionGenerationPerformed(                              frameRecords[m]' frameRecords[m != 0 ? m - 1 : Count - 1]);                        // Determine bar sizes.                      float targetHeight = frameRecords[m].Target * barHeightScale;                      float timeHeight = frameRecords[m].Time * barHeightScale;                      float intervalHeight = frameRecords[m].Interval * barHeightScale;                      int barLeft = graphArea.Left + 1 + barOffset + i * barWidth;                        // Draw the bars.                      context.SetSourceRGB(0.5' 0.5' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(                          barLeft' graphArea.Bottom - 1 - intervalHeight' barWidth' intervalHeight - timeHeight));                      context.Fill();                        if (timeBarNumber == 0)                          context.SetSourceRGB(1' 0' 0);                      else if (timeBarNumber == 1)                          context.SetSourceRGB(0' 1' 0);                      else if (timeBarNumber == 2)                          context.SetSourceRGB(0' 0' 1);                      else                          context.SetSourceRGB(1' 1' 1);                        context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - timeHeight' barWidth' timeHeight));                      context.Fill();                        context.SetSourceRGB(0.2' 0.2' 0.5);                      context.Rectangle(                          new Cairo.Rectangle(barLeft' graphArea.Bottom - 1 - targetHeight' barWidth' 1));                      context.Fill();                        // Move to the next record.                      if (++m >= Count)                          m = 0;                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.SetSourceRGB(0.3' 0.3' 0.3);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.SetSourceRGB(0.3' 0.3' 0.3);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.SetSourceRGB(0.3' 0.3' 0.3);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.LineTo(graphArea.Right - 2' meanIntervalHeight);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.SetSourceRGB(0.7' 0.7' 0.7);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.SetSourceRGB(0.7' 0.7' 0.7);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.SetSourceRGB(0.7' 0.7' 0.7);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.LineTo(graphArea.Right - 2' meanTimeHeight);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: int markerThickness = barHeightScale < .5f ? 1 : 2;
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: context.SetSourceRGB(0.5' 1' 1);
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i <= (graphArea.Height - 1) / barHeightScale; i += 10)                  {                      int markerLineHeight = graphArea.Bottom - 1 - (int)(i * barHeightScale);                      int markerWidth = i % 50 == 0 ? 12 : 4;                      context.Rectangle(                      new Cairo.Rectangle(graphArea.Left + 1' markerLineHeight - 1' markerWidth' markerThickness));                      context.Fill();                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i <= (graphArea.Height - 1) / barHeightScale; i += 10)                  {                      int markerLineHeight = graphArea.Bottom - 1 - (int)(i * barHeightScale);                      int markerWidth = i % 50 == 0 ? 12 : 4;                      context.Rectangle(                      new Cairo.Rectangle(graphArea.Left + 1' markerLineHeight - 1' markerWidth' markerThickness));                      context.Fill();                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i <= (graphArea.Height - 1) / barHeightScale; i += 10)                  {                      int markerLineHeight = graphArea.Bottom - 1 - (int)(i * barHeightScale);                      int markerWidth = i % 50 == 0 ? 12 : 4;                      context.Rectangle(                      new Cairo.Rectangle(graphArea.Left + 1' markerLineHeight - 1' markerWidth' markerThickness));                      context.Fill();                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecordCollector,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,DrawGraph,The following statement contains a magic number: for (int i = 0; i <= (graphArea.Height - 1) / barHeightScale; i += 10)                  {                      int markerLineHeight = graphArea.Bottom - 1 - (int)(i * barHeightScale);                      int markerWidth = i % 50 == 0 ? 12 : 4;                      context.Rectangle(                      new Cairo.Rectangle(graphArea.Left + 1' markerLineHeight - 1' markerWidth' markerThickness));                      context.Fill();                  }
Magic Number,DesktopSprites.SpriteManagement,FrameRecord,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,FrameRecord,The following statement contains a magic number: Gen2Collections = GC.CollectionCount(2);
Magic Number,DesktopSprites.SpriteManagement,FrameRecord,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,CollectionGenerationPerformed,The following statement contains a magic number: if (a.Gen2Collections != b.Gen2Collections)                          return 2;                      else if (a.Gen1Collections != b.Gen1Collections)                          return 1;                      else if (a.Gen0Collections != b.Gen0Collections)                          return 0;                      else                          return -1;
Magic Number,DesktopSprites.SpriteManagement,FrameRecord,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AnimationLoopBase.cs,CollectionGenerationPerformedBrush,The following statement contains a magic number: switch (CollectionGenerationPerformed(a' b))                      {                          case 2:                              return Brushes.Blue;                          case 1:                              return Brushes.Green;                          case 0:                              return Brushes.Red;                          default:                              return Brushes.White;                      }
Magic Number,DesktopSprites.SpriteManagement,AlphaRemappingTable,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\AlphaRemappingTable.cs,LoadMap,The following statement contains a magic number: using (FileStream file = File.OpenRead(path))              {                  if (file.Length % 7 != 0)                      throw new InvalidDataException("Length of file was not the expected multiple of 7 bytes.");                    map.Clear();                    while (file.Position < file.Length)                      map.Add(                          new RgbColor((byte)file.ReadByte()' (byte)file.ReadByte()' (byte)file.ReadByte())'                          new ArgbColor((byte)file.ReadByte()' (byte)file.ReadByte()' (byte)file.ReadByte()' (byte)file.ReadByte()));              }
Magic Number,DesktopSprites.SpriteManagement,GifImage,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,GetHash,The following statement contains a magic number: byte[] colorValues = new byte[palette.Length * 3];
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,DetermineTransparentIndexes,The following statement contains a magic number: if (!found)              {                  // There were no duplicate indexes. But there is room to make the color table bigger and use the extra slot.                  if (colorTable.Length != 256)                  {                      RgbColor[] newTable = new RgbColor[colorTable.Length + 1];                      Array.Copy(colorTable' newTable' colorTable.Length);                      colorTable = newTable;                  }                    // Use the last index in the new table' or if there was no room to expand the table' use the last index and just hope that                  // index was reserved for transparency or that transparency is not required.                  imageTransparentIndex = (byte)(colorTable.Length - 1);                  imageTransparentIndexRemap = (byte)(colorTable.Length - 1);              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,TargetBitsPerPixel,The following statement contains a magic number: byte minBbp = (byte)Math.Ceiling(Math.Log(colorCount' 2));
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,TargetBitsPerPixel,The following statement contains a magic number: while (candidateBbp < minBbp || (candidateBbp & (int)validDepths) == 0)              {                  candidateBbp *= 2;                  if (candidateBbp > 8)                      throw new ArgumentException("The size of the color table is too large to be indexed by any acceptable bit depth.");              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,TargetBitsPerPixel,The following statement contains a magic number: while (candidateBbp < minBbp || (candidateBbp & (int)validDepths) == 0)              {                  candidateBbp *= 2;                  if (candidateBbp > 8)                      throw new ArgumentException("The size of the color table is too large to be indexed by any acceptable bit depth.");              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadHeader,The following statement contains a magic number: string signature = new string(reader.ReadCharsExact(3));
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadHeader,The following statement contains a magic number: string version = new string(reader.ReadCharsExact(3));
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadHeader,The following statement contains a magic number: if (!char.IsDigit(version' 0) || !char.IsDigit(version' 1) || !char.IsLetter(version' 2))                  throw new InvalidDataException("Invalid version in header. Read '{0}'.".FormatWith(version));
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadLogicalScreenDescriptor,The following statement contains a magic number: byte colorResolution = (byte)(((packedFields & 0x70) >> 4) + 1);
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadLogicalScreenDescriptor,The following statement contains a magic number: bool sortFlag = (packedFields & 0x08) >> 3 == 1;
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadGraphicControlExtension,The following statement contains a magic number: if (reader.ReadByte() != 4)                  throw new InvalidDataException("Unexpected block length for a graphic control extension.");
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadGraphicControlExtension,The following statement contains a magic number: DisposalMethod disposalMethod = (DisposalMethod)((packedFields & 0x1C) >> 2);
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadApplicationExtension,The following statement contains a magic number: if (reader.ReadByte() != 11)                  throw new InvalidDataException("Unexpected block length for an application extension.");
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadApplicationExtension,The following statement contains a magic number: string applicationIdentifier = new string(reader.ReadCharsExact(8));
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadApplicationExtension,The following statement contains a magic number: string applicationAuthenticationCode = new string(reader.ReadCharsExact(3));
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadNetscapeApplicationExtension,The following statement contains a magic number: if (reader.ReadByte() != 3)                  throw new InvalidDataException("Unexpected block length for the Netscape application extension.");
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadImageData,The following statement contains a magic number: int yIncrement = imageDescriptor.Interlaced ? 8 : 1;
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,BufferBits,The following statement contains a magic number: while (bitsBuffered < codeSize)              {                  // Read in a new data block if we exhausted the block buffer.                  if (bytesLeftInBlock == 0)                  {                      // Get size of the next data block.                      bytesLeftInBlock = reader.ReadByte();                      // If we happen to read the block terminator' we are done reading image data.                      if (bytesLeftInBlock == 0)                          return true;                      // Read the data block of given size.                      reader.ReadExact(block' 0' bytesLeftInBlock);                      blockIndex = 0;                  }                  bitBuffer += block[blockIndex++] << bitsBuffered;                  bitsBuffered += 8;                  bytesLeftInBlock--;              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following statement contains a magic number: while (stackIndex > 0)              {                  // Apply pixel to our buffers.                  byte pixel = pixelStack[--stackIndex];                  if (pixel != transparentIndex)                      ApplyPixelToFrame(iterator' pixel);                    if (++left < right)                  {                      // Move right one pixel.                      iterator.IncrementX();                  }                  else                  {                      // Move to next row. If we're not interlacing this just means the next row.                      // If interlacing' we must fill in every 8th row' then every 4th' then every 2nd then every other row.                      left = imageDescriptor.Subframe.Left;                      top += yIncrement;                      iterator.SetPosition(left' top);                        // If we reached the end of this interlacing pass' go back to the top and fill in every row between the current rows.                      int bottom = imageDescriptor.Subframe.Bottom;                      if (imageDescriptor.Interlaced && top >= bottom)                      {                          #region Choose next interlacing line.                          do                          {                              interlacePass++;                              switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }                          }                          while (top >= bottom);                          #endregion                      }                        if (top >= bottom)                          return true;                  }              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following statement contains a magic number: while (stackIndex > 0)              {                  // Apply pixel to our buffers.                  byte pixel = pixelStack[--stackIndex];                  if (pixel != transparentIndex)                      ApplyPixelToFrame(iterator' pixel);                    if (++left < right)                  {                      // Move right one pixel.                      iterator.IncrementX();                  }                  else                  {                      // Move to next row. If we're not interlacing this just means the next row.                      // If interlacing' we must fill in every 8th row' then every 4th' then every 2nd then every other row.                      left = imageDescriptor.Subframe.Left;                      top += yIncrement;                      iterator.SetPosition(left' top);                        // If we reached the end of this interlacing pass' go back to the top and fill in every row between the current rows.                      int bottom = imageDescriptor.Subframe.Bottom;                      if (imageDescriptor.Interlaced && top >= bottom)                      {                          #region Choose next interlacing line.                          do                          {                              interlacePass++;                              switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }                          }                          while (top >= bottom);                          #endregion                      }                        if (top >= bottom)                          return true;                  }              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following statement contains a magic number: while (stackIndex > 0)              {                  // Apply pixel to our buffers.                  byte pixel = pixelStack[--stackIndex];                  if (pixel != transparentIndex)                      ApplyPixelToFrame(iterator' pixel);                    if (++left < right)                  {                      // Move right one pixel.                      iterator.IncrementX();                  }                  else                  {                      // Move to next row. If we're not interlacing this just means the next row.                      // If interlacing' we must fill in every 8th row' then every 4th' then every 2nd then every other row.                      left = imageDescriptor.Subframe.Left;                      top += yIncrement;                      iterator.SetPosition(left' top);                        // If we reached the end of this interlacing pass' go back to the top and fill in every row between the current rows.                      int bottom = imageDescriptor.Subframe.Bottom;                      if (imageDescriptor.Interlaced && top >= bottom)                      {                          #region Choose next interlacing line.                          do                          {                              interlacePass++;                              switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }                          }                          while (top >= bottom);                          #endregion                      }                        if (top >= bottom)                          return true;                  }              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following statement contains a magic number: while (stackIndex > 0)              {                  // Apply pixel to our buffers.                  byte pixel = pixelStack[--stackIndex];                  if (pixel != transparentIndex)                      ApplyPixelToFrame(iterator' pixel);                    if (++left < right)                  {                      // Move right one pixel.                      iterator.IncrementX();                  }                  else                  {                      // Move to next row. If we're not interlacing this just means the next row.                      // If interlacing' we must fill in every 8th row' then every 4th' then every 2nd then every other row.                      left = imageDescriptor.Subframe.Left;                      top += yIncrement;                      iterator.SetPosition(left' top);                        // If we reached the end of this interlacing pass' go back to the top and fill in every row between the current rows.                      int bottom = imageDescriptor.Subframe.Bottom;                      if (imageDescriptor.Interlaced && top >= bottom)                      {                          #region Choose next interlacing line.                          do                          {                              interlacePass++;                              switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }                          }                          while (top >= bottom);                          #endregion                      }                        if (top >= bottom)                          return true;                  }              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following statement contains a magic number: while (stackIndex > 0)              {                  // Apply pixel to our buffers.                  byte pixel = pixelStack[--stackIndex];                  if (pixel != transparentIndex)                      ApplyPixelToFrame(iterator' pixel);                    if (++left < right)                  {                      // Move right one pixel.                      iterator.IncrementX();                  }                  else                  {                      // Move to next row. If we're not interlacing this just means the next row.                      // If interlacing' we must fill in every 8th row' then every 4th' then every 2nd then every other row.                      left = imageDescriptor.Subframe.Left;                      top += yIncrement;                      iterator.SetPosition(left' top);                        // If we reached the end of this interlacing pass' go back to the top and fill in every row between the current rows.                      int bottom = imageDescriptor.Subframe.Bottom;                      if (imageDescriptor.Interlaced && top >= bottom)                      {                          #region Choose next interlacing line.                          do                          {                              interlacePass++;                              switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }                          }                          while (top >= bottom);                          #endregion                      }                        if (top >= bottom)                          return true;                  }              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following statement contains a magic number: while (stackIndex > 0)              {                  // Apply pixel to our buffers.                  byte pixel = pixelStack[--stackIndex];                  if (pixel != transparentIndex)                      ApplyPixelToFrame(iterator' pixel);                    if (++left < right)                  {                      // Move right one pixel.                      iterator.IncrementX();                  }                  else                  {                      // Move to next row. If we're not interlacing this just means the next row.                      // If interlacing' we must fill in every 8th row' then every 4th' then every 2nd then every other row.                      left = imageDescriptor.Subframe.Left;                      top += yIncrement;                      iterator.SetPosition(left' top);                        // If we reached the end of this interlacing pass' go back to the top and fill in every row between the current rows.                      int bottom = imageDescriptor.Subframe.Bottom;                      if (imageDescriptor.Interlaced && top >= bottom)                      {                          #region Choose next interlacing line.                          do                          {                              interlacePass++;                              switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }                          }                          while (top >= bottom);                          #endregion                      }                        if (top >= bottom)                          return true;                  }              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following statement contains a magic number: while (stackIndex > 0)              {                  // Apply pixel to our buffers.                  byte pixel = pixelStack[--stackIndex];                  if (pixel != transparentIndex)                      ApplyPixelToFrame(iterator' pixel);                    if (++left < right)                  {                      // Move right one pixel.                      iterator.IncrementX();                  }                  else                  {                      // Move to next row. If we're not interlacing this just means the next row.                      // If interlacing' we must fill in every 8th row' then every 4th' then every 2nd then every other row.                      left = imageDescriptor.Subframe.Left;                      top += yIncrement;                      iterator.SetPosition(left' top);                        // If we reached the end of this interlacing pass' go back to the top and fill in every row between the current rows.                      int bottom = imageDescriptor.Subframe.Bottom;                      if (imageDescriptor.Interlaced && top >= bottom)                      {                          #region Choose next interlacing line.                          do                          {                              interlacePass++;                              switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }                          }                          while (top >= bottom);                          #endregion                      }                        if (top >= bottom)                          return true;                  }              }
Magic Number,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following statement contains a magic number: while (stackIndex > 0)              {                  // Apply pixel to our buffers.                  byte pixel = pixelStack[--stackIndex];                  if (pixel != transparentIndex)                      ApplyPixelToFrame(iterator' pixel);                    if (++left < right)                  {                      // Move right one pixel.                      iterator.IncrementX();                  }                  else                  {                      // Move to next row. If we're not interlacing this just means the next row.                      // If interlacing' we must fill in every 8th row' then every 4th' then every 2nd then every other row.                      left = imageDescriptor.Subframe.Left;                      top += yIncrement;                      iterator.SetPosition(left' top);                        // If we reached the end of this interlacing pass' go back to the top and fill in every row between the current rows.                      int bottom = imageDescriptor.Subframe.Bottom;                      if (imageDescriptor.Interlaced && top >= bottom)                      {                          #region Choose next interlacing line.                          do                          {                              interlacePass++;                              switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }                          }                          while (top >= bottom);                          #endregion                      }                        if (top >= bottom)                          return true;                  }              }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,DataBuffer,The following statement contains a magic number: if (bitsPerValue != 1 && bitsPerValue != 2 && bitsPerValue != 4 && bitsPerValue != 8)                      throw new ArgumentOutOfRangeException("bitsPerValue"' bitsPerValue' "bitsPerValue may only be 1' 2' 4 or 8.");
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,DataBuffer,The following statement contains a magic number: if (bitsPerValue != 1 && bitsPerValue != 2 && bitsPerValue != 4 && bitsPerValue != 8)                      throw new ArgumentOutOfRangeException("bitsPerValue"' bitsPerValue' "bitsPerValue may only be 1' 2' 4 or 8.");
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,DataBuffer,The following statement contains a magic number: if (bitsPerValue != 1 && bitsPerValue != 2 && bitsPerValue != 4 && bitsPerValue != 8)                      throw new ArgumentOutOfRangeException("bitsPerValue"' bitsPerValue' "bitsPerValue may only be 1' 2' 4 or 8.");
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,AllValuesInByte,The following statement contains a magic number: if (BitsPerValue != 8 && value != byte.MinValue && value != byte.MaxValue)                  {                      if (BitsPerValue == 4)                          resultValue = (byte)((value << 4) | value);                      else if (BitsPerValue == 2)                          resultValue = (byte)((value << 6) | (value << 4) | (value << 2) | value);                      else if (BitsPerValue == 1)                          resultValue = (byte)((value << 7) | (value << 6) | (value << 5) | (value << 4) |                              (value << 3) | (value << 2) | (value << 1) | value);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,GetValue,The following statement contains a magic number: if (ValuesPerByte == 1)                  {                      return Buffer[seek];                  }                  else                  {                      int index = seek / ValuesPerByte;                      int shiftToEdge = 8 - BitsPerValue;                      int shift = shiftToEdge - BitsPerValue * (seek % ValuesPerByte);                      int lowMask = byte.MaxValue >> shiftToEdge;                      int valueShifted = Buffer[index] >> shift;                      return (byte)(valueShifted & lowMask);                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,SetValue,The following statement contains a magic number: if (ValuesPerByte == 1)                  {                      Buffer[seek] = value;                  }                  else                  {                      int index = seek / ValuesPerByte;                      int shiftToEdge = 8 - BitsPerValue;                      int shift = shiftToEdge - BitsPerValue * (seek % ValuesPerByte);                      int lowMask = byte.MaxValue >> shiftToEdge;                      int mask = ~(lowMask << shift);                      int valueShifted = value << shift;                      Buffer[index] &= (byte)mask;                      Buffer[index] |= (byte)valueShifted;                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,UpsizeBuffer,The following statement contains a magic number: if (BitsPerValue == 8)                      throw new InvalidOperationException("The BitsPerValue for the buffer is already at its maximum of 8.");
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,UpsizeBuffer,The following statement contains a magic number: byte newBitsPerValue = (byte)(BitsPerValue * 2);
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,EnumerateValues,The following statement contains a magic number: if (ValuesPerByte == 1)                  {                      // Values are byte aligned.                      for (int i = 0; i < Buffer.Length; i++)                          yield return Buffer[i];                  }                  else if (Stride == Width)                  {                      // Values are packed' and so must be unpacked.                      byte mask = (byte)(0xFF >> 8 - BitsPerValue);                      for (int i = 0; i < Buffer.Length; i++)                      {                          byte value = Buffer[i];                          for (byte valueInByte = 0; valueInByte < ValuesPerByte; valueInByte++)                          {                              yield return (byte)(value & mask);                              value >>= BitsPerValue;                          }                      }                  }                  else                  {                      // Values are packed' and we must account for some padding at the end of each row which should be skipped.                      int x = 0;                      int y = 0;                      byte mask = (byte)(0xFF >> 8 - BitsPerValue);                      for (int i = 0; i < Buffer.Length; i++)                      {                          byte value = Buffer[i];                          for (byte valueInByte = 0; valueInByte < ValuesPerByte; valueInByte++)                          {                              yield return (byte)(value & mask);                              value >>= BitsPerValue;                              if (++x >= Width)                              {                                  x = 0;                                  y++;                                  // Skip the padding bits at the end of the row.                                  break;                              }                          }                      }                  }
Magic Number,DesktopSprites.SpriteManagement,DataBuffer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,EnumerateValues,The following statement contains a magic number: if (ValuesPerByte == 1)                  {                      // Values are byte aligned.                      for (int i = 0; i < Buffer.Length; i++)                          yield return Buffer[i];                  }                  else if (Stride == Width)                  {                      // Values are packed' and so must be unpacked.                      byte mask = (byte)(0xFF >> 8 - BitsPerValue);                      for (int i = 0; i < Buffer.Length; i++)                      {                          byte value = Buffer[i];                          for (byte valueInByte = 0; valueInByte < ValuesPerByte; valueInByte++)                          {                              yield return (byte)(value & mask);                              value >>= BitsPerValue;                          }                      }                  }                  else                  {                      // Values are packed' and we must account for some padding at the end of each row which should be skipped.                      int x = 0;                      int y = 0;                      byte mask = (byte)(0xFF >> 8 - BitsPerValue);                      for (int i = 0; i < Buffer.Length; i++)                      {                          byte value = Buffer[i];                          for (byte valueInByte = 0; valueInByte < ValuesPerByte; valueInByte++)                          {                              yield return (byte)(value & mask);                              value >>= BitsPerValue;                              if (++x >= Width)                              {                                  x = 0;                                  y++;                                  // Skip the padding bits at the end of the row.                                  break;                              }                          }                      }                  }
Magic Number,DesktopSprites.SpriteManagement,Iterator,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,SetPosition,The following statement contains a magic number: startShift = 8 - bitsPerValue;
Magic Number,DesktopSprites.SpriteManagement,LzwDictionary,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,Reset,The following statement contains a magic number: Available = (short)(clearCode + 2);
Magic Number,DesktopSprites.SpriteManagement,LogicalScreenDescriptor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,LogicalScreenDescriptor,The following statement contains a magic number: if (pixelAspectRatio == 0)                      ApproximateAspectRatio = null;                  else                      ApproximateAspectRatio = (pixelAspectRatio + 15) / 64f;
Magic Number,DesktopSprites.SpriteManagement,GraphicControlExtension,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,GraphicControlExtension,The following statement contains a magic number: Delay = delayTime * 10;
Magic Number,DesktopSprites.SpriteManagement,GifFrame<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,GetColorTable,The following statement contains a magic number: for (int i = 0; i < ColorTableSize; i++)                  colors[i] = new ArgbColor(255' colorTable[i]);
Magic Number,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,GetButtonsFromNative,The following statement contains a magic number: switch (button)              {                  case 1: return SimpleMouseButtons.Left;                  case 2: return SimpleMouseButtons.Middle;                  case 3: return SimpleMouseButtons.Right;                  default: return SimpleMouseButtons.None;              }
Magic Number,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,GetButtonsFromNative,The following statement contains a magic number: switch (button)              {                  case 1: return SimpleMouseButtons.Left;                  case 2: return SimpleMouseButtons.Middle;                  case 3: return SimpleMouseButtons.Right;                  default: return SimpleMouseButtons.None;              }
Magic Number,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,AlterPixbufForTransparency,The following statement contains a magic number: if (File.Exists(mapFilePath))              {                  AlphaRemappingTable map = new AlphaRemappingTable();                  map.LoadMap(mapFilePath);                    // Loop over the pixels in each row (to account for stride width of the source).                  IntPtr start = pixbuf.Pixels;                  byte[] scan = new byte[pixbuf.Rowstride];                  for (int row = 0; row < pixbuf.Height; row++)                  {                      // Copy the scan line into a managed array.                      IntPtr rowPtr = IntPtr.Add(start' row * pixbuf.Rowstride);                      Marshal.Copy(rowPtr' scan' 0' pixbuf.Rowstride);                      for (int x = 0; x < pixbuf.Width; x++)                      {                          // Map RGB colors to ARGB colors.                          int offset = 4 * x;                          ArgbColor argbColor;                          if (map.TryGetMapping(new RgbColor(scan[offset + 0]' scan[offset + 1]' scan[offset + 2])' out argbColor))                          {                              scan[offset + 0] = argbColor.R;                              scan[offset + 1] = argbColor.G;                              scan[offset + 2] = argbColor.B;                              scan[offset + 3] = argbColor.A;                          }                      }                      // Copy the altered array back into the source.                      Marshal.Copy(scan' 0' rowPtr' pixbuf.Rowstride);                  }              }
Magic Number,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,AlterPixbufForTransparency,The following statement contains a magic number: if (File.Exists(mapFilePath))              {                  AlphaRemappingTable map = new AlphaRemappingTable();                  map.LoadMap(mapFilePath);                    // Loop over the pixels in each row (to account for stride width of the source).                  IntPtr start = pixbuf.Pixels;                  byte[] scan = new byte[pixbuf.Rowstride];                  for (int row = 0; row < pixbuf.Height; row++)                  {                      // Copy the scan line into a managed array.                      IntPtr rowPtr = IntPtr.Add(start' row * pixbuf.Rowstride);                      Marshal.Copy(rowPtr' scan' 0' pixbuf.Rowstride);                      for (int x = 0; x < pixbuf.Width; x++)                      {                          // Map RGB colors to ARGB colors.                          int offset = 4 * x;                          ArgbColor argbColor;                          if (map.TryGetMapping(new RgbColor(scan[offset + 0]' scan[offset + 1]' scan[offset + 2])' out argbColor))                          {                              scan[offset + 0] = argbColor.R;                              scan[offset + 1] = argbColor.G;                              scan[offset + 2] = argbColor.B;                              scan[offset + 3] = argbColor.A;                          }                      }                      // Copy the altered array back into the source.                      Marshal.Copy(scan' 0' rowPtr' pixbuf.Rowstride);                  }              }
Magic Number,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,AlterPixbufForTransparency,The following statement contains a magic number: if (File.Exists(mapFilePath))              {                  AlphaRemappingTable map = new AlphaRemappingTable();                  map.LoadMap(mapFilePath);                    // Loop over the pixels in each row (to account for stride width of the source).                  IntPtr start = pixbuf.Pixels;                  byte[] scan = new byte[pixbuf.Rowstride];                  for (int row = 0; row < pixbuf.Height; row++)                  {                      // Copy the scan line into a managed array.                      IntPtr rowPtr = IntPtr.Add(start' row * pixbuf.Rowstride);                      Marshal.Copy(rowPtr' scan' 0' pixbuf.Rowstride);                      for (int x = 0; x < pixbuf.Width; x++)                      {                          // Map RGB colors to ARGB colors.                          int offset = 4 * x;                          ArgbColor argbColor;                          if (map.TryGetMapping(new RgbColor(scan[offset + 0]' scan[offset + 1]' scan[offset + 2])' out argbColor))                          {                              scan[offset + 0] = argbColor.R;                              scan[offset + 1] = argbColor.G;                              scan[offset + 2] = argbColor.B;                              scan[offset + 3] = argbColor.A;                          }                      }                      // Copy the altered array back into the source.                      Marshal.Copy(scan' 0' rowPtr' pixbuf.Rowstride);                  }              }
Magic Number,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,AlterPixbufForTransparency,The following statement contains a magic number: if (File.Exists(mapFilePath))              {                  AlphaRemappingTable map = new AlphaRemappingTable();                  map.LoadMap(mapFilePath);                    // Loop over the pixels in each row (to account for stride width of the source).                  IntPtr start = pixbuf.Pixels;                  byte[] scan = new byte[pixbuf.Rowstride];                  for (int row = 0; row < pixbuf.Height; row++)                  {                      // Copy the scan line into a managed array.                      IntPtr rowPtr = IntPtr.Add(start' row * pixbuf.Rowstride);                      Marshal.Copy(rowPtr' scan' 0' pixbuf.Rowstride);                      for (int x = 0; x < pixbuf.Width; x++)                      {                          // Map RGB colors to ARGB colors.                          int offset = 4 * x;                          ArgbColor argbColor;                          if (map.TryGetMapping(new RgbColor(scan[offset + 0]' scan[offset + 1]' scan[offset + 2])' out argbColor))                          {                              scan[offset + 0] = argbColor.R;                              scan[offset + 1] = argbColor.G;                              scan[offset + 2] = argbColor.B;                              scan[offset + 3] = argbColor.A;                          }                      }                      // Copy the altered array back into the source.                      Marshal.Copy(scan' 0' rowPtr' pixbuf.Rowstride);                  }              }
Magic Number,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,Draw,The following statement contains a magic number: lock (drawSync)              {                  // Remove all back references from windows to sprites. Any that are not restored indicate removed sprites.                  foreach (GraphicsWindow window in spriteWindows.Values)                      window.Sprite = null;                    // Link sprites to windows' creating new windows as needed for new sprites.                  drawOrderedWindows.Clear();                  foreach (ISprite sprite in sprites)                  {                      // Create a new window for a new sprite.                      if (!spriteWindows.ContainsKey(sprite))                          spriteWindows[sprite] = CreateWindow(sprite);                        // Save the windows position in the draw order.                      drawOrderedWindows.Add(spriteWindows[sprite]);                        // Create a back reference to the sprite the window is responsible for' which indicates it is in use.                      spriteWindows[sprite].Sprite = sprite;                  }                    /*                  // Set the stacking order of the windows.                  foreach (GraphicsWindow window in drawOrderedWindows)                      if (window.Visible)                          window.GdkWindow.Raise();                      else                          window.Show();                  */                  // FIXME: Refreshing the whole stacking order is highly draining and leads to flickering.                  // Implement a LinkedList based minimum moves restack.                  foreach (GraphicsWindow window in drawOrderedWindows)                      ApplicationInvoke(() =>                      {                          if (!window.Visible)                              window.Show();                      });                    // Remove windows whose sprites have been removed (and thus were not re-linked).                  foreach (var kvp in spriteWindows)                      if (kvp.Value.Sprite == null)                      {                          removedSprites.Add(kvp.Key);                          ApplicationInvoke(() => kvp.Value.Destroy());                      }                  foreach (ISprite sprite in removedSprites)                      spriteWindows.Remove(sprite);                  removedSprites.Clear();                    // Draw each sprite in the collection to its own window' in the correct order.                  foreach (GraphicsWindow loopWindow in drawOrderedWindows)                  {                      // C# 4 behavior. Using a loop variable in an anonymous expression will capture the final value' and not the current                      // iteration. To do that a local copy must be made. This is fixed in C# 5.                      GraphicsWindow window = loopWindow;                        ISprite sprite = window.Sprite;                        // Gtk# operations need to be invoked on the main thread. Although they will usually succeed' eventually an invalid                      // unmanaged memory access is likely to result.                      // By invoking within the loop' the actions are chunked up so that the message pump doesn't become tied down for too                      // long' which allows it to continue to respond to other messages in a timely manner.                      ApplicationInvoke(() =>                      {                          var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                          if (imagePath != null)                          {                              var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' createPair);                              var animation = sprite.FacingRight ? pair.Right : pair.Left;                              var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                              if (frame != null)                                  window.CurrentImage = frame.Image;                              else                                  window.CurrentImage = null;                          }                            // The window takes on the location and size of the sprite to draw.                          window.GdkWindow.MoveResize(sprite.Region.X' sprite.Region.Y' sprite.Region.Width' sprite.Region.Height);                            // Apply the image now the window is set up' by updating the clipping region and drawing it.                          window.SetClip(sprite.Region.Width' sprite.Region.Height);                          window.DrawFrame(sprite.Region.Width' sprite.Region.Height);                            // Display any speech.                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              window.ShowSpeech(speakingSprite.SpeechText' sprite.Region.X + sprite.Region.Width / 2' sprite.Region.Y - 2);                          else                              window.HideSpeech();                      });                  }              }
Magic Number,DesktopSprites.SpriteManagement,GtkSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,Draw,The following statement contains a magic number: lock (drawSync)              {                  // Remove all back references from windows to sprites. Any that are not restored indicate removed sprites.                  foreach (GraphicsWindow window in spriteWindows.Values)                      window.Sprite = null;                    // Link sprites to windows' creating new windows as needed for new sprites.                  drawOrderedWindows.Clear();                  foreach (ISprite sprite in sprites)                  {                      // Create a new window for a new sprite.                      if (!spriteWindows.ContainsKey(sprite))                          spriteWindows[sprite] = CreateWindow(sprite);                        // Save the windows position in the draw order.                      drawOrderedWindows.Add(spriteWindows[sprite]);                        // Create a back reference to the sprite the window is responsible for' which indicates it is in use.                      spriteWindows[sprite].Sprite = sprite;                  }                    /*                  // Set the stacking order of the windows.                  foreach (GraphicsWindow window in drawOrderedWindows)                      if (window.Visible)                          window.GdkWindow.Raise();                      else                          window.Show();                  */                  // FIXME: Refreshing the whole stacking order is highly draining and leads to flickering.                  // Implement a LinkedList based minimum moves restack.                  foreach (GraphicsWindow window in drawOrderedWindows)                      ApplicationInvoke(() =>                      {                          if (!window.Visible)                              window.Show();                      });                    // Remove windows whose sprites have been removed (and thus were not re-linked).                  foreach (var kvp in spriteWindows)                      if (kvp.Value.Sprite == null)                      {                          removedSprites.Add(kvp.Key);                          ApplicationInvoke(() => kvp.Value.Destroy());                      }                  foreach (ISprite sprite in removedSprites)                      spriteWindows.Remove(sprite);                  removedSprites.Clear();                    // Draw each sprite in the collection to its own window' in the correct order.                  foreach (GraphicsWindow loopWindow in drawOrderedWindows)                  {                      // C# 4 behavior. Using a loop variable in an anonymous expression will capture the final value' and not the current                      // iteration. To do that a local copy must be made. This is fixed in C# 5.                      GraphicsWindow window = loopWindow;                        ISprite sprite = window.Sprite;                        // Gtk# operations need to be invoked on the main thread. Although they will usually succeed' eventually an invalid                      // unmanaged memory access is likely to result.                      // By invoking within the loop' the actions are chunked up so that the message pump doesn't become tied down for too                      // long' which allows it to continue to respond to other messages in a timely manner.                      ApplicationInvoke(() =>                      {                          var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                          if (imagePath != null)                          {                              var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' createPair);                              var animation = sprite.FacingRight ? pair.Right : pair.Left;                              var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                              if (frame != null)                                  window.CurrentImage = frame.Image;                              else                                  window.CurrentImage = null;                          }                            // The window takes on the location and size of the sprite to draw.                          window.GdkWindow.MoveResize(sprite.Region.X' sprite.Region.Y' sprite.Region.Width' sprite.Region.Height);                            // Apply the image now the window is set up' by updating the clipping region and drawing it.                          window.SetClip(sprite.Region.Width' sprite.Region.Height);                          window.DrawFrame(sprite.Region.Width' sprite.Region.Height);                            // Display any speech.                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              window.ShowSpeech(speakingSprite.SpeechText' sprite.Region.X + sprite.Region.Width / 2' sprite.Region.Y - 2);                          else                              window.HideSpeech();                      });                  }              }
Magic Number,DesktopSprites.SpriteManagement,SpeechWindow,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,ShowAboveCenter,The following statement contains a magic number: const int XPadding = 6;
Magic Number,DesktopSprites.SpriteManagement,SpeechWindow,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,ShowAboveCenter,The following statement contains a magic number: const int YPadding = 2;
Magic Number,DesktopSprites.SpriteManagement,SpeechWindow,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,ShowAboveCenter,The following statement contains a magic number: Move(x - size.Width / 2 - XPadding' y - size.Height - YPadding);
Magic Number,DesktopSprites.SpriteManagement,SpeechWindow,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,ShowAboveCenter,The following statement contains a magic number: Resize(size.Width + 2 * XPadding' size.Height + 2 * YPadding);
Magic Number,DesktopSprites.SpriteManagement,SpeechWindow,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,ShowAboveCenter,The following statement contains a magic number: Resize(size.Width + 2 * XPadding' size.Height + 2 * YPadding);
Magic Number,DesktopSprites.SpriteManagement,ClippedImage,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,ClippedImage,The following statement contains a magic number: gtkSpriteInterface.ApplicationInvoke(() =>                  {                      // Create the image and get its clipping mask.                      Pixmap clipMap;                      Pixmap clipMask;                      Image = new Pixbuf(fileName);                      Image.RenderPixmapAndMask(out clipMap' out clipMask' 255);                      Clip = clipMask;                      clipMap.Dispose();                  });
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: if (depth != 8)                      throw new ArgumentOutOfRangeException("depth"' depth' "depth must be 8.");
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: byte[] data = new byte[width * height * 4];
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: for (int row = 0; row < height; row++)                      for (int x = 0; x < width; x++)                      {                          // Get the index value from the 8bbp source.                          byte index = buffer[row * stride + x];                          // Get the destination offset in the 32bbp array.                          int offset = 4 * (width * row + x);                          if (index != transparentIndex)                          {                              // Get the color from the palette' and set the RGB values.                              RgbColor color = palette[index];                              data[offset + 0] = color.R;                              data[offset + 1] = color.G;                              data[offset + 2] = color.B;                              data[offset + 3] = 255;                                // Save the point for creating the mask later.                              points.Add(new Point(x' row));                          }                          else                          {                              // This color is transparent.                              data[offset + 3] = 0;                          }                      }
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: for (int row = 0; row < height; row++)                      for (int x = 0; x < width; x++)                      {                          // Get the index value from the 8bbp source.                          byte index = buffer[row * stride + x];                          // Get the destination offset in the 32bbp array.                          int offset = 4 * (width * row + x);                          if (index != transparentIndex)                          {                              // Get the color from the palette' and set the RGB values.                              RgbColor color = palette[index];                              data[offset + 0] = color.R;                              data[offset + 1] = color.G;                              data[offset + 2] = color.B;                              data[offset + 3] = 255;                                // Save the point for creating the mask later.                              points.Add(new Point(x' row));                          }                          else                          {                              // This color is transparent.                              data[offset + 3] = 0;                          }                      }
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: for (int row = 0; row < height; row++)                      for (int x = 0; x < width; x++)                      {                          // Get the index value from the 8bbp source.                          byte index = buffer[row * stride + x];                          // Get the destination offset in the 32bbp array.                          int offset = 4 * (width * row + x);                          if (index != transparentIndex)                          {                              // Get the color from the palette' and set the RGB values.                              RgbColor color = palette[index];                              data[offset + 0] = color.R;                              data[offset + 1] = color.G;                              data[offset + 2] = color.B;                              data[offset + 3] = 255;                                // Save the point for creating the mask later.                              points.Add(new Point(x' row));                          }                          else                          {                              // This color is transparent.                              data[offset + 3] = 0;                          }                      }
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: for (int row = 0; row < height; row++)                      for (int x = 0; x < width; x++)                      {                          // Get the index value from the 8bbp source.                          byte index = buffer[row * stride + x];                          // Get the destination offset in the 32bbp array.                          int offset = 4 * (width * row + x);                          if (index != transparentIndex)                          {                              // Get the color from the palette' and set the RGB values.                              RgbColor color = palette[index];                              data[offset + 0] = color.R;                              data[offset + 1] = color.G;                              data[offset + 2] = color.B;                              data[offset + 3] = 255;                                // Save the point for creating the mask later.                              points.Add(new Point(x' row));                          }                          else                          {                              // This color is transparent.                              data[offset + 3] = 0;                          }                      }
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: for (int row = 0; row < height; row++)                      for (int x = 0; x < width; x++)                      {                          // Get the index value from the 8bbp source.                          byte index = buffer[row * stride + x];                          // Get the destination offset in the 32bbp array.                          int offset = 4 * (width * row + x);                          if (index != transparentIndex)                          {                              // Get the color from the palette' and set the RGB values.                              RgbColor color = palette[index];                              data[offset + 0] = color.R;                              data[offset + 1] = color.G;                              data[offset + 2] = color.B;                              data[offset + 3] = 255;                                // Save the point for creating the mask later.                              points.Add(new Point(x' row));                          }                          else                          {                              // This color is transparent.                              data[offset + 3] = 0;                          }                      }
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: frameImage.Image = new Pixbuf(data' true' 8' width' height' width * 4);
Magic Number,DesktopSprites.SpriteManagement,GtkFrame,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GtkSpriteInterface.cs,FromBuffer,The following statement contains a magic number: frameImage.Image = new Pixbuf(data' true' 8' width' height' width * 4);
Magic Number,DesktopSprites.SpriteManagement,ArgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\ArgbColor.cs,ToArgb,The following statement contains a magic number: return (A << 24) | (R << 16) | (G << 8) | B;
Magic Number,DesktopSprites.SpriteManagement,ArgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\ArgbColor.cs,ToArgb,The following statement contains a magic number: return (A << 24) | (R << 16) | (G << 8) | B;
Magic Number,DesktopSprites.SpriteManagement,ArgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\ArgbColor.cs,ToArgb,The following statement contains a magic number: return (A << 24) | (R << 16) | (G << 8) | B;
Magic Number,DesktopSprites.SpriteManagement,ArgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\ArgbColor.cs,PremultipliedAlpha,The following statement contains a magic number: return new ArgbColor(A' (byte)(R * A / 255)' (byte)(G * A / 255)' (byte)(B * A / 255));
Magic Number,DesktopSprites.SpriteManagement,ArgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\ArgbColor.cs,PremultipliedAlpha,The following statement contains a magic number: return new ArgbColor(A' (byte)(R * A / 255)' (byte)(G * A / 255)' (byte)(B * A / 255));
Magic Number,DesktopSprites.SpriteManagement,ArgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\ArgbColor.cs,PremultipliedAlpha,The following statement contains a magic number: return new ArgbColor(A' (byte)(R * A / 255)' (byte)(G * A / 255)' (byte)(B * A / 255));
Magic Number,DesktopSprites.SpriteManagement,RgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\RgbColor.cs,ToArgb,The following statement contains a magic number: return (255 << 24) | (R << 16) | (G << 8) | B;
Magic Number,DesktopSprites.SpriteManagement,RgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\RgbColor.cs,ToArgb,The following statement contains a magic number: return (255 << 24) | (R << 16) | (G << 8) | B;
Magic Number,DesktopSprites.SpriteManagement,RgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\RgbColor.cs,ToArgb,The following statement contains a magic number: return (255 << 24) | (R << 16) | (G << 8) | B;
Magic Number,DesktopSprites.SpriteManagement,RgbColor,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\RgbColor.cs,ToArgb,The following statement contains a magic number: return (255 << 24) | (R << 16) | (G << 8) | B;
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,WinFormSpriteInterface,The following statement contains a magic number: lock (appInitiated)              {                  appThread.Start(Tuple.Create(appInitiated' displayBounds));                    // Do other initialization in parallel whilst the UI thread is spinning up.                  generatePair = paths => CreatePair(paths' null);                  render = Render;                  setPreventSelfCloseTrue = () => preventSelfClose = true;                  setPreventSelfCloseFalse = () =>                  {                      preventSelfClose = false;                      if (closePending)                          Close();                  };                  using (var family = FontFamily.GenericSansSerif)                      font = new Font(family' 12' GraphicsUnit.Pixel);                  postUpdateInvalidRegion.MakeEmpty();                  if (ParallelBlendThreads > 0)                  {                      parallelBlend = new Barrier(ParallelBlendTotalSections);                      for (int i = 0; i < ParallelBlendThreads; i++)                          new Thread(AlphaBlendWorker) { Name = "WinFormSpriteInterface.AlphaBlendWorker" }.Start(i);                  }                    Monitor.Wait(appInitiated);              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,ImageFrameFromBuffer,The following statement contains a magic number: return SetupSafely(                  new ImageFrame(new ImageData(buffer' palette' transparentIndex' stride' width' height' depth))'                  frame =>                  {                      var colorPalette = frame.Image.ArgbPalette;                      // Check for an alpha remapping table' and apply it if one exists.                      string mapFilePath = Path.ChangeExtension(fileName' AlphaRemappingTable.FileExtension);                      if (File.Exists(mapFilePath))                      {                          AlphaRemappingTable map = new AlphaRemappingTable();                          map.LoadMap(mapFilePath);                          for (int i = 0; i < colorPalette.Length; i++)                          {                              ArgbColor paletteColor = new ArgbColor(colorPalette[i]);                              if (paletteColor.A != 255)                                  continue;                              ArgbColor argbColor;                              if (map.TryGetMapping(new RgbColor(paletteColor.R' paletteColor.G' paletteColor.B)' out argbColor))                                  colorPalette[i] = argbColor.PremultipliedAlpha().ToArgb();                          }                      }                      // Check for duplicate palettes in the cache and reuse an existing palette where possible.                      lock (paletteCache)                          frame.Image.ArgbPalette = paletteCache.GetOrAdd(colorPalette' colorPalette);                  });
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The following statement contains a magic number: for (int frameIndex = 0; frameIndex < left.FrameCount; frameIndex++)              {                  if (left.GetDuration(frameIndex) != right.GetDuration(frameIndex))                      return false;                  var leftFrame = left[frameIndex].Image;                  var rightFrame = right[frameIndex].Image;                  // If as a result of the 2x downscaling the images no longer match in size' they cannot be mirror candidates.                  if (leftFrame.Depth != rightFrame.Depth || leftFrame.Width != rightFrame.Width || leftFrame.Height != rightFrame.Height)                      return false;                  // Check for an exact horizontal mirror match by comparing pixels in each image.                  byte[] leftData = leftFrame.Data;                  byte[] rightData = rightFrame.Data;                  int[] leftPalette = leftFrame.ArgbPalette;                  int[] rightPalette = rightFrame.ArgbPalette;                  int rightMax = rightFrame.Stride - 1;                  if (leftFrame.Depth == 8)                  {                      // If the images share a palette' we can check faster by eliding the deference of the palette and just compare indexes.                      if (leftPalette == rightPalette)                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftData[leftRow + x] != rightData[rightRow + rightMax - x])                                      return false;                          }                      }                      else                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftPalette[leftData[leftRow + x]] != rightPalette[rightData[rightRow + rightMax - x]])                                      return false;                          }                      }                  }                  else                  {                      bool hasPadding = rightFrame.Width % 2 != 0;                      for (int y = 0; y < leftFrame.Height; y++)                      {                          int leftRow = y * leftFrame.Stride;                          int rightRow = y * rightFrame.Stride;                          for (int x = 0; x < leftFrame.Width; x++)                          {                              bool xIsEven = x % 2 == 0;                              int halfX = x / 2;                              int rightOffset = hasPadding && !xIsEven ? 1 : 0;                              var leftIndex = leftData[leftRow + halfX];                              var rightIndex = rightData[rightRow + rightMax - halfX - rightOffset];                              if (xIsEven)                              {                                  leftIndex >>= 4;                                  if (hasPadding)                                      rightIndex >>= 4;                                  else                                      rightIndex &= 0xF;                              }                              else                              {                                  leftIndex &= 0xF;                                  if (hasPadding)                                      rightIndex &= 0xF;                                  else                                      rightIndex >>= 4;                              }                              if (leftPalette[leftIndex] != rightPalette[rightIndex])                                  return false;                          }                      }                  }              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The following statement contains a magic number: for (int frameIndex = 0; frameIndex < left.FrameCount; frameIndex++)              {                  if (left.GetDuration(frameIndex) != right.GetDuration(frameIndex))                      return false;                  var leftFrame = left[frameIndex].Image;                  var rightFrame = right[frameIndex].Image;                  // If as a result of the 2x downscaling the images no longer match in size' they cannot be mirror candidates.                  if (leftFrame.Depth != rightFrame.Depth || leftFrame.Width != rightFrame.Width || leftFrame.Height != rightFrame.Height)                      return false;                  // Check for an exact horizontal mirror match by comparing pixels in each image.                  byte[] leftData = leftFrame.Data;                  byte[] rightData = rightFrame.Data;                  int[] leftPalette = leftFrame.ArgbPalette;                  int[] rightPalette = rightFrame.ArgbPalette;                  int rightMax = rightFrame.Stride - 1;                  if (leftFrame.Depth == 8)                  {                      // If the images share a palette' we can check faster by eliding the deference of the palette and just compare indexes.                      if (leftPalette == rightPalette)                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftData[leftRow + x] != rightData[rightRow + rightMax - x])                                      return false;                          }                      }                      else                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftPalette[leftData[leftRow + x]] != rightPalette[rightData[rightRow + rightMax - x]])                                      return false;                          }                      }                  }                  else                  {                      bool hasPadding = rightFrame.Width % 2 != 0;                      for (int y = 0; y < leftFrame.Height; y++)                      {                          int leftRow = y * leftFrame.Stride;                          int rightRow = y * rightFrame.Stride;                          for (int x = 0; x < leftFrame.Width; x++)                          {                              bool xIsEven = x % 2 == 0;                              int halfX = x / 2;                              int rightOffset = hasPadding && !xIsEven ? 1 : 0;                              var leftIndex = leftData[leftRow + halfX];                              var rightIndex = rightData[rightRow + rightMax - halfX - rightOffset];                              if (xIsEven)                              {                                  leftIndex >>= 4;                                  if (hasPadding)                                      rightIndex >>= 4;                                  else                                      rightIndex &= 0xF;                              }                              else                              {                                  leftIndex &= 0xF;                                  if (hasPadding)                                      rightIndex &= 0xF;                                  else                                      rightIndex >>= 4;                              }                              if (leftPalette[leftIndex] != rightPalette[rightIndex])                                  return false;                          }                      }                  }              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The following statement contains a magic number: for (int frameIndex = 0; frameIndex < left.FrameCount; frameIndex++)              {                  if (left.GetDuration(frameIndex) != right.GetDuration(frameIndex))                      return false;                  var leftFrame = left[frameIndex].Image;                  var rightFrame = right[frameIndex].Image;                  // If as a result of the 2x downscaling the images no longer match in size' they cannot be mirror candidates.                  if (leftFrame.Depth != rightFrame.Depth || leftFrame.Width != rightFrame.Width || leftFrame.Height != rightFrame.Height)                      return false;                  // Check for an exact horizontal mirror match by comparing pixels in each image.                  byte[] leftData = leftFrame.Data;                  byte[] rightData = rightFrame.Data;                  int[] leftPalette = leftFrame.ArgbPalette;                  int[] rightPalette = rightFrame.ArgbPalette;                  int rightMax = rightFrame.Stride - 1;                  if (leftFrame.Depth == 8)                  {                      // If the images share a palette' we can check faster by eliding the deference of the palette and just compare indexes.                      if (leftPalette == rightPalette)                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftData[leftRow + x] != rightData[rightRow + rightMax - x])                                      return false;                          }                      }                      else                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftPalette[leftData[leftRow + x]] != rightPalette[rightData[rightRow + rightMax - x]])                                      return false;                          }                      }                  }                  else                  {                      bool hasPadding = rightFrame.Width % 2 != 0;                      for (int y = 0; y < leftFrame.Height; y++)                      {                          int leftRow = y * leftFrame.Stride;                          int rightRow = y * rightFrame.Stride;                          for (int x = 0; x < leftFrame.Width; x++)                          {                              bool xIsEven = x % 2 == 0;                              int halfX = x / 2;                              int rightOffset = hasPadding && !xIsEven ? 1 : 0;                              var leftIndex = leftData[leftRow + halfX];                              var rightIndex = rightData[rightRow + rightMax - halfX - rightOffset];                              if (xIsEven)                              {                                  leftIndex >>= 4;                                  if (hasPadding)                                      rightIndex >>= 4;                                  else                                      rightIndex &= 0xF;                              }                              else                              {                                  leftIndex &= 0xF;                                  if (hasPadding)                                      rightIndex &= 0xF;                                  else                                      rightIndex >>= 4;                              }                              if (leftPalette[leftIndex] != rightPalette[rightIndex])                                  return false;                          }                      }                  }              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The following statement contains a magic number: for (int frameIndex = 0; frameIndex < left.FrameCount; frameIndex++)              {                  if (left.GetDuration(frameIndex) != right.GetDuration(frameIndex))                      return false;                  var leftFrame = left[frameIndex].Image;                  var rightFrame = right[frameIndex].Image;                  // If as a result of the 2x downscaling the images no longer match in size' they cannot be mirror candidates.                  if (leftFrame.Depth != rightFrame.Depth || leftFrame.Width != rightFrame.Width || leftFrame.Height != rightFrame.Height)                      return false;                  // Check for an exact horizontal mirror match by comparing pixels in each image.                  byte[] leftData = leftFrame.Data;                  byte[] rightData = rightFrame.Data;                  int[] leftPalette = leftFrame.ArgbPalette;                  int[] rightPalette = rightFrame.ArgbPalette;                  int rightMax = rightFrame.Stride - 1;                  if (leftFrame.Depth == 8)                  {                      // If the images share a palette' we can check faster by eliding the deference of the palette and just compare indexes.                      if (leftPalette == rightPalette)                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftData[leftRow + x] != rightData[rightRow + rightMax - x])                                      return false;                          }                      }                      else                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftPalette[leftData[leftRow + x]] != rightPalette[rightData[rightRow + rightMax - x]])                                      return false;                          }                      }                  }                  else                  {                      bool hasPadding = rightFrame.Width % 2 != 0;                      for (int y = 0; y < leftFrame.Height; y++)                      {                          int leftRow = y * leftFrame.Stride;                          int rightRow = y * rightFrame.Stride;                          for (int x = 0; x < leftFrame.Width; x++)                          {                              bool xIsEven = x % 2 == 0;                              int halfX = x / 2;                              int rightOffset = hasPadding && !xIsEven ? 1 : 0;                              var leftIndex = leftData[leftRow + halfX];                              var rightIndex = rightData[rightRow + rightMax - halfX - rightOffset];                              if (xIsEven)                              {                                  leftIndex >>= 4;                                  if (hasPadding)                                      rightIndex >>= 4;                                  else                                      rightIndex &= 0xF;                              }                              else                              {                                  leftIndex &= 0xF;                                  if (hasPadding)                                      rightIndex &= 0xF;                                  else                                      rightIndex >>= 4;                              }                              if (leftPalette[leftIndex] != rightPalette[rightIndex])                                  return false;                          }                      }                  }              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The following statement contains a magic number: for (int frameIndex = 0; frameIndex < left.FrameCount; frameIndex++)              {                  if (left.GetDuration(frameIndex) != right.GetDuration(frameIndex))                      return false;                  var leftFrame = left[frameIndex].Image;                  var rightFrame = right[frameIndex].Image;                  // If as a result of the 2x downscaling the images no longer match in size' they cannot be mirror candidates.                  if (leftFrame.Depth != rightFrame.Depth || leftFrame.Width != rightFrame.Width || leftFrame.Height != rightFrame.Height)                      return false;                  // Check for an exact horizontal mirror match by comparing pixels in each image.                  byte[] leftData = leftFrame.Data;                  byte[] rightData = rightFrame.Data;                  int[] leftPalette = leftFrame.ArgbPalette;                  int[] rightPalette = rightFrame.ArgbPalette;                  int rightMax = rightFrame.Stride - 1;                  if (leftFrame.Depth == 8)                  {                      // If the images share a palette' we can check faster by eliding the deference of the palette and just compare indexes.                      if (leftPalette == rightPalette)                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftData[leftRow + x] != rightData[rightRow + rightMax - x])                                      return false;                          }                      }                      else                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftPalette[leftData[leftRow + x]] != rightPalette[rightData[rightRow + rightMax - x]])                                      return false;                          }                      }                  }                  else                  {                      bool hasPadding = rightFrame.Width % 2 != 0;                      for (int y = 0; y < leftFrame.Height; y++)                      {                          int leftRow = y * leftFrame.Stride;                          int rightRow = y * rightFrame.Stride;                          for (int x = 0; x < leftFrame.Width; x++)                          {                              bool xIsEven = x % 2 == 0;                              int halfX = x / 2;                              int rightOffset = hasPadding && !xIsEven ? 1 : 0;                              var leftIndex = leftData[leftRow + halfX];                              var rightIndex = rightData[rightRow + rightMax - halfX - rightOffset];                              if (xIsEven)                              {                                  leftIndex >>= 4;                                  if (hasPadding)                                      rightIndex >>= 4;                                  else                                      rightIndex &= 0xF;                              }                              else                              {                                  leftIndex &= 0xF;                                  if (hasPadding)                                      rightIndex &= 0xF;                                  else                                      rightIndex >>= 4;                              }                              if (leftPalette[leftIndex] != rightPalette[rightIndex])                                  return false;                          }                      }                  }              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The following statement contains a magic number: for (int frameIndex = 0; frameIndex < left.FrameCount; frameIndex++)              {                  if (left.GetDuration(frameIndex) != right.GetDuration(frameIndex))                      return false;                  var leftFrame = left[frameIndex].Image;                  var rightFrame = right[frameIndex].Image;                  // If as a result of the 2x downscaling the images no longer match in size' they cannot be mirror candidates.                  if (leftFrame.Depth != rightFrame.Depth || leftFrame.Width != rightFrame.Width || leftFrame.Height != rightFrame.Height)                      return false;                  // Check for an exact horizontal mirror match by comparing pixels in each image.                  byte[] leftData = leftFrame.Data;                  byte[] rightData = rightFrame.Data;                  int[] leftPalette = leftFrame.ArgbPalette;                  int[] rightPalette = rightFrame.ArgbPalette;                  int rightMax = rightFrame.Stride - 1;                  if (leftFrame.Depth == 8)                  {                      // If the images share a palette' we can check faster by eliding the deference of the palette and just compare indexes.                      if (leftPalette == rightPalette)                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftData[leftRow + x] != rightData[rightRow + rightMax - x])                                      return false;                          }                      }                      else                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftPalette[leftData[leftRow + x]] != rightPalette[rightData[rightRow + rightMax - x]])                                      return false;                          }                      }                  }                  else                  {                      bool hasPadding = rightFrame.Width % 2 != 0;                      for (int y = 0; y < leftFrame.Height; y++)                      {                          int leftRow = y * leftFrame.Stride;                          int rightRow = y * rightFrame.Stride;                          for (int x = 0; x < leftFrame.Width; x++)                          {                              bool xIsEven = x % 2 == 0;                              int halfX = x / 2;                              int rightOffset = hasPadding && !xIsEven ? 1 : 0;                              var leftIndex = leftData[leftRow + halfX];                              var rightIndex = rightData[rightRow + rightMax - halfX - rightOffset];                              if (xIsEven)                              {                                  leftIndex >>= 4;                                  if (hasPadding)                                      rightIndex >>= 4;                                  else                                      rightIndex &= 0xF;                              }                              else                              {                                  leftIndex &= 0xF;                                  if (hasPadding)                                      rightIndex &= 0xF;                                  else                                      rightIndex >>= 4;                              }                              if (leftPalette[leftIndex] != rightPalette[rightIndex])                                  return false;                          }                      }                  }              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AnimationsAreHorizontallyMirrored,The following statement contains a magic number: for (int frameIndex = 0; frameIndex < left.FrameCount; frameIndex++)              {                  if (left.GetDuration(frameIndex) != right.GetDuration(frameIndex))                      return false;                  var leftFrame = left[frameIndex].Image;                  var rightFrame = right[frameIndex].Image;                  // If as a result of the 2x downscaling the images no longer match in size' they cannot be mirror candidates.                  if (leftFrame.Depth != rightFrame.Depth || leftFrame.Width != rightFrame.Width || leftFrame.Height != rightFrame.Height)                      return false;                  // Check for an exact horizontal mirror match by comparing pixels in each image.                  byte[] leftData = leftFrame.Data;                  byte[] rightData = rightFrame.Data;                  int[] leftPalette = leftFrame.ArgbPalette;                  int[] rightPalette = rightFrame.ArgbPalette;                  int rightMax = rightFrame.Stride - 1;                  if (leftFrame.Depth == 8)                  {                      // If the images share a palette' we can check faster by eliding the deference of the palette and just compare indexes.                      if (leftPalette == rightPalette)                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftData[leftRow + x] != rightData[rightRow + rightMax - x])                                      return false;                          }                      }                      else                      {                          for (int y = 0; y < leftFrame.Height; y++)                          {                              int leftRow = y * leftFrame.Stride;                              int rightRow = y * rightFrame.Stride;                              for (int x = 0; x < leftFrame.Width; x++)                                  if (leftPalette[leftData[leftRow + x]] != rightPalette[rightData[rightRow + rightMax - x]])                                      return false;                          }                      }                  }                  else                  {                      bool hasPadding = rightFrame.Width % 2 != 0;                      for (int y = 0; y < leftFrame.Height; y++)                      {                          int leftRow = y * leftFrame.Stride;                          int rightRow = y * rightFrame.Stride;                          for (int x = 0; x < leftFrame.Width; x++)                          {                              bool xIsEven = x % 2 == 0;                              int halfX = x / 2;                              int rightOffset = hasPadding && !xIsEven ? 1 : 0;                              var leftIndex = leftData[leftRow + halfX];                              var rightIndex = rightData[rightRow + rightMax - halfX - rightOffset];                              if (xIsEven)                              {                                  leftIndex >>= 4;                                  if (hasPadding)                                      rightIndex >>= 4;                                  else                                      rightIndex &= 0xF;                              }                              else                              {                                  leftIndex &= 0xF;                                  if (hasPadding)                                      rightIndex &= 0xF;                                  else                                      rightIndex >>= 4;                              }                              if (leftPalette[leftIndex] != rightPalette[rightIndex])                                  return false;                          }                      }                  }              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The following statement contains a magic number: lock (spritesGuard)              {                  if (sprites == null)                      return;                    // Translation offset so the top-left of the form and drawing surface coincide.                  Size translate = new Size(-form.Left' -form.Top);                    // Save the invalid region from last frame.                  preUpdateInvalidRegion.MakeEmpty();                  preUpdateInvalidRegion.Union(postUpdateInvalidRegion);                    // Reset the post-update clipping region.                  postUpdateInvalidRegion.MakeEmpty();                    #region Timings Graph Area                  Rectangle timingsArea = Rectangle.Empty;                  string timingsInfo = null;                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Create info string.                      timingsInfo = "fps: " +                          Collector.FramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture) + "/" +                          Collector.AchievableFramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture);                      Size timingsSize = Size.Ceiling(form.BackgroundGraphics.MeasureString(timingsInfo' font));                        // Set location and get area of graph draw.                      Point offset = new Point(10' 10);                      Point graphLocation = new Point(offset.X' offset.Y + timingsSize.Height);                      Rectangle recorderGraphArea = Collector.SetGraphingAttributes(graphLocation' 150' 1' 1.5f);                      postUpdateInvalidRegion.Union(recorderGraphArea);                        // Set location of info string draw.                      timingsArea = new Rectangle(                          recorderGraphArea.Left' recorderGraphArea.Top - timingsSize.Height - 1'                          timingsSize.Width + 1' timingsSize.Height + 1);                      postUpdateInvalidRegion.Union(timingsArea);                  }                  #endregion                    // Determine and apply the clipping area' this is only beneficial when there are few sprites on screen. As more are added                  // the cost of hit testing that combined area becomes larger' and so it's just cheaper to redraw everything than to perform                  // hit testing on a complex area' and then end up redrawing most everything anyway.                  const int ClippingThreshold = 15;                  if (sprites.Count <= ClippingThreshold)                  {                      foreach (ISprite sprite in sprites)                      {                          var invalidRect = OffsetRectangle(sprite.Region' translate);                          invalidRect.Size += new Size(1' 1);                          postUpdateInvalidRegion.Union(invalidRect);                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              postUpdateInvalidRegion.Union(                                  OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate));                      }                      postUpdateInvalidRegion.Intersect(OffsetRectangle(DisplayBounds' translate));                  }                  else                  {                      postUpdateInvalidRegion.Union(OffsetRectangle(DisplayBounds' translate));                  }                    // Determine the current clipping area required' and clear it of old graphics.                  form.BackgroundGraphics.SetClip(preUpdateInvalidRegion' CombineMode.Replace);                  form.BackgroundGraphics.Clear(Color.FromArgb(0));                    // Set the clipping area to the region we'll be drawing in for this frame.                  form.BackgroundGraphics.SetClip(postUpdateInvalidRegion' CombineMode.Replace);                    #region Show Clipping Region                  if (ShowClippingRegion)                  {                      // Get the clipping region as a series of non-overlapping rectangles.                      RectangleF[] invalidRectangles = postUpdateInvalidRegion.GetRegionScans(identityMatrix);                        // Display the clipping rectangles.                      foreach (RectangleF invalidRectangleF in invalidRectangles)                      {                          Rectangle invalidRectangle = new Rectangle(                              (int)invalidRectangleF.X' (int)invalidRectangleF.Y'                              (int)invalidRectangleF.Width - 1' (int)invalidRectangleF.Height - 1);                          form.BackgroundGraphics.DrawRectangle(Pens.Blue' invalidRectangle);                      }                  }                  #endregion                    // When rendering a large number of sprites' we will use multiple threads to improve the frame rate. When the number of                  // sprites is small we will render using only a single thread to reduce CPU by eliminating parallelization overhead.                  const int ParallelBlendingThreshold = 75;                  // Draw all the sprites.                  foreach (ISprite sprite in sprites)                  {                      // Draw the sprite image.                      var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                      if (imagePath != null)                      {                          var area = OffsetRectangle(sprite.Region' translate);                          var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' generatePair);                          var animation = sprite.FacingRight ? pair.Right : pair.Left;                          var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                          unsafe                          {                              backgroundData = form.GetBackgroundData();                          }                          if (frame.Image.Bitmap != null)                              form.BackgroundGraphics.DrawImage(frame.Image.Bitmap' area);                          else if (sprites.Count <= ParallelBlendingThreshold)                              AlphaBlend(frame.Image' area' animation.Mirror);                          else                              AlphaBlendParallel(frame.Image' area' animation.Mirror);                      }                        // Draw a speech bubble for a speaking sprite.                      ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                      if (speakingSprite != null && speakingSprite.SpeechText != null)                      {                          Rectangle bubble = OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate);                          form.BackgroundGraphics.FillRectangle(Brushes.White'                              bubble.X + 1' bubble.Y + 1' bubble.Width - 2' bubble.Height - 2);                          form.BackgroundGraphics.DrawRectangle(Pens.Black'                              bubble.X' bubble.Y' bubble.Width - 1' bubble.Height - 1);                          form.BackgroundGraphics.DrawString(speakingSprite.SpeechText' font' Brushes.Black' bubble.Location);                      }                  }                    #region Timings Graph                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Display a graph of frame times and garbage collections.                      Collector.DrawGraph(form.BackgroundGraphics);                        // Display how long this frame took.                      form.BackgroundGraphics.FillRectangle(Brushes.Black' timingsArea);                      form.BackgroundGraphics.DrawString(timingsInfo' font' Brushes.White' timingsArea.Left' timingsArea.Top);                  }                  #endregion              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The following statement contains a magic number: lock (spritesGuard)              {                  if (sprites == null)                      return;                    // Translation offset so the top-left of the form and drawing surface coincide.                  Size translate = new Size(-form.Left' -form.Top);                    // Save the invalid region from last frame.                  preUpdateInvalidRegion.MakeEmpty();                  preUpdateInvalidRegion.Union(postUpdateInvalidRegion);                    // Reset the post-update clipping region.                  postUpdateInvalidRegion.MakeEmpty();                    #region Timings Graph Area                  Rectangle timingsArea = Rectangle.Empty;                  string timingsInfo = null;                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Create info string.                      timingsInfo = "fps: " +                          Collector.FramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture) + "/" +                          Collector.AchievableFramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture);                      Size timingsSize = Size.Ceiling(form.BackgroundGraphics.MeasureString(timingsInfo' font));                        // Set location and get area of graph draw.                      Point offset = new Point(10' 10);                      Point graphLocation = new Point(offset.X' offset.Y + timingsSize.Height);                      Rectangle recorderGraphArea = Collector.SetGraphingAttributes(graphLocation' 150' 1' 1.5f);                      postUpdateInvalidRegion.Union(recorderGraphArea);                        // Set location of info string draw.                      timingsArea = new Rectangle(                          recorderGraphArea.Left' recorderGraphArea.Top - timingsSize.Height - 1'                          timingsSize.Width + 1' timingsSize.Height + 1);                      postUpdateInvalidRegion.Union(timingsArea);                  }                  #endregion                    // Determine and apply the clipping area' this is only beneficial when there are few sprites on screen. As more are added                  // the cost of hit testing that combined area becomes larger' and so it's just cheaper to redraw everything than to perform                  // hit testing on a complex area' and then end up redrawing most everything anyway.                  const int ClippingThreshold = 15;                  if (sprites.Count <= ClippingThreshold)                  {                      foreach (ISprite sprite in sprites)                      {                          var invalidRect = OffsetRectangle(sprite.Region' translate);                          invalidRect.Size += new Size(1' 1);                          postUpdateInvalidRegion.Union(invalidRect);                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              postUpdateInvalidRegion.Union(                                  OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate));                      }                      postUpdateInvalidRegion.Intersect(OffsetRectangle(DisplayBounds' translate));                  }                  else                  {                      postUpdateInvalidRegion.Union(OffsetRectangle(DisplayBounds' translate));                  }                    // Determine the current clipping area required' and clear it of old graphics.                  form.BackgroundGraphics.SetClip(preUpdateInvalidRegion' CombineMode.Replace);                  form.BackgroundGraphics.Clear(Color.FromArgb(0));                    // Set the clipping area to the region we'll be drawing in for this frame.                  form.BackgroundGraphics.SetClip(postUpdateInvalidRegion' CombineMode.Replace);                    #region Show Clipping Region                  if (ShowClippingRegion)                  {                      // Get the clipping region as a series of non-overlapping rectangles.                      RectangleF[] invalidRectangles = postUpdateInvalidRegion.GetRegionScans(identityMatrix);                        // Display the clipping rectangles.                      foreach (RectangleF invalidRectangleF in invalidRectangles)                      {                          Rectangle invalidRectangle = new Rectangle(                              (int)invalidRectangleF.X' (int)invalidRectangleF.Y'                              (int)invalidRectangleF.Width - 1' (int)invalidRectangleF.Height - 1);                          form.BackgroundGraphics.DrawRectangle(Pens.Blue' invalidRectangle);                      }                  }                  #endregion                    // When rendering a large number of sprites' we will use multiple threads to improve the frame rate. When the number of                  // sprites is small we will render using only a single thread to reduce CPU by eliminating parallelization overhead.                  const int ParallelBlendingThreshold = 75;                  // Draw all the sprites.                  foreach (ISprite sprite in sprites)                  {                      // Draw the sprite image.                      var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                      if (imagePath != null)                      {                          var area = OffsetRectangle(sprite.Region' translate);                          var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' generatePair);                          var animation = sprite.FacingRight ? pair.Right : pair.Left;                          var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                          unsafe                          {                              backgroundData = form.GetBackgroundData();                          }                          if (frame.Image.Bitmap != null)                              form.BackgroundGraphics.DrawImage(frame.Image.Bitmap' area);                          else if (sprites.Count <= ParallelBlendingThreshold)                              AlphaBlend(frame.Image' area' animation.Mirror);                          else                              AlphaBlendParallel(frame.Image' area' animation.Mirror);                      }                        // Draw a speech bubble for a speaking sprite.                      ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                      if (speakingSprite != null && speakingSprite.SpeechText != null)                      {                          Rectangle bubble = OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate);                          form.BackgroundGraphics.FillRectangle(Brushes.White'                              bubble.X + 1' bubble.Y + 1' bubble.Width - 2' bubble.Height - 2);                          form.BackgroundGraphics.DrawRectangle(Pens.Black'                              bubble.X' bubble.Y' bubble.Width - 1' bubble.Height - 1);                          form.BackgroundGraphics.DrawString(speakingSprite.SpeechText' font' Brushes.Black' bubble.Location);                      }                  }                    #region Timings Graph                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Display a graph of frame times and garbage collections.                      Collector.DrawGraph(form.BackgroundGraphics);                        // Display how long this frame took.                      form.BackgroundGraphics.FillRectangle(Brushes.Black' timingsArea);                      form.BackgroundGraphics.DrawString(timingsInfo' font' Brushes.White' timingsArea.Left' timingsArea.Top);                  }                  #endregion              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The following statement contains a magic number: lock (spritesGuard)              {                  if (sprites == null)                      return;                    // Translation offset so the top-left of the form and drawing surface coincide.                  Size translate = new Size(-form.Left' -form.Top);                    // Save the invalid region from last frame.                  preUpdateInvalidRegion.MakeEmpty();                  preUpdateInvalidRegion.Union(postUpdateInvalidRegion);                    // Reset the post-update clipping region.                  postUpdateInvalidRegion.MakeEmpty();                    #region Timings Graph Area                  Rectangle timingsArea = Rectangle.Empty;                  string timingsInfo = null;                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Create info string.                      timingsInfo = "fps: " +                          Collector.FramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture) + "/" +                          Collector.AchievableFramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture);                      Size timingsSize = Size.Ceiling(form.BackgroundGraphics.MeasureString(timingsInfo' font));                        // Set location and get area of graph draw.                      Point offset = new Point(10' 10);                      Point graphLocation = new Point(offset.X' offset.Y + timingsSize.Height);                      Rectangle recorderGraphArea = Collector.SetGraphingAttributes(graphLocation' 150' 1' 1.5f);                      postUpdateInvalidRegion.Union(recorderGraphArea);                        // Set location of info string draw.                      timingsArea = new Rectangle(                          recorderGraphArea.Left' recorderGraphArea.Top - timingsSize.Height - 1'                          timingsSize.Width + 1' timingsSize.Height + 1);                      postUpdateInvalidRegion.Union(timingsArea);                  }                  #endregion                    // Determine and apply the clipping area' this is only beneficial when there are few sprites on screen. As more are added                  // the cost of hit testing that combined area becomes larger' and so it's just cheaper to redraw everything than to perform                  // hit testing on a complex area' and then end up redrawing most everything anyway.                  const int ClippingThreshold = 15;                  if (sprites.Count <= ClippingThreshold)                  {                      foreach (ISprite sprite in sprites)                      {                          var invalidRect = OffsetRectangle(sprite.Region' translate);                          invalidRect.Size += new Size(1' 1);                          postUpdateInvalidRegion.Union(invalidRect);                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              postUpdateInvalidRegion.Union(                                  OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate));                      }                      postUpdateInvalidRegion.Intersect(OffsetRectangle(DisplayBounds' translate));                  }                  else                  {                      postUpdateInvalidRegion.Union(OffsetRectangle(DisplayBounds' translate));                  }                    // Determine the current clipping area required' and clear it of old graphics.                  form.BackgroundGraphics.SetClip(preUpdateInvalidRegion' CombineMode.Replace);                  form.BackgroundGraphics.Clear(Color.FromArgb(0));                    // Set the clipping area to the region we'll be drawing in for this frame.                  form.BackgroundGraphics.SetClip(postUpdateInvalidRegion' CombineMode.Replace);                    #region Show Clipping Region                  if (ShowClippingRegion)                  {                      // Get the clipping region as a series of non-overlapping rectangles.                      RectangleF[] invalidRectangles = postUpdateInvalidRegion.GetRegionScans(identityMatrix);                        // Display the clipping rectangles.                      foreach (RectangleF invalidRectangleF in invalidRectangles)                      {                          Rectangle invalidRectangle = new Rectangle(                              (int)invalidRectangleF.X' (int)invalidRectangleF.Y'                              (int)invalidRectangleF.Width - 1' (int)invalidRectangleF.Height - 1);                          form.BackgroundGraphics.DrawRectangle(Pens.Blue' invalidRectangle);                      }                  }                  #endregion                    // When rendering a large number of sprites' we will use multiple threads to improve the frame rate. When the number of                  // sprites is small we will render using only a single thread to reduce CPU by eliminating parallelization overhead.                  const int ParallelBlendingThreshold = 75;                  // Draw all the sprites.                  foreach (ISprite sprite in sprites)                  {                      // Draw the sprite image.                      var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                      if (imagePath != null)                      {                          var area = OffsetRectangle(sprite.Region' translate);                          var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' generatePair);                          var animation = sprite.FacingRight ? pair.Right : pair.Left;                          var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                          unsafe                          {                              backgroundData = form.GetBackgroundData();                          }                          if (frame.Image.Bitmap != null)                              form.BackgroundGraphics.DrawImage(frame.Image.Bitmap' area);                          else if (sprites.Count <= ParallelBlendingThreshold)                              AlphaBlend(frame.Image' area' animation.Mirror);                          else                              AlphaBlendParallel(frame.Image' area' animation.Mirror);                      }                        // Draw a speech bubble for a speaking sprite.                      ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                      if (speakingSprite != null && speakingSprite.SpeechText != null)                      {                          Rectangle bubble = OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate);                          form.BackgroundGraphics.FillRectangle(Brushes.White'                              bubble.X + 1' bubble.Y + 1' bubble.Width - 2' bubble.Height - 2);                          form.BackgroundGraphics.DrawRectangle(Pens.Black'                              bubble.X' bubble.Y' bubble.Width - 1' bubble.Height - 1);                          form.BackgroundGraphics.DrawString(speakingSprite.SpeechText' font' Brushes.Black' bubble.Location);                      }                  }                    #region Timings Graph                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Display a graph of frame times and garbage collections.                      Collector.DrawGraph(form.BackgroundGraphics);                        // Display how long this frame took.                      form.BackgroundGraphics.FillRectangle(Brushes.Black' timingsArea);                      form.BackgroundGraphics.DrawString(timingsInfo' font' Brushes.White' timingsArea.Left' timingsArea.Top);                  }                  #endregion              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The following statement contains a magic number: lock (spritesGuard)              {                  if (sprites == null)                      return;                    // Translation offset so the top-left of the form and drawing surface coincide.                  Size translate = new Size(-form.Left' -form.Top);                    // Save the invalid region from last frame.                  preUpdateInvalidRegion.MakeEmpty();                  preUpdateInvalidRegion.Union(postUpdateInvalidRegion);                    // Reset the post-update clipping region.                  postUpdateInvalidRegion.MakeEmpty();                    #region Timings Graph Area                  Rectangle timingsArea = Rectangle.Empty;                  string timingsInfo = null;                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Create info string.                      timingsInfo = "fps: " +                          Collector.FramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture) + "/" +                          Collector.AchievableFramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture);                      Size timingsSize = Size.Ceiling(form.BackgroundGraphics.MeasureString(timingsInfo' font));                        // Set location and get area of graph draw.                      Point offset = new Point(10' 10);                      Point graphLocation = new Point(offset.X' offset.Y + timingsSize.Height);                      Rectangle recorderGraphArea = Collector.SetGraphingAttributes(graphLocation' 150' 1' 1.5f);                      postUpdateInvalidRegion.Union(recorderGraphArea);                        // Set location of info string draw.                      timingsArea = new Rectangle(                          recorderGraphArea.Left' recorderGraphArea.Top - timingsSize.Height - 1'                          timingsSize.Width + 1' timingsSize.Height + 1);                      postUpdateInvalidRegion.Union(timingsArea);                  }                  #endregion                    // Determine and apply the clipping area' this is only beneficial when there are few sprites on screen. As more are added                  // the cost of hit testing that combined area becomes larger' and so it's just cheaper to redraw everything than to perform                  // hit testing on a complex area' and then end up redrawing most everything anyway.                  const int ClippingThreshold = 15;                  if (sprites.Count <= ClippingThreshold)                  {                      foreach (ISprite sprite in sprites)                      {                          var invalidRect = OffsetRectangle(sprite.Region' translate);                          invalidRect.Size += new Size(1' 1);                          postUpdateInvalidRegion.Union(invalidRect);                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              postUpdateInvalidRegion.Union(                                  OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate));                      }                      postUpdateInvalidRegion.Intersect(OffsetRectangle(DisplayBounds' translate));                  }                  else                  {                      postUpdateInvalidRegion.Union(OffsetRectangle(DisplayBounds' translate));                  }                    // Determine the current clipping area required' and clear it of old graphics.                  form.BackgroundGraphics.SetClip(preUpdateInvalidRegion' CombineMode.Replace);                  form.BackgroundGraphics.Clear(Color.FromArgb(0));                    // Set the clipping area to the region we'll be drawing in for this frame.                  form.BackgroundGraphics.SetClip(postUpdateInvalidRegion' CombineMode.Replace);                    #region Show Clipping Region                  if (ShowClippingRegion)                  {                      // Get the clipping region as a series of non-overlapping rectangles.                      RectangleF[] invalidRectangles = postUpdateInvalidRegion.GetRegionScans(identityMatrix);                        // Display the clipping rectangles.                      foreach (RectangleF invalidRectangleF in invalidRectangles)                      {                          Rectangle invalidRectangle = new Rectangle(                              (int)invalidRectangleF.X' (int)invalidRectangleF.Y'                              (int)invalidRectangleF.Width - 1' (int)invalidRectangleF.Height - 1);                          form.BackgroundGraphics.DrawRectangle(Pens.Blue' invalidRectangle);                      }                  }                  #endregion                    // When rendering a large number of sprites' we will use multiple threads to improve the frame rate. When the number of                  // sprites is small we will render using only a single thread to reduce CPU by eliminating parallelization overhead.                  const int ParallelBlendingThreshold = 75;                  // Draw all the sprites.                  foreach (ISprite sprite in sprites)                  {                      // Draw the sprite image.                      var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                      if (imagePath != null)                      {                          var area = OffsetRectangle(sprite.Region' translate);                          var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' generatePair);                          var animation = sprite.FacingRight ? pair.Right : pair.Left;                          var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                          unsafe                          {                              backgroundData = form.GetBackgroundData();                          }                          if (frame.Image.Bitmap != null)                              form.BackgroundGraphics.DrawImage(frame.Image.Bitmap' area);                          else if (sprites.Count <= ParallelBlendingThreshold)                              AlphaBlend(frame.Image' area' animation.Mirror);                          else                              AlphaBlendParallel(frame.Image' area' animation.Mirror);                      }                        // Draw a speech bubble for a speaking sprite.                      ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                      if (speakingSprite != null && speakingSprite.SpeechText != null)                      {                          Rectangle bubble = OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate);                          form.BackgroundGraphics.FillRectangle(Brushes.White'                              bubble.X + 1' bubble.Y + 1' bubble.Width - 2' bubble.Height - 2);                          form.BackgroundGraphics.DrawRectangle(Pens.Black'                              bubble.X' bubble.Y' bubble.Width - 1' bubble.Height - 1);                          form.BackgroundGraphics.DrawString(speakingSprite.SpeechText' font' Brushes.Black' bubble.Location);                      }                  }                    #region Timings Graph                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Display a graph of frame times and garbage collections.                      Collector.DrawGraph(form.BackgroundGraphics);                        // Display how long this frame took.                      form.BackgroundGraphics.FillRectangle(Brushes.Black' timingsArea);                      form.BackgroundGraphics.DrawString(timingsInfo' font' Brushes.White' timingsArea.Left' timingsArea.Top);                  }                  #endregion              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The following statement contains a magic number: lock (spritesGuard)              {                  if (sprites == null)                      return;                    // Translation offset so the top-left of the form and drawing surface coincide.                  Size translate = new Size(-form.Left' -form.Top);                    // Save the invalid region from last frame.                  preUpdateInvalidRegion.MakeEmpty();                  preUpdateInvalidRegion.Union(postUpdateInvalidRegion);                    // Reset the post-update clipping region.                  postUpdateInvalidRegion.MakeEmpty();                    #region Timings Graph Area                  Rectangle timingsArea = Rectangle.Empty;                  string timingsInfo = null;                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Create info string.                      timingsInfo = "fps: " +                          Collector.FramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture) + "/" +                          Collector.AchievableFramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture);                      Size timingsSize = Size.Ceiling(form.BackgroundGraphics.MeasureString(timingsInfo' font));                        // Set location and get area of graph draw.                      Point offset = new Point(10' 10);                      Point graphLocation = new Point(offset.X' offset.Y + timingsSize.Height);                      Rectangle recorderGraphArea = Collector.SetGraphingAttributes(graphLocation' 150' 1' 1.5f);                      postUpdateInvalidRegion.Union(recorderGraphArea);                        // Set location of info string draw.                      timingsArea = new Rectangle(                          recorderGraphArea.Left' recorderGraphArea.Top - timingsSize.Height - 1'                          timingsSize.Width + 1' timingsSize.Height + 1);                      postUpdateInvalidRegion.Union(timingsArea);                  }                  #endregion                    // Determine and apply the clipping area' this is only beneficial when there are few sprites on screen. As more are added                  // the cost of hit testing that combined area becomes larger' and so it's just cheaper to redraw everything than to perform                  // hit testing on a complex area' and then end up redrawing most everything anyway.                  const int ClippingThreshold = 15;                  if (sprites.Count <= ClippingThreshold)                  {                      foreach (ISprite sprite in sprites)                      {                          var invalidRect = OffsetRectangle(sprite.Region' translate);                          invalidRect.Size += new Size(1' 1);                          postUpdateInvalidRegion.Union(invalidRect);                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              postUpdateInvalidRegion.Union(                                  OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate));                      }                      postUpdateInvalidRegion.Intersect(OffsetRectangle(DisplayBounds' translate));                  }                  else                  {                      postUpdateInvalidRegion.Union(OffsetRectangle(DisplayBounds' translate));                  }                    // Determine the current clipping area required' and clear it of old graphics.                  form.BackgroundGraphics.SetClip(preUpdateInvalidRegion' CombineMode.Replace);                  form.BackgroundGraphics.Clear(Color.FromArgb(0));                    // Set the clipping area to the region we'll be drawing in for this frame.                  form.BackgroundGraphics.SetClip(postUpdateInvalidRegion' CombineMode.Replace);                    #region Show Clipping Region                  if (ShowClippingRegion)                  {                      // Get the clipping region as a series of non-overlapping rectangles.                      RectangleF[] invalidRectangles = postUpdateInvalidRegion.GetRegionScans(identityMatrix);                        // Display the clipping rectangles.                      foreach (RectangleF invalidRectangleF in invalidRectangles)                      {                          Rectangle invalidRectangle = new Rectangle(                              (int)invalidRectangleF.X' (int)invalidRectangleF.Y'                              (int)invalidRectangleF.Width - 1' (int)invalidRectangleF.Height - 1);                          form.BackgroundGraphics.DrawRectangle(Pens.Blue' invalidRectangle);                      }                  }                  #endregion                    // When rendering a large number of sprites' we will use multiple threads to improve the frame rate. When the number of                  // sprites is small we will render using only a single thread to reduce CPU by eliminating parallelization overhead.                  const int ParallelBlendingThreshold = 75;                  // Draw all the sprites.                  foreach (ISprite sprite in sprites)                  {                      // Draw the sprite image.                      var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                      if (imagePath != null)                      {                          var area = OffsetRectangle(sprite.Region' translate);                          var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' generatePair);                          var animation = sprite.FacingRight ? pair.Right : pair.Left;                          var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                          unsafe                          {                              backgroundData = form.GetBackgroundData();                          }                          if (frame.Image.Bitmap != null)                              form.BackgroundGraphics.DrawImage(frame.Image.Bitmap' area);                          else if (sprites.Count <= ParallelBlendingThreshold)                              AlphaBlend(frame.Image' area' animation.Mirror);                          else                              AlphaBlendParallel(frame.Image' area' animation.Mirror);                      }                        // Draw a speech bubble for a speaking sprite.                      ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                      if (speakingSprite != null && speakingSprite.SpeechText != null)                      {                          Rectangle bubble = OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate);                          form.BackgroundGraphics.FillRectangle(Brushes.White'                              bubble.X + 1' bubble.Y + 1' bubble.Width - 2' bubble.Height - 2);                          form.BackgroundGraphics.DrawRectangle(Pens.Black'                              bubble.X' bubble.Y' bubble.Width - 1' bubble.Height - 1);                          form.BackgroundGraphics.DrawString(speakingSprite.SpeechText' font' Brushes.Black' bubble.Location);                      }                  }                    #region Timings Graph                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Display a graph of frame times and garbage collections.                      Collector.DrawGraph(form.BackgroundGraphics);                        // Display how long this frame took.                      form.BackgroundGraphics.FillRectangle(Brushes.Black' timingsArea);                      form.BackgroundGraphics.DrawString(timingsInfo' font' Brushes.White' timingsArea.Left' timingsArea.Top);                  }                  #endregion              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The following statement contains a magic number: lock (spritesGuard)              {                  if (sprites == null)                      return;                    // Translation offset so the top-left of the form and drawing surface coincide.                  Size translate = new Size(-form.Left' -form.Top);                    // Save the invalid region from last frame.                  preUpdateInvalidRegion.MakeEmpty();                  preUpdateInvalidRegion.Union(postUpdateInvalidRegion);                    // Reset the post-update clipping region.                  postUpdateInvalidRegion.MakeEmpty();                    #region Timings Graph Area                  Rectangle timingsArea = Rectangle.Empty;                  string timingsInfo = null;                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Create info string.                      timingsInfo = "fps: " +                          Collector.FramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture) + "/" +                          Collector.AchievableFramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture);                      Size timingsSize = Size.Ceiling(form.BackgroundGraphics.MeasureString(timingsInfo' font));                        // Set location and get area of graph draw.                      Point offset = new Point(10' 10);                      Point graphLocation = new Point(offset.X' offset.Y + timingsSize.Height);                      Rectangle recorderGraphArea = Collector.SetGraphingAttributes(graphLocation' 150' 1' 1.5f);                      postUpdateInvalidRegion.Union(recorderGraphArea);                        // Set location of info string draw.                      timingsArea = new Rectangle(                          recorderGraphArea.Left' recorderGraphArea.Top - timingsSize.Height - 1'                          timingsSize.Width + 1' timingsSize.Height + 1);                      postUpdateInvalidRegion.Union(timingsArea);                  }                  #endregion                    // Determine and apply the clipping area' this is only beneficial when there are few sprites on screen. As more are added                  // the cost of hit testing that combined area becomes larger' and so it's just cheaper to redraw everything than to perform                  // hit testing on a complex area' and then end up redrawing most everything anyway.                  const int ClippingThreshold = 15;                  if (sprites.Count <= ClippingThreshold)                  {                      foreach (ISprite sprite in sprites)                      {                          var invalidRect = OffsetRectangle(sprite.Region' translate);                          invalidRect.Size += new Size(1' 1);                          postUpdateInvalidRegion.Union(invalidRect);                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              postUpdateInvalidRegion.Union(                                  OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate));                      }                      postUpdateInvalidRegion.Intersect(OffsetRectangle(DisplayBounds' translate));                  }                  else                  {                      postUpdateInvalidRegion.Union(OffsetRectangle(DisplayBounds' translate));                  }                    // Determine the current clipping area required' and clear it of old graphics.                  form.BackgroundGraphics.SetClip(preUpdateInvalidRegion' CombineMode.Replace);                  form.BackgroundGraphics.Clear(Color.FromArgb(0));                    // Set the clipping area to the region we'll be drawing in for this frame.                  form.BackgroundGraphics.SetClip(postUpdateInvalidRegion' CombineMode.Replace);                    #region Show Clipping Region                  if (ShowClippingRegion)                  {                      // Get the clipping region as a series of non-overlapping rectangles.                      RectangleF[] invalidRectangles = postUpdateInvalidRegion.GetRegionScans(identityMatrix);                        // Display the clipping rectangles.                      foreach (RectangleF invalidRectangleF in invalidRectangles)                      {                          Rectangle invalidRectangle = new Rectangle(                              (int)invalidRectangleF.X' (int)invalidRectangleF.Y'                              (int)invalidRectangleF.Width - 1' (int)invalidRectangleF.Height - 1);                          form.BackgroundGraphics.DrawRectangle(Pens.Blue' invalidRectangle);                      }                  }                  #endregion                    // When rendering a large number of sprites' we will use multiple threads to improve the frame rate. When the number of                  // sprites is small we will render using only a single thread to reduce CPU by eliminating parallelization overhead.                  const int ParallelBlendingThreshold = 75;                  // Draw all the sprites.                  foreach (ISprite sprite in sprites)                  {                      // Draw the sprite image.                      var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                      if (imagePath != null)                      {                          var area = OffsetRectangle(sprite.Region' translate);                          var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' generatePair);                          var animation = sprite.FacingRight ? pair.Right : pair.Left;                          var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                          unsafe                          {                              backgroundData = form.GetBackgroundData();                          }                          if (frame.Image.Bitmap != null)                              form.BackgroundGraphics.DrawImage(frame.Image.Bitmap' area);                          else if (sprites.Count <= ParallelBlendingThreshold)                              AlphaBlend(frame.Image' area' animation.Mirror);                          else                              AlphaBlendParallel(frame.Image' area' animation.Mirror);                      }                        // Draw a speech bubble for a speaking sprite.                      ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                      if (speakingSprite != null && speakingSprite.SpeechText != null)                      {                          Rectangle bubble = OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate);                          form.BackgroundGraphics.FillRectangle(Brushes.White'                              bubble.X + 1' bubble.Y + 1' bubble.Width - 2' bubble.Height - 2);                          form.BackgroundGraphics.DrawRectangle(Pens.Black'                              bubble.X' bubble.Y' bubble.Width - 1' bubble.Height - 1);                          form.BackgroundGraphics.DrawString(speakingSprite.SpeechText' font' Brushes.Black' bubble.Location);                      }                  }                    #region Timings Graph                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Display a graph of frame times and garbage collections.                      Collector.DrawGraph(form.BackgroundGraphics);                        // Display how long this frame took.                      form.BackgroundGraphics.FillRectangle(Brushes.Black' timingsArea);                      form.BackgroundGraphics.DrawString(timingsInfo' font' Brushes.White' timingsArea.Left' timingsArea.Top);                  }                  #endregion              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,Render,The following statement contains a magic number: lock (spritesGuard)              {                  if (sprites == null)                      return;                    // Translation offset so the top-left of the form and drawing surface coincide.                  Size translate = new Size(-form.Left' -form.Top);                    // Save the invalid region from last frame.                  preUpdateInvalidRegion.MakeEmpty();                  preUpdateInvalidRegion.Union(postUpdateInvalidRegion);                    // Reset the post-update clipping region.                  postUpdateInvalidRegion.MakeEmpty();                    #region Timings Graph Area                  Rectangle timingsArea = Rectangle.Empty;                  string timingsInfo = null;                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Create info string.                      timingsInfo = "fps: " +                          Collector.FramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture) + "/" +                          Collector.AchievableFramesPerSecond.ToString("0.0"' System.Globalization.CultureInfo.CurrentCulture);                      Size timingsSize = Size.Ceiling(form.BackgroundGraphics.MeasureString(timingsInfo' font));                        // Set location and get area of graph draw.                      Point offset = new Point(10' 10);                      Point graphLocation = new Point(offset.X' offset.Y + timingsSize.Height);                      Rectangle recorderGraphArea = Collector.SetGraphingAttributes(graphLocation' 150' 1' 1.5f);                      postUpdateInvalidRegion.Union(recorderGraphArea);                        // Set location of info string draw.                      timingsArea = new Rectangle(                          recorderGraphArea.Left' recorderGraphArea.Top - timingsSize.Height - 1'                          timingsSize.Width + 1' timingsSize.Height + 1);                      postUpdateInvalidRegion.Union(timingsArea);                  }                  #endregion                    // Determine and apply the clipping area' this is only beneficial when there are few sprites on screen. As more are added                  // the cost of hit testing that combined area becomes larger' and so it's just cheaper to redraw everything than to perform                  // hit testing on a complex area' and then end up redrawing most everything anyway.                  const int ClippingThreshold = 15;                  if (sprites.Count <= ClippingThreshold)                  {                      foreach (ISprite sprite in sprites)                      {                          var invalidRect = OffsetRectangle(sprite.Region' translate);                          invalidRect.Size += new Size(1' 1);                          postUpdateInvalidRegion.Union(invalidRect);                          ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                          if (speakingSprite != null && speakingSprite.SpeechText != null)                              postUpdateInvalidRegion.Union(                                  OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate));                      }                      postUpdateInvalidRegion.Intersect(OffsetRectangle(DisplayBounds' translate));                  }                  else                  {                      postUpdateInvalidRegion.Union(OffsetRectangle(DisplayBounds' translate));                  }                    // Determine the current clipping area required' and clear it of old graphics.                  form.BackgroundGraphics.SetClip(preUpdateInvalidRegion' CombineMode.Replace);                  form.BackgroundGraphics.Clear(Color.FromArgb(0));                    // Set the clipping area to the region we'll be drawing in for this frame.                  form.BackgroundGraphics.SetClip(postUpdateInvalidRegion' CombineMode.Replace);                    #region Show Clipping Region                  if (ShowClippingRegion)                  {                      // Get the clipping region as a series of non-overlapping rectangles.                      RectangleF[] invalidRectangles = postUpdateInvalidRegion.GetRegionScans(identityMatrix);                        // Display the clipping rectangles.                      foreach (RectangleF invalidRectangleF in invalidRectangles)                      {                          Rectangle invalidRectangle = new Rectangle(                              (int)invalidRectangleF.X' (int)invalidRectangleF.Y'                              (int)invalidRectangleF.Width - 1' (int)invalidRectangleF.Height - 1);                          form.BackgroundGraphics.DrawRectangle(Pens.Blue' invalidRectangle);                      }                  }                  #endregion                    // When rendering a large number of sprites' we will use multiple threads to improve the frame rate. When the number of                  // sprites is small we will render using only a single thread to reduce CPU by eliminating parallelization overhead.                  const int ParallelBlendingThreshold = 75;                  // Draw all the sprites.                  foreach (ISprite sprite in sprites)                  {                      // Draw the sprite image.                      var imagePath = sprite.FacingRight ? sprite.ImagePaths.Right : sprite.ImagePaths.Left;                      if (imagePath != null)                      {                          var area = OffsetRectangle(sprite.Region' translate);                          var pair = animationPairsByPaths.GetOrAdd(sprite.ImagePaths' generatePair);                          var animation = sprite.FacingRight ? pair.Right : pair.Left;                          var frame = animation.Image[sprite.ImageTimeIndex' sprite.PreventAnimationLoop];                          unsafe                          {                              backgroundData = form.GetBackgroundData();                          }                          if (frame.Image.Bitmap != null)                              form.BackgroundGraphics.DrawImage(frame.Image.Bitmap' area);                          else if (sprites.Count <= ParallelBlendingThreshold)                              AlphaBlend(frame.Image' area' animation.Mirror);                          else                              AlphaBlendParallel(frame.Image' area' animation.Mirror);                      }                        // Draw a speech bubble for a speaking sprite.                      ISpeakingSprite speakingSprite = sprite as ISpeakingSprite;                      if (speakingSprite != null && speakingSprite.SpeechText != null)                      {                          Rectangle bubble = OffsetRectangle(GetSpeechBubbleRegion(speakingSprite' form.BackgroundGraphics)' translate);                          form.BackgroundGraphics.FillRectangle(Brushes.White'                              bubble.X + 1' bubble.Y + 1' bubble.Width - 2' bubble.Height - 2);                          form.BackgroundGraphics.DrawRectangle(Pens.Black'                              bubble.X' bubble.Y' bubble.Width - 1' bubble.Height - 1);                          form.BackgroundGraphics.DrawString(speakingSprite.SpeechText' font' Brushes.Black' bubble.Location);                      }                  }                    #region Timings Graph                  if (Collector != null && ShowPerformanceGraph && Collector.Count != 0)                  {                      // Display a graph of frame times and garbage collections.                      Collector.DrawGraph(form.BackgroundGraphics);                        // Display how long this frame took.                      form.BackgroundGraphics.FillRectangle(Brushes.Black' timingsArea);                      form.BackgroundGraphics.DrawString(timingsInfo' font' Brushes.White' timingsArea.Left' timingsArea.Top);                  }                  #endregion              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend,The following statement contains a magic number: if (image.Width == area.Width && image.Height == area.Height)              {                  if (image.Depth == 8)                      AlphaBlend8bbpUnscaled(image' area.Location' mirror' section' sectionCount);                  else                      AlphaBlend4bbpUnscaled(image' area.Location' mirror' section' sectionCount);              }              else              {                  if (image.Depth == 8)                      AlphaBlend8bbp(image' area' mirror' section' sectionCount);                  else                      AlphaBlend4bbp(image' area' mirror' section' sectionCount);              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend,The following statement contains a magic number: if (image.Width == area.Width && image.Height == area.Height)              {                  if (image.Depth == 8)                      AlphaBlend8bbpUnscaled(image' area.Location' mirror' section' sectionCount);                  else                      AlphaBlend4bbpUnscaled(image' area.Location' mirror' section' sectionCount);              }              else              {                  if (image.Depth == 8)                      AlphaBlend8bbp(image' area' mirror' section' sectionCount);                  else                      AlphaBlend4bbp(image' area' mirror' section' sectionCount);              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendScalingInitialize,The following statement contains a magic number: xShift = Math.Min((int)Math.Log(int.MaxValue / (xScale * xMax)' 2)' 30);
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendScalingInitialize,The following statement contains a magic number: xShift = Math.Min((int)Math.Log(int.MaxValue / (xScale * xMax)' 2)' 30);
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendScalingInitialize,The following statement contains a magic number: yShift = Math.Min((int)Math.Log(int.MaxValue / (yScale * yMax)' 2)' 30);
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendScalingInitialize,The following statement contains a magic number: yShift = Math.Min((int)Math.Log(int.MaxValue / (yScale * yMax)' 2)' 30);
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend8bbpUnscaled,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  for (int x = xMin; x < xMax; x++)                  {                      byte paletteIndex = data[dataIndex + x];                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataIndex += dataIndexRowChange;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbpUnscaled,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  for (int x = xMin; x < xMax; x++)                  {                      byte paletteIndexes = data[dataIndex + x / 2];                      int paletteIndex;                      if (x % 2 == 0)                          paletteIndex = paletteIndexes >> 4;                      else                          paletteIndex = paletteIndexes & 0xF;                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataIndex += dataIndexRowChange;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbpUnscaled,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  for (int x = xMin; x < xMax; x++)                  {                      byte paletteIndexes = data[dataIndex + x / 2];                      int paletteIndex;                      if (x % 2 == 0)                          paletteIndex = paletteIndexes >> 4;                      else                          paletteIndex = paletteIndexes & 0xF;                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataIndex += dataIndexRowChange;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbpUnscaled,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  for (int x = xMin; x < xMax; x++)                  {                      byte paletteIndexes = data[dataIndex + x / 2];                      int paletteIndex;                      if (x % 2 == 0)                          paletteIndex = paletteIndexes >> 4;                      else                          paletteIndex = paletteIndexes & 0xF;                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataIndex += dataIndexRowChange;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbpUnscaled,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  for (int x = xMin; x < xMax; x++)                  {                      byte paletteIndexes = data[dataIndex + x / 2];                      int paletteIndex;                      if (x % 2 == 0)                          paletteIndex = paletteIndexes >> 4;                      else                          paletteIndex = paletteIndexes & 0xF;                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataIndex += dataIndexRowChange;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend8bbp,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  int dataRowIndex = (dataRowIndexFixedPoint >> yShift) * imageStride;                  int dataColumnIndexFixedPoint = dataColumnIndexFixedPointInitial;                  for (int x = xMin; x < xMax; x++)                  {                      int dataIndex = dataRowIndex + (dataColumnIndexFixedPoint >> xShift);                      dataColumnIndexFixedPoint += xScaleFixedPoint;                      byte paletteIndex = data[dataIndex];                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataRowIndexFixedPoint += yScaleFixedPoint;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbp,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  int dataRowIndex = (dataRowIndexFixedPoint >> yShift) * imageStride;                  int dataColumnIndexFixedPoint = dataColumnIndexFixedPointInitial;                  for (int x = xMin; x < xMax; x++)                  {                      int dataColumnIndex = dataColumnIndexFixedPoint >> xShift;                      dataColumnIndexFixedPoint += xScaleFixedPoint;                      int dataIndex = dataRowIndex + dataColumnIndex / 2;                      byte paletteIndexes = data[dataIndex];                      int paletteIndex;                      if (dataColumnIndex % 2 == 0)                          paletteIndex = paletteIndexes >> 4;                      else                          paletteIndex = paletteIndexes & 0xF;                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataRowIndexFixedPoint += yScaleFixedPoint;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbp,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  int dataRowIndex = (dataRowIndexFixedPoint >> yShift) * imageStride;                  int dataColumnIndexFixedPoint = dataColumnIndexFixedPointInitial;                  for (int x = xMin; x < xMax; x++)                  {                      int dataColumnIndex = dataColumnIndexFixedPoint >> xShift;                      dataColumnIndexFixedPoint += xScaleFixedPoint;                      int dataIndex = dataRowIndex + dataColumnIndex / 2;                      byte paletteIndexes = data[dataIndex];                      int paletteIndex;                      if (dataColumnIndex % 2 == 0)                          paletteIndex = paletteIndexes >> 4;                      else                          paletteIndex = paletteIndexes & 0xF;                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataRowIndexFixedPoint += yScaleFixedPoint;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbp,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  int dataRowIndex = (dataRowIndexFixedPoint >> yShift) * imageStride;                  int dataColumnIndexFixedPoint = dataColumnIndexFixedPointInitial;                  for (int x = xMin; x < xMax; x++)                  {                      int dataColumnIndex = dataColumnIndexFixedPoint >> xShift;                      dataColumnIndexFixedPoint += xScaleFixedPoint;                      int dataIndex = dataRowIndex + dataColumnIndex / 2;                      byte paletteIndexes = data[dataIndex];                      int paletteIndex;                      if (dataColumnIndex % 2 == 0)                          paletteIndex = paletteIndexes >> 4;                      else                          paletteIndex = paletteIndexes & 0xF;                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataRowIndexFixedPoint += yScaleFixedPoint;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlend4bbp,The following statement contains a magic number: for (int y = yMin; y < yMax; y++)              {                  int dataRowIndex = (dataRowIndexFixedPoint >> yShift) * imageStride;                  int dataColumnIndexFixedPoint = dataColumnIndexFixedPointInitial;                  for (int x = xMin; x < xMax; x++)                  {                      int dataColumnIndex = dataColumnIndexFixedPoint >> xShift;                      dataColumnIndexFixedPoint += xScaleFixedPoint;                      int dataIndex = dataRowIndex + dataColumnIndex / 2;                      byte paletteIndexes = data[dataIndex];                      int paletteIndex;                      if (dataColumnIndex % 2 == 0)                          paletteIndex = paletteIndexes >> 4;                      else                          paletteIndex = paletteIndexes & 0xF;                      int srcColor = palette[paletteIndex];                      int srcAlpha = (srcColor >> 24) & 0xFF;                      if (srcAlpha == byte.MaxValue)                          backgroundData[backgroundIndex] = srcColor;                      else if (srcAlpha > 0)                          AlphaBlendPixel(backgroundIndex' srcColor' srcAlpha);                      backgroundIndex += backgroundIndexChange;                  }                  backgroundIndex += backgroundIndexRowChange;                  dataRowIndexFixedPoint += yScaleFixedPoint;              }
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendPixel,The following statement contains a magic number: int dstAG = ((dstColor >> 8) & 0x00FF00FF) * inverseSrcAlpha;
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,AlphaBlendPixel,The following statement contains a magic number: backgroundData[backgroundIndex] =                  srcColor +                  ((dstRB >> 8) & 0x00FF00FF) +                  (dstAG & unchecked((int)0xFF00FF00));
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,GetSpeechBubbleRegion,The following statement contains a magic number: Point location = new Point(                  speakingSprite.Region.X + speakingSprite.Region.Width / 2 - speechSize.Width / 2 - 1'                  speakingSprite.Region.Y - speechSize.Height - 1);
Magic Number,DesktopSprites.SpriteManagement,WinFormSpriteInterface,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,GetSpeechBubbleRegion,The following statement contains a magic number: Point location = new Point(                  speakingSprite.Region.X + speakingSprite.Region.Width / 2 - speechSize.Width / 2 - 1'                  speakingSprite.Region.Y - speechSize.Height - 1);
Magic Number,DesktopSprites.SpriteManagement,ImageData,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,ImageData,The following statement contains a magic number: for (int i = 0; i < ArgbPalette.Length; i++)                      ArgbPalette[i] = new ArgbColor(255' palette[i]).ToArgb();
Magic Number,DesktopSprites.SpriteManagement,ArgbPaletteEqualityComparer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,GetHashCode,The following statement contains a magic number: const int OffsetBasis32 = unchecked((int)2166136261);
Magic Number,DesktopSprites.SpriteManagement,ArgbPaletteEqualityComparer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,GetHashCode,The following statement contains a magic number: const int FnvPrime32 = 16777619;
Magic Number,DesktopSprites.SpriteManagement,ArgbPaletteEqualityComparer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,GetHashCode,The following statement contains a magic number: foreach (int i in obj)                  {                      hash ^= (i >> 24) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 16) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 8) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 0) & 0xFF;                      hash *= FnvPrime32;                  }
Magic Number,DesktopSprites.SpriteManagement,ArgbPaletteEqualityComparer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,GetHashCode,The following statement contains a magic number: foreach (int i in obj)                  {                      hash ^= (i >> 24) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 16) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 8) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 0) & 0xFF;                      hash *= FnvPrime32;                  }
Magic Number,DesktopSprites.SpriteManagement,ArgbPaletteEqualityComparer,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\WinFormSpriteInterface.cs,GetHashCode,The following statement contains a magic number: foreach (int i in obj)                  {                      hash ^= (i >> 24) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 16) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 8) & 0xFF;                      hash *= FnvPrime32;                      hash ^= (i >> 0) & 0xFF;                      hash *= FnvPrime32;                  }
Missing Default,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ReadImageData,The following switch statement is missing a default case: switch (dictionary.ProcessCode(code' pixelStack' ref stackIndex))                  {                      case LzwDictionary.Result.EndOfInformation:                          subframeComplete = true;                          break;                      case LzwDictionary.Result.Cleared:                          codeSize = lzwMinimumCodeSize + 1;                          codeMask = (1 << codeSize) - 1;                          break;                      case LzwDictionary.Result.FirstCode:                          continue;                      case LzwDictionary.Result.PushedCodeword:                          // Increase the code size if the number of available codes now exceeds the number addressable by the current size.                          if (dictionary.Available < MaxCodeWords && (dictionary.Available & codeMask) == 0)                          {                              codeSize++;                              codeMask += dictionary.Available;                          }                          break;                  }
Missing Default,DesktopSprites.SpriteManagement,GifDecoder<T>,C:\repos\RoosterDragon_Desktop-Ponies\Desktop Sprites\SpriteManagement\GifImage.cs,ApplyStackToFrame,The following switch statement is missing a default case: switch (interlacePass)                              {                                  case 2:                                      top = 4;                                      break;                                  case 3:                                      top = 2;                                      yIncrement = 4;                                      break;                                  case 4:                                      top = 1;                                      yIncrement = 2;                                      break;                                  case 5:                                      return true;                              }
