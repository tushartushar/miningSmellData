Implementation smell,Namespace,Class,File,Method,Description
Long Method,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The method has 175 lines of code.
Long Method,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The method has 130 lines of code.
Complex Method,Lucene.Net.Facet,DrillDownQuery,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillDownQuery.cs,Rewrite,Cyclomatic complexity of the method is 10
Complex Method,Lucene.Net.Facet,DrillSidewaysQuery,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysQuery.cs,Equals,Cyclomatic complexity of the method is 12
Complex Method,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,Score,Cyclomatic complexity of the method is 12
Complex Method,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoQueryFirstScoring,Cyclomatic complexity of the method is 10
Complex Method,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,Cyclomatic complexity of the method is 23
Complex Method,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,Cyclomatic complexity of the method is 17
Complex Method,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,Build,Cyclomatic complexity of the method is 19
Complex Method,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessFacetFields,Cyclomatic complexity of the method is 10
Complex Method,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Facet,RandomSamplingFacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\RandomSamplingFacetsCollector.cs,CreateSample,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Facet.Range,DoubleRangeFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\DoubleRangeFacetCounts.cs,Count,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,Cyclomatic complexity of the method is 12
Complex Method,Lucene.Net.Facet.Range,Int64RangeFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeFacetCounts.cs,Count,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Facet.SortedSet,DefaultSortedSetDocValuesReaderState,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\DefaultSortedSetDocValuesReaderState.cs,DefaultSortedSetDocValuesReaderState,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,GetDim,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,Count,Cyclomatic complexity of the method is 15
Complex Method,Lucene.Net.Facet.Taxonomy,SingleTaxonomyFacets,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FloatTaxonomyFacets.cs,GetTopChildren,Cyclomatic complexity of the method is 12
Complex Method,Lucene.Net.Facet.Taxonomy,Int32TaxonomyFacets,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntTaxonomyFacets.cs,GetTopChildren,Cyclomatic complexity of the method is 12
Complex Method,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyReader.cs,DoOpenIfChanged,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Facet.Taxonomy.Directory,TaxonomyIndexArrays,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\TaxonomyIndexArrays.cs,InitParents,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Grow,Cyclomatic complexity of the method is 9
Long Parameter List,Lucene.Net.Facet,DrillSideways,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSideways.cs,Search,The method has 7 parameters.
Long Parameter List,Lucene.Net.Facet,DrillSidewaysQuery,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysQuery.cs,DrillSidewaysQuery,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DrillSidewaysScorer,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoQueryFirstScoring,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet,FacetResult,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetResult.cs,FacetResult,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet,FacetResult,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetResult.cs,FacetResult,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,Search,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,Search,The method has 6 parameters.
Long Parameter List,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,Search,The method has 8 parameters.
Long Parameter List,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,SearchAfter,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,SearchAfter,The method has 6 parameters.
Long Parameter List,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,SearchAfter,The method has 7 parameters.
Long Parameter List,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,SearchAfter,The method has 9 parameters.
Long Parameter List,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,DoSearch,The method has 9 parameters.
Long Parameter List,Lucene.Net.Facet.Range,DoubleRange,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\DoubleRange.cs,DoubleRange,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet.Range,DoubleRangeFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\DoubleRangeFacetCounts.cs,DoubleRangeFacetCounts,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet.Range,Int64Range,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRange.cs,Int64Range,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet.Range,Int64RangeFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeFacetCounts.cs,Int64RangeFacetCounts,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet.Taxonomy,PrintTaxonomyStats,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\PrintTaxonomyStats.cs,PrintAllChildren,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumValueSource,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumValueSource.cs,TaxonomyFacetSumValueSource,The method has 5 parameters.
Long Parameter List,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyReader.cs,DirectoryTaxonomyReader,The method has 5 parameters.
Long Statement,Lucene.Net.Facet,DrillSideways,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSideways.cs,Search,The length of the statement  "	DrillSidewaysQuery dsq = new DrillSidewaysQuery (baseQuery' drillDownCollector' drillSidewaysCollectors' drillDownQueries' ScoreSubDocsAtOnce ()); " is 146.
Long Statement,Lucene.Net.Facet,DrillSideways,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSideways.cs,Search,The length of the statement  "	return new DrillSidewaysResult (BuildFacetsResult (drillDownCollector' drillSidewaysCollectors' drillDownDims.Keys.ToArray ())' null); " is 134.
Long Statement,Lucene.Net.Facet,DrillSidewaysQuery,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysQuery.cs,Rewrite,The length of the statement  "		return new DrillSidewaysQuery (newQuery' drillDownCollector' drillSidewaysCollectors' drillDownQueries' scoreSubDocsAtOnce); " is 124.
Long Statement,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,Score,The length of the statement  "		//System.out.println("queryFirst: baseScorer=" + baseScorer + " disis.length=" + disis.length + " bits.length=" + bits.length); " is 127.
Long Statement,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The length of the statement  "						//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id")); " is 140.
Long Statement,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The length of the statement  "			//System.out.println("  collect doc=" + collectDocID + " main.freq=" + (counts[slot]-1) + " main.doc=" + collectDocID + " exactCount=" + numDims); " is 146.
Long Statement,Lucene.Net.Facet,FacetResult,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetResult.cs,Equals,The length of the statement  "	return Value.Equals (other2.Value) && ChildCount == other2.ChildCount && Arrays.Equals (LabelValues' other2.LabelValues); " is 121.
Long Statement,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,DoSearch,The length of the statement  "		throw new System.ArgumentException ("after.doc exceeds the number of documents in the reader: after.doc=" + after.Doc + " limit=" + limit); " is 139.
Long Statement,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,CheckSeen,The length of the statement  "		throw new System.ArgumentException ("dimension \"" + dim + "\" is not multiValued' but it appears more than once in this document"); " is 132.
Long Statement,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,Build,The length of the statement  "	IDictionary<string' IList<SortedSetDocValuesFacetField>> dvByField = new Dictionary<string' IList<SortedSetDocValuesFacetField>> (); " is 132.
Long Statement,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,Build,The length of the statement  "	IDictionary<string' IList<AssociationFacetField>> assocByField = new Dictionary<string' IList<AssociationFacetField>> (); " is 121.
Long Statement,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,Build,The length of the statement  "				throw new System.ArgumentException ("mixing incompatible types of AssocationFacetField (" + curType + " and " + type + ") in indexed field \"" + indexFieldName + "\"; use FacetsConfig to change the indexFieldName for each dimension"); " is 234.
Long Statement,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessFacetFields,The length of the statement  "				throw new System.ArgumentException ("dimension \"" + facetField.Dim + "\" is not hierarchical yet has " + facetField.Path.Length + " components"); " is 146.
Long Statement,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,CheckTaxoWriter,The length of the statement  "		throw new ThreadStateException ("a non-null ITaxonomyWriter must be provided when indexing FacetField or AssociationFacetField"); " is 129.
Long Statement,Lucene.Net.Facet,LabelAndValue,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\LabelAndValue.cs,ToString,The length of the statement  "	string valueString = (TypeOfValue == typeof(int)) ? Value.ToString ("0"' CultureInfo.InvariantCulture) : Value.ToString ("0.0#####"' CultureInfo.InvariantCulture); " is 163.
Long Statement,Lucene.Net.Facet.Range,DoubleRange,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\DoubleRange.cs,ToInt64Range,The length of the statement  "	return new Int64Range (Label' NumericUtils.DoubleToSortableInt64 (minIncl)' true' NumericUtils.DoubleToSortableInt64 (maxIncl)' true); " is 134.
Long Statement,Lucene.Net.Facet.Range,DoubleRangeFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\DoubleRangeFacetCounts.cs,Count,The length of the statement  "		longRanges [i] = new Int64Range (range.Label' NumericUtils.DoubleToSortableInt64 (range.minIncl)' true' NumericUtils.DoubleToSortableInt64 (range.maxIncl)' true); " is 162.
Long Statement,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Add,The length of the statement  "		//System.out.println("  cycle lo=" + lo + " hi=" + hi + " mid=" + mid + " boundary=" + boundaries[mid] + " to " + boundaries[mid+1]); " is 133.
Long Statement,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,Count,The length of the statement  "			throw new InvalidOperationException ("the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader"); " is 229.
Long Statement,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,Count,The length of the statement  "						//System.out.println("      segOrd=" + segOrd + " ord=" + term + " globalOrd=" + ordinalMap.getGlobalOrd(segOrd' term)); " is 120.
Long Statement,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,Count,The length of the statement  "						//System.out.println("    migrate segOrd=" + segOrd + " ord=" + ord + " globalOrd=" + ordinalMap.getGlobalOrd(segOrd' ord)); " is 124.
Long Statement,Lucene.Net.Facet.Taxonomy,CategoryPath,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\CategoryPath.cs,HasDelimiter,The length of the statement  "	throw new System.ArgumentException ("delimiter character '" + delimiter + "' (U+" + delimiter.ToString () + ") appears in path component \"" + offender + "\""); " is 160.
Long Statement,Lucene.Net.Facet.Taxonomy,FacetLabel,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FacetLabel.cs,CheckComponents,The length of the statement  "		throw new System.ArgumentException ("category path exceeds maximum allowed path length: max=" + MAX_CATEGORY_PATH_LENGTH + " len=" + len + " path=" + Arrays.ToString (Components).Substring (0' 30) + "..."); " is 206.
Long Statement,Lucene.Net.Facet.Taxonomy,SingleAssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FloatAssociationFacetField.cs,ToString,The length of the statement  "	return "FloatAssociationFacetField(dim=" + Dim + " path=" + Arrays.ToString (Path) + " value=" + BytesRefToSingle (Assoc).ToString ("0.0#####"' CultureInfo.InvariantCulture) + ")"; " is 180.
Long Statement,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,BytesRefToInt32,The length of the statement  "	return ((b.Bytes [b.Offset] & 0xFF) << 24) | ((b.Bytes [b.Offset + 1] & 0xFF) << 16) | ((b.Bytes [b.Offset + 2] & 0xFF) << 8) | (b.Bytes [b.Offset + 3] & 0xFF); " is 160.
Long Statement,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,ToString,The length of the statement  "	return "IntAssociationFacetField(dim=" + Dim + " path=" + Arrays.ToString (Path) + " value=" + BytesRefToInt32 (Assoc) + ")"; " is 125.
Long Statement,Lucene.Net.Facet.Taxonomy,PrintTaxonomyStats,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\PrintTaxonomyStats.cs,Main,The length of the statement  "		Console.WriteLine ("\nUsage: java -classpath ... org.apache.lucene.facet.util.PrintTaxonomyStats [-printTree] /path/to/taxononmy/index\n"); " is 139.
Long Statement,Lucene.Net.Facet.Taxonomy,PrintTaxonomyStats,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\PrintTaxonomyStats.cs,PrintStats,The length of the statement  "		@out.WriteLine ("/" + cp.Components [0] + ": " + numImmediateChildren + " immediate children; " + (1 + CountAllChildren (r' child)) + " total categories"); " is 155.
Long Statement,Lucene.Net.Facet.Taxonomy,SearcherTaxonomyManager,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\SearcherTaxonomyManager.cs,RefreshIfNeeded,The length of the statement  "			throw new InvalidOperationException ("DirectoryTaxonomyWriter.replaceTaxonomy was called' which is not allowed when using SearcherTaxonomyManager"); " is 148.
Long Statement,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The length of the statement  "				int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF); " is 147.
Long Statement,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The length of the statement  "				int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF); " is 149.
Long Statement,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The length of the statement  "				int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF); " is 147.
Long Statement,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The length of the statement  "				int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF); " is 149.
Long Statement,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyReader.cs,GetOrdinal,The length of the statement  "	DocsEnum docs = MultiFields.GetTermDocsEnum (indexReader' null' Consts.FULL' new BytesRef (FacetsConfig.PathToString (cp.Components' cp.Length))' 0); " is 149.
Long Statement,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,CreateIndexWriterConfig,The length of the statement  "	return (new IndexWriterConfig (LuceneVersion.LUCENE_48' null)).SetOpenMode (openMode).SetMergePolicy (new LogByteSizeMergePolicy ()); " is 133.
Long Statement,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,EnsureOpen,The length of the statement  "		throw new ObjectDisposedException (this.GetType ().GetTypeInfo ().FullName' "The taxonomy writer has already been closed"); " is 123.
Long Statement,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,PrepareCommit,The length of the statement  "		if (!indexWriter.CommitData.TryGetValue (INDEX_EPOCH' out epochStr) || epochStr == null || Convert.ToInt64 (epochStr' 16) != indexEpoch) { " is 138.
Long Statement,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,GetParent,The length of the statement  "	Debug.Assert (ordinal < parents.Length' "requested ordinal (" + ordinal + "); parents.length (" + parents.Length + ") !"); " is 122.
Long Statement,Lucene.Net.Facet.Taxonomy.Directory,TaxonomyIndexArrays,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\TaxonomyIndexArrays.cs,InitParents,The length of the statement  "	DocsAndPositionsEnum positions = MultiFields.GetTermPositionsEnum (reader' null' Consts.FIELD_PAYLOADS' Consts.PAYLOAD_PARENT_BYTES_REF' DocsAndPositionsFlags.PAYLOADS); " is 169.
Virtual Method Call from Constructor,Lucene.Net.Facet.Range,DoubleRangeFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\DoubleRangeFacetCounts.cs,DoubleRangeFacetCounts,The constructor "DoubleRangeFacetCounts" calls a virtual method "GetMatchingDocs".
Virtual Method Call from Constructor,Lucene.Net.Facet.Range,Int64RangeFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeFacetCounts.cs,Int64RangeFacetCounts,The constructor "Int64RangeFacetCounts" calls a virtual method "GetMatchingDocs".
Virtual Method Call from Constructor,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,SortedSetDocValuesFacetCounts,The constructor "SortedSetDocValuesFacetCounts" calls a virtual method "GetDocValues".
Virtual Method Call from Constructor,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,SortedSetDocValuesFacetCounts,The constructor "SortedSetDocValuesFacetCounts" calls a virtual method "GetMatchingDocs".
Virtual Method Call from Constructor,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,FastTaxonomyFacetCounts,The constructor "FastTaxonomyFacetCounts" calls a virtual method "GetMatchingDocs".
Virtual Method Call from Constructor,Lucene.Net.Facet.Taxonomy,TaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetCounts.cs,TaxonomyFacetCounts,The constructor "TaxonomyFacetCounts" calls a virtual method "GetMatchingDocs".
Virtual Method Call from Constructor,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,TaxonomyFacetSumSingleAssociations,The constructor "TaxonomyFacetSumSingleAssociations" calls a virtual method "GetMatchingDocs".
Virtual Method Call from Constructor,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,TaxonomyFacetSumInt32Associations,The constructor "TaxonomyFacetSumInt32Associations" calls a virtual method "GetMatchingDocs".
Virtual Method Call from Constructor,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumValueSource,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumValueSource.cs,TaxonomyFacetSumValueSource,The constructor "TaxonomyFacetSumValueSource" calls a virtual method "GetMatchingDocs".
Virtual Method Call from Constructor,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,DirectoryTaxonomyWriter,The constructor "DirectoryTaxonomyWriter" calls a virtual method "CreateIndexWriterConfig".
Virtual Method Call from Constructor,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,DirectoryTaxonomyWriter,The constructor "DirectoryTaxonomyWriter" calls a virtual method "OpenIndexWriter".
Virtual Method Call from Constructor,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,DirectoryTaxonomyWriter,The constructor "DirectoryTaxonomyWriter" calls a virtual method "AddCategory".
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,Score,The following statement contains a magic number: if (bitsUpto > 0 || scoreSubDocsAtOnce || baseQueryCost < drillDownCost / 10) {  	//System.out.println("queryFirst: baseScorer=" + baseScorer + " disis.length=" + disis.length + " bits.length=" + bits.length);  	DoQueryFirstScoring (collector' disis' sidewaysCollectors' bits' bitsSidewaysCollectors);  } else if (numDims > 1 && (dims [1].disi == null || dims [1].disi.GetCost () < baseQueryCost / 10)) {  	//System.out.println("drillDownAdvance");  	DoDrillDownAdvanceScoring (collector' disis' sidewaysCollectors);  } else {  	//System.out.println("union");  	DoUnionScoring (collector' disis' sidewaysCollectors);  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,Score,The following statement contains a magic number: if (bitsUpto > 0 || scoreSubDocsAtOnce || baseQueryCost < drillDownCost / 10) {  	//System.out.println("queryFirst: baseScorer=" + baseScorer + " disis.length=" + disis.length + " bits.length=" + bits.length);  	DoQueryFirstScoring (collector' disis' sidewaysCollectors' bits' bitsSidewaysCollectors);  } else if (numDims > 1 && (dims [1].disi == null || dims [1].disi.GetCost () < baseQueryCost / 10)) {  	//System.out.println("drillDownAdvance");  	DoDrillDownAdvanceScoring (collector' disis' sidewaysCollectors);  } else {  	//System.out.println("union");  	DoUnionScoring (collector' disis' sidewaysCollectors);  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,Score,The following statement contains a magic number: if (numDims > 1 && (dims [1].disi == null || dims [1].disi.GetCost () < baseQueryCost / 10)) {  	//System.out.println("drillDownAdvance");  	DoDrillDownAdvanceScoring (collector' disis' sidewaysCollectors);  } else {  	//System.out.println("union");  	DoUnionScoring (collector' disis' sidewaysCollectors);  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: while (true) {  	//if (DEBUG) {  	//  System.out.println("\ncycle nextChunkStart=" + nextChunkStart + " docIds[0]=" + docIDs[0]);  	//}  	// First dim:  	//if (DEBUG) {  	//  System.out.println("  dim0");  	//}  	DocIdSetIterator disi = disis [0];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] != docID) {  				seen.Set (slot);  				// Mark slot as valid:  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " id=" + context.reader().document(docID).get("id"));  				//}  				docIDs [slot] = docID;  				missingDims [slot] = 1;  				counts [slot] = 1;  			}  			docID = disi.NextDoc ();  		}  	}  	// Second dim:  	//if (DEBUG) {  	//  System.out.println("  dim1");  	//}  	disi = disis [1];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] != docID) {  				// Mark slot as valid:  				seen.Set (slot);  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  				//}  				docIDs [slot] = docID;  				missingDims [slot] = 0;  				counts [slot] = 1;  			} else {  				// TODO: single-valued dims will always be true  				// below; we could somehow specialize  				if (missingDims [slot] >= 1) {  					missingDims [slot] = 2;  					counts [slot] = 2;  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  					//}  				} else {  					counts [slot] = 1;  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  					//}  				}  			}  			docID = disi.NextDoc ();  		}  	}  	// After this we can "upgrade" to conjunction' because  	// any doc not seen by either dim 0 or dim 1 cannot be  	// a hit or a near miss:  	//if (DEBUG) {  	//  System.out.println("  baseScorer");  	//}  	// Fold in baseScorer' using advance:  	int filledCount = 0;  	int slot0 = 0;  	while (slot0 < CHUNK && (slot0 = seen.NextSetBit (slot0)) != -1) {  		int ddDocID = docIDs [slot0];  		Debug.Assert (ddDocID != -1);  		int baseDocID = baseScorer.DocID;  		if (baseDocID < ddDocID) {  			baseDocID = baseScorer.Advance (ddDocID);  		}  		if (baseDocID == ddDocID) {  			//if (DEBUG) {  			//  System.out.println("    keep docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));  			//}  			scores [slot0] = baseScorer.GetScore ();  			filledSlots [filledCount++] = slot0;  			counts [slot0]++;  		} else {  			//if (DEBUG) {  			//  System.out.println("    no docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));  			//}  			docIDs [slot0] = -1;  			// TODO: we could jump slot0 forward to the  			// baseDocID ... but we'd need to set docIDs for  			// intervening slots to -1  		}  		slot0++;  	}  	seen.Clear (0' CHUNK);  	if (filledCount == 0) {  		if (nextChunkStart >= maxDoc) {  			break;  		}  		nextChunkStart += CHUNK;  		continue;  	}  	// TODO: factor this out & share w/ union scorer'  	// except we start from dim=2 instead:  	for (int dim = 2; dim < numDims; dim++) {  		//if (DEBUG) {  		//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  		//}  		disi = disis [dim];  		if (disi != null) {  			int docID = disi.DocID;  			while (docID < nextChunkStart) {  				int slot = docID & MASK;  				if (docIDs [slot] == docID && counts [slot] >= dim) {  					// TODO: single-valued dims will always be true  					// below; we could somehow specialize  					if (missingDims [slot] >= dim) {  						//if (DEBUG) {  						//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  						//}  						missingDims [slot] = dim + 1;  						counts [slot] = dim + 2;  					} else {  						//if (DEBUG) {  						//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  						//}  						counts [slot] = dim + 1;  					}  				}  				// TODO: sometimes use advance?  				docID = disi.NextDoc ();  			}  		}  	}  	// Collect:  	//if (DEBUG) {  	//  System.out.println("  now collect: " + filledCount + " hits");  	//}  	for (int i = 0; i < filledCount; i++) {  		int slot = filledSlots [i];  		collectDocID = docIDs [slot];  		collectScore = scores [slot];  		//if (DEBUG) {  		//  System.out.println("    docID=" + docIDs[slot] + " count=" + counts[slot]);  		//}  		if (counts [slot] == 1 + numDims) {  			CollectHit (collector' sidewaysCollectors);  		} else if (counts [slot] == numDims) {  			CollectNearMiss (sidewaysCollectors [missingDims [slot]]);  		}  	}  	if (nextChunkStart >= maxDoc) {  		break;  	}  	nextChunkStart += CHUNK;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: while (true) {  	//if (DEBUG) {  	//  System.out.println("\ncycle nextChunkStart=" + nextChunkStart + " docIds[0]=" + docIDs[0]);  	//}  	// First dim:  	//if (DEBUG) {  	//  System.out.println("  dim0");  	//}  	DocIdSetIterator disi = disis [0];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] != docID) {  				seen.Set (slot);  				// Mark slot as valid:  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " id=" + context.reader().document(docID).get("id"));  				//}  				docIDs [slot] = docID;  				missingDims [slot] = 1;  				counts [slot] = 1;  			}  			docID = disi.NextDoc ();  		}  	}  	// Second dim:  	//if (DEBUG) {  	//  System.out.println("  dim1");  	//}  	disi = disis [1];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] != docID) {  				// Mark slot as valid:  				seen.Set (slot);  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  				//}  				docIDs [slot] = docID;  				missingDims [slot] = 0;  				counts [slot] = 1;  			} else {  				// TODO: single-valued dims will always be true  				// below; we could somehow specialize  				if (missingDims [slot] >= 1) {  					missingDims [slot] = 2;  					counts [slot] = 2;  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  					//}  				} else {  					counts [slot] = 1;  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  					//}  				}  			}  			docID = disi.NextDoc ();  		}  	}  	// After this we can "upgrade" to conjunction' because  	// any doc not seen by either dim 0 or dim 1 cannot be  	// a hit or a near miss:  	//if (DEBUG) {  	//  System.out.println("  baseScorer");  	//}  	// Fold in baseScorer' using advance:  	int filledCount = 0;  	int slot0 = 0;  	while (slot0 < CHUNK && (slot0 = seen.NextSetBit (slot0)) != -1) {  		int ddDocID = docIDs [slot0];  		Debug.Assert (ddDocID != -1);  		int baseDocID = baseScorer.DocID;  		if (baseDocID < ddDocID) {  			baseDocID = baseScorer.Advance (ddDocID);  		}  		if (baseDocID == ddDocID) {  			//if (DEBUG) {  			//  System.out.println("    keep docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));  			//}  			scores [slot0] = baseScorer.GetScore ();  			filledSlots [filledCount++] = slot0;  			counts [slot0]++;  		} else {  			//if (DEBUG) {  			//  System.out.println("    no docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));  			//}  			docIDs [slot0] = -1;  			// TODO: we could jump slot0 forward to the  			// baseDocID ... but we'd need to set docIDs for  			// intervening slots to -1  		}  		slot0++;  	}  	seen.Clear (0' CHUNK);  	if (filledCount == 0) {  		if (nextChunkStart >= maxDoc) {  			break;  		}  		nextChunkStart += CHUNK;  		continue;  	}  	// TODO: factor this out & share w/ union scorer'  	// except we start from dim=2 instead:  	for (int dim = 2; dim < numDims; dim++) {  		//if (DEBUG) {  		//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  		//}  		disi = disis [dim];  		if (disi != null) {  			int docID = disi.DocID;  			while (docID < nextChunkStart) {  				int slot = docID & MASK;  				if (docIDs [slot] == docID && counts [slot] >= dim) {  					// TODO: single-valued dims will always be true  					// below; we could somehow specialize  					if (missingDims [slot] >= dim) {  						//if (DEBUG) {  						//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  						//}  						missingDims [slot] = dim + 1;  						counts [slot] = dim + 2;  					} else {  						//if (DEBUG) {  						//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  						//}  						counts [slot] = dim + 1;  					}  				}  				// TODO: sometimes use advance?  				docID = disi.NextDoc ();  			}  		}  	}  	// Collect:  	//if (DEBUG) {  	//  System.out.println("  now collect: " + filledCount + " hits");  	//}  	for (int i = 0; i < filledCount; i++) {  		int slot = filledSlots [i];  		collectDocID = docIDs [slot];  		collectScore = scores [slot];  		//if (DEBUG) {  		//  System.out.println("    docID=" + docIDs[slot] + " count=" + counts[slot]);  		//}  		if (counts [slot] == 1 + numDims) {  			CollectHit (collector' sidewaysCollectors);  		} else if (counts [slot] == numDims) {  			CollectNearMiss (sidewaysCollectors [missingDims [slot]]);  		}  	}  	if (nextChunkStart >= maxDoc) {  		break;  	}  	nextChunkStart += CHUNK;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: while (true) {  	//if (DEBUG) {  	//  System.out.println("\ncycle nextChunkStart=" + nextChunkStart + " docIds[0]=" + docIDs[0]);  	//}  	// First dim:  	//if (DEBUG) {  	//  System.out.println("  dim0");  	//}  	DocIdSetIterator disi = disis [0];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] != docID) {  				seen.Set (slot);  				// Mark slot as valid:  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " id=" + context.reader().document(docID).get("id"));  				//}  				docIDs [slot] = docID;  				missingDims [slot] = 1;  				counts [slot] = 1;  			}  			docID = disi.NextDoc ();  		}  	}  	// Second dim:  	//if (DEBUG) {  	//  System.out.println("  dim1");  	//}  	disi = disis [1];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] != docID) {  				// Mark slot as valid:  				seen.Set (slot);  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  				//}  				docIDs [slot] = docID;  				missingDims [slot] = 0;  				counts [slot] = 1;  			} else {  				// TODO: single-valued dims will always be true  				// below; we could somehow specialize  				if (missingDims [slot] >= 1) {  					missingDims [slot] = 2;  					counts [slot] = 2;  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  					//}  				} else {  					counts [slot] = 1;  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  					//}  				}  			}  			docID = disi.NextDoc ();  		}  	}  	// After this we can "upgrade" to conjunction' because  	// any doc not seen by either dim 0 or dim 1 cannot be  	// a hit or a near miss:  	//if (DEBUG) {  	//  System.out.println("  baseScorer");  	//}  	// Fold in baseScorer' using advance:  	int filledCount = 0;  	int slot0 = 0;  	while (slot0 < CHUNK && (slot0 = seen.NextSetBit (slot0)) != -1) {  		int ddDocID = docIDs [slot0];  		Debug.Assert (ddDocID != -1);  		int baseDocID = baseScorer.DocID;  		if (baseDocID < ddDocID) {  			baseDocID = baseScorer.Advance (ddDocID);  		}  		if (baseDocID == ddDocID) {  			//if (DEBUG) {  			//  System.out.println("    keep docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));  			//}  			scores [slot0] = baseScorer.GetScore ();  			filledSlots [filledCount++] = slot0;  			counts [slot0]++;  		} else {  			//if (DEBUG) {  			//  System.out.println("    no docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));  			//}  			docIDs [slot0] = -1;  			// TODO: we could jump slot0 forward to the  			// baseDocID ... but we'd need to set docIDs for  			// intervening slots to -1  		}  		slot0++;  	}  	seen.Clear (0' CHUNK);  	if (filledCount == 0) {  		if (nextChunkStart >= maxDoc) {  			break;  		}  		nextChunkStart += CHUNK;  		continue;  	}  	// TODO: factor this out & share w/ union scorer'  	// except we start from dim=2 instead:  	for (int dim = 2; dim < numDims; dim++) {  		//if (DEBUG) {  		//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  		//}  		disi = disis [dim];  		if (disi != null) {  			int docID = disi.DocID;  			while (docID < nextChunkStart) {  				int slot = docID & MASK;  				if (docIDs [slot] == docID && counts [slot] >= dim) {  					// TODO: single-valued dims will always be true  					// below; we could somehow specialize  					if (missingDims [slot] >= dim) {  						//if (DEBUG) {  						//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  						//}  						missingDims [slot] = dim + 1;  						counts [slot] = dim + 2;  					} else {  						//if (DEBUG) {  						//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  						//}  						counts [slot] = dim + 1;  					}  				}  				// TODO: sometimes use advance?  				docID = disi.NextDoc ();  			}  		}  	}  	// Collect:  	//if (DEBUG) {  	//  System.out.println("  now collect: " + filledCount + " hits");  	//}  	for (int i = 0; i < filledCount; i++) {  		int slot = filledSlots [i];  		collectDocID = docIDs [slot];  		collectScore = scores [slot];  		//if (DEBUG) {  		//  System.out.println("    docID=" + docIDs[slot] + " count=" + counts[slot]);  		//}  		if (counts [slot] == 1 + numDims) {  			CollectHit (collector' sidewaysCollectors);  		} else if (counts [slot] == numDims) {  			CollectNearMiss (sidewaysCollectors [missingDims [slot]]);  		}  	}  	if (nextChunkStart >= maxDoc) {  		break;  	}  	nextChunkStart += CHUNK;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: while (true) {  	//if (DEBUG) {  	//  System.out.println("\ncycle nextChunkStart=" + nextChunkStart + " docIds[0]=" + docIDs[0]);  	//}  	// First dim:  	//if (DEBUG) {  	//  System.out.println("  dim0");  	//}  	DocIdSetIterator disi = disis [0];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] != docID) {  				seen.Set (slot);  				// Mark slot as valid:  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " id=" + context.reader().document(docID).get("id"));  				//}  				docIDs [slot] = docID;  				missingDims [slot] = 1;  				counts [slot] = 1;  			}  			docID = disi.NextDoc ();  		}  	}  	// Second dim:  	//if (DEBUG) {  	//  System.out.println("  dim1");  	//}  	disi = disis [1];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] != docID) {  				// Mark slot as valid:  				seen.Set (slot);  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  				//}  				docIDs [slot] = docID;  				missingDims [slot] = 0;  				counts [slot] = 1;  			} else {  				// TODO: single-valued dims will always be true  				// below; we could somehow specialize  				if (missingDims [slot] >= 1) {  					missingDims [slot] = 2;  					counts [slot] = 2;  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  					//}  				} else {  					counts [slot] = 1;  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  					//}  				}  			}  			docID = disi.NextDoc ();  		}  	}  	// After this we can "upgrade" to conjunction' because  	// any doc not seen by either dim 0 or dim 1 cannot be  	// a hit or a near miss:  	//if (DEBUG) {  	//  System.out.println("  baseScorer");  	//}  	// Fold in baseScorer' using advance:  	int filledCount = 0;  	int slot0 = 0;  	while (slot0 < CHUNK && (slot0 = seen.NextSetBit (slot0)) != -1) {  		int ddDocID = docIDs [slot0];  		Debug.Assert (ddDocID != -1);  		int baseDocID = baseScorer.DocID;  		if (baseDocID < ddDocID) {  			baseDocID = baseScorer.Advance (ddDocID);  		}  		if (baseDocID == ddDocID) {  			//if (DEBUG) {  			//  System.out.println("    keep docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));  			//}  			scores [slot0] = baseScorer.GetScore ();  			filledSlots [filledCount++] = slot0;  			counts [slot0]++;  		} else {  			//if (DEBUG) {  			//  System.out.println("    no docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));  			//}  			docIDs [slot0] = -1;  			// TODO: we could jump slot0 forward to the  			// baseDocID ... but we'd need to set docIDs for  			// intervening slots to -1  		}  		slot0++;  	}  	seen.Clear (0' CHUNK);  	if (filledCount == 0) {  		if (nextChunkStart >= maxDoc) {  			break;  		}  		nextChunkStart += CHUNK;  		continue;  	}  	// TODO: factor this out & share w/ union scorer'  	// except we start from dim=2 instead:  	for (int dim = 2; dim < numDims; dim++) {  		//if (DEBUG) {  		//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  		//}  		disi = disis [dim];  		if (disi != null) {  			int docID = disi.DocID;  			while (docID < nextChunkStart) {  				int slot = docID & MASK;  				if (docIDs [slot] == docID && counts [slot] >= dim) {  					// TODO: single-valued dims will always be true  					// below; we could somehow specialize  					if (missingDims [slot] >= dim) {  						//if (DEBUG) {  						//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  						//}  						missingDims [slot] = dim + 1;  						counts [slot] = dim + 2;  					} else {  						//if (DEBUG) {  						//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  						//}  						counts [slot] = dim + 1;  					}  				}  				// TODO: sometimes use advance?  				docID = disi.NextDoc ();  			}  		}  	}  	// Collect:  	//if (DEBUG) {  	//  System.out.println("  now collect: " + filledCount + " hits");  	//}  	for (int i = 0; i < filledCount; i++) {  		int slot = filledSlots [i];  		collectDocID = docIDs [slot];  		collectScore = scores [slot];  		//if (DEBUG) {  		//  System.out.println("    docID=" + docIDs[slot] + " count=" + counts[slot]);  		//}  		if (counts [slot] == 1 + numDims) {  			CollectHit (collector' sidewaysCollectors);  		} else if (counts [slot] == numDims) {  			CollectNearMiss (sidewaysCollectors [missingDims [slot]]);  		}  	}  	if (nextChunkStart >= maxDoc) {  		break;  	}  	nextChunkStart += CHUNK;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (disi != null) {  	int docID = disi.DocID;  	while (docID < nextChunkStart) {  		int slot = docID & MASK;  		if (docIDs [slot] != docID) {  			// Mark slot as valid:  			seen.Set (slot);  			//if (DEBUG) {  			//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  			//}  			docIDs [slot] = docID;  			missingDims [slot] = 0;  			counts [slot] = 1;  		} else {  			// TODO: single-valued dims will always be true  			// below; we could somehow specialize  			if (missingDims [slot] >= 1) {  				missingDims [slot] = 2;  				counts [slot] = 2;  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  				//}  			} else {  				counts [slot] = 1;  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  				//}  			}  		}  		docID = disi.NextDoc ();  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (disi != null) {  	int docID = disi.DocID;  	while (docID < nextChunkStart) {  		int slot = docID & MASK;  		if (docIDs [slot] != docID) {  			// Mark slot as valid:  			seen.Set (slot);  			//if (DEBUG) {  			//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  			//}  			docIDs [slot] = docID;  			missingDims [slot] = 0;  			counts [slot] = 1;  		} else {  			// TODO: single-valued dims will always be true  			// below; we could somehow specialize  			if (missingDims [slot] >= 1) {  				missingDims [slot] = 2;  				counts [slot] = 2;  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  				//}  			} else {  				counts [slot] = 1;  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  				//}  			}  		}  		docID = disi.NextDoc ();  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: while (docID < nextChunkStart) {  	int slot = docID & MASK;  	if (docIDs [slot] != docID) {  		// Mark slot as valid:  		seen.Set (slot);  		//if (DEBUG) {  		//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  		//}  		docIDs [slot] = docID;  		missingDims [slot] = 0;  		counts [slot] = 1;  	} else {  		// TODO: single-valued dims will always be true  		// below; we could somehow specialize  		if (missingDims [slot] >= 1) {  			missingDims [slot] = 2;  			counts [slot] = 2;  			//if (DEBUG) {  			//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  			//}  		} else {  			counts [slot] = 1;  			//if (DEBUG) {  			//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  			//}  		}  	}  	docID = disi.NextDoc ();  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: while (docID < nextChunkStart) {  	int slot = docID & MASK;  	if (docIDs [slot] != docID) {  		// Mark slot as valid:  		seen.Set (slot);  		//if (DEBUG) {  		//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  		//}  		docIDs [slot] = docID;  		missingDims [slot] = 0;  		counts [slot] = 1;  	} else {  		// TODO: single-valued dims will always be true  		// below; we could somehow specialize  		if (missingDims [slot] >= 1) {  			missingDims [slot] = 2;  			counts [slot] = 2;  			//if (DEBUG) {  			//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  			//}  		} else {  			counts [slot] = 1;  			//if (DEBUG) {  			//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  			//}  		}  	}  	docID = disi.NextDoc ();  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (docIDs [slot] != docID) {  	// Mark slot as valid:  	seen.Set (slot);  	//if (DEBUG) {  	//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  	//}  	docIDs [slot] = docID;  	missingDims [slot] = 0;  	counts [slot] = 1;  } else {  	// TODO: single-valued dims will always be true  	// below; we could somehow specialize  	if (missingDims [slot] >= 1) {  		missingDims [slot] = 2;  		counts [slot] = 2;  		//if (DEBUG) {  		//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  		//}  	} else {  		counts [slot] = 1;  		//if (DEBUG) {  		//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  		//}  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (docIDs [slot] != docID) {  	// Mark slot as valid:  	seen.Set (slot);  	//if (DEBUG) {  	//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));  	//}  	docIDs [slot] = docID;  	missingDims [slot] = 0;  	counts [slot] = 1;  } else {  	// TODO: single-valued dims will always be true  	// below; we could somehow specialize  	if (missingDims [slot] >= 1) {  		missingDims [slot] = 2;  		counts [slot] = 2;  		//if (DEBUG) {  		//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  		//}  	} else {  		counts [slot] = 1;  		//if (DEBUG) {  		//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  		//}  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (missingDims [slot] >= 1) {  	missingDims [slot] = 2;  	counts [slot] = 2;  	//if (DEBUG) {  	//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  	//}  } else {  	counts [slot] = 1;  	//if (DEBUG) {  	//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  	//}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (missingDims [slot] >= 1) {  	missingDims [slot] = 2;  	counts [slot] = 2;  	//if (DEBUG) {  	//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));  	//}  } else {  	counts [slot] = 1;  	//if (DEBUG) {  	//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));  	//}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: missingDims [slot] = 2;  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: counts [slot] = 2;  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: for (int dim = 2; dim < numDims; dim++) {  	//if (DEBUG) {  	//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  	//}  	disi = disis [dim];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] == docID && counts [slot] >= dim) {  				// TODO: single-valued dims will always be true  				// below; we could somehow specialize  				if (missingDims [slot] >= dim) {  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  					//}  					missingDims [slot] = dim + 1;  					counts [slot] = dim + 2;  				} else {  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  					//}  					counts [slot] = dim + 1;  				}  			}  			// TODO: sometimes use advance?  			docID = disi.NextDoc ();  		}  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: for (int dim = 2; dim < numDims; dim++) {  	//if (DEBUG) {  	//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  	//}  	disi = disis [dim];  	if (disi != null) {  		int docID = disi.DocID;  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] == docID && counts [slot] >= dim) {  				// TODO: single-valued dims will always be true  				// below; we could somehow specialize  				if (missingDims [slot] >= dim) {  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  					//}  					missingDims [slot] = dim + 1;  					counts [slot] = dim + 2;  				} else {  					//if (DEBUG) {  					//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  					//}  					counts [slot] = dim + 1;  				}  			}  			// TODO: sometimes use advance?  			docID = disi.NextDoc ();  		}  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (disi != null) {  	int docID = disi.DocID;  	while (docID < nextChunkStart) {  		int slot = docID & MASK;  		if (docIDs [slot] == docID && counts [slot] >= dim) {  			// TODO: single-valued dims will always be true  			// below; we could somehow specialize  			if (missingDims [slot] >= dim) {  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  				//}  				missingDims [slot] = dim + 1;  				counts [slot] = dim + 2;  			} else {  				//if (DEBUG) {  				//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  				//}  				counts [slot] = dim + 1;  			}  		}  		// TODO: sometimes use advance?  		docID = disi.NextDoc ();  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: while (docID < nextChunkStart) {  	int slot = docID & MASK;  	if (docIDs [slot] == docID && counts [slot] >= dim) {  		// TODO: single-valued dims will always be true  		// below; we could somehow specialize  		if (missingDims [slot] >= dim) {  			//if (DEBUG) {  			//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  			//}  			missingDims [slot] = dim + 1;  			counts [slot] = dim + 2;  		} else {  			//if (DEBUG) {  			//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  			//}  			counts [slot] = dim + 1;  		}  	}  	// TODO: sometimes use advance?  	docID = disi.NextDoc ();  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (docIDs [slot] == docID && counts [slot] >= dim) {  	// TODO: single-valued dims will always be true  	// below; we could somehow specialize  	if (missingDims [slot] >= dim) {  		//if (DEBUG) {  		//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  		//}  		missingDims [slot] = dim + 1;  		counts [slot] = dim + 2;  	} else {  		//if (DEBUG) {  		//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  		//}  		counts [slot] = dim + 1;  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: if (missingDims [slot] >= dim) {  	//if (DEBUG) {  	//  System.out.println("    set docID=" + docID + " count=" + (dim+2));  	//}  	missingDims [slot] = dim + 1;  	counts [slot] = dim + 2;  } else {  	//if (DEBUG) {  	//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));  	//}  	counts [slot] = dim + 1;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoDrillDownAdvanceScoring,The following statement contains a magic number: counts [slot] = dim + 2;  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: while (true) {  	//if (DEBUG) {  	//  System.out.println("\ncycle nextChunkStart=" + nextChunkStart + " docIds[0]=" + docIDs[0]);  	//}  	int filledCount = 0;  	int docID = baseScorer.DocID;  	//if (DEBUG) {  	//  System.out.println("  base docID=" + docID);  	//}  	while (docID < nextChunkStart) {  		int slot = docID & MASK;  		//if (DEBUG) {  		//  System.out.println("    docIDs[slot=" + slot + "]=" + docID + " id=" + context.reader().document(docID).get("id"));  		//}  		// Mark slot as valid:  		Debug.Assert (docIDs [slot] != docID' "slot=" + slot + " docID=" + docID);  		docIDs [slot] = docID;  		scores [slot] = baseScorer.GetScore ();  		filledSlots [filledCount++] = slot;  		missingDims [slot] = 0;  		counts [slot] = 1;  		docID = baseScorer.NextDoc ();  	}  	if (filledCount == 0) {  		if (nextChunkStart >= maxDoc) {  			break;  		}  		nextChunkStart += CHUNK;  		continue;  	}  	// First drill-down dim' basically adds SHOULD onto  	// the baseQuery:  	//if (DEBUG) {  	//  System.out.println("  dim=0 [" + dims[0].dim + "]");  	//}  	DocIdSetIterator disi = disis [0];  	if (disi != null) {  		docID = disi.DocID;  		//if (DEBUG) {  		//  System.out.println("    start docID=" + docID);  		//}  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] == docID) {  				//if (DEBUG) {  				//  System.out.println("      set docID=" + docID + " count=2");  				//}  				missingDims [slot] = 1;  				counts [slot] = 2;  			}  			docID = disi.NextDoc ();  		}  	}  	for (int dim = 1; dim < numDims; dim++) {  		//if (DEBUG) {  		//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  		//}  		disi = disis [dim];  		if (disi != null) {  			docID = disi.DocID;  			//if (DEBUG) {  			//  System.out.println("    start docID=" + docID);  			//}  			while (docID < nextChunkStart) {  				int slot = docID & MASK;  				if (docIDs [slot] == docID && counts [slot] >= dim) {  					// This doc is still in the running...  					// TODO: single-valued dims will always be true  					// below; we could somehow specialize  					if (missingDims [slot] >= dim) {  						//if (DEBUG) {  						//  System.out.println("      set docID=" + docID + " count=" + (dim+2));  						//}  						missingDims [slot] = dim + 1;  						counts [slot] = dim + 2;  					} else {  						//if (DEBUG) {  						//  System.out.println("      set docID=" + docID + " missing count=" + (dim+1));  						//}  						counts [slot] = dim + 1;  					}  				}  				docID = disi.NextDoc ();  			}  		}  	}  	// Collect:  	//System.out.println("  now collect: " + filledCount + " hits");  	for (int i = 0; i < filledCount; i++) {  		// NOTE: This is actually in-order collection'  		// because we only accept docs originally returned by  		// the baseScorer (ie that Scorer is AND'd)  		int slot = filledSlots [i];  		collectDocID = docIDs [slot];  		collectScore = scores [slot];  		//if (DEBUG) {  		//  System.out.println("    docID=" + docIDs[slot] + " count=" + counts[slot]);  		//}  		//System.out.println("  collect doc=" + collectDocID + " main.freq=" + (counts[slot]-1) + " main.doc=" + collectDocID + " exactCount=" + numDims);  		if (counts [slot] == 1 + numDims) {  			//System.out.println("    hit");  			CollectHit (collector' sidewaysCollectors);  		} else if (counts [slot] == numDims) {  			//System.out.println("    sw");  			CollectNearMiss (sidewaysCollectors [missingDims [slot]]);  		}  	}  	if (nextChunkStart >= maxDoc) {  		break;  	}  	nextChunkStart += CHUNK;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: while (true) {  	//if (DEBUG) {  	//  System.out.println("\ncycle nextChunkStart=" + nextChunkStart + " docIds[0]=" + docIDs[0]);  	//}  	int filledCount = 0;  	int docID = baseScorer.DocID;  	//if (DEBUG) {  	//  System.out.println("  base docID=" + docID);  	//}  	while (docID < nextChunkStart) {  		int slot = docID & MASK;  		//if (DEBUG) {  		//  System.out.println("    docIDs[slot=" + slot + "]=" + docID + " id=" + context.reader().document(docID).get("id"));  		//}  		// Mark slot as valid:  		Debug.Assert (docIDs [slot] != docID' "slot=" + slot + " docID=" + docID);  		docIDs [slot] = docID;  		scores [slot] = baseScorer.GetScore ();  		filledSlots [filledCount++] = slot;  		missingDims [slot] = 0;  		counts [slot] = 1;  		docID = baseScorer.NextDoc ();  	}  	if (filledCount == 0) {  		if (nextChunkStart >= maxDoc) {  			break;  		}  		nextChunkStart += CHUNK;  		continue;  	}  	// First drill-down dim' basically adds SHOULD onto  	// the baseQuery:  	//if (DEBUG) {  	//  System.out.println("  dim=0 [" + dims[0].dim + "]");  	//}  	DocIdSetIterator disi = disis [0];  	if (disi != null) {  		docID = disi.DocID;  		//if (DEBUG) {  		//  System.out.println("    start docID=" + docID);  		//}  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] == docID) {  				//if (DEBUG) {  				//  System.out.println("      set docID=" + docID + " count=2");  				//}  				missingDims [slot] = 1;  				counts [slot] = 2;  			}  			docID = disi.NextDoc ();  		}  	}  	for (int dim = 1; dim < numDims; dim++) {  		//if (DEBUG) {  		//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  		//}  		disi = disis [dim];  		if (disi != null) {  			docID = disi.DocID;  			//if (DEBUG) {  			//  System.out.println("    start docID=" + docID);  			//}  			while (docID < nextChunkStart) {  				int slot = docID & MASK;  				if (docIDs [slot] == docID && counts [slot] >= dim) {  					// This doc is still in the running...  					// TODO: single-valued dims will always be true  					// below; we could somehow specialize  					if (missingDims [slot] >= dim) {  						//if (DEBUG) {  						//  System.out.println("      set docID=" + docID + " count=" + (dim+2));  						//}  						missingDims [slot] = dim + 1;  						counts [slot] = dim + 2;  					} else {  						//if (DEBUG) {  						//  System.out.println("      set docID=" + docID + " missing count=" + (dim+1));  						//}  						counts [slot] = dim + 1;  					}  				}  				docID = disi.NextDoc ();  			}  		}  	}  	// Collect:  	//System.out.println("  now collect: " + filledCount + " hits");  	for (int i = 0; i < filledCount; i++) {  		// NOTE: This is actually in-order collection'  		// because we only accept docs originally returned by  		// the baseScorer (ie that Scorer is AND'd)  		int slot = filledSlots [i];  		collectDocID = docIDs [slot];  		collectScore = scores [slot];  		//if (DEBUG) {  		//  System.out.println("    docID=" + docIDs[slot] + " count=" + counts[slot]);  		//}  		//System.out.println("  collect doc=" + collectDocID + " main.freq=" + (counts[slot]-1) + " main.doc=" + collectDocID + " exactCount=" + numDims);  		if (counts [slot] == 1 + numDims) {  			//System.out.println("    hit");  			CollectHit (collector' sidewaysCollectors);  		} else if (counts [slot] == numDims) {  			//System.out.println("    sw");  			CollectNearMiss (sidewaysCollectors [missingDims [slot]]);  		}  	}  	if (nextChunkStart >= maxDoc) {  		break;  	}  	nextChunkStart += CHUNK;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: if (disi != null) {  	docID = disi.DocID;  	//if (DEBUG) {  	//  System.out.println("    start docID=" + docID);  	//}  	while (docID < nextChunkStart) {  		int slot = docID & MASK;  		if (docIDs [slot] == docID) {  			//if (DEBUG) {  			//  System.out.println("      set docID=" + docID + " count=2");  			//}  			missingDims [slot] = 1;  			counts [slot] = 2;  		}  		docID = disi.NextDoc ();  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: while (docID < nextChunkStart) {  	int slot = docID & MASK;  	if (docIDs [slot] == docID) {  		//if (DEBUG) {  		//  System.out.println("      set docID=" + docID + " count=2");  		//}  		missingDims [slot] = 1;  		counts [slot] = 2;  	}  	docID = disi.NextDoc ();  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: if (docIDs [slot] == docID) {  	//if (DEBUG) {  	//  System.out.println("      set docID=" + docID + " count=2");  	//}  	missingDims [slot] = 1;  	counts [slot] = 2;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: counts [slot] = 2;  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: for (int dim = 1; dim < numDims; dim++) {  	//if (DEBUG) {  	//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");  	//}  	disi = disis [dim];  	if (disi != null) {  		docID = disi.DocID;  		//if (DEBUG) {  		//  System.out.println("    start docID=" + docID);  		//}  		while (docID < nextChunkStart) {  			int slot = docID & MASK;  			if (docIDs [slot] == docID && counts [slot] >= dim) {  				// This doc is still in the running...  				// TODO: single-valued dims will always be true  				// below; we could somehow specialize  				if (missingDims [slot] >= dim) {  					//if (DEBUG) {  					//  System.out.println("      set docID=" + docID + " count=" + (dim+2));  					//}  					missingDims [slot] = dim + 1;  					counts [slot] = dim + 2;  				} else {  					//if (DEBUG) {  					//  System.out.println("      set docID=" + docID + " missing count=" + (dim+1));  					//}  					counts [slot] = dim + 1;  				}  			}  			docID = disi.NextDoc ();  		}  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: if (disi != null) {  	docID = disi.DocID;  	//if (DEBUG) {  	//  System.out.println("    start docID=" + docID);  	//}  	while (docID < nextChunkStart) {  		int slot = docID & MASK;  		if (docIDs [slot] == docID && counts [slot] >= dim) {  			// This doc is still in the running...  			// TODO: single-valued dims will always be true  			// below; we could somehow specialize  			if (missingDims [slot] >= dim) {  				//if (DEBUG) {  				//  System.out.println("      set docID=" + docID + " count=" + (dim+2));  				//}  				missingDims [slot] = dim + 1;  				counts [slot] = dim + 2;  			} else {  				//if (DEBUG) {  				//  System.out.println("      set docID=" + docID + " missing count=" + (dim+1));  				//}  				counts [slot] = dim + 1;  			}  		}  		docID = disi.NextDoc ();  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: while (docID < nextChunkStart) {  	int slot = docID & MASK;  	if (docIDs [slot] == docID && counts [slot] >= dim) {  		// This doc is still in the running...  		// TODO: single-valued dims will always be true  		// below; we could somehow specialize  		if (missingDims [slot] >= dim) {  			//if (DEBUG) {  			//  System.out.println("      set docID=" + docID + " count=" + (dim+2));  			//}  			missingDims [slot] = dim + 1;  			counts [slot] = dim + 2;  		} else {  			//if (DEBUG) {  			//  System.out.println("      set docID=" + docID + " missing count=" + (dim+1));  			//}  			counts [slot] = dim + 1;  		}  	}  	docID = disi.NextDoc ();  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: if (docIDs [slot] == docID && counts [slot] >= dim) {  	// This doc is still in the running...  	// TODO: single-valued dims will always be true  	// below; we could somehow specialize  	if (missingDims [slot] >= dim) {  		//if (DEBUG) {  		//  System.out.println("      set docID=" + docID + " count=" + (dim+2));  		//}  		missingDims [slot] = dim + 1;  		counts [slot] = dim + 2;  	} else {  		//if (DEBUG) {  		//  System.out.println("      set docID=" + docID + " missing count=" + (dim+1));  		//}  		counts [slot] = dim + 1;  	}  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: if (missingDims [slot] >= dim) {  	//if (DEBUG) {  	//  System.out.println("      set docID=" + docID + " count=" + (dim+2));  	//}  	missingDims [slot] = dim + 1;  	counts [slot] = dim + 2;  } else {  	//if (DEBUG) {  	//  System.out.println("      set docID=" + docID + " missing count=" + (dim+1));  	//}  	counts [slot] = dim + 1;  }  
Magic Number,Lucene.Net.Facet,DrillSidewaysScorer,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\DrillSidewaysScorer.cs,DoUnionScoring,The following statement contains a magic number: counts [slot] = dim + 2;  
Magic Number,Lucene.Net.Facet,FacetResult,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetResult.cs,GetHashCode,The following statement contains a magic number: foreach (LabelAndValue labelValue in LabelValues) {  	hashCode = labelValue.GetHashCode () + 31 * hashCode;  }  
Magic Number,Lucene.Net.Facet,FacetResult,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetResult.cs,GetHashCode,The following statement contains a magic number: hashCode = labelValue.GetHashCode () + 31 * hashCode;  
Magic Number,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,Collect,The following statement contains a magic number: if (keepScores) {  	if (totalHits >= scores.Length) {  		float[] newScores = new float[ArrayUtil.Oversize (totalHits + 1' 4)];  		Array.Copy (scores' 0' newScores' 0' totalHits);  		scores = newScores;  	}  	scores [totalHits] = scorer.GetScore ();  }  
Magic Number,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,Collect,The following statement contains a magic number: if (totalHits >= scores.Length) {  	float[] newScores = new float[ArrayUtil.Oversize (totalHits + 1' 4)];  	Array.Copy (scores' 0' newScores' 0' totalHits);  	scores = newScores;  }  
Magic Number,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,SetNextReader,The following statement contains a magic number: if (keepScores) {  	scores = new float[64];  	// some initial size  }  
Magic Number,Lucene.Net.Facet,FacetsCollector,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsCollector.cs,SetNextReader,The following statement contains a magic number: scores = new float[64];  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessFacetFields,The following statement contains a magic number: foreach (KeyValuePair<string' IList<FacetField>> ent in byField) {  	string indexFieldName = ent.Key;  	//System.out.println("  indexFieldName=" + indexFieldName + " fields=" + ent.getValue());  	Int32sRef ordinals = new Int32sRef (32);  	foreach (FacetField facetField in ent.Value) {  		FacetsConfig.DimConfig ft = GetDimConfig (facetField.Dim);  		if (facetField.Path.Length > 1 && ft.IsHierarchical == false) {  			throw new System.ArgumentException ("dimension \"" + facetField.Dim + "\" is not hierarchical yet has " + facetField.Path.Length + " components");  		}  		FacetLabel cp = new FacetLabel (facetField.Dim' facetField.Path);  		CheckTaxoWriter (taxoWriter);  		int ordinal = taxoWriter.AddCategory (cp);  		if (ordinals.Length == ordinals.Int32s.Length) {  			ordinals.Grow (ordinals.Length + 1);  		}  		ordinals.Int32s [ordinals.Length++] = ordinal;  		//System.out.println("ords[" + (ordinals.length-1) + "]=" + ordinal);  		//System.out.println("  add cp=" + cp);  		if (ft.IsMultiValued && (ft.IsHierarchical || ft.RequireDimCount)) {  			//System.out.println("  add parents");  			// Add all parents too:  			int parent = taxoWriter.GetParent (ordinal);  			while (parent > 0) {  				if (ordinals.Int32s.Length == ordinals.Length) {  					ordinals.Grow (ordinals.Length + 1);  				}  				ordinals.Int32s [ordinals.Length++] = parent;  				parent = taxoWriter.GetParent (parent);  			}  			if (ft.RequireDimCount == false) {  				// Remove last (dimension) ord:  				ordinals.Length--;  			}  		}  		// Drill down:  		for (int i = 1; i <= cp.Length; i++) {  			doc.Add (new StringField (indexFieldName' PathToString (cp.Components' i)' Field.Store.NO));  		}  	}  	// Facet counts:  	// DocValues are considered stored fields:  	doc.Add (new BinaryDocValuesField (indexFieldName' DedupAndEncode (ordinals)));  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (KeyValuePair<string' IList<AssociationFacetField>> ent in byField) {  	byte[] bytes = new byte[16];  	int upto = 0;  	string indexFieldName = ent.Key;  	foreach (AssociationFacetField field in ent.Value) {  		// NOTE: we don't add parents for associations  		CheckTaxoWriter (taxoWriter);  		FacetLabel label = new FacetLabel (field.Dim' field.Path);  		int ordinal = taxoWriter.AddCategory (label);  		if (upto + 4 > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + 4);  		}  		// big-endian:  		bytes [upto++] = (byte)(ordinal >> 24);  		bytes [upto++] = (byte)(ordinal >> 16);  		bytes [upto++] = (byte)(ordinal >> 8);  		bytes [upto++] = (byte)ordinal;  		if (upto + field.Assoc.Length > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  		}  		Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  		upto += field.Assoc.Length;  		// Drill down:  		for (int i = 1; i <= label.Length; i++) {  			doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  		}  	}  	doc.Add (new BinaryDocValuesField (indexFieldName' new BytesRef (bytes' 0' upto)));  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (KeyValuePair<string' IList<AssociationFacetField>> ent in byField) {  	byte[] bytes = new byte[16];  	int upto = 0;  	string indexFieldName = ent.Key;  	foreach (AssociationFacetField field in ent.Value) {  		// NOTE: we don't add parents for associations  		CheckTaxoWriter (taxoWriter);  		FacetLabel label = new FacetLabel (field.Dim' field.Path);  		int ordinal = taxoWriter.AddCategory (label);  		if (upto + 4 > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + 4);  		}  		// big-endian:  		bytes [upto++] = (byte)(ordinal >> 24);  		bytes [upto++] = (byte)(ordinal >> 16);  		bytes [upto++] = (byte)(ordinal >> 8);  		bytes [upto++] = (byte)ordinal;  		if (upto + field.Assoc.Length > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  		}  		Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  		upto += field.Assoc.Length;  		// Drill down:  		for (int i = 1; i <= label.Length; i++) {  			doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  		}  	}  	doc.Add (new BinaryDocValuesField (indexFieldName' new BytesRef (bytes' 0' upto)));  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (KeyValuePair<string' IList<AssociationFacetField>> ent in byField) {  	byte[] bytes = new byte[16];  	int upto = 0;  	string indexFieldName = ent.Key;  	foreach (AssociationFacetField field in ent.Value) {  		// NOTE: we don't add parents for associations  		CheckTaxoWriter (taxoWriter);  		FacetLabel label = new FacetLabel (field.Dim' field.Path);  		int ordinal = taxoWriter.AddCategory (label);  		if (upto + 4 > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + 4);  		}  		// big-endian:  		bytes [upto++] = (byte)(ordinal >> 24);  		bytes [upto++] = (byte)(ordinal >> 16);  		bytes [upto++] = (byte)(ordinal >> 8);  		bytes [upto++] = (byte)ordinal;  		if (upto + field.Assoc.Length > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  		}  		Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  		upto += field.Assoc.Length;  		// Drill down:  		for (int i = 1; i <= label.Length; i++) {  			doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  		}  	}  	doc.Add (new BinaryDocValuesField (indexFieldName' new BytesRef (bytes' 0' upto)));  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (KeyValuePair<string' IList<AssociationFacetField>> ent in byField) {  	byte[] bytes = new byte[16];  	int upto = 0;  	string indexFieldName = ent.Key;  	foreach (AssociationFacetField field in ent.Value) {  		// NOTE: we don't add parents for associations  		CheckTaxoWriter (taxoWriter);  		FacetLabel label = new FacetLabel (field.Dim' field.Path);  		int ordinal = taxoWriter.AddCategory (label);  		if (upto + 4 > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + 4);  		}  		// big-endian:  		bytes [upto++] = (byte)(ordinal >> 24);  		bytes [upto++] = (byte)(ordinal >> 16);  		bytes [upto++] = (byte)(ordinal >> 8);  		bytes [upto++] = (byte)ordinal;  		if (upto + field.Assoc.Length > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  		}  		Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  		upto += field.Assoc.Length;  		// Drill down:  		for (int i = 1; i <= label.Length; i++) {  			doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  		}  	}  	doc.Add (new BinaryDocValuesField (indexFieldName' new BytesRef (bytes' 0' upto)));  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (KeyValuePair<string' IList<AssociationFacetField>> ent in byField) {  	byte[] bytes = new byte[16];  	int upto = 0;  	string indexFieldName = ent.Key;  	foreach (AssociationFacetField field in ent.Value) {  		// NOTE: we don't add parents for associations  		CheckTaxoWriter (taxoWriter);  		FacetLabel label = new FacetLabel (field.Dim' field.Path);  		int ordinal = taxoWriter.AddCategory (label);  		if (upto + 4 > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + 4);  		}  		// big-endian:  		bytes [upto++] = (byte)(ordinal >> 24);  		bytes [upto++] = (byte)(ordinal >> 16);  		bytes [upto++] = (byte)(ordinal >> 8);  		bytes [upto++] = (byte)ordinal;  		if (upto + field.Assoc.Length > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  		}  		Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  		upto += field.Assoc.Length;  		// Drill down:  		for (int i = 1; i <= label.Length; i++) {  			doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  		}  	}  	doc.Add (new BinaryDocValuesField (indexFieldName' new BytesRef (bytes' 0' upto)));  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (KeyValuePair<string' IList<AssociationFacetField>> ent in byField) {  	byte[] bytes = new byte[16];  	int upto = 0;  	string indexFieldName = ent.Key;  	foreach (AssociationFacetField field in ent.Value) {  		// NOTE: we don't add parents for associations  		CheckTaxoWriter (taxoWriter);  		FacetLabel label = new FacetLabel (field.Dim' field.Path);  		int ordinal = taxoWriter.AddCategory (label);  		if (upto + 4 > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + 4);  		}  		// big-endian:  		bytes [upto++] = (byte)(ordinal >> 24);  		bytes [upto++] = (byte)(ordinal >> 16);  		bytes [upto++] = (byte)(ordinal >> 8);  		bytes [upto++] = (byte)ordinal;  		if (upto + field.Assoc.Length > bytes.Length) {  			bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  		}  		Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  		upto += field.Assoc.Length;  		// Drill down:  		for (int i = 1; i <= label.Length; i++) {  			doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  		}  	}  	doc.Add (new BinaryDocValuesField (indexFieldName' new BytesRef (bytes' 0' upto)));  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (AssociationFacetField field in ent.Value) {  	// NOTE: we don't add parents for associations  	CheckTaxoWriter (taxoWriter);  	FacetLabel label = new FacetLabel (field.Dim' field.Path);  	int ordinal = taxoWriter.AddCategory (label);  	if (upto + 4 > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + 4);  	}  	// big-endian:  	bytes [upto++] = (byte)(ordinal >> 24);  	bytes [upto++] = (byte)(ordinal >> 16);  	bytes [upto++] = (byte)(ordinal >> 8);  	bytes [upto++] = (byte)ordinal;  	if (upto + field.Assoc.Length > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  	}  	Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  	upto += field.Assoc.Length;  	// Drill down:  	for (int i = 1; i <= label.Length; i++) {  		doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (AssociationFacetField field in ent.Value) {  	// NOTE: we don't add parents for associations  	CheckTaxoWriter (taxoWriter);  	FacetLabel label = new FacetLabel (field.Dim' field.Path);  	int ordinal = taxoWriter.AddCategory (label);  	if (upto + 4 > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + 4);  	}  	// big-endian:  	bytes [upto++] = (byte)(ordinal >> 24);  	bytes [upto++] = (byte)(ordinal >> 16);  	bytes [upto++] = (byte)(ordinal >> 8);  	bytes [upto++] = (byte)ordinal;  	if (upto + field.Assoc.Length > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  	}  	Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  	upto += field.Assoc.Length;  	// Drill down:  	for (int i = 1; i <= label.Length; i++) {  		doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (AssociationFacetField field in ent.Value) {  	// NOTE: we don't add parents for associations  	CheckTaxoWriter (taxoWriter);  	FacetLabel label = new FacetLabel (field.Dim' field.Path);  	int ordinal = taxoWriter.AddCategory (label);  	if (upto + 4 > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + 4);  	}  	// big-endian:  	bytes [upto++] = (byte)(ordinal >> 24);  	bytes [upto++] = (byte)(ordinal >> 16);  	bytes [upto++] = (byte)(ordinal >> 8);  	bytes [upto++] = (byte)ordinal;  	if (upto + field.Assoc.Length > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  	}  	Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  	upto += field.Assoc.Length;  	// Drill down:  	for (int i = 1; i <= label.Length; i++) {  		doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (AssociationFacetField field in ent.Value) {  	// NOTE: we don't add parents for associations  	CheckTaxoWriter (taxoWriter);  	FacetLabel label = new FacetLabel (field.Dim' field.Path);  	int ordinal = taxoWriter.AddCategory (label);  	if (upto + 4 > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + 4);  	}  	// big-endian:  	bytes [upto++] = (byte)(ordinal >> 24);  	bytes [upto++] = (byte)(ordinal >> 16);  	bytes [upto++] = (byte)(ordinal >> 8);  	bytes [upto++] = (byte)ordinal;  	if (upto + field.Assoc.Length > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  	}  	Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  	upto += field.Assoc.Length;  	// Drill down:  	for (int i = 1; i <= label.Length; i++) {  		doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: foreach (AssociationFacetField field in ent.Value) {  	// NOTE: we don't add parents for associations  	CheckTaxoWriter (taxoWriter);  	FacetLabel label = new FacetLabel (field.Dim' field.Path);  	int ordinal = taxoWriter.AddCategory (label);  	if (upto + 4 > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + 4);  	}  	// big-endian:  	bytes [upto++] = (byte)(ordinal >> 24);  	bytes [upto++] = (byte)(ordinal >> 16);  	bytes [upto++] = (byte)(ordinal >> 8);  	bytes [upto++] = (byte)ordinal;  	if (upto + field.Assoc.Length > bytes.Length) {  		bytes = ArrayUtil.Grow (bytes' upto + field.Assoc.Length);  	}  	Array.Copy (field.Assoc.Bytes' field.Assoc.Offset' bytes' upto' field.Assoc.Length);  	upto += field.Assoc.Length;  	// Drill down:  	for (int i = 1; i <= label.Length; i++) {  		doc.Add (new StringField (indexFieldName' PathToString (label.Components' i)' Field.Store.NO));  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: if (upto + 4 > bytes.Length) {  	bytes = ArrayUtil.Grow (bytes' upto + 4);  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: if (upto + 4 > bytes.Length) {  	bytes = ArrayUtil.Grow (bytes' upto + 4);  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: bytes = ArrayUtil.Grow (bytes' upto + 4);  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: bytes [upto++] = (byte)(ordinal >> 24);  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: bytes [upto++] = (byte)(ordinal >> 16);  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,ProcessAssocFacetFields,The following statement contains a magic number: bytes [upto++] = (byte)(ordinal >> 8);  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: for (int i = 0; i < ordinals.Length; i++) {  	int ord = ordinals.Int32s [ordinals.Offset + i];  	// ord could be == lastOrd' so we must dedup:  	if (ord > lastOrd) {  		int delta;  		if (lastOrd == -1) {  			delta = ord;  		} else {  			delta = ord - lastOrd;  		}  		if ((delta & ~0x7F) == 0) {  			bytes [upto] = (byte)delta;  			upto++;  		} else if ((delta & ~0x3FFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 1] = (byte)(delta & 0x7F);  			upto += 2;  		} else if ((delta & ~0x1FFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 2] = (byte)(delta & 0x7F);  			upto += 3;  		} else if ((delta & ~0xFFFFFFF) == 0) {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 3] = (byte)(delta & 0x7F);  			upto += 4;  		} else {  			bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  			bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  			bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  			bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  			bytes [upto + 4] = (byte)(delta & 0x7F);  			upto += 5;  		}  		lastOrd = ord;  	}  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if (ord > lastOrd) {  	int delta;  	if (lastOrd == -1) {  		delta = ord;  	} else {  		delta = ord - lastOrd;  	}  	if ((delta & ~0x7F) == 0) {  		bytes [upto] = (byte)delta;  		upto++;  	} else if ((delta & ~0x3FFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 1] = (byte)(delta & 0x7F);  		upto += 2;  	} else if ((delta & ~0x1FFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 2] = (byte)(delta & 0x7F);  		upto += 3;  	} else if ((delta & ~0xFFFFFFF) == 0) {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 3] = (byte)(delta & 0x7F);  		upto += 4;  	} else {  		bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  		bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  		bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  		bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  		bytes [upto + 4] = (byte)(delta & 0x7F);  		upto += 5;  	}  	lastOrd = ord;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x7F) == 0) {  	bytes [upto] = (byte)delta;  	upto++;  } else if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x3FFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 1] = (byte)(delta & 0x7F);  	upto += 2;  } else if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: upto += 2;  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0x1FFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 2] = (byte)(delta & 0x7F);  	upto += 3;  } else if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 2] = (byte)(delta & 0x7F);  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: upto += 3;  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: if ((delta & ~0xFFFFFFF) == 0) {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 3] = (byte)(delta & 0x7F);  	upto += 4;  } else {  	bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  	bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  	bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  	bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  	bytes [upto + 4] = (byte)(delta & 0x7F);  	upto += 5;  }  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 3] = (byte)(delta & 0x7F);  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: upto += 4;  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto] = unchecked((byte)(0x80 | ((delta & 0xF0000000) >> 28)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 1] = unchecked((byte)(0x80 | ((delta & 0xFE00000) >> 21)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 2] = unchecked((byte)(0x80 | ((delta & 0x1FC000) >> 14)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 3] = unchecked((byte)(0x80 | ((delta & 0x3F80) >> 7)));  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: bytes [upto + 4] = (byte)(delta & 0x7F);  
Magic Number,Lucene.Net.Facet,FacetsConfig,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\FacetsConfig.cs,DedupAndEncode,The following statement contains a magic number: upto += 5;  
Magic Number,Lucene.Net.Facet,LabelAndValue,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\LabelAndValue.cs,GetHashCode,The following statement contains a magic number: return Label.GetHashCode () + 1439 * Value.GetHashCode ();  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: endsMap [long.MaxValue] = 2;  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: foreach (Int64Range range in ranges) {  	int? cur;  	if (!endsMap.TryGetValue (range.minIncl' out cur)) {  		endsMap [range.minIncl] = 1;  	} else {  		endsMap [range.minIncl] = (int)cur | 1;  	}  	if (!endsMap.TryGetValue (range.maxIncl' out cur)) {  		endsMap [range.maxIncl] = 2;  	} else {  		endsMap [range.maxIncl] = (int)cur | 2;  	}  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: foreach (Int64Range range in ranges) {  	int? cur;  	if (!endsMap.TryGetValue (range.minIncl' out cur)) {  		endsMap [range.minIncl] = 1;  	} else {  		endsMap [range.minIncl] = (int)cur | 1;  	}  	if (!endsMap.TryGetValue (range.maxIncl' out cur)) {  		endsMap [range.maxIncl] = 2;  	} else {  		endsMap [range.maxIncl] = (int)cur | 2;  	}  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: if (!endsMap.TryGetValue (range.maxIncl' out cur)) {  	endsMap [range.maxIncl] = 2;  } else {  	endsMap [range.maxIncl] = (int)cur | 2;  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: if (!endsMap.TryGetValue (range.maxIncl' out cur)) {  	endsMap [range.maxIncl] = 2;  } else {  	endsMap [range.maxIncl] = (int)cur | 2;  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: endsMap [range.maxIncl] = 2;  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: endsMap [range.maxIncl] = (int)cur | 2;  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: if (endsMap [v] == 3) {  	elementaryIntervals.Add (new InclusiveRange (v' v));  	prev = v + 1;  } else {  	prev = v;  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: while (upto0 < endsList.Count) {  	v = endsList [upto0].HasValue ? endsList [upto0].Value : 0;  	int flags = endsMap [v].HasValue ? endsMap [v].Value : 0;  	//System.out.println("  v=" + v + " flags=" + flags);  	if (flags == 3) {  		// This point is both an end and a start; we need to  		// separate it:  		if (v > prev) {  			elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  		}  		elementaryIntervals.Add (new InclusiveRange (v' v));  		prev = v + 1;  	} else if (flags == 1) {  		// This point is only the start of an interval;  		// attach it to next interval:  		if (v > prev) {  			elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  		}  		prev = v;  	} else {  		Debug.Assert (flags == 2);  		// This point is only the end of an interval; attach  		// it to last interval:  		elementaryIntervals.Add (new InclusiveRange (prev' v));  		prev = v + 1;  	}  	//System.out.println("    ints=" + elementaryIntervals);  	upto0++;  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: while (upto0 < endsList.Count) {  	v = endsList [upto0].HasValue ? endsList [upto0].Value : 0;  	int flags = endsMap [v].HasValue ? endsMap [v].Value : 0;  	//System.out.println("  v=" + v + " flags=" + flags);  	if (flags == 3) {  		// This point is both an end and a start; we need to  		// separate it:  		if (v > prev) {  			elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  		}  		elementaryIntervals.Add (new InclusiveRange (v' v));  		prev = v + 1;  	} else if (flags == 1) {  		// This point is only the start of an interval;  		// attach it to next interval:  		if (v > prev) {  			elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  		}  		prev = v;  	} else {  		Debug.Assert (flags == 2);  		// This point is only the end of an interval; attach  		// it to last interval:  		elementaryIntervals.Add (new InclusiveRange (prev' v));  		prev = v + 1;  	}  	//System.out.println("    ints=" + elementaryIntervals);  	upto0++;  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: if (flags == 3) {  	// This point is both an end and a start; we need to  	// separate it:  	if (v > prev) {  		elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  	}  	elementaryIntervals.Add (new InclusiveRange (v' v));  	prev = v + 1;  } else if (flags == 1) {  	// This point is only the start of an interval;  	// attach it to next interval:  	if (v > prev) {  		elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  	}  	prev = v;  } else {  	Debug.Assert (flags == 2);  	// This point is only the end of an interval; attach  	// it to last interval:  	elementaryIntervals.Add (new InclusiveRange (prev' v));  	prev = v + 1;  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: if (flags == 3) {  	// This point is both an end and a start; we need to  	// separate it:  	if (v > prev) {  		elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  	}  	elementaryIntervals.Add (new InclusiveRange (v' v));  	prev = v + 1;  } else if (flags == 1) {  	// This point is only the start of an interval;  	// attach it to next interval:  	if (v > prev) {  		elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  	}  	prev = v;  } else {  	Debug.Assert (flags == 2);  	// This point is only the end of an interval; attach  	// it to last interval:  	elementaryIntervals.Add (new InclusiveRange (prev' v));  	prev = v + 1;  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: if (flags == 1) {  	// This point is only the start of an interval;  	// attach it to next interval:  	if (v > prev) {  		elementaryIntervals.Add (new InclusiveRange (prev' v - 1));  	}  	prev = v;  } else {  	Debug.Assert (flags == 2);  	// This point is only the end of an interval; attach  	// it to last interval:  	elementaryIntervals.Add (new InclusiveRange (prev' v));  	prev = v + 1;  }  
Magic Number,Lucene.Net.Facet.Range,Int64RangeCounter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Range\LongRangeCounter.cs,Int64RangeCounter,The following statement contains a magic number: Debug.Assert (flags == 2);  
Magic Number,Lucene.Net.Facet.SortedSet,DefaultSortedSetDocValuesReaderState,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\DefaultSortedSetDocValuesReaderState.cs,DefaultSortedSetDocValuesReaderState,The following statement contains a magic number: for (int ord = 0; ord < valueCount; ord++) {  	BytesRef term = new BytesRef ();  	dv.LookupOrd (ord' term);  	string[] components = FacetsConfig.StringToPath (term.Utf8ToString ());  	if (components.Length != 2) {  		throw new System.ArgumentException ("this class can only handle 2 level hierarchy (dim/value); got: " + Arrays.ToString (components) + " " + term.Utf8ToString ());  	}  	if (!components [0].Equals (lastDim)) {  		if (lastDim != null) {  			prefixToOrdRange [lastDim] = new OrdRange (startOrd' ord - 1);  		}  		startOrd = ord;  		lastDim = components [0];  	}  }  
Magic Number,Lucene.Net.Facet.SortedSet,DefaultSortedSetDocValuesReaderState,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\DefaultSortedSetDocValuesReaderState.cs,DefaultSortedSetDocValuesReaderState,The following statement contains a magic number: if (components.Length != 2) {  	throw new System.ArgumentException ("this class can only handle 2 level hierarchy (dim/value); got: " + Arrays.ToString (components) + " " + term.Utf8ToString ());  }  
Magic Number,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,Count,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	var reader = hits.Context.AtomicReader;  	//System.out.println("  reader=" + reader);  	// LUCENE-5090: make sure the provided reader context "matches"  	// the top-level reader passed to the  	// SortedSetDocValuesReaderState' else cryptic  	// AIOOBE can happen:  	if (!Equals (ReaderUtil.GetTopLevelContext (hits.Context).Reader' origReader)) {  		throw new InvalidOperationException ("the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader");  	}  	SortedSetDocValues segValues = reader.GetSortedSetDocValues (field);  	if (segValues == null) {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	// TODO: yet another option is to count all segs  	// first' only in seg-ord space' and then do a  	// merge-sort-PQ in the end to only "resolve to  	// global" those seg ords that can compete' if we know  	// we just want top K?  ie' this is the same algo  	// that'd be used for merging facets across shards  	// (distributed faceting).  but this has much higher  	// temp ram req'ts (sum of number of ords across all  	// segs)  	if (ordinalMap != null) {  		int segOrd = hits.Context.Ord;  		int numSegOrds = (int)segValues.ValueCount;  		if (hits.TotalHits < numSegOrds / 10) {  			//System.out.println("    remap as-we-go");  			// Remap every ord to global ord as we iterate:  			int doc;  			while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  				//System.out.println("    doc=" + doc);  				segValues.SetDocument (doc);  				int term = (int)segValues.NextOrd ();  				while (term != SortedSetDocValues.NO_MORE_ORDS) {  					//System.out.println("      segOrd=" + segOrd + " ord=" + term + " globalOrd=" + ordinalMap.getGlobalOrd(segOrd' term));  					counts [(int)ordinalMap.GetGlobalOrd (segOrd' term)]++;  					term = (int)segValues.NextOrd ();  				}  			}  		} else {  			//System.out.println("    count in seg ord first");  			// First count in seg-ord space:  			int[] segCounts = new int[numSegOrds];  			int doc;  			while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  				//System.out.println("    doc=" + doc);  				segValues.SetDocument (doc);  				int term = (int)segValues.NextOrd ();  				while (term != SortedSetDocValues.NO_MORE_ORDS) {  					//System.out.println("      ord=" + term);  					segCounts [term]++;  					term = (int)segValues.NextOrd ();  				}  			}  			// Then' migrate to global ords:  			for (int ord = 0; ord < numSegOrds; ord++) {  				int count = segCounts [ord];  				if (count != 0) {  					//System.out.println("    migrate segOrd=" + segOrd + " ord=" + ord + " globalOrd=" + ordinalMap.getGlobalOrd(segOrd' ord));  					counts [(int)ordinalMap.GetGlobalOrd (segOrd' ord)] += count;  				}  			}  		}  	} else {  		// No ord mapping (e.g.' single segment index):  		// just aggregate directly into counts:  		int doc;  		while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  			segValues.SetDocument (doc);  			int term = (int)segValues.NextOrd ();  			while (term != SortedSetDocValues.NO_MORE_ORDS) {  				counts [term]++;  				term = (int)segValues.NextOrd ();  			}  		}  	}  }  
Magic Number,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,Count,The following statement contains a magic number: if (ordinalMap != null) {  	int segOrd = hits.Context.Ord;  	int numSegOrds = (int)segValues.ValueCount;  	if (hits.TotalHits < numSegOrds / 10) {  		//System.out.println("    remap as-we-go");  		// Remap every ord to global ord as we iterate:  		int doc;  		while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  			//System.out.println("    doc=" + doc);  			segValues.SetDocument (doc);  			int term = (int)segValues.NextOrd ();  			while (term != SortedSetDocValues.NO_MORE_ORDS) {  				//System.out.println("      segOrd=" + segOrd + " ord=" + term + " globalOrd=" + ordinalMap.getGlobalOrd(segOrd' term));  				counts [(int)ordinalMap.GetGlobalOrd (segOrd' term)]++;  				term = (int)segValues.NextOrd ();  			}  		}  	} else {  		//System.out.println("    count in seg ord first");  		// First count in seg-ord space:  		int[] segCounts = new int[numSegOrds];  		int doc;  		while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  			//System.out.println("    doc=" + doc);  			segValues.SetDocument (doc);  			int term = (int)segValues.NextOrd ();  			while (term != SortedSetDocValues.NO_MORE_ORDS) {  				//System.out.println("      ord=" + term);  				segCounts [term]++;  				term = (int)segValues.NextOrd ();  			}  		}  		// Then' migrate to global ords:  		for (int ord = 0; ord < numSegOrds; ord++) {  			int count = segCounts [ord];  			if (count != 0) {  				//System.out.println("    migrate segOrd=" + segOrd + " ord=" + ord + " globalOrd=" + ordinalMap.getGlobalOrd(segOrd' ord));  				counts [(int)ordinalMap.GetGlobalOrd (segOrd' ord)] += count;  			}  		}  	}  } else {  	// No ord mapping (e.g.' single segment index):  	// just aggregate directly into counts:  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		segValues.SetDocument (doc);  		int term = (int)segValues.NextOrd ();  		while (term != SortedSetDocValues.NO_MORE_ORDS) {  			counts [term]++;  			term = (int)segValues.NextOrd ();  		}  	}  }  
Magic Number,Lucene.Net.Facet.SortedSet,SortedSetDocValuesFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\SortedSet\SortedSetDocValuesFacetCounts.cs,Count,The following statement contains a magic number: if (hits.TotalHits < numSegOrds / 10) {  	//System.out.println("    remap as-we-go");  	// Remap every ord to global ord as we iterate:  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("    doc=" + doc);  		segValues.SetDocument (doc);  		int term = (int)segValues.NextOrd ();  		while (term != SortedSetDocValues.NO_MORE_ORDS) {  			//System.out.println("      segOrd=" + segOrd + " ord=" + term + " globalOrd=" + ordinalMap.getGlobalOrd(segOrd' term));  			counts [(int)ordinalMap.GetGlobalOrd (segOrd' term)]++;  			term = (int)segValues.NextOrd ();  		}  	}  } else {  	//System.out.println("    count in seg ord first");  	// First count in seg-ord space:  	int[] segCounts = new int[numSegOrds];  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("    doc=" + doc);  		segValues.SetDocument (doc);  		int term = (int)segValues.NextOrd ();  		while (term != SortedSetDocValues.NO_MORE_ORDS) {  			//System.out.println("      ord=" + term);  			segCounts [term]++;  			term = (int)segValues.NextOrd ();  		}  	}  	// Then' migrate to global ords:  	for (int ord = 0; ord < numSegOrds; ord++) {  		int count = segCounts [ord];  		if (count != 0) {  			//System.out.println("    migrate segOrd=" + segOrd + " ord=" + ord + " globalOrd=" + ordinalMap.getGlobalOrd(segOrd' ord));  			counts [(int)ordinalMap.GetGlobalOrd (segOrd' ord)] += count;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,CategoryPath,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\CategoryPath.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < Length; i++) {  	hash = hash * 31 + Components [i].GetHashCode ();  }  
Magic Number,Lucene.Net.Facet.Taxonomy,CategoryPath,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\CategoryPath.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + Components [i].GetHashCode ();  
Magic Number,Lucene.Net.Facet.Taxonomy,CategoryPath,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\CategoryPath.cs,Int64HashCode,The following statement contains a magic number: for (int i = 0; i < Length; i++) {  	hash = hash * 65599 + Components [i].GetHashCode ();  }  
Magic Number,Lucene.Net.Facet.Taxonomy,CategoryPath,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\CategoryPath.cs,Int64HashCode,The following statement contains a magic number: hash = hash * 65599 + Components [i].GetHashCode ();  
Magic Number,Lucene.Net.Facet.Taxonomy,DocValuesOrdinalsReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\DocValuesOrdinalsReader.cs,Decode,The following statement contains a magic number: while (offset < upto) {  	byte b = buf.Bytes [offset++];  	if ((sbyte)b >= 0) {  		ordinals.Int32s [ordinals.Length] = ((value << 7) | b) + prev;  		value = 0;  		prev = ordinals.Int32s [ordinals.Length];  		ordinals.Length++;  	} else {  		value = (value << 7) | (b & 0x7F);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,DocValuesOrdinalsReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\DocValuesOrdinalsReader.cs,Decode,The following statement contains a magic number: while (offset < upto) {  	byte b = buf.Bytes [offset++];  	if ((sbyte)b >= 0) {  		ordinals.Int32s [ordinals.Length] = ((value << 7) | b) + prev;  		value = 0;  		prev = ordinals.Int32s [ordinals.Length];  		ordinals.Length++;  	} else {  		value = (value << 7) | (b & 0x7F);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,DocValuesOrdinalsReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\DocValuesOrdinalsReader.cs,Decode,The following statement contains a magic number: if ((sbyte)b >= 0) {  	ordinals.Int32s [ordinals.Length] = ((value << 7) | b) + prev;  	value = 0;  	prev = ordinals.Int32s [ordinals.Length];  	ordinals.Length++;  } else {  	value = (value << 7) | (b & 0x7F);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,DocValuesOrdinalsReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\DocValuesOrdinalsReader.cs,Decode,The following statement contains a magic number: if ((sbyte)b >= 0) {  	ordinals.Int32s [ordinals.Length] = ((value << 7) | b) + prev;  	value = 0;  	prev = ordinals.Int32s [ordinals.Length];  	ordinals.Length++;  } else {  	value = (value << 7) | (b & 0x7F);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,DocValuesOrdinalsReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\DocValuesOrdinalsReader.cs,Decode,The following statement contains a magic number: ordinals.Int32s [ordinals.Length] = ((value << 7) | b) + prev;  
Magic Number,Lucene.Net.Facet.Taxonomy,DocValuesOrdinalsReader,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\DocValuesOrdinalsReader.cs,Decode,The following statement contains a magic number: value = (value << 7) | (b & 0x7F);  
Magic Number,Lucene.Net.Facet.Taxonomy,FacetLabel,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FacetLabel.cs,CheckComponents,The following statement contains a magic number: if (len > MAX_CATEGORY_PATH_LENGTH) {  	throw new System.ArgumentException ("category path exceeds maximum allowed path length: max=" + MAX_CATEGORY_PATH_LENGTH + " len=" + len + " path=" + Arrays.ToString (Components).Substring (0' 30) + "...");  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FacetLabel,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FacetLabel.cs,CheckComponents,The following statement contains a magic number: throw new System.ArgumentException ("category path exceeds maximum allowed path length: max=" + MAX_CATEGORY_PATH_LENGTH + " len=" + len + " path=" + Arrays.ToString (Components).Substring (0' 30) + "...");  
Magic Number,Lucene.Net.Facet.Taxonomy,FacetLabel,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FacetLabel.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < Length; i++) {  	hash = hash * 31 + Components [i].GetHashCode ();  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FacetLabel,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FacetLabel.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + Components [i].GetHashCode ();  
Magic Number,Lucene.Net.Facet.Taxonomy,FacetLabel,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FacetLabel.cs,Int64HashCode,The following statement contains a magic number: for (int i = 0; i < Length; i++) {  	hash = hash * 65599 + Components [i].GetHashCode ();  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FacetLabel,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FacetLabel.cs,Int64HashCode,The following statement contains a magic number: hash = hash * 65599 + Components [i].GetHashCode ();  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	BytesRef bytesRef = new BytesRef ();  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		dv.Get (doc' bytesRef);  		var bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int ord = 0;  		int offset = bytesRef.Offset;  		int prev = 0;  		while (offset < end) {  			byte b = bytes [offset++];  			if ((sbyte)b >= 0) {  				prev = ord = ((ord << 7) | b) + prev;  				++m_values [ord];  				ord = 0;  			} else {  				ord = (ord << 7) | (b & 0x7F);  			}  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	BytesRef bytesRef = new BytesRef ();  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		dv.Get (doc' bytesRef);  		var bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int ord = 0;  		int offset = bytesRef.Offset;  		int prev = 0;  		while (offset < end) {  			byte b = bytes [offset++];  			if ((sbyte)b >= 0) {  				prev = ord = ((ord << 7) | b) + prev;  				++m_values [ord];  				ord = 0;  			} else {  				ord = (ord << 7) | (b & 0x7F);  			}  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	dv.Get (doc' bytesRef);  	var bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int ord = 0;  	int offset = bytesRef.Offset;  	int prev = 0;  	while (offset < end) {  		byte b = bytes [offset++];  		if ((sbyte)b >= 0) {  			prev = ord = ((ord << 7) | b) + prev;  			++m_values [ord];  			ord = 0;  		} else {  			ord = (ord << 7) | (b & 0x7F);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	dv.Get (doc' bytesRef);  	var bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int ord = 0;  	int offset = bytesRef.Offset;  	int prev = 0;  	while (offset < end) {  		byte b = bytes [offset++];  		if ((sbyte)b >= 0) {  			prev = ord = ((ord << 7) | b) + prev;  			++m_values [ord];  			ord = 0;  		} else {  			ord = (ord << 7) | (b & 0x7F);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: while (offset < end) {  	byte b = bytes [offset++];  	if ((sbyte)b >= 0) {  		prev = ord = ((ord << 7) | b) + prev;  		++m_values [ord];  		ord = 0;  	} else {  		ord = (ord << 7) | (b & 0x7F);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: while (offset < end) {  	byte b = bytes [offset++];  	if ((sbyte)b >= 0) {  		prev = ord = ((ord << 7) | b) + prev;  		++m_values [ord];  		ord = 0;  	} else {  		ord = (ord << 7) | (b & 0x7F);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: if ((sbyte)b >= 0) {  	prev = ord = ((ord << 7) | b) + prev;  	++m_values [ord];  	ord = 0;  } else {  	ord = (ord << 7) | (b & 0x7F);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: if ((sbyte)b >= 0) {  	prev = ord = ((ord << 7) | b) + prev;  	++m_values [ord];  	ord = 0;  } else {  	ord = (ord << 7) | (b & 0x7F);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: prev = ord = ((ord << 7) | b) + prev;  
Magic Number,Lucene.Net.Facet.Taxonomy,FastTaxonomyFacetCounts,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\FastTaxonomyFacetCounts.cs,Count,The following statement contains a magic number: ord = (ord << 7) | (b & 0x7F);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,Int32ToBytesRef,The following statement contains a magic number: bytes [0] = (byte)(v >> 24);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,Int32ToBytesRef,The following statement contains a magic number: bytes [1] = (byte)(v >> 16);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,Int32ToBytesRef,The following statement contains a magic number: bytes [2] = (byte)(v >> 8);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,Int32ToBytesRef,The following statement contains a magic number: bytes [2] = (byte)(v >> 8);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,Int32ToBytesRef,The following statement contains a magic number: bytes [3] = (byte)v;  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,BytesRefToInt32,The following statement contains a magic number: return ((b.Bytes [b.Offset] & 0xFF) << 24) | ((b.Bytes [b.Offset + 1] & 0xFF) << 16) | ((b.Bytes [b.Offset + 2] & 0xFF) << 8) | (b.Bytes [b.Offset + 3] & 0xFF);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,BytesRefToInt32,The following statement contains a magic number: return ((b.Bytes [b.Offset] & 0xFF) << 24) | ((b.Bytes [b.Offset + 1] & 0xFF) << 16) | ((b.Bytes [b.Offset + 2] & 0xFF) << 8) | (b.Bytes [b.Offset + 3] & 0xFF);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,BytesRefToInt32,The following statement contains a magic number: return ((b.Bytes [b.Offset] & 0xFF) << 24) | ((b.Bytes [b.Offset + 1] & 0xFF) << 16) | ((b.Bytes [b.Offset + 2] & 0xFF) << 8) | (b.Bytes [b.Offset + 3] & 0xFF);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,BytesRefToInt32,The following statement contains a magic number: return ((b.Bytes [b.Offset] & 0xFF) << 24) | ((b.Bytes [b.Offset + 1] & 0xFF) << 16) | ((b.Bytes [b.Offset + 2] & 0xFF) << 8) | (b.Bytes [b.Offset + 3] & 0xFF);  
Magic Number,Lucene.Net.Facet.Taxonomy,Int32AssociationFacetField,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\IntAssociationFacetField.cs,BytesRefToInt32,The following statement contains a magic number: return ((b.Bytes [b.Offset] & 0xFF) << 24) | ((b.Bytes [b.Offset + 1] & 0xFF) << 16) | ((b.Bytes [b.Offset + 2] & 0xFF) << 8) | (b.Bytes [b.Offset + 3] & 0xFF);  
Magic Number,Lucene.Net.Facet.Taxonomy,PrintTaxonomyStats,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\PrintTaxonomyStats.cs,Main,The following statement contains a magic number: if (args.Length != (printTree ? 2 : 1)) {  	// LUCENENET TODO: Usage depends on wrapping this into a console application assembly.  	Console.WriteLine ("\nUsage: java -classpath ... org.apache.lucene.facet.util.PrintTaxonomyStats [-printTree] /path/to/taxononmy/index\n");  	return 1;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += Number.Int32BitsToSingle (value);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += Number.Int32BitsToSingle (value);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += Number.Int32BitsToSingle (value);  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: offset += 4;  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumSingleAssociations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumFloatAssociations.cs,SumValues,The following statement contains a magic number: offset += 4;  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: foreach (FacetsCollector.MatchingDocs hits in matchingDocs) {  	BinaryDocValues dv = hits.Context.AtomicReader.GetBinaryDocValues (m_indexFieldName);  	if (dv == null)// this reader does not have DocValues for the requested category list  	 {  		continue;  	}  	DocIdSetIterator docs = hits.Bits.GetIterator ();  	int doc;  	while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  		//System.out.println("  doc=" + doc);  		// TODO: use OrdinalsReader?  we'd need to add a  		// BytesRef getAssociation()?  		BytesRef bytesRef = new BytesRef ();  		dv.Get (doc' bytesRef);  		byte[] bytes = bytesRef.Bytes;  		int end = bytesRef.Offset + bytesRef.Length;  		int offset = bytesRef.Offset;  		while (offset < end) {  			int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  			offset += 4;  			m_values [ord] += value;  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while ((doc = docs.NextDoc ()) != DocIdSetIterator.NO_MORE_DOCS) {  	//System.out.println("  doc=" + doc);  	// TODO: use OrdinalsReader?  we'd need to add a  	// BytesRef getAssociation()?  	BytesRef bytesRef = new BytesRef ();  	dv.Get (doc' bytesRef);  	byte[] bytes = bytesRef.Bytes;  	int end = bytesRef.Offset + bytesRef.Length;  	int offset = bytesRef.Offset;  	while (offset < end) {  		int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  		offset += 4;  		m_values [ord] += value;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: while (offset < end) {  	int ord = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	int value = ((bytes [offset] & 0xFF) << 24) | ((bytes [offset + 1] & 0xFF) << 16) | ((bytes [offset + 2] & 0xFF) << 8) | (bytes [offset + 3] & 0xFF);  	offset += 4;  	m_values [ord] += value;  }  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: offset += 4;  
Magic Number,Lucene.Net.Facet.Taxonomy,TaxonomyFacetSumInt32Associations,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\TaxonomyFacetSumIntAssociations.cs,SumValues,The following statement contains a magic number: offset += 4;  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,DirectoryTaxonomyWriter,The following statement contains a magic number: if (!DirectoryReader.IndexExists (directory)) {  	indexEpoch = 1;  } else {  	string epochStr = null;  	IDictionary<string' string> commitData = ReadCommitData (directory);  	if (commitData != null && commitData.ContainsKey (INDEX_EPOCH)) {  		epochStr = commitData [INDEX_EPOCH];  	}  	// no commit data' or no epoch in it means an old taxonomy' so set its epoch to 1' for lack  	// of a better value.  	indexEpoch = epochStr == null ? 1 : Convert.ToInt64 (epochStr' 16);  }  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,DirectoryTaxonomyWriter,The following statement contains a magic number: indexEpoch = epochStr == null ? 1 : Convert.ToInt64 (epochStr' 16);  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,DefaultTaxonomyWriterCache,The following statement contains a magic number: return new Cl2oTaxonomyWriterCache (1024' 0.15f' 3);  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,DefaultTaxonomyWriterCache,The following statement contains a magic number: return new Cl2oTaxonomyWriterCache (1024' 0.15f' 3);  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,Commit,The following statement contains a magic number: lock (this) {  	EnsureOpen ();  	// LUCENE-4972: if we always call setCommitData' we create empty commits  	string epochStr = null;  	indexWriter.CommitData.TryGetValue (INDEX_EPOCH' out epochStr);  	if (epochStr == null || Convert.ToInt64 (epochStr' 16) != indexEpoch) {  		indexWriter.SetCommitData (CombinedCommitData (indexWriter.CommitData));  	}  	indexWriter.Commit ();  }  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,Commit,The following statement contains a magic number: if (epochStr == null || Convert.ToInt64 (epochStr' 16) != indexEpoch) {  	indexWriter.SetCommitData (CombinedCommitData (indexWriter.CommitData));  }  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,CombinedCommitData,The following statement contains a magic number: m [INDEX_EPOCH] = Convert.ToString (indexEpoch' 16);  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,PrepareCommit,The following statement contains a magic number: lock (this) {  	EnsureOpen ();  	// LUCENE-4972: if we always call setCommitData' we create empty commits  	string epochStr;  	if (!indexWriter.CommitData.TryGetValue (INDEX_EPOCH' out epochStr) || epochStr == null || Convert.ToInt64 (epochStr' 16) != indexEpoch) {  		indexWriter.SetCommitData (CombinedCommitData (indexWriter.CommitData));  	}  	indexWriter.PrepareCommit ();  }  
Magic Number,Lucene.Net.Facet.Taxonomy.Directory,DirectoryTaxonomyWriter,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\Directory\DirectoryTaxonomyWriter.cs,PrepareCommit,The following statement contains a magic number: if (!indexWriter.CommitData.TryGetValue (INDEX_EPOCH' out epochStr) || epochStr == null || Convert.ToInt64 (epochStr' 16) != indexEpoch) {  	indexWriter.SetCommitData (CombinedCommitData (indexWriter.CommitData));  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CategoryPathUtils,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CategoryPathUtils.cs,HashCodeOfSerialized,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int len = charBlockArray [offset++];  	hash = hash * 31 + charBlockArray.SubSequence (offset' offset + len).GetHashCode ();  	offset += len;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CategoryPathUtils,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CategoryPathUtils.cs,HashCodeOfSerialized,The following statement contains a magic number: hash = hash * 31 + charBlockArray.SubSequence (offset' offset + len).GetHashCode ();  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,CollisionMap,The following statement contains a magic number: this.capacity = CompactLabelToOrdinal.DetermineCapacity (2' initialCapacity);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: if (this.entries != null) {  	foreach (Entry e in this.entries) {  		if (e != null) {  			memoryUsage += (4 * 4);  			for (Entry ee = e.next; ee != null; ee = ee.next) {  				memoryUsage += (4 * 4);  			}  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: if (this.entries != null) {  	foreach (Entry e in this.entries) {  		if (e != null) {  			memoryUsage += (4 * 4);  			for (Entry ee = e.next; ee != null; ee = ee.next) {  				memoryUsage += (4 * 4);  			}  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: if (this.entries != null) {  	foreach (Entry e in this.entries) {  		if (e != null) {  			memoryUsage += (4 * 4);  			for (Entry ee = e.next; ee != null; ee = ee.next) {  				memoryUsage += (4 * 4);  			}  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: if (this.entries != null) {  	foreach (Entry e in this.entries) {  		if (e != null) {  			memoryUsage += (4 * 4);  			for (Entry ee = e.next; ee != null; ee = ee.next) {  				memoryUsage += (4 * 4);  			}  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: foreach (Entry e in this.entries) {  	if (e != null) {  		memoryUsage += (4 * 4);  		for (Entry ee = e.next; ee != null; ee = ee.next) {  			memoryUsage += (4 * 4);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: foreach (Entry e in this.entries) {  	if (e != null) {  		memoryUsage += (4 * 4);  		for (Entry ee = e.next; ee != null; ee = ee.next) {  			memoryUsage += (4 * 4);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: foreach (Entry e in this.entries) {  	if (e != null) {  		memoryUsage += (4 * 4);  		for (Entry ee = e.next; ee != null; ee = ee.next) {  			memoryUsage += (4 * 4);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: foreach (Entry e in this.entries) {  	if (e != null) {  		memoryUsage += (4 * 4);  		for (Entry ee = e.next; ee != null; ee = ee.next) {  			memoryUsage += (4 * 4);  		}  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: if (e != null) {  	memoryUsage += (4 * 4);  	for (Entry ee = e.next; ee != null; ee = ee.next) {  		memoryUsage += (4 * 4);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: if (e != null) {  	memoryUsage += (4 * 4);  	for (Entry ee = e.next; ee != null; ee = ee.next) {  		memoryUsage += (4 * 4);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: if (e != null) {  	memoryUsage += (4 * 4);  	for (Entry ee = e.next; ee != null; ee = ee.next) {  		memoryUsage += (4 * 4);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: if (e != null) {  	memoryUsage += (4 * 4);  	for (Entry ee = e.next; ee != null; ee = ee.next) {  		memoryUsage += (4 * 4);  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: memoryUsage += (4 * 4);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: memoryUsage += (4 * 4);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: for (Entry ee = e.next; ee != null; ee = ee.next) {  	memoryUsage += (4 * 4);  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: for (Entry ee = e.next; ee != null; ee = ee.next) {  	memoryUsage += (4 * 4);  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: memoryUsage += (4 * 4);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CollisionMap,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CollisionMap.cs,GetMemoryUsage,The following statement contains a magic number: memoryUsage += (4 * 4);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,CompactLabelToOrdinal,The following statement contains a magic number: this.capacity = DetermineCapacity ((int)Math.Pow (2' numHashArrays)' initialCapacity);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Init,The following statement contains a magic number: for (int i = 0; i < this.hashArrays.Length; i++) {  	this.hashArrays [i] = new HashArray (c);  	c /= 2;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Init,The following statement contains a magic number: c /= 2;  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Grow,The following statement contains a magic number: this.capacity *= 2;  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,StringHashCode,The following statement contains a magic number: hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,StringHashCode,The following statement contains a magic number: hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,StringHashCode,The following statement contains a magic number: hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,StringHashCode,The following statement contains a magic number: hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,StringHashCode,The following statement contains a magic number: hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,StringHashCode,The following statement contains a magic number: hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,StringHashCode,The following statement contains a magic number: hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,StringHashCode,The following statement contains a magic number: hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: if (this.hashArrays != null) {  	// HashArray capacity is instance-specific.  	foreach (HashArray ha in this.hashArrays) {  		// Each has 2 capacity-length arrays of ints.  		memoryUsage += (ha.capacity * 2 * 4) + 4;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: if (this.hashArrays != null) {  	// HashArray capacity is instance-specific.  	foreach (HashArray ha in this.hashArrays) {  		// Each has 2 capacity-length arrays of ints.  		memoryUsage += (ha.capacity * 2 * 4) + 4;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: if (this.hashArrays != null) {  	// HashArray capacity is instance-specific.  	foreach (HashArray ha in this.hashArrays) {  		// Each has 2 capacity-length arrays of ints.  		memoryUsage += (ha.capacity * 2 * 4) + 4;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: foreach (HashArray ha in this.hashArrays) {  	// Each has 2 capacity-length arrays of ints.  	memoryUsage += (ha.capacity * 2 * 4) + 4;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: foreach (HashArray ha in this.hashArrays) {  	// Each has 2 capacity-length arrays of ints.  	memoryUsage += (ha.capacity * 2 * 4) + 4;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: foreach (HashArray ha in this.hashArrays) {  	// Each has 2 capacity-length arrays of ints.  	memoryUsage += (ha.capacity * 2 * 4) + 4;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: memoryUsage += (ha.capacity * 2 * 4) + 4;  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: memoryUsage += (ha.capacity * 2 * 4) + 4;  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: memoryUsage += (ha.capacity * 2 * 4) + 4;  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: if (this.labelRepository != null) {  	// All blocks are the same size.  	int blockSize = this.labelRepository.blockSize;  	// Each block has room for blockSize UTF-16 chars.  	int actualBlockSize = (blockSize * 2) + 4;  	memoryUsage += this.labelRepository.blocks.Count * actualBlockSize;  	memoryUsage += 8;  	// Two int values for array as a whole.  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: if (this.labelRepository != null) {  	// All blocks are the same size.  	int blockSize = this.labelRepository.blockSize;  	// Each block has room for blockSize UTF-16 chars.  	int actualBlockSize = (blockSize * 2) + 4;  	memoryUsage += this.labelRepository.blocks.Count * actualBlockSize;  	memoryUsage += 8;  	// Two int values for array as a whole.  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: if (this.labelRepository != null) {  	// All blocks are the same size.  	int blockSize = this.labelRepository.blockSize;  	// Each block has room for blockSize UTF-16 chars.  	int actualBlockSize = (blockSize * 2) + 4;  	memoryUsage += this.labelRepository.blocks.Count * actualBlockSize;  	memoryUsage += 8;  	// Two int values for array as a whole.  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,GetMemoryUsage,The following statement contains a magic number: memoryUsage += 8;  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: try {  	dis = new BinaryReader (new FileStream (file.FullName' FileMode.Open' FileAccess.Read));  	// TaxiReader needs to load the "counter" or occupancy (L2O) to know  	// the next unique facet. we used to load the delimiter too' but  	// never used it.  	l2o.m_counter = dis.ReadInt32 ();  	l2o.capacity = DetermineCapacity ((int)Math.Pow (2' l2o.hashArrays.Length)' l2o.m_counter);  	l2o.Init ();  	// now read the chars  	l2o.labelRepository = CharBlockArray.Open (dis.BaseStream);  	l2o.collisionMap = new CollisionMap (l2o.labelRepository);  	// Calculate hash on the fly based on how CategoryPath hashes  	// itself. Maybe in the future we can call some static based methods  	// in CategoryPath so that this doesn't break again? I don't like  	// having code in two different places...  	int cid = 0;  	// Skip the initial offset' it's the CategoryPath(0'0)' which isn't  	// a hashed value.  	int offset = 1;  	int lastStartOffset = offset;  	// This loop really relies on a well-formed input (assumes pretty blindly  	// that array offsets will work).  Since the initial file is machine   	// generated' I think this should be OK.  	while (offset < l2o.labelRepository.Length) {  		// identical code to CategoryPath.hashFromSerialized. since we need to  		// advance offset' we cannot call the method directly. perhaps if we  		// could pass a mutable Integer or something...  		int length = (ushort)l2o.labelRepository [offset++];  		int hash = length;  		if (length != 0) {  			for (int i = 0; i < length; i++) {  				int len = (ushort)l2o.labelRepository [offset++];  				hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  				offset += len;  			}  		}  		// Now that we've hashed the components of the label' do the  		// final part of the hash algorithm.  		hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  		hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  		// Add the label' and let's keep going  		l2o.AddLabelOffset (hash' cid' lastStartOffset);  		cid++;  		lastStartOffset = offset;  	}  } catch (SerializationException se) {  	throw new IOException ("Invalid file format. Cannot deserialize."' se);  } finally {  	if (dis != null) {  		dis.Dispose ();  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: try {  	dis = new BinaryReader (new FileStream (file.FullName' FileMode.Open' FileAccess.Read));  	// TaxiReader needs to load the "counter" or occupancy (L2O) to know  	// the next unique facet. we used to load the delimiter too' but  	// never used it.  	l2o.m_counter = dis.ReadInt32 ();  	l2o.capacity = DetermineCapacity ((int)Math.Pow (2' l2o.hashArrays.Length)' l2o.m_counter);  	l2o.Init ();  	// now read the chars  	l2o.labelRepository = CharBlockArray.Open (dis.BaseStream);  	l2o.collisionMap = new CollisionMap (l2o.labelRepository);  	// Calculate hash on the fly based on how CategoryPath hashes  	// itself. Maybe in the future we can call some static based methods  	// in CategoryPath so that this doesn't break again? I don't like  	// having code in two different places...  	int cid = 0;  	// Skip the initial offset' it's the CategoryPath(0'0)' which isn't  	// a hashed value.  	int offset = 1;  	int lastStartOffset = offset;  	// This loop really relies on a well-formed input (assumes pretty blindly  	// that array offsets will work).  Since the initial file is machine   	// generated' I think this should be OK.  	while (offset < l2o.labelRepository.Length) {  		// identical code to CategoryPath.hashFromSerialized. since we need to  		// advance offset' we cannot call the method directly. perhaps if we  		// could pass a mutable Integer or something...  		int length = (ushort)l2o.labelRepository [offset++];  		int hash = length;  		if (length != 0) {  			for (int i = 0; i < length; i++) {  				int len = (ushort)l2o.labelRepository [offset++];  				hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  				offset += len;  			}  		}  		// Now that we've hashed the components of the label' do the  		// final part of the hash algorithm.  		hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  		hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  		// Add the label' and let's keep going  		l2o.AddLabelOffset (hash' cid' lastStartOffset);  		cid++;  		lastStartOffset = offset;  	}  } catch (SerializationException se) {  	throw new IOException ("Invalid file format. Cannot deserialize."' se);  } finally {  	if (dis != null) {  		dis.Dispose ();  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: try {  	dis = new BinaryReader (new FileStream (file.FullName' FileMode.Open' FileAccess.Read));  	// TaxiReader needs to load the "counter" or occupancy (L2O) to know  	// the next unique facet. we used to load the delimiter too' but  	// never used it.  	l2o.m_counter = dis.ReadInt32 ();  	l2o.capacity = DetermineCapacity ((int)Math.Pow (2' l2o.hashArrays.Length)' l2o.m_counter);  	l2o.Init ();  	// now read the chars  	l2o.labelRepository = CharBlockArray.Open (dis.BaseStream);  	l2o.collisionMap = new CollisionMap (l2o.labelRepository);  	// Calculate hash on the fly based on how CategoryPath hashes  	// itself. Maybe in the future we can call some static based methods  	// in CategoryPath so that this doesn't break again? I don't like  	// having code in two different places...  	int cid = 0;  	// Skip the initial offset' it's the CategoryPath(0'0)' which isn't  	// a hashed value.  	int offset = 1;  	int lastStartOffset = offset;  	// This loop really relies on a well-formed input (assumes pretty blindly  	// that array offsets will work).  Since the initial file is machine   	// generated' I think this should be OK.  	while (offset < l2o.labelRepository.Length) {  		// identical code to CategoryPath.hashFromSerialized. since we need to  		// advance offset' we cannot call the method directly. perhaps if we  		// could pass a mutable Integer or something...  		int length = (ushort)l2o.labelRepository [offset++];  		int hash = length;  		if (length != 0) {  			for (int i = 0; i < length; i++) {  				int len = (ushort)l2o.labelRepository [offset++];  				hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  				offset += len;  			}  		}  		// Now that we've hashed the components of the label' do the  		// final part of the hash algorithm.  		hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  		hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  		// Add the label' and let's keep going  		l2o.AddLabelOffset (hash' cid' lastStartOffset);  		cid++;  		lastStartOffset = offset;  	}  } catch (SerializationException se) {  	throw new IOException ("Invalid file format. Cannot deserialize."' se);  } finally {  	if (dis != null) {  		dis.Dispose ();  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: try {  	dis = new BinaryReader (new FileStream (file.FullName' FileMode.Open' FileAccess.Read));  	// TaxiReader needs to load the "counter" or occupancy (L2O) to know  	// the next unique facet. we used to load the delimiter too' but  	// never used it.  	l2o.m_counter = dis.ReadInt32 ();  	l2o.capacity = DetermineCapacity ((int)Math.Pow (2' l2o.hashArrays.Length)' l2o.m_counter);  	l2o.Init ();  	// now read the chars  	l2o.labelRepository = CharBlockArray.Open (dis.BaseStream);  	l2o.collisionMap = new CollisionMap (l2o.labelRepository);  	// Calculate hash on the fly based on how CategoryPath hashes  	// itself. Maybe in the future we can call some static based methods  	// in CategoryPath so that this doesn't break again? I don't like  	// having code in two different places...  	int cid = 0;  	// Skip the initial offset' it's the CategoryPath(0'0)' which isn't  	// a hashed value.  	int offset = 1;  	int lastStartOffset = offset;  	// This loop really relies on a well-formed input (assumes pretty blindly  	// that array offsets will work).  Since the initial file is machine   	// generated' I think this should be OK.  	while (offset < l2o.labelRepository.Length) {  		// identical code to CategoryPath.hashFromSerialized. since we need to  		// advance offset' we cannot call the method directly. perhaps if we  		// could pass a mutable Integer or something...  		int length = (ushort)l2o.labelRepository [offset++];  		int hash = length;  		if (length != 0) {  			for (int i = 0; i < length; i++) {  				int len = (ushort)l2o.labelRepository [offset++];  				hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  				offset += len;  			}  		}  		// Now that we've hashed the components of the label' do the  		// final part of the hash algorithm.  		hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  		hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  		// Add the label' and let's keep going  		l2o.AddLabelOffset (hash' cid' lastStartOffset);  		cid++;  		lastStartOffset = offset;  	}  } catch (SerializationException se) {  	throw new IOException ("Invalid file format. Cannot deserialize."' se);  } finally {  	if (dis != null) {  		dis.Dispose ();  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: try {  	dis = new BinaryReader (new FileStream (file.FullName' FileMode.Open' FileAccess.Read));  	// TaxiReader needs to load the "counter" or occupancy (L2O) to know  	// the next unique facet. we used to load the delimiter too' but  	// never used it.  	l2o.m_counter = dis.ReadInt32 ();  	l2o.capacity = DetermineCapacity ((int)Math.Pow (2' l2o.hashArrays.Length)' l2o.m_counter);  	l2o.Init ();  	// now read the chars  	l2o.labelRepository = CharBlockArray.Open (dis.BaseStream);  	l2o.collisionMap = new CollisionMap (l2o.labelRepository);  	// Calculate hash on the fly based on how CategoryPath hashes  	// itself. Maybe in the future we can call some static based methods  	// in CategoryPath so that this doesn't break again? I don't like  	// having code in two different places...  	int cid = 0;  	// Skip the initial offset' it's the CategoryPath(0'0)' which isn't  	// a hashed value.  	int offset = 1;  	int lastStartOffset = offset;  	// This loop really relies on a well-formed input (assumes pretty blindly  	// that array offsets will work).  Since the initial file is machine   	// generated' I think this should be OK.  	while (offset < l2o.labelRepository.Length) {  		// identical code to CategoryPath.hashFromSerialized. since we need to  		// advance offset' we cannot call the method directly. perhaps if we  		// could pass a mutable Integer or something...  		int length = (ushort)l2o.labelRepository [offset++];  		int hash = length;  		if (length != 0) {  			for (int i = 0; i < length; i++) {  				int len = (ushort)l2o.labelRepository [offset++];  				hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  				offset += len;  			}  		}  		// Now that we've hashed the components of the label' do the  		// final part of the hash algorithm.  		hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  		hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  		// Add the label' and let's keep going  		l2o.AddLabelOffset (hash' cid' lastStartOffset);  		cid++;  		lastStartOffset = offset;  	}  } catch (SerializationException se) {  	throw new IOException ("Invalid file format. Cannot deserialize."' se);  } finally {  	if (dis != null) {  		dis.Dispose ();  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: try {  	dis = new BinaryReader (new FileStream (file.FullName' FileMode.Open' FileAccess.Read));  	// TaxiReader needs to load the "counter" or occupancy (L2O) to know  	// the next unique facet. we used to load the delimiter too' but  	// never used it.  	l2o.m_counter = dis.ReadInt32 ();  	l2o.capacity = DetermineCapacity ((int)Math.Pow (2' l2o.hashArrays.Length)' l2o.m_counter);  	l2o.Init ();  	// now read the chars  	l2o.labelRepository = CharBlockArray.Open (dis.BaseStream);  	l2o.collisionMap = new CollisionMap (l2o.labelRepository);  	// Calculate hash on the fly based on how CategoryPath hashes  	// itself. Maybe in the future we can call some static based methods  	// in CategoryPath so that this doesn't break again? I don't like  	// having code in two different places...  	int cid = 0;  	// Skip the initial offset' it's the CategoryPath(0'0)' which isn't  	// a hashed value.  	int offset = 1;  	int lastStartOffset = offset;  	// This loop really relies on a well-formed input (assumes pretty blindly  	// that array offsets will work).  Since the initial file is machine   	// generated' I think this should be OK.  	while (offset < l2o.labelRepository.Length) {  		// identical code to CategoryPath.hashFromSerialized. since we need to  		// advance offset' we cannot call the method directly. perhaps if we  		// could pass a mutable Integer or something...  		int length = (ushort)l2o.labelRepository [offset++];  		int hash = length;  		if (length != 0) {  			for (int i = 0; i < length; i++) {  				int len = (ushort)l2o.labelRepository [offset++];  				hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  				offset += len;  			}  		}  		// Now that we've hashed the components of the label' do the  		// final part of the hash algorithm.  		hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  		hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  		// Add the label' and let's keep going  		l2o.AddLabelOffset (hash' cid' lastStartOffset);  		cid++;  		lastStartOffset = offset;  	}  } catch (SerializationException se) {  	throw new IOException ("Invalid file format. Cannot deserialize."' se);  } finally {  	if (dis != null) {  		dis.Dispose ();  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: l2o.capacity = DetermineCapacity ((int)Math.Pow (2' l2o.hashArrays.Length)' l2o.m_counter);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: while (offset < l2o.labelRepository.Length) {  	// identical code to CategoryPath.hashFromSerialized. since we need to  	// advance offset' we cannot call the method directly. perhaps if we  	// could pass a mutable Integer or something...  	int length = (ushort)l2o.labelRepository [offset++];  	int hash = length;  	if (length != 0) {  		for (int i = 0; i < length; i++) {  			int len = (ushort)l2o.labelRepository [offset++];  			hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  			offset += len;  		}  	}  	// Now that we've hashed the components of the label' do the  	// final part of the hash algorithm.  	hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  	hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  	// Add the label' and let's keep going  	l2o.AddLabelOffset (hash' cid' lastStartOffset);  	cid++;  	lastStartOffset = offset;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: while (offset < l2o.labelRepository.Length) {  	// identical code to CategoryPath.hashFromSerialized. since we need to  	// advance offset' we cannot call the method directly. perhaps if we  	// could pass a mutable Integer or something...  	int length = (ushort)l2o.labelRepository [offset++];  	int hash = length;  	if (length != 0) {  		for (int i = 0; i < length; i++) {  			int len = (ushort)l2o.labelRepository [offset++];  			hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  			offset += len;  		}  	}  	// Now that we've hashed the components of the label' do the  	// final part of the hash algorithm.  	hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  	hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  	// Add the label' and let's keep going  	l2o.AddLabelOffset (hash' cid' lastStartOffset);  	cid++;  	lastStartOffset = offset;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: while (offset < l2o.labelRepository.Length) {  	// identical code to CategoryPath.hashFromSerialized. since we need to  	// advance offset' we cannot call the method directly. perhaps if we  	// could pass a mutable Integer or something...  	int length = (ushort)l2o.labelRepository [offset++];  	int hash = length;  	if (length != 0) {  		for (int i = 0; i < length; i++) {  			int len = (ushort)l2o.labelRepository [offset++];  			hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  			offset += len;  		}  	}  	// Now that we've hashed the components of the label' do the  	// final part of the hash algorithm.  	hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  	hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  	// Add the label' and let's keep going  	l2o.AddLabelOffset (hash' cid' lastStartOffset);  	cid++;  	lastStartOffset = offset;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: while (offset < l2o.labelRepository.Length) {  	// identical code to CategoryPath.hashFromSerialized. since we need to  	// advance offset' we cannot call the method directly. perhaps if we  	// could pass a mutable Integer or something...  	int length = (ushort)l2o.labelRepository [offset++];  	int hash = length;  	if (length != 0) {  		for (int i = 0; i < length; i++) {  			int len = (ushort)l2o.labelRepository [offset++];  			hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  			offset += len;  		}  	}  	// Now that we've hashed the components of the label' do the  	// final part of the hash algorithm.  	hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  	hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  	// Add the label' and let's keep going  	l2o.AddLabelOffset (hash' cid' lastStartOffset);  	cid++;  	lastStartOffset = offset;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: while (offset < l2o.labelRepository.Length) {  	// identical code to CategoryPath.hashFromSerialized. since we need to  	// advance offset' we cannot call the method directly. perhaps if we  	// could pass a mutable Integer or something...  	int length = (ushort)l2o.labelRepository [offset++];  	int hash = length;  	if (length != 0) {  		for (int i = 0; i < length; i++) {  			int len = (ushort)l2o.labelRepository [offset++];  			hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  			offset += len;  		}  	}  	// Now that we've hashed the components of the label' do the  	// final part of the hash algorithm.  	hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  	hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  	// Add the label' and let's keep going  	l2o.AddLabelOffset (hash' cid' lastStartOffset);  	cid++;  	lastStartOffset = offset;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: if (length != 0) {  	for (int i = 0; i < length; i++) {  		int len = (ushort)l2o.labelRepository [offset++];  		hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  		offset += len;  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int len = (ushort)l2o.labelRepository [offset++];  	hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  	offset += len;  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: hash = hash * 31 + l2o.labelRepository.SubSequence (offset' offset + len).GetHashCode ();  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: hash = hash ^ (((int)((uint)hash >> 20)) ^ ((int)((uint)hash >> 12)));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,CompactLabelToOrdinal,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\CompactLabelToOrdinal.cs,Open,The following statement contains a magic number: hash = hash ^ ((int)((uint)hash >> 7)) ^ ((int)((uint)hash >> 4));  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,NameInt32CacheLRU,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\NameIntCacheLRU.cs,CreateCache,The following statement contains a magic number: if (maxSize < int.MaxValue) {  	cache = new LurchTable<object' int> (1000' LurchTableOrder.Access);  	//for LRU  } else {  	cache = new Dictionary<object' int> (1000);  	//no need for LRU  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,NameInt32CacheLRU,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\NameIntCacheLRU.cs,CreateCache,The following statement contains a magic number: if (maxSize < int.MaxValue) {  	cache = new LurchTable<object' int> (1000' LurchTableOrder.Access);  	//for LRU  } else {  	cache = new Dictionary<object' int> (1000);  	//no need for LRU  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,NameInt32CacheLRU,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\NameIntCacheLRU.cs,CreateCache,The following statement contains a magic number: cache = new LurchTable<object' int> (1000' LurchTableOrder.Access);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,NameInt32CacheLRU,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\NameIntCacheLRU.cs,CreateCache,The following statement contains a magic number: cache = new Dictionary<object' int> (1000);  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,NameInt32CacheLRU,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\NameIntCacheLRU.cs,MakeRoomLRU,The following statement contains a magic number: lock (this) {  	// Double-check that another thread didn't beat us to the operation  	n = cache.Count - (2 * maxCacheSize) / 3;  	if (n <= 0) {  		return false;  	}  	//System.Diagnostics.Debug.WriteLine("Removing cache entries in MakeRoomLRU");  	// LUCENENET: Loop in reverse so we can safely delete  	// a range of items (0 - n) without a   	// "Collection was modified" conflict  	for (int i = n - 1; i >= 0; i--) {  		cache.Remove (cache.Keys.ElementAt (i));  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,NameInt32CacheLRU,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\NameIntCacheLRU.cs,MakeRoomLRU,The following statement contains a magic number: lock (this) {  	// Double-check that another thread didn't beat us to the operation  	n = cache.Count - (2 * maxCacheSize) / 3;  	if (n <= 0) {  		return false;  	}  	//System.Diagnostics.Debug.WriteLine("Removing cache entries in MakeRoomLRU");  	// LUCENENET: Loop in reverse so we can safely delete  	// a range of items (0 - n) without a   	// "Collection was modified" conflict  	for (int i = n - 1; i >= 0; i--) {  		cache.Remove (cache.Keys.ElementAt (i));  	}  }  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,NameInt32CacheLRU,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\NameIntCacheLRU.cs,MakeRoomLRU,The following statement contains a magic number: n = cache.Count - (2 * maxCacheSize) / 3;  
Magic Number,Lucene.Net.Facet.Taxonomy.WriterCache,NameInt32CacheLRU,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Facet\Taxonomy\WriterCache\NameIntCacheLRU.cs,MakeRoomLRU,The following statement contains a magic number: n = cache.Count - (2 * maxCacheSize) / 3;  
