Implementation smell,Namespace,Class,File,Method,Description
Long Method,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The method has 258 lines of code.
Long Method,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The method has 208 lines of code.
Long Method,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The method has 148 lines of code.
Long Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The method has 156 lines of code.
Long Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The method has 156 lines of code.
Long Method,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The method has 133 lines of code.
Long Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The method has 111 lines of code.
Long Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The method has 100 lines of code.
Long Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The method has 108 lines of code.
Long Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The method has 128 lines of code.
Complex Method,Lucene.Net.Util.Automaton,TestCompiledAutomaton,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestCompiledAutomaton.cs,TestTerms,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,GetTDistance,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,TestOne,Cyclomatic complexity of the method is 11
Complex Method,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,Cyclomatic complexity of the method is 33
Complex Method,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,Cyclomatic complexity of the method is 32
Complex Method,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,Cyclomatic complexity of the method is 21
Complex Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,DoTest,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,Cyclomatic complexity of the method is 22
Complex Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,Cyclomatic complexity of the method is 23
Complex Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRandomTermLookup,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsRandom,Cyclomatic complexity of the method is 13
Complex Method,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFSTRandom,Cyclomatic complexity of the method is 13
Complex Method,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,Cyclomatic complexity of the method is 21
Complex Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,Cyclomatic complexity of the method is 11
Complex Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomBulkCopy,Cyclomatic complexity of the method is 11
Complex Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,CreatePackedInts,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,Cyclomatic complexity of the method is 12
Complex Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,Cyclomatic complexity of the method is 20
Complex Method,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,Cyclomatic complexity of the method is 14
Long Parameter List,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,TestOne,The method has 5 parameters. Parameters: r' a' startCode' endCode' iters
Long Parameter List,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,VisitTerms,The method has 7 parameters. Parameters: dirOut' wordsFileIn' inputMode' prune' outputs' doPack' noArcArrays
Long Parameter List,Lucene.Net.Util.Fst,VisitTermsAnonymousInnerClassHelper,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,VisitTermsAnonymousInnerClassHelper,The method has 7 parameters. Parameters: dirOut' wordsFileIn' inputMode' prune' outputs' doPack' noArcArrays
Long Parameter List,Lucene.Net.Util.Fst,VisitTermsAnonymousInnerClassHelper2,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,VisitTermsAnonymousInnerClassHelper2,The method has 7 parameters. Parameters: dirOut' wordsFileIn' inputMode' prune' outputs' doPack' noArcArrays
Long Parameter List,Lucene.Net.Util.Fst,VisitTermsAnonymousInnerClassHelper3,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,VisitTermsAnonymousInnerClassHelper3,The method has 7 parameters. Parameters: dirOut' wordsFileIn' inputMode' prune' outputs' doPack' noArcArrays
Long Parameter List,Lucene.Net.Util.Fst,VisitTermsAnonymousInnerClassHelper4,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,VisitTermsAnonymousInnerClassHelper4,The method has 8 parameters. Parameters: dirOut' wordsFileIn' inputMode' prune' outputs' doPack' noArcArrays' NO_OUTPUT
Long Parameter List,Lucene.Net.Util.Fst,SyntheticData,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Generate,The method has 5 parameters. Parameters: out' b' from' to' depth
Long Statement,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestIntermediateMerges,The length of the statement  "            OfflineSorter.SortInfo info = CheckSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARER' OfflineSorter.BufferSize.Megabytes(1)' OfflineSorter.DefaultTempDir()' 2)' GenerateRandom((int)OfflineSorter.MB * 20)); " is 209.
Long Statement,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestSmallRandom,The length of the statement  "            OfflineSorter.SortInfo sortInfo = CheckSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARER' OfflineSorter.BufferSize.Megabytes(1)' OfflineSorter.DefaultTempDir()' OfflineSorter.MAX_TEMPFILES)' GenerateRandom((int)OfflineSorter.MB * 20)); " is 239.
Long Statement,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestLargerRandom,The length of the statement  "            CheckSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARER' OfflineSorter.BufferSize.Megabytes(16)' OfflineSorter.DefaultTempDir()' OfflineSorter.MAX_TEMPFILES)' GenerateRandom((int)OfflineSorter.MB * 100)); " is 207.
Long Statement,Lucene.Net.Util.Automaton,TestBasicOperations,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestBasicOperations.cs,TestGetRandomAcceptedString,The length of the statement  "                        throw; // LUCENENET: CA2200: Rethrow to preserve stack details (https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2200-rethrow-to-preserve-stack-details) " is 164.
Long Statement,Lucene.Net.Util.Automaton,TestCompiledAutomaton,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestCompiledAutomaton.cs,TestFloor,The length of the statement  "                Assert.AreEqual(result' new BytesRef(expected)' "actual=" + result.Utf8ToString() + " vs expected=" + expected + " (input=" + input + ")"); " is 139.
Long Statement,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,TestOne,The length of the statement  "                    if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) | (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) " is 166.
Long Statement,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,AssertAutomaton,The length of the statement  "                        throw; // LUCENENET: CA2200: Rethrow to preserve stack details (https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2200-rethrow-to-preserve-stack-details) " is 164.
Long Statement,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The length of the statement  "                    Builder<object> b = new Builder<object>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' doPack' PackedInt32s.COMPACT' true' 15); " is 149.
Long Statement,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The length of the statement  "                        Console.WriteLine("\nTEST: now verify [fst size=" + fst.GetSizeInBytes() + "; nodeCount=" + fst.NodeCount + "; arcCount=" + fst.ArcCount + "]"); " is 144.
Long Statement,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The length of the statement  "                    Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' doPack' PackedInt32s.COMPACT' true' 15); " is 153.
Long Statement,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The length of the statement  "                        Console.WriteLine("\nTEST: now verify [fst size=" + fst.GetSizeInBytes() + "; nodeCount=" + fst.NodeCount + "; arcCount=" + fst.ArcCount + "]"); " is 144.
Long Statement,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The length of the statement  "                    Builder<long?> b = new Builder<long?>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' doPack' PackedInt32s.COMPACT' true' 15); " is 147.
Long Statement,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The length of the statement  "                        Console.WriteLine("\nTEST: now verify [fst size=" + fst.GetSizeInBytes() + "; nodeCount=" + fst.NodeCount + "; arcCount=" + fst.ArcCount + "]"); " is 144.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The length of the statement  "            string[] strings = new string[] { "station"' "commotion"' "elation"' "elastic"' "plastic"' "stop"' "ftop"' "ftation"' "stat" }; " is 127.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The length of the statement  "            string[] strings2 = new string[] { "station"' "commotion"' "elation"' "elastic"' "plastic"' "stop"' "ftop"' "ftation" }; " is 120.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The length of the statement  "            IndexWriterConfig conf = NewIndexWriterConfig(TEST_VERSION_CURRENT' analyzer).SetMaxBufferedDocs(-1).SetRAMBufferSizeMB(64); " is 124.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The length of the statement  "            Builder<long?> builder = new Builder<long?>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' doRewrite' PackedInt32s.DEFAULT' true' 15); " is 156.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The length of the statement  "                    Console.WriteLine("FST: " + docCount + " docs; " + ord + " terms; " + fst.NodeCount + " nodes; " + fst.ArcCount + " arcs;" + " " + fst.GetSizeInBytes() + " bytes"); " is 164.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The length of the statement  "                            Assert.IsNull(fstSeekResult' "got " + (fstSeekResult == null ? "null" : fstSeekResult.Input.Utf8ToString()) + " but expected null"); " is 132.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The length of the statement  "                                        Console.WriteLine("expected null but got: input=" + nextResult.Input.Utf8ToString() + " output=" + outputs.OutputToString(nextResult.Output)); " is 142.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,AssertSame,The length of the statement  "                Assert.AreEqual(termsEnum.Term' fstEnum.Current.Input' termsEnum.Term.Utf8ToString() + " != " + fstEnum.Current.Input.Utf8ToString()); " is 134.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,AssertSame,The length of the statement  "                    Assert.AreEqual(termsEnum.DocFreq' fstEnum.Current.Output' "term=" + termsEnum.Term.Utf8ToString() + " " + termsEnum.Term); " is 123.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The length of the statement  "                RandomIndexWriter w = new RandomIndexWriter(Random' dir' NewIndexWriterConfig(TEST_VERSION_CURRENT' new MockAnalyzer(Random)).SetOpenMode(OpenMode.CREATE)); " is 156.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The length of the statement  "                    Assert.AreEqual(exists ? 1 : 0' idxS.Search(new TermQuery(new Term("id"' id))' 1).TotalHits' (exists ? "" : "non-exist ") + "id=" + id); " is 136.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The length of the statement  "                        Assert.AreEqual(new BytesRef(nextID)' termsEnum.Term' "expected=" + nextID + " actual=" + termsEnum.Term.Utf8ToString()); " is 121.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRandomTermLookup,The length of the statement  "            RandomIndexWriter w = new RandomIndexWriter(Random' dir' NewIndexWriterConfig(TEST_VERSION_CURRENT' new MockAnalyzer(Random)) " is 125.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestFinalOutputOnEndState,The length of the statement  "            Builder<long?> builder = new Builder<long?>(FST.INPUT_TYPE.BYTE4' 2' 0' true' true' int.MaxValue' outputs' null' Random.NextBoolean()' PackedInt32s.DEFAULT' true' 15); " is 167.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestInternalFinalState,The length of the statement  "            Builder<long?> builder = new Builder<long?>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' willRewrite' PackedInt32s.DEFAULT' true' 15); " is 158.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The length of the statement  "            Util.TopResults<long?> res = Util.ShortestPaths(fst' fst.GetFirstArc(new FST.Arc<long?>())' outputs.NoOutput' minLongComparer' 3' true); " is 136.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The length of the statement  "            PairOutputs<long?' long?> outputs = new PairOutputs<long?' long?>(PositiveInt32Outputs.Singleton' PositiveInt32Outputs.Singleton); // output -  weight " is 150.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The length of the statement  "            Util.TopResults<Pair> res = Util.ShortestPaths(fst' fst.GetFirstArc(new FST.Arc<Pair>())' outputs.NoOutput' minPairWeightComparer' 3' true); " is 140.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsRandom,The length of the statement  "                        matches.Add(new Util.Result<long?>(Util.ToInt32sRef(new BytesRef(e.Key.Substring(prefix.Length))' new Int32sRef())' e.Value - prefixOutput)); " is 141.
Long Statement,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFSTRandom,The length of the statement  "            PairOutputs<long?' long?> outputs = new PairOutputs<long?' long?>(PositiveInt32Outputs.Singleton' PositiveInt32Outputs.Singleton); // output -  weight " is 150.
Long Statement,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The length of the statement  "                            Console.WriteLine(string.Format(CultureInfo.InvariantCulture' "{0:000000.000}s: {1:000000000}..."' ((Environment.TickCount - tStart) / 1000.0)' ord)); " is 150.
Long Statement,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The length of the statement  "                    Console.WriteLine(ord + " terms; " + fst.NodeCount + " nodes; " + fst.ArcCount + " arcs; " + fst.ArcWithOutputCount + " arcs w/ output; tot size " + fst.GetSizeInBytes()); " is 171.
Long Statement,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The length of the statement  "                                        throw new Exception("wrong output (got " + Outputs.OutputToString(actual) + " but expected " + Outputs.OutputToString(expected) + ") on input=" + w); " is 149.
Long Statement,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The length of the statement  "                            Console.WriteLine("Verify " + (iter == 1 ? "(by output) " : "") + "took " + totSec + " sec + (" + (int)((totSec * 1000000000 / ord)) + " nsec per lookup)"); " is 156.
Long Statement,Lucene.Net.Util.Fst,SyntheticData,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,VerifyStateAndBelow,The length of the statement  "                        Assert.AreEqual(expanded' (depth <= FST.FIXED_ARRAY_SHALLOW_DISTANCE && children >= FST.FIXED_ARRAY_NUM_ARCS_SHALLOW) || children >= FST.FIXED_ARRAY_NUM_ARCS_DEEP); " is 164.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The length of the statement  "                        CodecUtil.CheckHeader(@in' PackedInt32s.CODEC_NAME' PackedInt32s.VERSION_START' PackedInt32s.VERSION_CURRENT); // codec header " is 126.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The length of the statement  "                            Assert.AreEqual(values[i]' r.Get(i)' "index=" + i + " valueCount=" + valueCount + " nbits=" + nbits + " for " + r.GetType().Name); " is 130.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The length of the statement  "                        Assert.AreEqual(expectedBytesUsed' computedBytesUsed' r.GetType() + "expected " + expectedBytesUsed + "' got: " + computedBytesUsed); " is 133.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The length of the statement  "                            Assert.AreEqual(values[i]' r.Next()' "index=" + i + " valueCount=" + valueCount + " nbits=" + nbits + " for " + r.GetType().Name); " is 130.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The length of the statement  "                                Assert.AreEqual(values[i + k]' next.Int64s[next.Offset + k]' "index=" + i + " valueCount=" + valueCount + " nbits=" + nbits + " for " + r.GetType().Name); " is 154.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEndPointer,The length of the statement  "                        PackedInt32s.IReaderIterator it = PackedInt32s.GetReaderIteratorNoHeader(@in' format' version' valueCount' bpv' RandomInts.RandomInt32Between(Random' 1' 1 << 16)); " is 163.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,AssertRandomEquality,The length of the statement  "                    Assert.Fail(string.Format(CultureInfo.InvariantCulture' "Exception while filling {0}: valueCount={1}' bitsPerValue={2}"' packedInt.GetType().Name' valueCount' bitsPerValue)); " is 174.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,Fill,The length of the statement  "                Assert.AreEqual(value' packedInt.Get(i)' string.Format(CultureInfo.InvariantCulture' "The set/get of the value at index {0} should match for {1}"' i' packedInt.GetType().Name)); " is 177.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,AssertListEquality,The length of the statement  "                    Assert.AreEqual( @base.Get(i)' packedInts[j].Get(i)' string.Format(CultureInfo.InvariantCulture' "{0}. The value at index {1} should be the same for {2} and {3}"' message' i' @base.GetType().Name' packedInts[j].GetType().Name)); " is 228.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The length of the statement  "                Assert.AreEqual(1' p64sb.Get(INDEX - 1)' "The value at position " + (INDEX - 1) + " should be correct for " + p64sb.GetType().Name); " is 132.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The length of the statement  "                Assert.AreEqual(1' p8.Get(index - 1)' "The value at position " + (index - 1) + " should be correct for Packed8ThreeBlocks"); " is 124.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The length of the statement  "                Assert.AreEqual(1' p16.Get(index - 1)' "The value at position " + (index - 1) + " should be correct for Packed16ThreeBlocks"); " is 126.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The length of the statement  "            PagedGrowableWriter writer = new PagedGrowableWriter(0' pageSize' TestUtil.NextInt32(Random' 1' 64)' Random.NextSingle()); " is 122.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The length of the statement  "                    Assert.AreEqual(Arrays.CopyOfRange(blocks' blocksOffset' blocks.Length)' Arrays.CopyOfRange(blocks2' blocksOffset2' blocks2.Length)' msg); " is 138.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The length of the statement  "                BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(@in' PackedInt32s.VERSION_CURRENT' blockSize' valueCount); " is 120.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The length of the statement  "                assertEquals(fp' @in is ByteArrayDataInput ? ((ByteArrayDataInput)@in).Position : (((IndexInput)@in).GetFilePointer())); " is 120.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The length of the statement  "                BlockPackedReader reader = new BlockPackedReader(in1' PackedInt32s.VERSION_CURRENT' blockSize' valueCount' Random.NextBoolean()); " is 129.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The length of the statement  "                MonotonicBlockPackedReader reader = new MonotonicBlockPackedReader(@in' PackedInt32s.VERSION_CURRENT' blockSize' valueCount' Random.NextBoolean()); " is 147.
Long Statement,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockReaderOverflow,The length of the statement  "            BlockPackedReader reader = new BlockPackedReader(@in' PackedInt32s.VERSION_CURRENT' blockSize' valueCount' Random.NextBoolean()); " is 129.
Complex Conditional,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,GetTDistance,The conditional expression  "i > 1 && j > 1 && target[i - 1] == other[j - 2] && target[i - 2] == other[j - 1]"  is complex.
Complex Conditional,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockReaderOverflow,The conditional expression  "(i & (blockSize - 1)) == 0 && (i + blockSize < valueOffset || i > valueOffset && i + blockSize < valueCount)"  is complex.
Empty Catch Block,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestRamBuffer,The method has an empty catch block.
Empty Catch Block,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestRamBuffer,The method has an empty catch block.
Empty Catch Block,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestRamBuffer,The method has an empty catch block.
Empty Catch Block,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The method has an empty catch block.
Empty Catch Block,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The method has an empty catch block.
Empty Catch Block,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The method has an empty catch block.
Empty Catch Block,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The method has an empty catch block.
Empty Catch Block,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The method has an empty catch block.
Empty Catch Block,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The method has an empty catch block.
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestIntermediateMerges,The following statement contains a magic number: OfflineSorter.SortInfo info = CheckSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARER' OfflineSorter.BufferSize.Megabytes(1)' OfflineSorter.DefaultTempDir()' 2)' GenerateRandom((int)OfflineSorter.MB * 20));
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestIntermediateMerges,The following statement contains a magic number: OfflineSorter.SortInfo info = CheckSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARER' OfflineSorter.BufferSize.Megabytes(1)' OfflineSorter.DefaultTempDir()' 2)' GenerateRandom((int)OfflineSorter.MB * 20));
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestIntermediateMerges,The following statement contains a magic number: Assert.IsTrue(info.MergeRounds > 10);
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestSmallRandom,The following statement contains a magic number: OfflineSorter.SortInfo sortInfo = CheckSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARER' OfflineSorter.BufferSize.Megabytes(1)' OfflineSorter.DefaultTempDir()' OfflineSorter.MAX_TEMPFILES)' GenerateRandom((int)OfflineSorter.MB * 20));
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestLargerRandom,The following statement contains a magic number: CheckSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARER' OfflineSorter.BufferSize.Megabytes(16)' OfflineSorter.DefaultTempDir()' OfflineSorter.MAX_TEMPFILES)' GenerateRandom((int)OfflineSorter.MB * 100));
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestLargerRandom,The following statement contains a magic number: CheckSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARER' OfflineSorter.BufferSize.Megabytes(16)' OfflineSorter.DefaultTempDir()' OfflineSorter.MAX_TEMPFILES)' GenerateRandom((int)OfflineSorter.MB * 100));
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,GenerateRandom,The following statement contains a magic number: byte[] current = new byte[Random.Next(256)];
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,AssertFilesIdentical,The following statement contains a magic number: byte[] buf1 = new byte[64 * 1024];
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,AssertFilesIdentical,The following statement contains a magic number: byte[] buf1 = new byte[64 * 1024];
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,AssertFilesIdentical,The following statement contains a magic number: byte[] buf2 = new byte[64 * 1024];
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,AssertFilesIdentical,The following statement contains a magic number: byte[] buf2 = new byte[64 * 1024];
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestRamBuffer,The following statement contains a magic number: int numIters = AtLeast(10000);
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestRamBuffer,The following statement contains a magic number: OfflineSorter.BufferSize.Megabytes(1 + Random.Next(2047));
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestRamBuffer,The following statement contains a magic number: OfflineSorter.BufferSize.Megabytes(2047);
Magic Number,Lucene.Net.Util,TestOfflineSorter,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\TestOfflineSorter.cs,TestRamBuffer,The following statement contains a magic number: OfflineSorter.BufferSize.Megabytes(2048);
Magic Number,Lucene.Net.Util.Automaton,TestBasicOperations,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestBasicOperations.cs,TestGetRandomAcceptedString,The following statement contains a magic number: int ITER1 = AtLeast(100);
Magic Number,Lucene.Net.Util.Automaton,TestBasicOperations,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestBasicOperations.cs,TestGetRandomAcceptedString,The following statement contains a magic number: int ITER2 = AtLeast(100);
Magic Number,Lucene.Net.Util.Automaton,TestCompiledAutomaton,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestCompiledAutomaton.cs,TestTerms,The following statement contains a magic number: string s = Random.Next(10) == 1 ? terms[Random.Next(terms.Length)] : RandomString();
Magic Number,Lucene.Net.Util.Automaton,TestCompiledAutomaton,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestCompiledAutomaton.cs,TestTerms,The following statement contains a magic number: iter < 100 * RANDOM_MULTIPLIER
Magic Number,Lucene.Net.Util.Automaton,TestCompiledAutomaton,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestCompiledAutomaton.cs,TestRandom,The following statement contains a magic number: int numTerms = AtLeast(400);
Magic Number,Lucene.Net.Util.Automaton,TestDeterminism,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestDeterminism.cs,TestRegexps,The following statement contains a magic number: int num = AtLeast(500);
Magic Number,Lucene.Net.Util.Automaton,TestDeterminism,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestDeterminism.cs,TestAgainstSimple,The following statement contains a magic number: int num = AtLeast(200);
Magic Number,Lucene.Net.Util.Automaton,TestDeterminizeLexicon,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestDeterminizeLexicon.cs,TestLexicon,The following statement contains a magic number: j < 5000
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,TestLev2,The following statement contains a magic number: AssertLev(""' 2);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,TestLev2,The following statement contains a magic number: AssertCharVectors(2);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,AssertCharVectors,The following statement contains a magic number: int k = 2 * n + 1;
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,AssertCharVectors,The following statement contains a magic number: int limit = (int)Math.Pow(2' k + 2);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,AssertCharVectors,The following statement contains a magic number: int limit = (int)Math.Pow(2' k + 2);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,AssertCharVectors,The following statement contains a magic number: string encoded = Convert.ToString(i' 2);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,TranspositionsOf,The following statement contains a magic number: s.Length < 2
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,TranspositionsOf,The following statement contains a magic number: sb.Append(s.Substring(i + 2' s.Length - (i + 2)));
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,TranspositionsOf,The following statement contains a magic number: sb.Append(s.Substring(i + 2' s.Length - (i + 2)));
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,AssertBruteForce,The following statement contains a magic number: int maxNum = (int)Math.Pow(2' maxLen);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,AssertBruteForce,The following statement contains a magic number: string encoded = Convert.ToString(i' 2);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,AssertBruteForceT,The following statement contains a magic number: int maxNum = (int)Math.Pow(2' maxLen);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,AssertBruteForceT,The following statement contains a magic number: string encoded = Convert.ToString(i' 2);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,GetTDistance,The following statement contains a magic number: d[i][j] = Math.Min(d[i][j]' d[i - 2][j - 2] + cost);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,GetTDistance,The following statement contains a magic number: d[i][j] = Math.Min(d[i][j]' d[i - 2][j - 2] + cost);
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,GetTDistance,The following statement contains a magic number: i > 1 && j > 1 && target[i - 1] == other[j - 2] && target[i - 2] == other[j - 1]
Magic Number,Lucene.Net.Util.Automaton,TestLevenshteinAutomata,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestLevenshteinAutomata.cs,GetTDistance,The following statement contains a magic number: i > 1 && j > 1 && target[i - 1] == other[j - 2] && target[i - 2] == other[j - 1]
Magic Number,Lucene.Net.Util.Automaton,TestMinimize,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestMinimize.cs,Test,The following statement contains a magic number: int num = AtLeast(200);
Magic Number,Lucene.Net.Util.Automaton,TestMinimize,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestMinimize.cs,TestAgainstBrzozowski,The following statement contains a magic number: int num = AtLeast(200);
Magic Number,Lucene.Net.Util.Automaton,TestSpecialOperations,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestSpecialOperations.cs,TestIsFinite,The following statement contains a magic number: int num = AtLeast(200);
Magic Number,Lucene.Net.Util.Automaton,TestSpecialOperations,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestSpecialOperations.cs,TestFiniteStrings,The following statement contains a magic number: Assert.AreEqual(2' strings.Count);
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,GetCodeStart,The following statement contains a magic number: switch (r.Next(4))              {                  case 0:                      return TestUtil.NextInt32(r' 0' 128);                    case 1:                      return TestUtil.NextInt32(r' 128' 2048);                    case 2:                      return TestUtil.NextInt32(r' 2048' 65536);                    default:                      return TestUtil.NextInt32(r' 65536' 1 + MAX_UNICODE);              }
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,GetCodeStart,The following statement contains a magic number: switch (r.Next(4))              {                  case 0:                      return TestUtil.NextInt32(r' 0' 128);                    case 1:                      return TestUtil.NextInt32(r' 128' 2048);                    case 2:                      return TestUtil.NextInt32(r' 2048' 65536);                    default:                      return TestUtil.NextInt32(r' 65536' 1 + MAX_UNICODE);              }
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,GetCodeStart,The following statement contains a magic number: switch (r.Next(4))              {                  case 0:                      return TestUtil.NextInt32(r' 0' 128);                    case 1:                      return TestUtil.NextInt32(r' 128' 2048);                    case 2:                      return TestUtil.NextInt32(r' 2048' 65536);                    default:                      return TestUtil.NextInt32(r' 65536' 1 + MAX_UNICODE);              }
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,GetCodeStart,The following statement contains a magic number: switch (r.Next(4))              {                  case 0:                      return TestUtil.NextInt32(r' 0' 128);                    case 1:                      return TestUtil.NextInt32(r' 128' 2048);                    case 2:                      return TestUtil.NextInt32(r' 2048' 65536);                    default:                      return TestUtil.NextInt32(r' 65536' 1 + MAX_UNICODE);              }
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,GetCodeStart,The following statement contains a magic number: switch (r.Next(4))              {                  case 0:                      return TestUtil.NextInt32(r' 0' 128);                    case 1:                      return TestUtil.NextInt32(r' 128' 2048);                    case 2:                      return TestUtil.NextInt32(r' 2048' 65536);                    default:                      return TestUtil.NextInt32(r' 65536' 1 + MAX_UNICODE);              }
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,GetCodeStart,The following statement contains a magic number: switch (r.Next(4))              {                  case 0:                      return TestUtil.NextInt32(r' 0' 128);                    case 1:                      return TestUtil.NextInt32(r' 128' 2048);                    case 2:                      return TestUtil.NextInt32(r' 2048' 65536);                    default:                      return TestUtil.NextInt32(r' 65536' 1 + MAX_UNICODE);              }
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,GetCodeStart,The following statement contains a magic number: switch (r.Next(4))              {                  case 0:                      return TestUtil.NextInt32(r' 0' 128);                    case 1:                      return TestUtil.NextInt32(r' 128' 2048);                    case 2:                      return TestUtil.NextInt32(r' 2048' 65536);                    default:                      return TestUtil.NextInt32(r' 65536' 1 + MAX_UNICODE);              }
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,GetCodeStart,The following statement contains a magic number: switch (r.Next(4))              {                  case 0:                      return TestUtil.NextInt32(r' 0' 128);                    case 1:                      return TestUtil.NextInt32(r' 128' 2048);                    case 2:                      return TestUtil.NextInt32(r' 2048' 65536);                    default:                      return TestUtil.NextInt32(r' 65536' 1 + MAX_UNICODE);              }
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,TestRandomRanges,The following statement contains a magic number: int ITERS = AtLeast(10);
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,TestRandomRanges,The following statement contains a magic number: int ITERS_PER_DFA = AtLeast(100);
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,TestRandomRegexes,The following statement contains a magic number: int num = AtLeast(250);
Magic Number,Lucene.Net.Util.Automaton,TestUTF32ToUTF8,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Automaton\TestUTF32ToUTF8.cs,AssertAutomaton,The following statement contains a magic number: int num = AtLeast(1000);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: int[] ints = new int[7];
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: Builder<object> b = new Builder<object>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' doPack' PackedInt32s.COMPACT' true' 15);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: int[] ints2 = new int[200];
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: ints2[i] = r.Next(256);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: count % 100000 == 0
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: b.TotStateCount > int.MaxValue + 100L * 1024 * 1024
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: b.TotStateCount > int.MaxValue + 100L * 1024 * 1024
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: b.TotStateCount > int.MaxValue + 100L * 1024 * 1024
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: i % 1000000 == 0
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: ints2[j] = r.Next(256);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: ints2[j] = r.Next(256);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: verify < 2
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' doPack' PackedInt32s.COMPACT' true' 15);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: var outputBytes = new byte[20];
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: Builder<long?> b = new Builder<long?>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' doPack' PackedInt32s.COMPACT' true' 15);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: output += 1 + r.Next(10);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: output += 1 + r.Next(10);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: output += 1 + r.Next(10);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,Test,The following statement contains a magic number: doPackIter < 2
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,NextInput,The following statement contains a magic number: int downTo = 6;
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,NextInput,The following statement contains a magic number: ints[downTo] += 1 + r.Next(10);
Magic Number,Lucene.Net.Util.Fst,Test2BFST,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\Test2BFST.cs,NextInput,The following statement contains a magic number: ints[downTo] < 256
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: int iters = AtLeast(10);
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: int numBytes = TestUtil.NextInt32(Random' 1' 200000);
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: int blockBits = TestUtil.NextInt32(Random' 8' 15);
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: int blockBits = TestUtil.NextInt32(Random' 8' 15);
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: int op = Random.Next(8);
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: int len = TestUtil.NextInt32(Random' 1' Math.Min(pos' 100));
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: pos > 0 && Random.Next(50) == 17
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: pos > 0 && Random.Next(50) == 17
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: (pos > 0 && Random.Next(200) == 17)
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: (pos > 0 && Random.Next(200) == 17)
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following statement contains a magic number: bytesToVerify = new BytesStore(@in' numBytes' TestUtil.NextInt32(Random' 256' int.MaxValue));
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The following statement contains a magic number: int numOps = TestUtil.NextInt32(Random' 100' 200);
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The following statement contains a magic number: int numOps = TestUtil.NextInt32(Random' 100' 200);
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The following statement contains a magic number: int numBytes = Random.Next(Math.Min(1000' totalLength - 1));
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The following statement contains a magic number: int skipBytes = Random.Next(left - 4);
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The following statement contains a magic number: expectedInt |= (expected[expectedPos--] & 0xFF) << 24;
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The following statement contains a magic number: expectedInt |= (expected[expectedPos--] & 0xFF) << 16;
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The following statement contains a magic number: expectedInt |= (expected[expectedPos--] & 0xFF) << 8;
Magic Number,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,Verify,The following statement contains a magic number: left > 4
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: Assert.AreEqual(22' fst.NodeCount);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: Assert.AreEqual(27' fst.ArcCount);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: Assert.AreEqual(22' fst.NodeCount);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: Assert.AreEqual(27' fst.ArcCount);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: BytesRef output = Random.Next(30) == 17 ? NO_OUTPUT : new BytesRef(Convert.ToString(idx));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: BytesRef output = Random.Next(30) == 17 ? NO_OUTPUT : new BytesRef(Convert.ToString(idx));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: Assert.AreEqual(24' fst.NodeCount);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: Assert.AreEqual(30' fst.ArcCount);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBasicFSA,The following statement contains a magic number: inputMode < 2
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,DoTest,The following statement contains a magic number: long value = lastOutput + TestUtil.NextInt32(Random' 1' 1000);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,DoTest,The following statement contains a magic number: long value = lastOutput + TestUtil.NextInt32(Random' 1' 1000);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,DoTest,The following statement contains a magic number: BytesRef output = Random.Next(30) == 17 ? NO_OUTPUT : new BytesRef(Convert.ToString(idx));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,DoTest,The following statement contains a magic number: BytesRef output = Random.Next(30) == 17 ? NO_OUTPUT : new BytesRef(Convert.ToString(idx));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRandomWords,The following statement contains a magic number: int maxNumWords = isVerbose ? 500 : 1000;
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRandomWords,The following statement contains a magic number: int maxNumWords = isVerbose ? 500 : 1000;
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRandomWords,The following statement contains a magic number: TestRandomWords(maxNumWords' AtLeast(2)' isVerbose);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRandomWords,The following statement contains a magic number: inputMode < 2
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBigSet,The following statement contains a magic number: TestRandomWords(TestUtil.NextInt32(Random' 50000' 60000)' 1' false);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestBigSet,The following statement contains a magic number: TestRandomWords(TestUtil.NextInt32(Random' 50000' 60000)' 1' false);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The following statement contains a magic number: int RUN_TIME_MSEC = AtLeast(500);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The following statement contains a magic number: IndexWriterConfig conf = NewIndexWriterConfig(TEST_VERSION_CURRENT' analyzer).SetMaxBufferedDocs(-1).SetRAMBufferSizeMB(64);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The following statement contains a magic number: Builder<long?> builder = new Builder<long?>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' doRewrite' PackedInt32s.DEFAULT' true' 15);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The following statement contains a magic number: VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRealTerms,The following statement contains a magic number: int num = AtLeast(1000);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestDuplicateFSAString,The following statement contains a magic number: i < 10
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(a' new Int32sRef())' 17L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(b' new Int32sRef())' 42L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(c' new Int32sRef())' 13824324872317238L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(13824324872317238L' Util.Get(fst' c));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(42' Util.Get(fst' b));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(17' Util.Get(fst' a));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(17' seekResult.Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(17' seekResult.Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(42' seekResult.Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(Util.ToInt32sRef(new BytesRef("c")' new Int32sRef())' Util.GetByOutput(fst' 13824324872317238L));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.IsNull(Util.GetByOutput(fst' 47));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(Util.ToInt32sRef(new BytesRef("b")' new Int32sRef())' Util.GetByOutput(fst' 42));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestSimple,The following statement contains a magic number: Assert.AreEqual(Util.ToInt32sRef(new BytesRef("a")' new Int32sRef())' Util.GetByOutput(fst' 17));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The following statement contains a magic number: int NUM_IDS = AtLeast(200);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The following statement contains a magic number: idx < NUM_IDS / 10
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The following statement contains a magic number: iter < 2 * NUM_IDS
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The following statement contains a magic number: iter < 2 * NUM_IDS
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestPrimaryKeys,The following statement contains a magic number: cycle < 2
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRandomTermLookup,The following statement contains a magic number: int NUM_TERMS = (int)(1000 * RANDOM_MULTIPLIER * (1 + Random.NextDouble()));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestExpandedCloseToRoot,The following statement contains a magic number: s.Generate(@out' b' 'a'' 'i'' 10);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestFinalOutputOnEndState,The following statement contains a magic number: Builder<long?> builder = new Builder<long?>(FST.INPUT_TYPE.BYTE4' 2' 0' true' true' int.MaxValue' outputs' null' Random.NextBoolean()' PackedInt32s.DEFAULT' true' 15);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestFinalOutputOnEndState,The following statement contains a magic number: Builder<long?> builder = new Builder<long?>(FST.INPUT_TYPE.BYTE4' 2' 0' true' true' int.MaxValue' outputs' null' Random.NextBoolean()' PackedInt32s.DEFAULT' true' 15);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestFinalOutputOnEndState,The following statement contains a magic number: builder.Add(Util.ToUTF32("stat"' new Int32sRef())' 17L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestFinalOutputOnEndState,The following statement contains a magic number: builder.Add(Util.ToUTF32("station"' new Int32sRef())' 10L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestInternalFinalState,The following statement contains a magic number: Builder<long?> builder = new Builder<long?>(FST.INPUT_TYPE.BYTE1' 0' 0' true' true' int.MaxValue' outputs' null' willRewrite' PackedInt32s.DEFAULT' true' 15);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestNonFinalStopNode,The following statement contains a magic number: FST<long?> fst = new FST<long?>(FST.INPUT_TYPE.BYTE1' outputs' false' PackedInt32s.COMPACT' true' 15);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestNonFinalStopNode,The following statement contains a magic number: rootNode.Arcs[0].NextFinalOutput = 17L;
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestNonFinalStopNode,The following statement contains a magic number: rootNode.Arcs[1].Output = 42L;
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,CheckStopNodes,The following statement contains a magic number: Assert.AreEqual(17' arc.NextFinalOutput);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,CheckStopNodes,The following statement contains a magic number: Assert.AreEqual(42' arc.Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("aab")' scratch)' 22L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("aac")' scratch)' 7L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("ax")' scratch)' 17L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: Util.TopResults<long?> res = Util.ShortestPaths(fst' fst.GetFirstArc(new FST.Arc<long?>())' outputs.NoOutput' minLongComparer' 3' true);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: Assert.AreEqual(3' res.TopN.Count);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: Assert.AreEqual(7L' res.TopN[0].Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: Assert.AreEqual(17L' res.TopN[1].Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: Assert.AreEqual(Util.ToInt32sRef(new BytesRef("aab")' scratch)' res.TopN[2].Input);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: Assert.AreEqual(22L' res.TopN[2].Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPaths,The following statement contains a magic number: Assert.AreEqual(22L' res.TopN[2].Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRejectNoLimits,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("aab")' scratch)' 22L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRejectNoLimits,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("aac")' scratch)' 7L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRejectNoLimits,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("adcd")' scratch)' 17L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRejectNoLimits,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("adcde")' scratch)' 17L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRejectNoLimits,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("ax")' scratch)' 17L);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRejectNoLimits,The following statement contains a magic number: Assert.AreEqual(rejectCount.Get()' 4);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRejectNoLimits,The following statement contains a magic number: Assert.AreEqual(7L' res.TopN[0].Output);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestRejectNoLimits,The following statement contains a magic number: Assert.AreEqual(rejectCount.Get()' 4);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("aab")' scratch)' outputs.NewPair(22L' 57L));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("aab")' scratch)' outputs.NewPair(22L' 57L));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("aac")' scratch)' outputs.NewPair(7L' 36L));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("aac")' scratch)' outputs.NewPair(7L' 36L));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("ax")' scratch)' outputs.NewPair(17L' 85L));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: builder.Add(Util.ToInt32sRef(new BytesRef("ax")' scratch)' outputs.NewPair(17L' 85L));
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Util.TopResults<Pair> res = Util.ShortestPaths(fst' fst.GetFirstArc(new FST.Arc<Pair>())' outputs.NoOutput' minPairWeightComparer' 3' true);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(3' res.TopN.Count);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(7L' res.TopN[0].Output.Output1);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(36L' res.TopN[0].Output.Output2);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(17L' res.TopN[1].Output.Output1);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(85L' res.TopN[1].Output.Output2);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(Util.ToInt32sRef(new BytesRef("aab")' scratch)' res.TopN[2].Input);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(22L' res.TopN[2].Output.Output1);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(22L' res.TopN[2].Output.Output1);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(57L' res.TopN[2].Output.Output2);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFST,The following statement contains a magic number: Assert.AreEqual(57L' res.TopN[2].Output.Output2);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsRandom,The following statement contains a magic number: int numWords = AtLeast(1000);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsRandom,The following statement contains a magic number: int weight = TestUtil.NextInt32(random' 1' 100);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsRandom,The following statement contains a magic number: int topN = TestUtil.NextInt32(random' 1' 10);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFSTRandom,The following statement contains a magic number: int numWords = AtLeast(1000);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFSTRandom,The following statement contains a magic number: int weight = TestUtil.NextInt32(random' 1' 100);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFSTRandom,The following statement contains a magic number: int output = TestUtil.NextInt32(random' 0' 500);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestShortestPathsWFSTRandom,The following statement contains a magic number: int topN = TestUtil.NextInt32(random' 1' 10);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestLargeOutputsOnArrayArcs,The following statement contains a magic number: byte[] bytes = new byte[300];
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestLargeOutputsOnArrayArcs,The following statement contains a magic number: arc < 6
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestLargeOutputsOnArrayArcs,The following statement contains a magic number: Assert.AreEqual(300' result.Length);
Magic Number,Lucene.Net.Util.Fst,TestFSTs,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,TestLargeOutputsOnArrayArcs,The following statement contains a magic number: arc < 6
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,VisitTerms,The following statement contains a magic number: Builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4' 0' prune' prune == 0' true' int.MaxValue' outputs' null' doPack' PackedInt32s.DEFAULT' !noArcArrays' 15);
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: Int32sRef intsRef = new Int32sRef(10);
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: Console.WriteLine(string.Format(CultureInfo.InvariantCulture' "{0:000000.000}s: {1:000000000}..."' ((Environment.TickCount - tStart) / 1000.0)' ord));
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: ord % 500000 == 0
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: Console.WriteLine(((tMid - tStart) / 1000.0) + " sec to add all terms");
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: Console.WriteLine(((tEnd - tMid) / 1000.0) + " sec to finish/pack");
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: fst.NodeCount < 100
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: Console.WriteLine(((Environment.TickCount - tStart) / 1000.0) + "s: " + ord + "...");
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: ord % 500000 == 0
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: double totSec = ((Environment.TickCount - tStart) / 1000.0);
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: Console.WriteLine("Verify " + (iter == 1 ? "(by output) " : "") + "took " + totSec + " sec + (" + (int)((totSec * 1000000000 / ord)) + " nsec per lookup)");
Magic Number,Lucene.Net.Util.Fst,VisitTerms<T>,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,Run,The following statement contains a magic number: iter < 2
Magic Number,Lucene.Net.Util.Fst,VisitTermsAnonymousInnerClassHelper,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,GetOutput,The following statement contains a magic number: rand = new Random(17);
Magic Number,Lucene.Net.Util.Fst,VisitTermsAnonymousInnerClassHelper,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,GetOutput,The following statement contains a magic number: return outputs.NewPair(ord' TestUtil.NextInt32(rand' 1' 5000));
Magic Number,Lucene.Net.Util.Fst,VisitTermsAnonymousInnerClassHelper3,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,GetOutput,The following statement contains a magic number: rand = new Random(17);
Magic Number,Lucene.Net.Util.Fst,VisitTermsAnonymousInnerClassHelper3,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,GetOutput,The following statement contains a magic number: return (long)TestUtil.NextInt32(rand' 1' 5000);
Magic Number,Lucene.Net.Util.Fst,TopNSearcherAnonymousInnerClassHelper,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,AcceptResult,The following statement contains a magic number: bool accept = (int)output == 7;
Magic Number,Lucene.Net.Util.Fst,TopNSearcherAnonymousInnerClassHelper2,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestFSTs.cs,AcceptResult,The following statement contains a magic number: bool accept = (int)output == 7;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestOneValue2,The following statement contains a magic number: long[] values = new long[] { 63 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestOneValue2,The following statement contains a magic number: long[] expHighBits = new long[] { 2 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestOneValue2,The following statement contains a magic number: long[] expLowBits = new long[] { 31 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestOneMaxValue,The following statement contains a magic number: long[] expHighBits = new long[] { 2 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestOneMaxValue,The following statement contains a magic number: long[] expLowBits = new long[] { long.MaxValue / 2 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample1,The following statement contains a magic number: long[] expLowBits = new long[] { Convert.ToInt64("0011000001"' 2) };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample1,The following statement contains a magic number: long[] expHighBits = new long[] { Convert.ToInt64("1000001011010"' 2) };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHashCodeEquals,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHashCodeEquals,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHashCodeEquals,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHashCodeEquals,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHashCodeEquals,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHashCodeEquals,The following statement contains a magic number: EliasFanoEncoder efEncoder3 = MakeEncoder(new long[] { 1' 2' 3 }' EliasFanoEncoder.DEFAULT_INDEX_INTERVAL);
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHashCodeEquals,The following statement contains a magic number: EliasFanoEncoder efEncoder3 = MakeEncoder(new long[] { 1' 2' 3 }' EliasFanoEncoder.DEFAULT_INDEX_INTERVAL);
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestMonotoneSequences,The following statement contains a magic number: values[i] = (i / 2);
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestMonotoneSequences,The following statement contains a magic number: s < 1222
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestMonotoneSequencesLonger,The following statement contains a magic number: values[i] = (i / 2);
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestMonotoneSequencesLonger,The following statement contains a magic number: s < 4422
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestStrictMonotoneSequences,The following statement contains a magic number: values[i] = i * ((long)i - 1) / 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestStrictMonotoneSequences,The following statement contains a magic number: s < 1222
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestStrictMonotoneSequencesLonger,The following statement contains a magic number: values[i] = i * ((long)i - 1) / 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestStrictMonotoneSequencesLonger,The following statement contains a magic number: s < 4422
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHighBitLongZero,The following statement contains a magic number: const int s = 65;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestHighBitLongZero,The following statement contains a magic number: values[s - 1] = 128;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestAdvanceToAndBackToMultiples,The following statement contains a magic number: values[i] = i * ((long)i + 1) / 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestAdvanceToAndBackToMultiples,The following statement contains a magic number: TstEFSadvanceToAndBackToMultiples(values' values[s - 1]' 10);
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestAdvanceToAndBackToMultiples,The following statement contains a magic number: s < 130
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestEmptyIndex,The following statement contains a magic number: long indexInterval = 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestMaxContentEmptyIndex,The following statement contains a magic number: long indexInterval = 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestMinContentNonEmptyIndex,The following statement contains a magic number: long indexInterval = 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestMinContentNonEmptyIndex,The following statement contains a magic number: long[] twoLongs = new long[] { 0' 2 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestMinContentNonEmptyIndex,The following statement contains a magic number: long[] indexLongs = new long[] { 3 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToLast,The following statement contains a magic number: long indexInterval = 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToLast,The following statement contains a magic number: long[] twoLongs = new long[] { 0' 2 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToLast,The following statement contains a magic number: long[] indexLongs = new long[] { 3 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToLast,The following statement contains a magic number: Assert.AreEqual(2' efEncVI.GetDecoder().AdvanceToValue(2));
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToLast,The following statement contains a magic number: Assert.AreEqual(2' efEncVI.GetDecoder().AdvanceToValue(2));
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToAfterLast,The following statement contains a magic number: long indexInterval = 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToAfterLast,The following statement contains a magic number: long[] twoLongs = new long[] { 0' 2 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToAfterLast,The following statement contains a magic number: long[] indexLongs = new long[] { 3 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToAfterLast,The following statement contains a magic number: Assert.AreEqual(EliasFanoDecoder.NO_MORE_VALUES' efEncVI.GetDecoder().AdvanceToValue(3));
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToFirst,The following statement contains a magic number: long indexInterval = 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToFirst,The following statement contains a magic number: long[] twoLongs = new long[] { 0' 2 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestIndexAdvanceToFirst,The following statement contains a magic number: long[] indexLongs = new long[] { 3 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: long indexInterval = 2;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: long[] twoLongs = new long[] { 0' 1' 2' 3' 4' 5 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: long[] twoLongs = new long[] { 0' 1' 2' 3' 4' 5 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: long[] twoLongs = new long[] { 0' 1' 2' 3' 4' 5 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: long[] twoLongs = new long[] { 0' 1' 2' 3' 4' 5 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: long[] indexLongs = new long[] { 4 + 8 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: long[] indexLongs = new long[] { 4 + 8 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: long[] indexLongs = new long[] { 4 + 8 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: Assert.AreEqual(5' efDecVI.AdvanceToValue(5)' "advance 5");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: Assert.AreEqual(5' efDecVI.AdvanceToValue(5)' "advance 5");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestTwoIndexEntries,The following statement contains a magic number: Assert.AreEqual(EliasFanoDecoder.NO_MORE_VALUES' efDecVI.AdvanceToValue(5)' "advance 6");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long indexInterval = 4;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long[] indexLongs = new long[] { 8 + 12 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long[] indexLongs = new long[] { 8 + 12 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: long[] indexLongs = new long[] { 8 + 12 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: Assert.AreEqual(32' efDecVI.AdvanceToValue(22)' "advance 22");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2a,The following statement contains a magic number: Assert.AreEqual(32' efDecVI.AdvanceToValue(22)' "advance 22");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long indexInterval = 4;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long[] indexLongs = new long[] { 8 + 12 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long[] indexLongs = new long[] { 8 + 12 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: long[] indexLongs = new long[] { 8 + 12 * 16 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: Assert.AreEqual(5' efDecVI.NextValue()' "initial next");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: Assert.AreEqual(32' efDecVI.AdvanceToValue(22)' "advance 22");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2b,The following statement contains a magic number: Assert.AreEqual(32' efDecVI.AdvanceToValue(22)' "advance 22");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex1,The following statement contains a magic number: long indexInterval = 16;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex1,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex1,The following statement contains a magic number: Assert.AreEqual(32' efDecVI.AdvanceToValue(22)' "advance 22");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex1,The following statement contains a magic number: Assert.AreEqual(32' efDecVI.AdvanceToValue(22)' "advance 22");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: long indexInterval = 16;
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: long[] values = new long[] { 5' 8' 8' 15' 32 };
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: Assert.AreEqual(5' efDecVI.NextValue()' "initial next");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: Assert.AreEqual(32' efDecVI.AdvanceToValue(22)' "advance 22");
Magic Number,Lucene.Net.Util.Packed,TestEliasFanoSequence,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestEliasFanoSequence.cs,TestExample2NoIndex2,The following statement contains a magic number: Assert.AreEqual(32' efDecVI.AdvanceToValue(22)' "advance 22");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestByteCount,The following statement contains a magic number: int iters = AtLeast(3);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestByteCount,The following statement contains a magic number: Assert.IsTrue(byteCount * 8 >= (long)valueCount * bpv' msg);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestByteCount,The following statement contains a magic number: Assert.IsTrue((byteCount - 1) * 8 < (long)valueCount * bpv' msg);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestByteCount,The following statement contains a magic number: bpv <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBitsRequired,The following statement contains a magic number: Assert.AreEqual(61' PackedInt32s.BitsRequired((long)Math.Pow(2' 61) - 1));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBitsRequired,The following statement contains a magic number: Assert.AreEqual(61' PackedInt32s.BitsRequired((long)Math.Pow(2' 61) - 1));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBitsRequired,The following statement contains a magic number: Assert.AreEqual(61' PackedInt32s.BitsRequired((long)Math.Pow(2' 61) - 1));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBitsRequired,The following statement contains a magic number: Assert.AreEqual(61' PackedInt32s.BitsRequired(0x1FFFFFFFFFFFFFFFL));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBitsRequired,The following statement contains a magic number: Assert.AreEqual(62' PackedInt32s.BitsRequired(0x3FFFFFFFFFFFFFFFL));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBitsRequired,The following statement contains a magic number: Assert.AreEqual(63' PackedInt32s.BitsRequired(0x7FFFFFFFFFFFFFFFL));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMaxValues,The following statement contains a magic number: Assert.AreEqual(3' PackedInt32s.MaxValue(2)' "2 bit -> max == 3");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMaxValues,The following statement contains a magic number: Assert.AreEqual(3' PackedInt32s.MaxValue(2)' "2 bit -> max == 3");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMaxValues,The following statement contains a magic number: Assert.AreEqual(255' PackedInt32s.MaxValue(8)' "8 bit -> max == 255");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMaxValues,The following statement contains a magic number: Assert.AreEqual(255' PackedInt32s.MaxValue(8)' "8 bit -> max == 255");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMaxValues,The following statement contains a magic number: Assert.AreEqual(long.MaxValue' PackedInt32s.MaxValue(63)' "63 bit -> max == Long.MAX_VALUE");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMaxValues,The following statement contains a magic number: Assert.AreEqual(long.MaxValue' PackedInt32s.MaxValue(64)' "64 bit -> max == Long.MAX_VALUE (same as for 63 bit)");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The following statement contains a magic number: int num = AtLeast(3);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The following statement contains a magic number: int valueCount = TestUtil.NextInt32(Random' 1' 600);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The following statement contains a magic number: int bufferSize = Random.NextBoolean() ? TestUtil.NextInt32(Random' 0' 48) : TestUtil.NextInt32(Random' 0' 4096);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The following statement contains a magic number: int bufferSize = Random.NextBoolean() ? TestUtil.NextInt32(Random' 0' 48) : TestUtil.NextInt32(Random' 0' 4096);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The following statement contains a magic number: nbits == 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The following statement contains a magic number: int count = TestUtil.NextInt32(Random' 1' 95);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInts_Mem,The following statement contains a magic number: nbits <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEndPointer,The following statement contains a magic number: int valueCount = RandomInts.RandomInt32Between(Random' 1' 1000);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEndPointer,The following statement contains a magic number: PackedInt32s.IReaderIterator it = PackedInt32s.GetReaderIteratorNoHeader(@in' format' version' valueCount' bpv' RandomInts.RandomInt32Between(Random' 1' 1 << 16));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEndPointer,The following statement contains a magic number: bpv <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestControlledEquality,The following statement contains a magic number: const int VALUE_COUNT = 255;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestControlledEquality,The following statement contains a magic number: const int BITS_PER_VALUE = 8;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomBulkCopy,The following statement contains a magic number: int numIters = AtLeast(3);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomBulkCopy,The following statement contains a magic number: int valueCount = AtLeast(100000);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomBulkCopy,The following statement contains a magic number: int bits1 = TestUtil.NextInt32(Random' 1' 64);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomBulkCopy,The following statement contains a magic number: int bits2 = TestUtil.NextInt32(Random' 1' 64);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomBulkCopy,The following statement contains a magic number: iter2 < 20
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomEquality,The following statement contains a magic number: int numIters = AtLeast(2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomEquality,The following statement contains a magic number: int valueCount = TestUtil.NextInt32(Random' 1' 300);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestRandomEquality,The following statement contains a magic number: bitsPerValue <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,CreatePackedInts,The following statement contains a magic number: bitsPerValue <= 8
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,CreatePackedInts,The following statement contains a magic number: bitsPerValue <= 16
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,CreatePackedInts,The following statement contains a magic number: bitsPerValue <= 24 && valueCount <= Packed8ThreeBlocks.MAX_SIZE
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,CreatePackedInts,The following statement contains a magic number: bitsPerValue <= 32
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,CreatePackedInts,The following statement contains a magic number: bitsPerValue <= 48 && valueCount <= Packed16ThreeBlocks.MAX_SIZE
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,CreatePackedInts,The following statement contains a magic number: bitsPerValue <= 63
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSingleValue,The following statement contains a magic number: long value = 17L & PackedInt32s.MaxValue(bitsPerValue);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSingleValue,The following statement contains a magic number: bitsPerValue <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: PackedInt32s.Mutable mutable = new Packed64(26' 5);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: PackedInt32s.Mutable mutable = new Packed64(26' 5);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: mutable.Set(24' 31);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: mutable.Set(24' 31);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: Assert.AreEqual(31' mutable.Get(24)' "The value #24 should be correct");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: Assert.AreEqual(31' mutable.Get(24)' "The value #24 should be correct");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: mutable.Set(4' 16);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: mutable.Set(4' 16);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: Assert.AreEqual(31' mutable.Get(24)' "The value #24 should remain unchanged");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSecondaryBlockChange,The following statement contains a magic number: Assert.AreEqual(31' mutable.Get(24)' "The value #24 should remain unchanged");
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The following statement contains a magic number: int INDEX = (int)Math.Pow(2' 30) + 1;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The following statement contains a magic number: int INDEX = (int)Math.Pow(2' 30) + 1;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The following statement contains a magic number: int BITS = 2;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The following statement contains a magic number: int index = int.MaxValue / 24 + 1;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestIntOverflow,The following statement contains a magic number: index = int.MaxValue / 48 + 1;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestFill,The following statement contains a magic number: const int valueCount = 1111;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestFill,The following statement contains a magic number: bpv <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedIntsNull,The following statement contains a magic number: int size = TestUtil.NextInt32(Random' 11' 256);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedIntsNull,The following statement contains a magic number: int size = TestUtil.NextInt32(Random' 11' 256);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedIntsNull,The following statement contains a magic number: long[] arr = new long[size + 10];
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedIntsNull,The following statement contains a magic number: r = packedInts.Get(10' arr' 0' size + 10);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedIntsNull,The following statement contains a magic number: r = packedInts.Get(10' arr' 0' size + 10);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedIntsNull,The following statement contains a magic number: Assert.AreEqual(size - 10' r);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedIntsNull,The following statement contains a magic number: i < size - 10
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkGet,The following statement contains a magic number: const int valueCount = 1111;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkGet,The following statement contains a magic number: int len = TestUtil.NextInt32(Random' 1' valueCount * 2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkGet,The following statement contains a magic number: int off = Random.Next(77);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkGet,The following statement contains a magic number: ints.Set(i' (31L * i - 1099) & mask);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkGet,The following statement contains a magic number: ints.Set(i' (31L * i - 1099) & mask);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkGet,The following statement contains a magic number: bpv <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkSet,The following statement contains a magic number: const int valueCount = 1111;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkSet,The following statement contains a magic number: int len = TestUtil.NextInt32(Random' 1' valueCount * 2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkSet,The following statement contains a magic number: int off = Random.Next(77);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkSet,The following statement contains a magic number: arr[i] = (31L * i + 19) & mask;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkSet,The following statement contains a magic number: arr[i] = (31L * i + 19) & mask;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBulkSet,The following statement contains a magic number: bpv <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestCopy,The following statement contains a magic number: int valueCount = TestUtil.NextInt32(Random' 5' 600);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestCopy,The following statement contains a magic number: int valueCount = TestUtil.NextInt32(Random' 5' 600);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestCopy,The following statement contains a magic number: int mem = Random.Next(1024);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestCopy,The following statement contains a magic number: r1.Set(i' (31L * i - 1023) & mask);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestCopy,The following statement contains a magic number: r1.Set(i' (31L * i - 1023) & mask);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestCopy,The following statement contains a magic number: bpv <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: int valueCount = 113 + Random.Next(1111);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: int valueCount = 113 + Random.Next(1111);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(4' 2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(4' 2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(7' 10);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(7' 10);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(valueCount - 10' 99);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(valueCount - 10' 99);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(99' 999);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(99' 999);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(valueCount - 1' 1 << 10);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(1 << 10' wrt.Get(valueCount - 1));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(99' (1 << 23) - 1);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(99' (1 << 23) - 1);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(1 << 10' wrt.Get(valueCount - 1));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(2' -3);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: wrt.Set(2' -3);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(64' wrt.BitsPerValue);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(1 << 10' wrt.Get(valueCount - 1));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(-3L' wrt.Get(2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(-3L' wrt.Get(2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(2' wrt.Get(4));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(2' wrt.Get(4));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual((1 << 23) - 1' wrt.Get(99));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual((1 << 23) - 1' wrt.Get(99));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(10' wrt.Get(7));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(10' wrt.Get(7));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(99' wrt.Get(valueCount - 10));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(99' wrt.Get(valueCount - 10));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestGrowableWriter,The following statement contains a magic number: Assert.AreEqual(1 << 10' wrt.Get(valueCount - 1));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: int pageSize = 1 << (TestUtil.NextInt32(Random' 6' 30));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: int pageSize = 1 << (TestUtil.NextInt32(Random' 6' 30));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: PagedGrowableWriter writer = new PagedGrowableWriter(0' pageSize' TestUtil.NextInt32(Random' 1' 64)' Random.NextSingle());
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: int size = Random.Next(1000000);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: long max = 5;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: max = PackedInt32s.MaxValue(Rarely() ? TestUtil.NextInt32(Random' 0' 63) : TestUtil.NextInt32(Random' 0' 31));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: max = PackedInt32s.MaxValue(Rarely() ? TestUtil.NextInt32(Random' 0' 63) : TestUtil.NextInt32(Random' 0' 31));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: writer = new PagedGrowableWriter(size' pageSize' TestUtil.NextInt32(Random' 1' 64)' Random.NextSingle());
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: Assert.AreEqual(RamUsageEstimator.SizeOf(writer)' writer.RamBytesUsed()' 8);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: PagedGrowableWriter copy = writer.Resize(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: PagedGrowableWriter copy = writer.Resize(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: PagedGrowableWriter copy = writer.Resize(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: PagedGrowableWriter grow = writer.Grow(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: PagedGrowableWriter grow = writer.Grow(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriter,The following statement contains a magic number: PagedGrowableWriter grow = writer.Grow(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: int bitsPerValue = TestUtil.NextInt32(Random' 1' 64);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: int pageSize = 1 << (TestUtil.NextInt32(Random' 6' 30));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: int pageSize = 1 << (TestUtil.NextInt32(Random' 6' 30));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: PagedMutable writer = new PagedMutable(0' pageSize' bitsPerValue' Random.NextSingle() / 2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: int size = Random.Next(1000000);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: buf.Add(bitsPerValue == 64 ? Random.NextInt64() : TestUtil.NextInt64(Random' 0' max));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: PagedMutable copy = writer.Resize(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: PagedMutable copy = writer.Resize(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: PagedMutable copy = writer.Resize(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: PagedMutable grow = writer.Grow(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: PagedMutable grow = writer.Grow(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedMutable,The following statement contains a magic number: PagedMutable grow = writer.Grow(TestUtil.NextInt64(Random' writer.Count / 2' writer.Count * 3 / 2));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriterOverflow,The following statement contains a magic number: long size = TestUtil.NextInt64(Random' 2 * (long)int.MaxValue' 3 * (long)int.MaxValue);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriterOverflow,The following statement contains a magic number: long size = TestUtil.NextInt64(Random' 2 * (long)int.MaxValue' 3 * (long)int.MaxValue);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriterOverflow,The following statement contains a magic number: int pageSize = 1 << (TestUtil.NextInt32(Random' 16' 30));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriterOverflow,The following statement contains a magic number: int pageSize = 1 << (TestUtil.NextInt32(Random' 16' 30));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriterOverflow,The following statement contains a magic number: writer.Set(index' 2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriterOverflow,The following statement contains a magic number: Assert.AreEqual(2' writer.Get(index));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriterOverflow,The following statement contains a magic number: Assert.AreEqual(2' writer.Get(idx));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPagedGrowableWriterOverflow,The following statement contains a magic number: i < 1000000
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSave,The following statement contains a magic number: int valueCount = TestUtil.NextInt32(Random' 1' 2048);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSave,The following statement contains a magic number: int maxValue = (int)Math.Min(PackedInt32s.MaxValue(31)' PackedInt32s.MaxValue(bpv));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestSave,The following statement contains a magic number: bpv <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: int longIterations = Random.Next(100);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: int blocksOffset = Random.Next(100);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: int valuesOffset = Random.Next(100);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: int blocksOffset2 = Random.Next(100);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: int toClear = 64 % bpv;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: format == PackedInt32s.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: bpv <= 32
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: bpv <= 32
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: byte[] byteBlocks = new byte[8 * blocks.Length];
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: decoder.Decode(byteBlocks' blocksOffset * 8' values2' valuesOffset' byteIterations);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: decoder.Decode(byteBlocks' blocksOffset * 8' intValues2' valuesOffset' byteIterations);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: bpv <= 32
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: byte[] blocks3_ = new byte[8 * (blocksOffset2 + blocksLen)];
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: encoder.Encode(values' valuesOffset' blocks3_' 8 * blocksOffset2' byteIterations);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: encoder.Encode(intValues' valuesOffset' blocks4' 8 * blocksOffset2' byteIterations);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: bpv <= 32
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestEncodeDecode,The following statement contains a magic number: bpv <= 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: long[] arr = new long[RandomInts.RandomInt32Between(Random' 1' 1000000)];
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: int pageSize = 1 << TestUtil.NextInt32(Random' 6' 20);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: int pageSize = 1 << TestUtil.NextInt32(Random' 6' 20);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: int initialPageCount = TestUtil.NextInt32(Random' 0' 16);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: switch (dataType)                      {                          case Lucene.Net.Util.Packed.TestPackedInts.DataType.PACKED:                              buf = new AppendingPackedInt64Buffer(initialPageCount' pageSize' acceptableOverheadRatio);                              inc = 0;                              break;                          case Lucene.Net.Util.Packed.TestPackedInts.DataType.DELTA_PACKED:                              buf = new AppendingDeltaPackedInt64Buffer(initialPageCount' pageSize' acceptableOverheadRatio);                              inc = 0;                              break;                          case Lucene.Net.Util.Packed.TestPackedInts.DataType.MONOTONIC:                              buf = new MonotonicAppendingInt64Buffer(initialPageCount' pageSize' acceptableOverheadRatio);                              inc = TestUtil.NextInt32(Random' -1000' 1000);                              break;                          default:                              throw new Exception("added a type and forgot to add it here?");                        }
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: switch (dataType)                      {                          case Lucene.Net.Util.Packed.TestPackedInts.DataType.PACKED:                              buf = new AppendingPackedInt64Buffer(initialPageCount' pageSize' acceptableOverheadRatio);                              inc = 0;                              break;                          case Lucene.Net.Util.Packed.TestPackedInts.DataType.DELTA_PACKED:                              buf = new AppendingDeltaPackedInt64Buffer(initialPageCount' pageSize' acceptableOverheadRatio);                              inc = 0;                              break;                          case Lucene.Net.Util.Packed.TestPackedInts.DataType.MONOTONIC:                              buf = new MonotonicAppendingInt64Buffer(initialPageCount' pageSize' acceptableOverheadRatio);                              inc = TestUtil.NextInt32(Random' -1000' 1000);                              break;                          default:                              throw new Exception("added a type and forgot to add it here?");                        }
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: long[] target = new long[arr.Length + 1024];
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: int lenToRead = Random.Next(buf.PageSize * 2) + 1;
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: new int[] { 0' 1' 63' 64' RandomInts.RandomInt32Between(Random' 2' 62) }
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: new int[] { 0' 1' 63' 64' RandomInts.RandomInt32Between(Random' 2' 62) }
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: new int[] { 0' 1' 63' 64' RandomInts.RandomInt32Between(Random' 2' 62) }
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestAppendingLongBuffer,The following statement contains a magic number: new int[] { 0' 1' 63' 64' RandomInts.RandomInt32Between(Random' 2' 62) }
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInputOutput,The following statement contains a magic number: long[] longs = new long[Random.Next(8192)];
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInputOutput,The following statement contains a magic number: int bpv = RandomInts.RandomInt32Between(Random' 1' 64);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInputOutput,The following statement contains a magic number: bitsPerValues[i] = Random.NextBoolean() ? bpv : TestUtil.NextInt32(Random' bpv' 64);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInputOutput,The following statement contains a magic number: bpv == 64
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInputOutput,The following statement contains a magic number: totalBits = 8 * (long)Math.Ceiling((double)totalBits / 8);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInputOutput,The following statement contains a magic number: totalBits = 8 * (long)Math.Ceiling((double)totalBits / 8);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInputOutput,The following statement contains a magic number: Assert.AreEqual((long)Math.Ceiling((double)totalBits / 8)' @out.GetFilePointer());
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestPackedInputOutput,The following statement contains a magic number: assertEquals((long)Math.Ceiling((double)totalBits / 8)' @in.GetFilePointer());
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The following statement contains a magic number: int iters = AtLeast(2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The following statement contains a magic number: int blockSize = 1 << TestUtil.NextInt32(Random' 6' 18);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The following statement contains a magic number: int blockSize = 1 << TestUtil.NextInt32(Random' 6' 18);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The following statement contains a magic number: int valueCount = Random.Next(1 << 18);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The following statement contains a magic number: minValue = Rarely() ? Random.Next(256) : Rarely() ? -5 : Random.NextInt64();
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The following statement contains a magic number: minValue = Rarely() ? Random.Next(256) : Rarely() ? -5 : Random.NextInt64();
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockPackedReaderWriter,The following statement contains a magic number: bpv = Random.Next(65);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: int iters = AtLeast(2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: int blockSize = 1 << TestUtil.NextInt32(Random' 6' 18);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: int blockSize = 1 << TestUtil.NextInt32(Random' 6' 18);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: int valueCount = Random.Next(1 << 18);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: values[0] = Random.NextBoolean() ? Random.Next(10) : Random.Next(int.MaxValue);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: int maxDelta = Random.Next(64);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: maxDelta = Random.Next(64);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: Random.NextDouble() < 0.1d
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestMonotonicBlockPackedReaderWriter,The following statement contains a magic number: values[i] = Math.Max(0' values[i - 1] + TestUtil.NextInt32(Random' -16' maxDelta));
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockReaderOverflow,The following statement contains a magic number: long valueCount = TestUtil.NextInt64(Random' 1L + int.MaxValue' (long)int.MaxValue * 2);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockReaderOverflow,The following statement contains a magic number: int blockSize = 1 << TestUtil.NextInt32(Random' 20' 22);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockReaderOverflow,The following statement contains a magic number: int blockSize = 1 << TestUtil.NextInt32(Random' 20' 22);
Magic Number,Lucene.Net.Util.Packed,TestPackedInts,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Packed\TestPackedInts.cs,TestBlockReaderOverflow,The following statement contains a magic number: i < 5
Missing Default,Lucene.Net.Util.Fst,TestBytesStore,D:\research\architectureSmells\repos\apache_lucenenet\src\Lucene.Net.Tests\Util\Fst\TestBytesStore.cs,TestRandom,The following switch statement is missing a default case: switch (op)                      {                            case 0:                              {                                  // write random byte                                  byte b = (byte)Random.Next(256);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeByte b=" + b);                                  }                                    expected[pos++] = b;                                  bytes.WriteByte(b);                              }                              break;                            case 1:                              {                                  // write random byte[]                                  int len = Random.Next(Math.Min(numBytes - pos' 100));                                  byte[] temp = new byte[len];                                  Random.NextBytes(temp);                                  if (VERBOSE)                                  {                                      Console.WriteLine("    writeBytes len=" + len + " bytes=" + Arrays.ToString(temp));                                  }                                  Array.Copy(temp' 0' expected' pos' temp.Length);                                  bytes.WriteBytes(temp' 0' temp.Length);                                  pos += len;                              }                              break;                            case 2:                              {                                  // write int @ absolute pos                                  if (pos > 4)                                  {                                      int x = Random.Next();                                      int randomPos = Random.Next(pos - 4);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeInt pos=" + randomPos + " x=" + x);                                      }                                      bytes.WriteInt32(randomPos' x);                                      expected[randomPos++] = (byte)(x >> 24);                                      expected[randomPos++] = (byte)(x >> 16);                                      expected[randomPos++] = (byte)(x >> 8);                                      expected[randomPos++] = (byte)x;                                  }                              }                              break;                            case 3:                              {                                  // reverse bytes                                  if (pos > 1)                                  {                                      int len = TestUtil.NextInt32(Random' 2' Math.Min(100' pos));                                      int start;                                      if (len == pos)                                      {                                          start = 0;                                      }                                      else                                      {                                          start = Random.Next(pos - len);                                      }                                      int end = start + len - 1;                                      if (VERBOSE)                                      {                                          Console.WriteLine("    reverse start=" + start + " end=" + end + " len=" + len + " pos=" + pos);                                      }                                      bytes.Reverse(start' end);                                        while (start <= end)                                      {                                          byte b = expected[end];                                          expected[end] = expected[start];                                          expected[start] = b;                                          start++;                                          end--;                                      }                                  }                              }                              break;                            case 4:                              {                                  // abs write random byte[]                                  if (pos > 2)                                  {                                      int randomPos = Random.Next(pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(pos - randomPos - 1' 100));                                      byte[] temp = new byte[len];                                      Random.NextBytes(temp);                                      if (VERBOSE)                                      {                                          Console.WriteLine("    abs writeBytes pos=" + randomPos + " len=" + len + " bytes=" + Arrays.ToString(temp));                                      }                                      Array.Copy(temp' 0' expected' randomPos' temp.Length);                                      bytes.WriteBytes(randomPos' temp' 0' temp.Length);                                  }                              }                              break;                            case 5:                              {                                  // copyBytes                                  if (pos > 1)                                  {                                      int src = Random.Next(pos - 1);                                      int dest = TestUtil.NextInt32(Random' src + 1' pos - 1);                                      int len = TestUtil.NextInt32(Random' 1' Math.Min(300' pos - dest));                                      if (VERBOSE)                                      {                                          Console.WriteLine("    copyBytes src=" + src + " dest=" + dest + " len=" + len);                                      }                                      Array.Copy(expected' src' expected' dest' len);                                      bytes.CopyBytes(src' dest' len);                                  }                              }                              break;                            case 6:                              {                                  // skip                                  int len = Random.Next(Math.Min(100' numBytes - pos));                                    if (VERBOSE)                                  {                                      Console.WriteLine("    skip len=" + len);                                  }                                    pos += len;                                  bytes.SkipBytes(len);                                    // NOTE: must fill in zeros in case truncate was                                  // used' else we get false fails:                                  if (len > 0)                                  {                                      byte[] zeros = new byte[len];                                      bytes.WriteBytes(pos - len' zeros' 0' len);                                  }                              }                              break;                            case 7:                              {                                  // absWriteByte                                  if (pos > 0)                                  {                                      int dest = Random.Next(pos);                                      byte b = (byte)Random.Next(256);                                      expected[dest] = b;                                      bytes.WriteByte(dest' b);                                  }                                  break;                              }                      }
