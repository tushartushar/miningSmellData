Implementation smell,Namespace,Class,File,Method,Description
Long Method,Lucene.Net.Search.Suggest.Analyzing,AnalyzingInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingInfixSuggester.cs,DoLookup,The method has 102 lines of code.
Long Method,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The method has 159 lines of code.
Long Method,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,DoLookup,The method has 109 lines of code.
Long Method,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Build,The method has 108 lines of code.
Long Method,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,DoLookup,The method has 200 lines of code.
Complex Method,Lucene.Net.Search.Spell,DirectSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\DirectSpellChecker.cs,SuggestSimilar,Cyclomatic complexity of the method is 13
Complex Method,Lucene.Net.Search.Spell,DirectSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\DirectSpellChecker.cs,SuggestSimilar,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Search.Spell,JaroWinklerDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\JaroWinklerDistance.cs,Matches,Cyclomatic complexity of the method is 13
Complex Method,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Search.Spell,NGramDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\NGramDistance.cs,GetDistance,Cyclomatic complexity of the method is 17
Complex Method,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SuggestSimilar,Cyclomatic complexity of the method is 16
Complex Method,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,SuggestWordCombinations,Cyclomatic complexity of the method is 19
Complex Method,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,GenerateBreakUpSuggestions,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Search.Suggest.Analyzing,AnalyzingInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingInfixSuggester.cs,DoLookup,Cyclomatic complexity of the method is 11
Complex Method,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,Cyclomatic complexity of the method is 17
Complex Method,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,DoLookup,Cyclomatic complexity of the method is 19
Complex Method,Lucene.Net.Search.Suggest.Analyzing,BlendedInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\BlendedInfixSuggester.cs,CalculateCoefficient,Cyclomatic complexity of the method is 9
Complex Method,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Build,Cyclomatic complexity of the method is 15
Complex Method,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,DoLookup,Cyclomatic complexity of the method is 22
Complex Method,Lucene.Net.Search.Suggest.Fst,FSTCompletion,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletion.cs,LookupSortedByWeight,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Search.Suggest.Fst,WFSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\WFSTCompletionLookup.cs,DoLookup,Cyclomatic complexity of the method is 10
Complex Method,Lucene.Net.Search.Suggest.Jaspell,JaspellLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellLookup.cs,DoLookup,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,JaspellTernarySearchTrie,Cyclomatic complexity of the method is 14
Complex Method,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,DeleteNodeRecursion,Cyclomatic complexity of the method is 15
Complex Method,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,GetOrCreateNode,Cyclomatic complexity of the method is 11
Complex Method,Lucene.Net.Search.Suggest.Tst,TSTAutocomplete,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Tst\TSTAutocomplete.cs,PrefixCompletion,Cyclomatic complexity of the method is 14
Complex Method,Lucene.Net.Search.Suggest.Tst,TSTLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Tst\TSTLookup.cs,WriteRecursively,Cyclomatic complexity of the method is 11
Long Parameter List,Lucene.Net.Search.Spell,DirectSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\DirectSpellChecker.cs,SuggestSimilar,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Spell,DirectSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\DirectSpellChecker.cs,SuggestSimilar,The method has 7 parameters.
Long Parameter List,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SuggestSimilar,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SuggestSimilar,The method has 6 parameters.
Long Parameter List,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,SuggestWordBreaks,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,GenerateBreakUpSuggestions,The method has 9 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Analyzing,AnalyzingInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingInfixSuggester.cs,AnalyzingInfixSuggester,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Analyzing,AnalyzingInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingInfixSuggester.cs,DoLookup,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Analyzing,AnalyzingInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingInfixSuggester.cs,CreateResults,The method has 7 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,AnalyzingSuggester,The method has 6 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Analyzing,BlendedInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\BlendedInfixSuggester.cs,BlendedInfixSuggester,The method has 7 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Analyzing,BlendedInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\BlendedInfixSuggester.cs,DoLookup,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Analyzing,BlendedInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\BlendedInfixSuggester.cs,CreateResults,The method has 7 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Analyzing,FuzzySuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FuzzySuggester.cs,FuzzySuggester,The method has 11 parameters.
Long Parameter List,Lucene.Net.Search.Suggest,DocumentDictionary,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\DocumentDictionary.cs,DocumentDictionary,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Suggest,DocumentValueSourceDictionary,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\DocumentValueSourceDictionary.cs,DocumentValueSourceDictionary,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,Encode,The method has 7 parameters.
Long Parameter List,Lucene.Net.Search.Suggest,SortedTermFreqIteratorWrapper,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedTermFreqIteratorWrapper.cs,Encode,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Fst,FSTCompletion,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletion.cs,Collect,The method has 5 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,MatchAlmostRecursion,The method has 7 parameters.
Long Parameter List,Lucene.Net.Search.Suggest.Tst,TSTAutocomplete,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Tst\TSTAutocomplete.cs,BalancedTree,The method has 5 parameters.
Long Identifier,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,AnalyzingSuggester,The length of the parameter maxSurfaceFormsPerAnalyzedForm is 30.
Long Identifier,Lucene.Net.Search.Suggest.Analyzing,FuzzySuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FuzzySuggester.cs,FuzzySuggester,The length of the parameter maxSurfaceFormsPerAnalyzedForm is 30.
Long Statement,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The length of the statement  "			if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) { " is 143.
Long Statement,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,SuggestWordBreaks,The length of the statement  "	IComparer<SuggestWordArrayWrapper> queueComparer = sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY ? (IComparer<SuggestWordArrayWrapper>)new LengthThenMaxFreqComparer (this) : new LengthThenSumFreqComparer (this); " is 236.
Long Statement,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,SuggestWordBreaks,The length of the statement  "	PriorityQueue<SuggestWordArrayWrapper> suggestions = new PriorityQueue<SuggestWordArrayWrapper> (queueInitialCapacity' queueComparer); " is 134.
Long Statement,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,SuggestWordBreaks,The length of the statement  "	GenerateBreakUpSuggestions (term' ir' 1' maxSuggestions' useMinSuggestionFrequency' new SuggestWord[0]' suggestions' 0' sortMethod); " is 132.
Long Statement,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,SuggestWordCombinations,The length of the statement  "	PriorityQueue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper> (queueInitialCapacity' queueComparer); " is 136.
Long Statement,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,SuggestWordCombinations,The length of the statement  "						CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper (this' new CombineSuggestion (word' origIndexes)' (origIndexes.Length - 1)); " is 143.
Long Statement,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,GenerateBreakUpSuggestions,The length of the statement  "				int evaluations = GenerateBreakUpSuggestions (new Term (term.Field' rightWord.String)' ir' newNumberBreaks' maxSuggestions' useMinSuggestionFrequency' NewPrefix (prefix' leftWord)' suggestions' totalEvaluations' sortMethod); " is 224.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,AnalyzingInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingInfixSuggester.cs,Update,The length of the statement  "	writer.UpdateDocument (new Term (EXACT_TEXT_FIELD_NAME' text.Utf8ToString ())' BuildDocument (text' contexts' weight' payload)); " is 128.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The length of the statement  "					throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")"); " is 139.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The length of the statement  "						throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")"); " is 134.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The length of the statement  "							throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved"); " is 120.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Load,The length of the statement  "	this.fst = new FST<PairOutputs<long?' BytesRef>.Pair> (input' new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton)); " is 160.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,DoLookup,The length of the statement  "		IList<FSTUtil.Path<PairOutputs<long?' BytesRef>.Pair>> prefixPaths = FSTUtil.IntersectPrefixPaths (ConvertAutomaton (lookupAutomaton)' fst); " is 140.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,DoLookup,The length of the statement  "			searcher_Renamed = new Util.Fst.Util.TopNSearcher<PairOutputs<long?' BytesRef>.Pair> (fst' count * maxSurfaceFormsPerAnalyzedForm' count * maxSurfaceFormsPerAnalyzedForm' weightComparer); " is 187.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,DoLookup,The length of the statement  "		searcher = new TopNSearcherAnonymousInnerClassHelper (this' fst' num - results.Count' num * maxAnalyzedPathsForOneInput' weightComparer' utf8Key' results); " is 155.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Build,The length of the statement  "					throw new System.ArgumentException ("tokens must not contain separator byte; got token=" + term + " but gramCount=" + ngramCount + "' which is greater than expected max ngram size=" + grams); " is 191.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Load,The length of the statement  "		throw new InvalidOperationException ("separator=" + separator + " is incorrect: original model was built with separator=" + separatorOrig); " is 139.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Load,The length of the statement  "		throw new InvalidOperationException ("grams=" + grams + " is incorrect: original model was built with grams=" + gramsOrig); " is 123.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,DoLookup,The length of the statement  "				throw new System.ArgumentException ("tokens must not contain separator byte; got token=" + tokenBytes + " but gramCount=" + gramCount + " does not match recalculated count=" + CountGrams (tokenBytes)); " is 201.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,DoLookup,The length of the statement  "				Util.Fst.Util.TopNSearcher<long?> searcher = new TopNSearcherAnonymousInnerClassHelper (this' fst' num' num + seen.Count' weightComparer' seen' finalLastToken); " is 160.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,DoLookup,The length of the statement  "				LookupResult result = new LookupResult (spare.ToString ()' // LUCENENET NOTE: We need to calculate this as decimal because when using double it can sometimes  " is 157.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FSTUtil,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FSTUtil.cs,IntersectPrefixPaths,The length of the statement  "	queue.Add (new Path<T> (a.GetInitialState ()' fst.GetFirstArc (new FST.Arc<T> ())' fst.Outputs.NoOutput' new Int32sRef ())); " is 124.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FSTUtil,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FSTUtil.cs,IntersectPrefixPaths,The length of the statement  "					queue.Add (new Path<T> (t.Dest' new FST.Arc<T> ().CopyFrom (nextArc)' fst.Outputs.Add (path.Output' nextArc.Output)' newInput)); " is 128.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FSTUtil,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FSTUtil.cs,IntersectPrefixPaths,The length of the statement  "					queue.Add (new Path<T> (t.Dest' new FST.Arc<T> ().CopyFrom (nextArc)' fst.Outputs.Add (path.Output' nextArc.Output)' newInput)); " is 128.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FSTUtil,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FSTUtil.cs,IntersectPrefixPaths,The length of the statement  "					Debug.Assert (nextArc == null || label < nextArc.Label' "last: " + label + " next: " + (nextArc == null ? "" : nextArc.Label.ToString ())); " is 139.
Long Statement,Lucene.Net.Search.Suggest.Analyzing,FuzzySuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FuzzySuggester.cs,ToLevenshteinAutomata,The length of the statement  "			LevenshteinAutomata lev = new LevenshteinAutomata (ints' unicodeAware ? Character.MAX_CODE_POINT : 255' transpositions); " is 120.
Long Statement,Lucene.Net.Search.Suggest.Fst,FSTCompletionBuilder,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionBuilder.cs,BuildAutomaton,The length of the statement  "	Builder<object> builder = new Builder<object> (FST.INPUT_TYPE.BYTE1' 0' 0' true' true' shareMaxTailLength' outputs' null' false' PackedInt32s.DEFAULT' true' 15); " is 161.
Long Statement,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The length of the statement  "	FileInfo tempInput = FileSupport.CreateTempFile (typeof(FSTCompletionLookup).Name' ".input"' OfflineSorter.DefaultTempDir ()); " is 126.
Long Statement,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The length of the statement  "	FileInfo tempSorted = FileSupport.CreateTempFile (typeof(FSTCompletionLookup).Name' ".sorted"' OfflineSorter.DefaultTempDir ()); " is 128.
Long Statement,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The length of the statement  "		FSTCompletionBuilder builder = new FSTCompletionBuilder (buckets' sorter = new ExternalRefSorter (new OfflineSorter ())' sharedTailLength); " is 139.
Long Statement,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,GetSizeInBytes,The length of the statement  "	long mem = RamUsageEstimator.ShallowSizeOf (this) + RamUsageEstimator.ShallowSizeOf (normalCompletion) + RamUsageEstimator.ShallowSizeOf (higherWeightsCompletion); " is 163.
Long Statement,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,GetSizeInBytes,The length of the statement  "	if (higherWeightsCompletion != null && (normalCompletion == null || normalCompletion.FST != higherWeightsCompletion.FST)) { " is 123.
Long Statement,Lucene.Net.Search.Suggest.Fst,WFSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\WFSTCompletionLookup.cs,DoLookup,The length of the statement  "		results.Add (new LookupResult (spare.ToString ()' DecodeWeight (prefixOutput.GetValueOrDefault () + arc.NextFinalOutput.GetValueOrDefault ()))); " is 144.
Long Statement,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,MatchAlmost,The length of the statement  "	return MatchAlmostRecursion (rootNode' 0' matchAlmostDiff' key' ((numReturnValues < 0) ? -1 : numReturnValues)' new List<string> ()' false); " is 140.
Long Statement,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,MatchAlmostRecursion,The length of the statement  "	if ((currentNode == null) || (matchAlmostNumReturnValues != -1 && matchAlmostResult2.Count >= matchAlmostNumReturnValues) || (d < 0) || (charIndex >= matchAlmostKey.Length)) { " is 175.
Long Statement,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,MatchAlmostRecursion,The length of the statement  "		matchAlmostResult = MatchAlmostRecursion (currentNode.relatives [TSTNode.LOKID]' charIndex' d' matchAlmostKey' matchAlmostNumReturnValues' matchAlmostResult' upTo); " is 164.
Long Statement,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,MatchAlmostRecursion,The length of the statement  "	matchAlmostResult = MatchAlmostRecursion (currentNode.relatives [TSTNode.EQKID]' charIndex + 1' nextD' matchAlmostKey' matchAlmostNumReturnValues' matchAlmostResult' upTo); " is 172.
Long Statement,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,MatchAlmostRecursion,The length of the statement  "		matchAlmostResult = MatchAlmostRecursion (currentNode.relatives [TSTNode.HIKID]' charIndex' d' matchAlmostKey' matchAlmostNumReturnValues' matchAlmostResult' upTo); " is 164.
Long Statement,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,MatchPrefix,The length of the statement  "	return SortKeysRecursion (startNode.relatives [TSTNode.EQKID]' ((numReturnValues < 0) ? -1 : numReturnValues)' sortKeysResult); " is 127.
Long Statement,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,SortKeysRecursion,The length of the statement  "	IList<string> sortKeysResult = SortKeysRecursion (currentNode.relatives [TSTNode.LOKID]' sortKeysNumReturnValues' sortKeysResult2); " is 131.
Long Statement,Lucene.Net.Search.Suggest.Tst,TernaryTreeNode,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Tst\TernaryTreeNode.cs,GetSizeInBytes,The length of the statement  "		mem += RamUsageEstimator.ShallowSizeOf (token) + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER + RamUsageEstimator.NUM_BYTES_CHAR * token.Length; " is 140.
Complex Conditional,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The conditional expression  "i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]"  is complex.
Complex Conditional,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,MatchAlmostRecursion,The conditional expression  "(currentNode == null) || (matchAlmostNumReturnValues != -1 && matchAlmostResult2.Count >= matchAlmostNumReturnValues) || (d < 0) || (charIndex >= matchAlmostKey.Length)"  is complex.
Virtual Method Call from Constructor,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SpellChecker,The constructor "SpellChecker" calls a virtual method "SetSpellIndex".
Virtual Method Call from Constructor,Lucene.Net.Search.Suggest.Analyzing,AnalyzingInfixSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingInfixSuggester.cs,AnalyzingInfixSuggester,The constructor "AnalyzingInfixSuggester" calls a virtual method "GetIndexWriterConfig".
Virtual Method Call from Constructor,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,JaspellTernarySearchTrie,The constructor "JaspellTernarySearchTrie" calls a virtual method "GetOrCreateNode".
Magic Number,Lucene.Net.Search.Spell,JaroWinklerDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\JaroWinklerDistance.cs,Matches,The following statement contains a magic number: return new int[] {  	matches'  	transpositions / 2'  	prefix'  	max.Length  };  
Magic Number,Lucene.Net.Search.Spell,JaroWinklerDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\JaroWinklerDistance.cs,GetHashCode,The following statement contains a magic number: return 113 * Number.SingleToInt32Bits (threshold) * this.GetType ().GetHashCode ();  
Magic Number,Lucene.Net.Search.Spell,LevensteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LevensteinDistance.cs,GetHashCode,The following statement contains a magic number: return 163 * this.GetType ().GetHashCode ();  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: for (j = 1; j <= m; j++) {  	t_j = otherPoints.Int32s [j - 1];  	for (i = 1; i <= n; i++) {  		cost = targetPoints.Int32s [i - 1] == t_j ? 0 : 1;  		// minimum of cell to the left+1' to the top+1' diagonally left and up +cost  		d [i] [j] = Math.Min (Math.Min (d [i - 1] [j] + 1' d [i] [j - 1] + 1)' d [i - 1] [j - 1] + cost);  		// transposition  		if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  			d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  		}  	}  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: for (j = 1; j <= m; j++) {  	t_j = otherPoints.Int32s [j - 1];  	for (i = 1; i <= n; i++) {  		cost = targetPoints.Int32s [i - 1] == t_j ? 0 : 1;  		// minimum of cell to the left+1' to the top+1' diagonally left and up +cost  		d [i] [j] = Math.Min (Math.Min (d [i - 1] [j] + 1' d [i] [j - 1] + 1)' d [i - 1] [j - 1] + cost);  		// transposition  		if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  			d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  		}  	}  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: for (j = 1; j <= m; j++) {  	t_j = otherPoints.Int32s [j - 1];  	for (i = 1; i <= n; i++) {  		cost = targetPoints.Int32s [i - 1] == t_j ? 0 : 1;  		// minimum of cell to the left+1' to the top+1' diagonally left and up +cost  		d [i] [j] = Math.Min (Math.Min (d [i - 1] [j] + 1' d [i] [j - 1] + 1)' d [i - 1] [j - 1] + cost);  		// transposition  		if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  			d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  		}  	}  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: for (j = 1; j <= m; j++) {  	t_j = otherPoints.Int32s [j - 1];  	for (i = 1; i <= n; i++) {  		cost = targetPoints.Int32s [i - 1] == t_j ? 0 : 1;  		// minimum of cell to the left+1' to the top+1' diagonally left and up +cost  		d [i] [j] = Math.Min (Math.Min (d [i - 1] [j] + 1' d [i] [j - 1] + 1)' d [i - 1] [j - 1] + cost);  		// transposition  		if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  			d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  		}  	}  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: for (i = 1; i <= n; i++) {  	cost = targetPoints.Int32s [i - 1] == t_j ? 0 : 1;  	// minimum of cell to the left+1' to the top+1' diagonally left and up +cost  	d [i] [j] = Math.Min (Math.Min (d [i - 1] [j] + 1' d [i] [j - 1] + 1)' d [i - 1] [j - 1] + cost);  	// transposition  	if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  		d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  	}  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: for (i = 1; i <= n; i++) {  	cost = targetPoints.Int32s [i - 1] == t_j ? 0 : 1;  	// minimum of cell to the left+1' to the top+1' diagonally left and up +cost  	d [i] [j] = Math.Min (Math.Min (d [i - 1] [j] + 1' d [i] [j - 1] + 1)' d [i - 1] [j - 1] + cost);  	// transposition  	if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  		d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  	}  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: for (i = 1; i <= n; i++) {  	cost = targetPoints.Int32s [i - 1] == t_j ? 0 : 1;  	// minimum of cell to the left+1' to the top+1' diagonally left and up +cost  	d [i] [j] = Math.Min (Math.Min (d [i - 1] [j] + 1' d [i] [j - 1] + 1)' d [i - 1] [j - 1] + cost);  	// transposition  	if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  		d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  	}  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: for (i = 1; i <= n; i++) {  	cost = targetPoints.Int32s [i - 1] == t_j ? 0 : 1;  	// minimum of cell to the left+1' to the top+1' diagonally left and up +cost  	d [i] [j] = Math.Min (Math.Min (d [i - 1] [j] + 1' d [i] [j - 1] + 1)' d [i - 1] [j - 1] + cost);  	// transposition  	if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  		d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  	}  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  	d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  	d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  	d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: if (i > 1 && j > 1 && targetPoints.Int32s [i - 1] == otherPoints.Int32s [j - 2] && targetPoints.Int32s [i - 2] == otherPoints.Int32s [j - 1]) {  	d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  }  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  
Magic Number,Lucene.Net.Search.Spell,LuceneLevenshteinDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\LuceneLevenshteinDistance.cs,GetDistance,The following statement contains a magic number: d [i] [j] = Math.Min (d [i] [j]' d [i - 2] [j - 2] + cost);  
Magic Number,Lucene.Net.Search.Spell,NGramDistance,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\NGramDistance.cs,GetHashCode,The following statement contains a magic number: return 1427 * n * this.GetType ().GetHashCode ();  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SetSpellIndex,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	if (!DirectoryReader.IndexExists (spellIndexDir)) {  		#pragma  		using (var writer = new IndexWriter (spellIndexDir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null))) {  		}  		#pragma  	}  	SwapSearcher (spellIndexDir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SetSpellIndex,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	if (!DirectoryReader.IndexExists (spellIndexDir)) {  		#pragma  		using (var writer = new IndexWriter (spellIndexDir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null))) {  		}  		#pragma  	}  	SwapSearcher (spellIndexDir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SetSpellIndex,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	if (!DirectoryReader.IndexExists (spellIndexDir)) {  		#pragma  		using (var writer = new IndexWriter (spellIndexDir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null))) {  		}  		#pragma  	}  	SwapSearcher (spellIndexDir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SetSpellIndex,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	if (!DirectoryReader.IndexExists (spellIndexDir)) {  		#pragma  		using (var writer = new IndexWriter (spellIndexDir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null))) {  		}  		#pragma  	}  	SwapSearcher (spellIndexDir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SetSpellIndex,The following statement contains a magic number: if (!DirectoryReader.IndexExists (spellIndexDir)) {  	#pragma  	using (var writer = new IndexWriter (spellIndexDir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null))) {  	}  	#pragma  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SetSpellIndex,The following statement contains a magic number: if (!DirectoryReader.IndexExists (spellIndexDir)) {  	#pragma  	using (var writer = new IndexWriter (spellIndexDir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null))) {  	}  	#pragma  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SetSpellIndex,The following statement contains a magic number: if (!DirectoryReader.IndexExists (spellIndexDir)) {  	#pragma  	using (var writer = new IndexWriter (spellIndexDir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null))) {  	}  	#pragma  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SetSpellIndex,The following statement contains a magic number: if (!DirectoryReader.IndexExists (spellIndexDir)) {  	#pragma  	using (var writer = new IndexWriter (spellIndexDir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null))) {  	}  	#pragma  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,SuggestSimilar,The following statement contains a magic number: try {  	if (ir == null || field == null) {  		suggestMode = SuggestMode.SUGGEST_ALWAYS;  	}  	if (suggestMode == SuggestMode.SUGGEST_ALWAYS) {  		ir = null;  		field = null;  	}  	int lengthWord = word.Length;  	int freq = (ir != null && field != null) ? ir.DocFreq (new Term (field' word)) : 0;  	int goalFreq = suggestMode == SuggestMode.SUGGEST_MORE_POPULAR ? freq : 0;  	// if the word exists in the real index and we don't care for word frequency' return the word itself  	if (suggestMode == SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && freq > 0) {  		return new string[] {  			word  		};  	}  	BooleanQuery query = new BooleanQuery ();  	string[] grams;  	string key;  	for (int ng = GetMin (lengthWord); ng <= GetMax (lengthWord); ng++) {  		key = "gram" + ng;  		// form key  		grams = FormGrams (word' ng);  		// form word into ngrams (allow dups too)  		if (grams.Length == 0) {  			continue;  			// hmm  		}  		if (bStart > 0)// should we boost prefixes?  		 {  			Add (query' "start" + ng' grams [0]' bStart);  			// matches start of word  		}  		if (bEnd > 0)// should we boost suffixes  		 {  			Add (query' "end" + ng' grams [grams.Length - 1]' bEnd);  			// matches end of word  		}  		for (int i = 0; i < grams.Length; i++) {  			Add (query' key' grams [i]);  		}  	}  	int maxHits = 10 * numSug;  	//    System.out.println("Q: " + query);  	ScoreDoc[] hits = indexSearcher.Search (query' null' maxHits).ScoreDocs;  	//    System.out.println("HITS: " + hits.length());  	SuggestWordQueue sugQueue = new SuggestWordQueue (numSug' comparer);  	// go thru more than 'maxr' matches in case the distance filter triggers  	int stop = Math.Min (hits.Length' maxHits);  	SuggestWord sugWord = new SuggestWord ();  	for (int i = 0; i < stop; i++) {  		sugWord.String = indexSearcher.Doc (hits [i].Doc).Get (F_WORD);  		// get orig word  		// don't suggest a word for itself' that would be silly  		if (sugWord.String.Equals (word)) {  			continue;  		}  		// edit distance  		sugWord.Score = sd.GetDistance (word' sugWord.String);  		if (sugWord.Score < accuracy) {  			continue;  		}  		if (ir != null && field != null)// use the user index  		 {  			sugWord.Freq = ir.DocFreq (new Term (field' sugWord.String));  			// freq in the index  			// don't suggest a word that is not present in the field  			if ((suggestMode == SuggestMode.SUGGEST_MORE_POPULAR && goalFreq > sugWord.Freq) || sugWord.Freq < 1) {  				continue;  			}  		}  		sugQueue.InsertWithOverflow (sugWord);  		if (sugQueue.Count == numSug) {  			// if queue full' maintain the minScore score  			accuracy = sugQueue.Top.Score;  		}  		sugWord = new SuggestWord ();  	}  	// convert to array string  	string[] list = new string[sugQueue.Count];  	for (int i = sugQueue.Count - 1; i >= 0; i--) {  		list [i] = sugQueue.Pop ().String;  	}  	return list;  } finally {  	ReleaseSearcher (indexSearcher);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,ClearIndex,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	var dir = this.spellIndex;  	#pragma  	using (var writer = new IndexWriter (dir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null) {  		OpenMode = OpenMode.CREATE  	})) {  	}  	#pragma  	SwapSearcher (dir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,ClearIndex,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	var dir = this.spellIndex;  	#pragma  	using (var writer = new IndexWriter (dir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null) {  		OpenMode = OpenMode.CREATE  	})) {  	}  	#pragma  	SwapSearcher (dir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,ClearIndex,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	var dir = this.spellIndex;  	#pragma  	using (var writer = new IndexWriter (dir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null) {  		OpenMode = OpenMode.CREATE  	})) {  	}  	#pragma  	SwapSearcher (dir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,ClearIndex,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	var dir = this.spellIndex;  	#pragma  	using (var writer = new IndexWriter (dir' new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' null) {  		OpenMode = OpenMode.CREATE  	})) {  	}  	#pragma  	SwapSearcher (dir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,IndexDictionary,The following statement contains a magic number: lock (modifyCurrentIndexLock) {  	EnsureOpen ();  	Directory dir = this.spellIndex;  	using (var writer = new IndexWriter (dir' config)) {  		IndexSearcher indexSearcher = ObtainSearcher ();  		IList<TermsEnum> termsEnums = new List<TermsEnum> ();  		IndexReader reader = searcher.IndexReader;  		if (reader.MaxDoc > 0) {  			foreach (AtomicReaderContext ctx in reader.Leaves) {  				Terms terms = ctx.AtomicReader.GetTerms (F_WORD);  				if (terms != null) {  					termsEnums.Add (terms.GetIterator (null));  				}  			}  		}  		bool isEmpty = termsEnums.Count == 0;  		try {  			IBytesRefIterator iter = dict.GetEntryIterator ();  			BytesRef currentTerm;  			while ((currentTerm = iter.Next ()) != null) {  				string word = currentTerm.Utf8ToString ();  				int len = word.Length;  				if (len < 3) {  					continue;  					// too short we bail but "too long" is fine...  				}  				if (!isEmpty) {  					foreach (TermsEnum te in termsEnums) {  						if (te.SeekExact (currentTerm)) {  							goto termsContinue;  						}  					}  				}  				// ok index the word  				var doc = CreateDocument (word' GetMin (len)' GetMax (len));  				writer.AddDocument (doc);  				termsContinue:  				;  			}  		} finally {  			ReleaseSearcher (indexSearcher);  		}  		if (fullMerge) {  			writer.ForceMerge (1);  		}  	}  	// TODO: this isn't that great' maybe in the future SpellChecker should take  	// IWC in its ctor / keep its writer open?  	// also re-open the spell index to see our own changes when the next suggestion  	// is fetched:  	SwapSearcher (dir);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,IndexDictionary,The following statement contains a magic number: using (var writer = new IndexWriter (dir' config)) {  	IndexSearcher indexSearcher = ObtainSearcher ();  	IList<TermsEnum> termsEnums = new List<TermsEnum> ();  	IndexReader reader = searcher.IndexReader;  	if (reader.MaxDoc > 0) {  		foreach (AtomicReaderContext ctx in reader.Leaves) {  			Terms terms = ctx.AtomicReader.GetTerms (F_WORD);  			if (terms != null) {  				termsEnums.Add (terms.GetIterator (null));  			}  		}  	}  	bool isEmpty = termsEnums.Count == 0;  	try {  		IBytesRefIterator iter = dict.GetEntryIterator ();  		BytesRef currentTerm;  		while ((currentTerm = iter.Next ()) != null) {  			string word = currentTerm.Utf8ToString ();  			int len = word.Length;  			if (len < 3) {  				continue;  				// too short we bail but "too long" is fine...  			}  			if (!isEmpty) {  				foreach (TermsEnum te in termsEnums) {  					if (te.SeekExact (currentTerm)) {  						goto termsContinue;  					}  				}  			}  			// ok index the word  			var doc = CreateDocument (word' GetMin (len)' GetMax (len));  			writer.AddDocument (doc);  			termsContinue:  			;  		}  	} finally {  		ReleaseSearcher (indexSearcher);  	}  	if (fullMerge) {  		writer.ForceMerge (1);  	}  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,IndexDictionary,The following statement contains a magic number: try {  	IBytesRefIterator iter = dict.GetEntryIterator ();  	BytesRef currentTerm;  	while ((currentTerm = iter.Next ()) != null) {  		string word = currentTerm.Utf8ToString ();  		int len = word.Length;  		if (len < 3) {  			continue;  			// too short we bail but "too long" is fine...  		}  		if (!isEmpty) {  			foreach (TermsEnum te in termsEnums) {  				if (te.SeekExact (currentTerm)) {  					goto termsContinue;  				}  			}  		}  		// ok index the word  		var doc = CreateDocument (word' GetMin (len)' GetMax (len));  		writer.AddDocument (doc);  		termsContinue:  		;  	}  } finally {  	ReleaseSearcher (indexSearcher);  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,IndexDictionary,The following statement contains a magic number: while ((currentTerm = iter.Next ()) != null) {  	string word = currentTerm.Utf8ToString ();  	int len = word.Length;  	if (len < 3) {  		continue;  		// too short we bail but "too long" is fine...  	}  	if (!isEmpty) {  		foreach (TermsEnum te in termsEnums) {  			if (te.SeekExact (currentTerm)) {  				goto termsContinue;  			}  		}  	}  	// ok index the word  	var doc = CreateDocument (word' GetMin (len)' GetMax (len));  	writer.AddDocument (doc);  	termsContinue:  	;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,IndexDictionary,The following statement contains a magic number: if (len < 3) {  	continue;  	// too short we bail but "too long" is fine...  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMin,The following statement contains a magic number: if (l > 5) {  	return 3;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMin,The following statement contains a magic number: if (l > 5) {  	return 3;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMin,The following statement contains a magic number: return 3;  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMin,The following statement contains a magic number: if (l == 5) {  	return 2;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMin,The following statement contains a magic number: if (l == 5) {  	return 2;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMin,The following statement contains a magic number: return 2;  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMax,The following statement contains a magic number: if (l > 5) {  	return 4;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMax,The following statement contains a magic number: if (l > 5) {  	return 4;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMax,The following statement contains a magic number: return 4;  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMax,The following statement contains a magic number: if (l == 5) {  	return 3;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMax,The following statement contains a magic number: if (l == 5) {  	return 3;  }  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMax,The following statement contains a magic number: return 3;  
Magic Number,Lucene.Net.Search.Spell,SpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\SpellChecker.cs,GetMax,The following statement contains a magic number: return 2;  
Magic Number,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,GenerateBreakUpSuggestions,The following statement contains a magic number: if (termLength < (useMinBreakWordLength * 2)) {  	return 0;  }  
Magic Number,Lucene.Net.Search.Spell,WordBreakSpellChecker,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Spell\WordBreakSpellChecker.cs,NewSuggestion,The following statement contains a magic number: newSuggestion [newSuggestion.Length - 2] = append1;  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,AnalyzingSuggester,The following statement contains a magic number: if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {  	throw new System.ArgumentException ("maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: " + maxSurfaceFormsPerAnalyzedForm + ")");  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: try {  	var output = new ByteArrayDataOutput (buffer);  	BytesRef surfaceForm;  	while ((surfaceForm = iterator.Next ()) != null) {  		ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  		maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  		foreach (Int32sRef path in paths) {  			Util.Fst.Util.ToBytesRef (path' scratch);  			// length of the analyzed text (FST input)  			if (scratch.Length > ushort.MaxValue - 2) {  				throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  			}  			ushort analyzedLength = (ushort)scratch.Length;  			// compute the required length:  			// analyzed sequence + weight (4) + surface + analyzedLength (short)  			int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  			BytesRef payload;  			if (hasPayloads) {  				if (surfaceForm.Length > (ushort.MaxValue - 2)) {  					throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  				}  				payload = iterator.Payload;  				// payload + surfaceLength (short)  				requiredLength += payload.Length + 2;  			} else {  				payload = null;  			}  			buffer = ArrayUtil.Grow (buffer' requiredLength);  			output.Reset (buffer);  			output.WriteInt16 ((short)analyzedLength);  			output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  			output.WriteInt32 (EncodeWeight (iterator.Weight));  			if (hasPayloads) {  				for (int i = 0; i < surfaceForm.Length; i++) {  					if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  						throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  					}  				}  				output.WriteInt16 ((short)surfaceForm.Length);  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  				output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  			} else {  				output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			}  			Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  			writer.Write (buffer' 0' output.Position);  		}  		count++;  	}  	writer.Dispose ();  	// Sort all input/output pairs (required by FST.Builder):  	(new OfflineSorter (new AnalyzingComparer (hasPayloads))).Sort (tempInput' tempSorted);  	// Free disk space:  	tempInput.Delete ();  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	var outputs = new PairOutputs<long?' BytesRef> (PositiveInt32Outputs.Singleton' ByteSequenceOutputs.Singleton);  	var builder = new Builder<PairOutputs<long?' BytesRef>.Pair> (FST.INPUT_TYPE.BYTE1' outputs);  	// Build FST:  	BytesRef previousAnalyzed = null;  	BytesRef analyzed = new BytesRef ();  	BytesRef surface = new BytesRef ();  	Int32sRef scratchInts = new Int32sRef ();  	var input = new ByteArrayDataInput ();  	// Used to remove duplicate surface forms (but we  	// still index the hightest-weight one).  We clear  	// this when we see a new analyzed form' so it cannot  	// grow unbounded (at most 256 entries):  	var seenSurfaceForms = new HashSet<BytesRef> ();  	var dedup = 0;  	while (reader.Read (scratch)) {  		input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  		ushort analyzedLength = (ushort)input.ReadInt16 ();  		analyzed.Grow (analyzedLength + 2);  		input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  		analyzed.Length = analyzedLength;  		long cost = input.ReadInt32 ();  		surface.Bytes = scratch.Bytes;  		if (hasPayloads) {  			surface.Length = (ushort)input.ReadInt16 ();  			surface.Offset = input.Position;  		} else {  			surface.Offset = input.Position;  			surface.Length = scratch.Length - surface.Offset;  		}  		if (previousAnalyzed == null) {  			previousAnalyzed = new BytesRef ();  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else if (analyzed.Equals (previousAnalyzed)) {  			dedup++;  			if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  				// More than maxSurfaceFormsPerAnalyzedForm  				// dups: skip the rest:  				continue;  			}  			if (seenSurfaceForms.Contains (surface)) {  				continue;  			}  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		} else {  			dedup = 0;  			previousAnalyzed.CopyBytes (analyzed);  			seenSurfaceForms.Clear ();  			seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  		}  		// TODO: I think we can avoid the extra 2 bytes when  		// there is no dup (dedup==0)' but we'd have to fix  		// the exactFirst logic ... which would be sort of  		// hairy because we'd need to special case the two  		// (dup/not dup)...  		// NOTE: must be byte 0 so we sort before whatever  		// is next  		analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  		analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  		analyzed.Length += 2;  		Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  		//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  		if (!hasPayloads) {  			builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  		} else {  			int payloadOffset = input.Position + surface.Length;  			int payloadLength = scratch.Length - payloadOffset;  			BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  			Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  			br.Bytes [surface.Length] = PAYLOAD_SEP;  			Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  			br.Length = br.Bytes.Length;  			builder.Add (scratchInts' outputs.NewPair (cost' br));  		}  	}  	fst = builder.Finish ();  	//Util.dotToFile(fst' "/tmp/suggest.dot");  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while ((surfaceForm = iterator.Next ()) != null) {  	ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  	maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  	foreach (Int32sRef path in paths) {  		Util.Fst.Util.ToBytesRef (path' scratch);  		// length of the analyzed text (FST input)  		if (scratch.Length > ushort.MaxValue - 2) {  			throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  		}  		ushort analyzedLength = (ushort)scratch.Length;  		// compute the required length:  		// analyzed sequence + weight (4) + surface + analyzedLength (short)  		int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  		BytesRef payload;  		if (hasPayloads) {  			if (surfaceForm.Length > (ushort.MaxValue - 2)) {  				throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  			}  			payload = iterator.Payload;  			// payload + surfaceLength (short)  			requiredLength += payload.Length + 2;  		} else {  			payload = null;  		}  		buffer = ArrayUtil.Grow (buffer' requiredLength);  		output.Reset (buffer);  		output.WriteInt16 ((short)analyzedLength);  		output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		if (hasPayloads) {  			for (int i = 0; i < surfaceForm.Length; i++) {  				if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  					throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  				}  			}  			output.WriteInt16 ((short)surfaceForm.Length);  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  		} else {  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		}  		Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  		writer.Write (buffer' 0' output.Position);  	}  	count++;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while ((surfaceForm = iterator.Next ()) != null) {  	ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  	maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  	foreach (Int32sRef path in paths) {  		Util.Fst.Util.ToBytesRef (path' scratch);  		// length of the analyzed text (FST input)  		if (scratch.Length > ushort.MaxValue - 2) {  			throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  		}  		ushort analyzedLength = (ushort)scratch.Length;  		// compute the required length:  		// analyzed sequence + weight (4) + surface + analyzedLength (short)  		int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  		BytesRef payload;  		if (hasPayloads) {  			if (surfaceForm.Length > (ushort.MaxValue - 2)) {  				throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  			}  			payload = iterator.Payload;  			// payload + surfaceLength (short)  			requiredLength += payload.Length + 2;  		} else {  			payload = null;  		}  		buffer = ArrayUtil.Grow (buffer' requiredLength);  		output.Reset (buffer);  		output.WriteInt16 ((short)analyzedLength);  		output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		if (hasPayloads) {  			for (int i = 0; i < surfaceForm.Length; i++) {  				if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  					throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  				}  			}  			output.WriteInt16 ((short)surfaceForm.Length);  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  		} else {  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		}  		Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  		writer.Write (buffer' 0' output.Position);  	}  	count++;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while ((surfaceForm = iterator.Next ()) != null) {  	ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  	maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  	foreach (Int32sRef path in paths) {  		Util.Fst.Util.ToBytesRef (path' scratch);  		// length of the analyzed text (FST input)  		if (scratch.Length > ushort.MaxValue - 2) {  			throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  		}  		ushort analyzedLength = (ushort)scratch.Length;  		// compute the required length:  		// analyzed sequence + weight (4) + surface + analyzedLength (short)  		int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  		BytesRef payload;  		if (hasPayloads) {  			if (surfaceForm.Length > (ushort.MaxValue - 2)) {  				throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  			}  			payload = iterator.Payload;  			// payload + surfaceLength (short)  			requiredLength += payload.Length + 2;  		} else {  			payload = null;  		}  		buffer = ArrayUtil.Grow (buffer' requiredLength);  		output.Reset (buffer);  		output.WriteInt16 ((short)analyzedLength);  		output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		if (hasPayloads) {  			for (int i = 0; i < surfaceForm.Length; i++) {  				if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  					throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  				}  			}  			output.WriteInt16 ((short)surfaceForm.Length);  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  		} else {  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		}  		Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  		writer.Write (buffer' 0' output.Position);  	}  	count++;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while ((surfaceForm = iterator.Next ()) != null) {  	ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  	maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  	foreach (Int32sRef path in paths) {  		Util.Fst.Util.ToBytesRef (path' scratch);  		// length of the analyzed text (FST input)  		if (scratch.Length > ushort.MaxValue - 2) {  			throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  		}  		ushort analyzedLength = (ushort)scratch.Length;  		// compute the required length:  		// analyzed sequence + weight (4) + surface + analyzedLength (short)  		int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  		BytesRef payload;  		if (hasPayloads) {  			if (surfaceForm.Length > (ushort.MaxValue - 2)) {  				throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  			}  			payload = iterator.Payload;  			// payload + surfaceLength (short)  			requiredLength += payload.Length + 2;  		} else {  			payload = null;  		}  		buffer = ArrayUtil.Grow (buffer' requiredLength);  		output.Reset (buffer);  		output.WriteInt16 ((short)analyzedLength);  		output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		if (hasPayloads) {  			for (int i = 0; i < surfaceForm.Length; i++) {  				if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  					throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  				}  			}  			output.WriteInt16 ((short)surfaceForm.Length);  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  		} else {  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		}  		Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  		writer.Write (buffer' 0' output.Position);  	}  	count++;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while ((surfaceForm = iterator.Next ()) != null) {  	ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  	maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  	foreach (Int32sRef path in paths) {  		Util.Fst.Util.ToBytesRef (path' scratch);  		// length of the analyzed text (FST input)  		if (scratch.Length > ushort.MaxValue - 2) {  			throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  		}  		ushort analyzedLength = (ushort)scratch.Length;  		// compute the required length:  		// analyzed sequence + weight (4) + surface + analyzedLength (short)  		int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  		BytesRef payload;  		if (hasPayloads) {  			if (surfaceForm.Length > (ushort.MaxValue - 2)) {  				throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  			}  			payload = iterator.Payload;  			// payload + surfaceLength (short)  			requiredLength += payload.Length + 2;  		} else {  			payload = null;  		}  		buffer = ArrayUtil.Grow (buffer' requiredLength);  		output.Reset (buffer);  		output.WriteInt16 ((short)analyzedLength);  		output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		if (hasPayloads) {  			for (int i = 0; i < surfaceForm.Length; i++) {  				if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  					throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  				}  			}  			output.WriteInt16 ((short)surfaceForm.Length);  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  		} else {  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		}  		Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  		writer.Write (buffer' 0' output.Position);  	}  	count++;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while ((surfaceForm = iterator.Next ()) != null) {  	ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  	maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  	foreach (Int32sRef path in paths) {  		Util.Fst.Util.ToBytesRef (path' scratch);  		// length of the analyzed text (FST input)  		if (scratch.Length > ushort.MaxValue - 2) {  			throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  		}  		ushort analyzedLength = (ushort)scratch.Length;  		// compute the required length:  		// analyzed sequence + weight (4) + surface + analyzedLength (short)  		int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  		BytesRef payload;  		if (hasPayloads) {  			if (surfaceForm.Length > (ushort.MaxValue - 2)) {  				throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  			}  			payload = iterator.Payload;  			// payload + surfaceLength (short)  			requiredLength += payload.Length + 2;  		} else {  			payload = null;  		}  		buffer = ArrayUtil.Grow (buffer' requiredLength);  		output.Reset (buffer);  		output.WriteInt16 ((short)analyzedLength);  		output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		if (hasPayloads) {  			for (int i = 0; i < surfaceForm.Length; i++) {  				if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  					throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  				}  			}  			output.WriteInt16 ((short)surfaceForm.Length);  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  		} else {  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		}  		Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  		writer.Write (buffer' 0' output.Position);  	}  	count++;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while ((surfaceForm = iterator.Next ()) != null) {  	ISet<Int32sRef> paths = ToFiniteStrings (surfaceForm' ts2a);  	maxAnalyzedPathsForOneInput = Math.Max (maxAnalyzedPathsForOneInput' paths.Count);  	foreach (Int32sRef path in paths) {  		Util.Fst.Util.ToBytesRef (path' scratch);  		// length of the analyzed text (FST input)  		if (scratch.Length > ushort.MaxValue - 2) {  			throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  		}  		ushort analyzedLength = (ushort)scratch.Length;  		// compute the required length:  		// analyzed sequence + weight (4) + surface + analyzedLength (short)  		int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  		BytesRef payload;  		if (hasPayloads) {  			if (surfaceForm.Length > (ushort.MaxValue - 2)) {  				throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  			}  			payload = iterator.Payload;  			// payload + surfaceLength (short)  			requiredLength += payload.Length + 2;  		} else {  			payload = null;  		}  		buffer = ArrayUtil.Grow (buffer' requiredLength);  		output.Reset (buffer);  		output.WriteInt16 ((short)analyzedLength);  		output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		if (hasPayloads) {  			for (int i = 0; i < surfaceForm.Length; i++) {  				if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  					throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  				}  			}  			output.WriteInt16 ((short)surfaceForm.Length);  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  			output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  		} else {  			output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		}  		Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  		writer.Write (buffer' 0' output.Position);  	}  	count++;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: foreach (Int32sRef path in paths) {  	Util.Fst.Util.ToBytesRef (path' scratch);  	// length of the analyzed text (FST input)  	if (scratch.Length > ushort.MaxValue - 2) {  		throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  	}  	ushort analyzedLength = (ushort)scratch.Length;  	// compute the required length:  	// analyzed sequence + weight (4) + surface + analyzedLength (short)  	int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  	BytesRef payload;  	if (hasPayloads) {  		if (surfaceForm.Length > (ushort.MaxValue - 2)) {  			throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  		}  		payload = iterator.Payload;  		// payload + surfaceLength (short)  		requiredLength += payload.Length + 2;  	} else {  		payload = null;  	}  	buffer = ArrayUtil.Grow (buffer' requiredLength);  	output.Reset (buffer);  	output.WriteInt16 ((short)analyzedLength);  	output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	if (hasPayloads) {  		for (int i = 0; i < surfaceForm.Length; i++) {  			if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  				throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  			}  		}  		output.WriteInt16 ((short)surfaceForm.Length);  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  	} else {  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  	}  	Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: foreach (Int32sRef path in paths) {  	Util.Fst.Util.ToBytesRef (path' scratch);  	// length of the analyzed text (FST input)  	if (scratch.Length > ushort.MaxValue - 2) {  		throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  	}  	ushort analyzedLength = (ushort)scratch.Length;  	// compute the required length:  	// analyzed sequence + weight (4) + surface + analyzedLength (short)  	int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  	BytesRef payload;  	if (hasPayloads) {  		if (surfaceForm.Length > (ushort.MaxValue - 2)) {  			throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  		}  		payload = iterator.Payload;  		// payload + surfaceLength (short)  		requiredLength += payload.Length + 2;  	} else {  		payload = null;  	}  	buffer = ArrayUtil.Grow (buffer' requiredLength);  	output.Reset (buffer);  	output.WriteInt16 ((short)analyzedLength);  	output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	if (hasPayloads) {  		for (int i = 0; i < surfaceForm.Length; i++) {  			if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  				throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  			}  		}  		output.WriteInt16 ((short)surfaceForm.Length);  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  	} else {  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  	}  	Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: foreach (Int32sRef path in paths) {  	Util.Fst.Util.ToBytesRef (path' scratch);  	// length of the analyzed text (FST input)  	if (scratch.Length > ushort.MaxValue - 2) {  		throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  	}  	ushort analyzedLength = (ushort)scratch.Length;  	// compute the required length:  	// analyzed sequence + weight (4) + surface + analyzedLength (short)  	int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  	BytesRef payload;  	if (hasPayloads) {  		if (surfaceForm.Length > (ushort.MaxValue - 2)) {  			throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  		}  		payload = iterator.Payload;  		// payload + surfaceLength (short)  		requiredLength += payload.Length + 2;  	} else {  		payload = null;  	}  	buffer = ArrayUtil.Grow (buffer' requiredLength);  	output.Reset (buffer);  	output.WriteInt16 ((short)analyzedLength);  	output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	if (hasPayloads) {  		for (int i = 0; i < surfaceForm.Length; i++) {  			if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  				throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  			}  		}  		output.WriteInt16 ((short)surfaceForm.Length);  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  	} else {  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  	}  	Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: foreach (Int32sRef path in paths) {  	Util.Fst.Util.ToBytesRef (path' scratch);  	// length of the analyzed text (FST input)  	if (scratch.Length > ushort.MaxValue - 2) {  		throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  	}  	ushort analyzedLength = (ushort)scratch.Length;  	// compute the required length:  	// analyzed sequence + weight (4) + surface + analyzedLength (short)  	int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  	BytesRef payload;  	if (hasPayloads) {  		if (surfaceForm.Length > (ushort.MaxValue - 2)) {  			throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  		}  		payload = iterator.Payload;  		// payload + surfaceLength (short)  		requiredLength += payload.Length + 2;  	} else {  		payload = null;  	}  	buffer = ArrayUtil.Grow (buffer' requiredLength);  	output.Reset (buffer);  	output.WriteInt16 ((short)analyzedLength);  	output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	if (hasPayloads) {  		for (int i = 0; i < surfaceForm.Length; i++) {  			if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  				throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  			}  		}  		output.WriteInt16 ((short)surfaceForm.Length);  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  	} else {  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  	}  	Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: foreach (Int32sRef path in paths) {  	Util.Fst.Util.ToBytesRef (path' scratch);  	// length of the analyzed text (FST input)  	if (scratch.Length > ushort.MaxValue - 2) {  		throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  	}  	ushort analyzedLength = (ushort)scratch.Length;  	// compute the required length:  	// analyzed sequence + weight (4) + surface + analyzedLength (short)  	int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  	BytesRef payload;  	if (hasPayloads) {  		if (surfaceForm.Length > (ushort.MaxValue - 2)) {  			throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  		}  		payload = iterator.Payload;  		// payload + surfaceLength (short)  		requiredLength += payload.Length + 2;  	} else {  		payload = null;  	}  	buffer = ArrayUtil.Grow (buffer' requiredLength);  	output.Reset (buffer);  	output.WriteInt16 ((short)analyzedLength);  	output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	if (hasPayloads) {  		for (int i = 0; i < surfaceForm.Length; i++) {  			if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  				throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  			}  		}  		output.WriteInt16 ((short)surfaceForm.Length);  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  	} else {  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  	}  	Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: foreach (Int32sRef path in paths) {  	Util.Fst.Util.ToBytesRef (path' scratch);  	// length of the analyzed text (FST input)  	if (scratch.Length > ushort.MaxValue - 2) {  		throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  	}  	ushort analyzedLength = (ushort)scratch.Length;  	// compute the required length:  	// analyzed sequence + weight (4) + surface + analyzedLength (short)  	int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  	BytesRef payload;  	if (hasPayloads) {  		if (surfaceForm.Length > (ushort.MaxValue - 2)) {  			throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  		}  		payload = iterator.Payload;  		// payload + surfaceLength (short)  		requiredLength += payload.Length + 2;  	} else {  		payload = null;  	}  	buffer = ArrayUtil.Grow (buffer' requiredLength);  	output.Reset (buffer);  	output.WriteInt16 ((short)analyzedLength);  	output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	if (hasPayloads) {  		for (int i = 0; i < surfaceForm.Length; i++) {  			if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  				throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  			}  		}  		output.WriteInt16 ((short)surfaceForm.Length);  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  	} else {  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  	}  	Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: foreach (Int32sRef path in paths) {  	Util.Fst.Util.ToBytesRef (path' scratch);  	// length of the analyzed text (FST input)  	if (scratch.Length > ushort.MaxValue - 2) {  		throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  	}  	ushort analyzedLength = (ushort)scratch.Length;  	// compute the required length:  	// analyzed sequence + weight (4) + surface + analyzedLength (short)  	int requiredLength = analyzedLength + 4 + surfaceForm.Length + 2;  	BytesRef payload;  	if (hasPayloads) {  		if (surfaceForm.Length > (ushort.MaxValue - 2)) {  			throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  		}  		payload = iterator.Payload;  		// payload + surfaceLength (short)  		requiredLength += payload.Length + 2;  	} else {  		payload = null;  	}  	buffer = ArrayUtil.Grow (buffer' requiredLength);  	output.Reset (buffer);  	output.WriteInt16 ((short)analyzedLength);  	output.WriteBytes (scratch.Bytes' scratch.Offset' scratch.Length);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	if (hasPayloads) {  		for (int i = 0; i < surfaceForm.Length; i++) {  			if (surfaceForm.Bytes [i] == PAYLOAD_SEP) {  				throw new ArgumentException ("surface form cannot contain unit separator character U+001F; this character is reserved");  			}  		}  		output.WriteInt16 ((short)surfaceForm.Length);  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  		output.WriteBytes (payload.Bytes' payload.Offset' payload.Length);  	} else {  		output.WriteBytes (surfaceForm.Bytes' surfaceForm.Offset' surfaceForm.Length);  	}  	Debug.Assert (output.Position == requiredLength' output.Position + " vs " + requiredLength);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: if (scratch.Length > ushort.MaxValue - 2) {  	throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: if (scratch.Length > ushort.MaxValue - 2) {  	throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: throw new System.ArgumentException ("cannot handle analyzed forms > " + (ushort.MaxValue - 2) + " in length (got " + scratch.Length + ")");  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: if (hasPayloads) {  	if (surfaceForm.Length > (ushort.MaxValue - 2)) {  		throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  	}  	payload = iterator.Payload;  	// payload + surfaceLength (short)  	requiredLength += payload.Length + 2;  } else {  	payload = null;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: if (hasPayloads) {  	if (surfaceForm.Length > (ushort.MaxValue - 2)) {  		throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  	}  	payload = iterator.Payload;  	// payload + surfaceLength (short)  	requiredLength += payload.Length + 2;  } else {  	payload = null;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: if (hasPayloads) {  	if (surfaceForm.Length > (ushort.MaxValue - 2)) {  		throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  	}  	payload = iterator.Payload;  	// payload + surfaceLength (short)  	requiredLength += payload.Length + 2;  } else {  	payload = null;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: if (surfaceForm.Length > (ushort.MaxValue - 2)) {  	throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: if (surfaceForm.Length > (ushort.MaxValue - 2)) {  	throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: throw new ArgumentException ("cannot handle surface form > " + (ushort.MaxValue - 2) + " in length (got " + surfaceForm.Length + ")");  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: requiredLength += payload.Length + 2;  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while (reader.Read (scratch)) {  	input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  	ushort analyzedLength = (ushort)input.ReadInt16 ();  	analyzed.Grow (analyzedLength + 2);  	input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  	analyzed.Length = analyzedLength;  	long cost = input.ReadInt32 ();  	surface.Bytes = scratch.Bytes;  	if (hasPayloads) {  		surface.Length = (ushort)input.ReadInt16 ();  		surface.Offset = input.Position;  	} else {  		surface.Offset = input.Position;  		surface.Length = scratch.Length - surface.Offset;  	}  	if (previousAnalyzed == null) {  		previousAnalyzed = new BytesRef ();  		previousAnalyzed.CopyBytes (analyzed);  		seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  	} else if (analyzed.Equals (previousAnalyzed)) {  		dedup++;  		if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  			// More than maxSurfaceFormsPerAnalyzedForm  			// dups: skip the rest:  			continue;  		}  		if (seenSurfaceForms.Contains (surface)) {  			continue;  		}  		seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  	} else {  		dedup = 0;  		previousAnalyzed.CopyBytes (analyzed);  		seenSurfaceForms.Clear ();  		seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  	}  	// TODO: I think we can avoid the extra 2 bytes when  	// there is no dup (dedup==0)' but we'd have to fix  	// the exactFirst logic ... which would be sort of  	// hairy because we'd need to special case the two  	// (dup/not dup)...  	// NOTE: must be byte 0 so we sort before whatever  	// is next  	analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  	analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  	analyzed.Length += 2;  	Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  	//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  	if (!hasPayloads) {  		builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  	} else {  		int payloadOffset = input.Position + surface.Length;  		int payloadLength = scratch.Length - payloadOffset;  		BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  		Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  		br.Bytes [surface.Length] = PAYLOAD_SEP;  		Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  		br.Length = br.Bytes.Length;  		builder.Add (scratchInts' outputs.NewPair (cost' br));  	}  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: while (reader.Read (scratch)) {  	input.Reset (scratch.Bytes' scratch.Offset' scratch.Length);  	ushort analyzedLength = (ushort)input.ReadInt16 ();  	analyzed.Grow (analyzedLength + 2);  	input.ReadBytes (analyzed.Bytes' 0' analyzedLength);  	analyzed.Length = analyzedLength;  	long cost = input.ReadInt32 ();  	surface.Bytes = scratch.Bytes;  	if (hasPayloads) {  		surface.Length = (ushort)input.ReadInt16 ();  		surface.Offset = input.Position;  	} else {  		surface.Offset = input.Position;  		surface.Length = scratch.Length - surface.Offset;  	}  	if (previousAnalyzed == null) {  		previousAnalyzed = new BytesRef ();  		previousAnalyzed.CopyBytes (analyzed);  		seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  	} else if (analyzed.Equals (previousAnalyzed)) {  		dedup++;  		if (dedup >= maxSurfaceFormsPerAnalyzedForm) {  			// More than maxSurfaceFormsPerAnalyzedForm  			// dups: skip the rest:  			continue;  		}  		if (seenSurfaceForms.Contains (surface)) {  			continue;  		}  		seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  	} else {  		dedup = 0;  		previousAnalyzed.CopyBytes (analyzed);  		seenSurfaceForms.Clear ();  		seenSurfaceForms.Add (BytesRef.DeepCopyOf (surface));  	}  	// TODO: I think we can avoid the extra 2 bytes when  	// there is no dup (dedup==0)' but we'd have to fix  	// the exactFirst logic ... which would be sort of  	// hairy because we'd need to special case the two  	// (dup/not dup)...  	// NOTE: must be byte 0 so we sort before whatever  	// is next  	analyzed.Bytes [analyzed.Offset + analyzed.Length] = 0;  	analyzed.Bytes [analyzed.Offset + analyzed.Length + 1] = (byte)dedup;  	analyzed.Length += 2;  	Util.Fst.Util.ToInt32sRef (analyzed' scratchInts);  	//System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());  	if (!hasPayloads) {  		builder.Add (scratchInts' outputs.NewPair (cost' BytesRef.DeepCopyOf (surface)));  	} else {  		int payloadOffset = input.Position + surface.Length;  		int payloadLength = scratch.Length - payloadOffset;  		BytesRef br = new BytesRef (surface.Length + 1 + payloadLength);  		Array.Copy (surface.Bytes' surface.Offset' br.Bytes' 0' surface.Length);  		br.Bytes [surface.Length] = PAYLOAD_SEP;  		Array.Copy (scratch.Bytes' payloadOffset' br.Bytes' surface.Length + 1' payloadLength);  		br.Length = br.Bytes.Length;  		builder.Add (scratchInts' outputs.NewPair (cost' br));  	}  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: analyzed.Grow (analyzedLength + 2);  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,AnalyzingSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\AnalyzingSuggester.cs,Build,The following statement contains a magic number: analyzed.Length += 2;  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Build,The following statement contains a magic number: using (Directory dir = FSDirectory.Open (tempIndexPath)) {  	#pragma  	IndexWriterConfig iwc = new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' indexAnalyzer);  	#pragma  	iwc.SetOpenMode (OpenMode.CREATE);  	iwc.SetRAMBufferSizeMB (ramBufferSizeMB);  	IndexWriter writer = new IndexWriter (dir' iwc);  	var ft = new FieldType (TextField.TYPE_NOT_STORED);  	// TODO: if only we had IndexOptions.TERMS_ONLY...  	ft.IndexOptions = IndexOptions.DOCS_AND_FREQS;  	ft.OmitNorms = true;  	ft.Freeze ();  	Document doc = new Document ();  	Field field = new Field ("body"' ""' ft);  	doc.Add (field);  	totTokens = 0;  	IndexReader reader = null;  	bool success = false;  	count = 0;  	try {  		while (true) {  			BytesRef surfaceForm = iterator.Next ();  			if (surfaceForm == null) {  				break;  			}  			field.SetStringValue (surfaceForm.Utf8ToString ());  			writer.AddDocument (doc);  			count++;  		}  		reader = DirectoryReader.Open (writer' false);  		Terms terms = MultiFields.GetTerms (reader' "body");  		if (terms == null) {  			throw new System.ArgumentException ("need at least one suggestion");  		}  		// Move all ngrams into an FST:  		TermsEnum termsEnum = terms.GetIterator (null);  		Outputs<long?> outputs = PositiveInt32Outputs.Singleton;  		Builder<long?> builder = new Builder<long?> (FST.INPUT_TYPE.BYTE1' outputs);  		Int32sRef scratchInts = new Int32sRef ();  		while (true) {  			BytesRef term = termsEnum.Next ();  			if (term == null) {  				break;  			}  			int ngramCount = CountGrams (term);  			if (ngramCount > grams) {  				throw new System.ArgumentException ("tokens must not contain separator byte; got token=" + term + " but gramCount=" + ngramCount + "' which is greater than expected max ngram size=" + grams);  			}  			if (ngramCount == 1) {  				totTokens += termsEnum.TotalTermFreq;  			}  			builder.Add (Lucene.Net.Util.Fst.Util.ToInt32sRef (term' scratchInts)' EncodeWeight (termsEnum.TotalTermFreq));  		}  		fst = builder.Finish ();  		if (fst == null) {  			throw new System.ArgumentException ("need at least one suggestion");  		}  		//System.out.println("FST: " + fst.getNodeCount() + " nodes");  		/*                     PrintWriter pw = new PrintWriter("/x/tmp/out.dot");                     Util.toDot(fst' pw' true' true);                     pw.close();                     */success = true;  	} finally {  		try {  			if (success) {  				IOUtils.Close (writer' reader);  			} else {  				IOUtils.CloseWhileHandlingException (writer' reader);  			}  		} finally {  			foreach (string file in dir.ListAll ()) {  				FileInfo path = new FileInfo (Path.Combine (tempIndexPath.FullName' file));  				try {  					path.Delete ();  				} catch (Exception e) {  					throw new InvalidOperationException ("failed to remove " + path' e);  				}  			}  			try {  				tempIndexPath.Delete ();  			} catch (Exception e) {  				throw new InvalidOperationException ("failed to remove " + tempIndexPath' e);  			}  		}  	}  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Build,The following statement contains a magic number: using (Directory dir = FSDirectory.Open (tempIndexPath)) {  	#pragma  	IndexWriterConfig iwc = new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' indexAnalyzer);  	#pragma  	iwc.SetOpenMode (OpenMode.CREATE);  	iwc.SetRAMBufferSizeMB (ramBufferSizeMB);  	IndexWriter writer = new IndexWriter (dir' iwc);  	var ft = new FieldType (TextField.TYPE_NOT_STORED);  	// TODO: if only we had IndexOptions.TERMS_ONLY...  	ft.IndexOptions = IndexOptions.DOCS_AND_FREQS;  	ft.OmitNorms = true;  	ft.Freeze ();  	Document doc = new Document ();  	Field field = new Field ("body"' ""' ft);  	doc.Add (field);  	totTokens = 0;  	IndexReader reader = null;  	bool success = false;  	count = 0;  	try {  		while (true) {  			BytesRef surfaceForm = iterator.Next ();  			if (surfaceForm == null) {  				break;  			}  			field.SetStringValue (surfaceForm.Utf8ToString ());  			writer.AddDocument (doc);  			count++;  		}  		reader = DirectoryReader.Open (writer' false);  		Terms terms = MultiFields.GetTerms (reader' "body");  		if (terms == null) {  			throw new System.ArgumentException ("need at least one suggestion");  		}  		// Move all ngrams into an FST:  		TermsEnum termsEnum = terms.GetIterator (null);  		Outputs<long?> outputs = PositiveInt32Outputs.Singleton;  		Builder<long?> builder = new Builder<long?> (FST.INPUT_TYPE.BYTE1' outputs);  		Int32sRef scratchInts = new Int32sRef ();  		while (true) {  			BytesRef term = termsEnum.Next ();  			if (term == null) {  				break;  			}  			int ngramCount = CountGrams (term);  			if (ngramCount > grams) {  				throw new System.ArgumentException ("tokens must not contain separator byte; got token=" + term + " but gramCount=" + ngramCount + "' which is greater than expected max ngram size=" + grams);  			}  			if (ngramCount == 1) {  				totTokens += termsEnum.TotalTermFreq;  			}  			builder.Add (Lucene.Net.Util.Fst.Util.ToInt32sRef (term' scratchInts)' EncodeWeight (termsEnum.TotalTermFreq));  		}  		fst = builder.Finish ();  		if (fst == null) {  			throw new System.ArgumentException ("need at least one suggestion");  		}  		//System.out.println("FST: " + fst.getNodeCount() + " nodes");  		/*                     PrintWriter pw = new PrintWriter("/x/tmp/out.dot");                     Util.toDot(fst' pw' true' true);                     pw.close();                     */success = true;  	} finally {  		try {  			if (success) {  				IOUtils.Close (writer' reader);  			} else {  				IOUtils.CloseWhileHandlingException (writer' reader);  			}  		} finally {  			foreach (string file in dir.ListAll ()) {  				FileInfo path = new FileInfo (Path.Combine (tempIndexPath.FullName' file));  				try {  					path.Delete ();  				} catch (Exception e) {  					throw new InvalidOperationException ("failed to remove " + path' e);  				}  			}  			try {  				tempIndexPath.Delete ();  			} catch (Exception e) {  				throw new InvalidOperationException ("failed to remove " + tempIndexPath' e);  			}  		}  	}  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Build,The following statement contains a magic number: using (Directory dir = FSDirectory.Open (tempIndexPath)) {  	#pragma  	IndexWriterConfig iwc = new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' indexAnalyzer);  	#pragma  	iwc.SetOpenMode (OpenMode.CREATE);  	iwc.SetRAMBufferSizeMB (ramBufferSizeMB);  	IndexWriter writer = new IndexWriter (dir' iwc);  	var ft = new FieldType (TextField.TYPE_NOT_STORED);  	// TODO: if only we had IndexOptions.TERMS_ONLY...  	ft.IndexOptions = IndexOptions.DOCS_AND_FREQS;  	ft.OmitNorms = true;  	ft.Freeze ();  	Document doc = new Document ();  	Field field = new Field ("body"' ""' ft);  	doc.Add (field);  	totTokens = 0;  	IndexReader reader = null;  	bool success = false;  	count = 0;  	try {  		while (true) {  			BytesRef surfaceForm = iterator.Next ();  			if (surfaceForm == null) {  				break;  			}  			field.SetStringValue (surfaceForm.Utf8ToString ());  			writer.AddDocument (doc);  			count++;  		}  		reader = DirectoryReader.Open (writer' false);  		Terms terms = MultiFields.GetTerms (reader' "body");  		if (terms == null) {  			throw new System.ArgumentException ("need at least one suggestion");  		}  		// Move all ngrams into an FST:  		TermsEnum termsEnum = terms.GetIterator (null);  		Outputs<long?> outputs = PositiveInt32Outputs.Singleton;  		Builder<long?> builder = new Builder<long?> (FST.INPUT_TYPE.BYTE1' outputs);  		Int32sRef scratchInts = new Int32sRef ();  		while (true) {  			BytesRef term = termsEnum.Next ();  			if (term == null) {  				break;  			}  			int ngramCount = CountGrams (term);  			if (ngramCount > grams) {  				throw new System.ArgumentException ("tokens must not contain separator byte; got token=" + term + " but gramCount=" + ngramCount + "' which is greater than expected max ngram size=" + grams);  			}  			if (ngramCount == 1) {  				totTokens += termsEnum.TotalTermFreq;  			}  			builder.Add (Lucene.Net.Util.Fst.Util.ToInt32sRef (term' scratchInts)' EncodeWeight (termsEnum.TotalTermFreq));  		}  		fst = builder.Finish ();  		if (fst == null) {  			throw new System.ArgumentException ("need at least one suggestion");  		}  		//System.out.println("FST: " + fst.getNodeCount() + " nodes");  		/*                     PrintWriter pw = new PrintWriter("/x/tmp/out.dot");                     Util.toDot(fst' pw' true' true);                     pw.close();                     */success = true;  	} finally {  		try {  			if (success) {  				IOUtils.Close (writer' reader);  			} else {  				IOUtils.CloseWhileHandlingException (writer' reader);  			}  		} finally {  			foreach (string file in dir.ListAll ()) {  				FileInfo path = new FileInfo (Path.Combine (tempIndexPath.FullName' file));  				try {  					path.Delete ();  				} catch (Exception e) {  					throw new InvalidOperationException ("failed to remove " + path' e);  				}  			}  			try {  				tempIndexPath.Delete ();  			} catch (Exception e) {  				throw new InvalidOperationException ("failed to remove " + tempIndexPath' e);  			}  		}  	}  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,Build,The following statement contains a magic number: using (Directory dir = FSDirectory.Open (tempIndexPath)) {  	#pragma  	IndexWriterConfig iwc = new IndexWriterConfig (LuceneVersion.LUCENE_CURRENT' indexAnalyzer);  	#pragma  	iwc.SetOpenMode (OpenMode.CREATE);  	iwc.SetRAMBufferSizeMB (ramBufferSizeMB);  	IndexWriter writer = new IndexWriter (dir' iwc);  	var ft = new FieldType (TextField.TYPE_NOT_STORED);  	// TODO: if only we had IndexOptions.TERMS_ONLY...  	ft.IndexOptions = IndexOptions.DOCS_AND_FREQS;  	ft.OmitNorms = true;  	ft.Freeze ();  	Document doc = new Document ();  	Field field = new Field ("body"' ""' ft);  	doc.Add (field);  	totTokens = 0;  	IndexReader reader = null;  	bool success = false;  	count = 0;  	try {  		while (true) {  			BytesRef surfaceForm = iterator.Next ();  			if (surfaceForm == null) {  				break;  			}  			field.SetStringValue (surfaceForm.Utf8ToString ());  			writer.AddDocument (doc);  			count++;  		}  		reader = DirectoryReader.Open (writer' false);  		Terms terms = MultiFields.GetTerms (reader' "body");  		if (terms == null) {  			throw new System.ArgumentException ("need at least one suggestion");  		}  		// Move all ngrams into an FST:  		TermsEnum termsEnum = terms.GetIterator (null);  		Outputs<long?> outputs = PositiveInt32Outputs.Singleton;  		Builder<long?> builder = new Builder<long?> (FST.INPUT_TYPE.BYTE1' outputs);  		Int32sRef scratchInts = new Int32sRef ();  		while (true) {  			BytesRef term = termsEnum.Next ();  			if (term == null) {  				break;  			}  			int ngramCount = CountGrams (term);  			if (ngramCount > grams) {  				throw new System.ArgumentException ("tokens must not contain separator byte; got token=" + term + " but gramCount=" + ngramCount + "' which is greater than expected max ngram size=" + grams);  			}  			if (ngramCount == 1) {  				totTokens += termsEnum.TotalTermFreq;  			}  			builder.Add (Lucene.Net.Util.Fst.Util.ToInt32sRef (term' scratchInts)' EncodeWeight (termsEnum.TotalTermFreq));  		}  		fst = builder.Finish ();  		if (fst == null) {  			throw new System.ArgumentException ("need at least one suggestion");  		}  		//System.out.println("FST: " + fst.getNodeCount() + " nodes");  		/*                     PrintWriter pw = new PrintWriter("/x/tmp/out.dot");                     Util.toDot(fst' pw' true' true);                     pw.close();                     */success = true;  	} finally {  		try {  			if (success) {  				IOUtils.Close (writer' reader);  			} else {  				IOUtils.CloseWhileHandlingException (writer' reader);  			}  		} finally {  			foreach (string file in dir.ListAll ()) {  				FileInfo path = new FileInfo (Path.Combine (tempIndexPath.FullName' file));  				try {  					path.Delete ();  				} catch (Exception e) {  					throw new InvalidOperationException ("failed to remove " + path' e);  				}  			}  			try {  				tempIndexPath.Delete ();  			} catch (Exception e) {  				throw new InvalidOperationException ("failed to remove " + tempIndexPath' e);  			}  		}  	}  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,DoLookup,The following statement contains a magic number: try {  	ITermToBytesRefAttribute termBytesAtt = ts.AddAttribute<ITermToBytesRefAttribute> ();  	IOffsetAttribute offsetAtt = ts.AddAttribute<IOffsetAttribute> ();  	IPositionLengthAttribute posLenAtt = ts.AddAttribute<IPositionLengthAttribute> ();  	IPositionIncrementAttribute posIncAtt = ts.AddAttribute<IPositionIncrementAttribute> ();  	ts.Reset ();  	var lastTokens = new BytesRef[grams];  	//System.out.println("lookup: key='" + key + "'");  	// Run full analysis' but save only the  	// last 1gram' last 2gram' etc.:  	BytesRef tokenBytes = termBytesAtt.BytesRef;  	int maxEndOffset = -1;  	bool sawRealToken = false;  	while (ts.IncrementToken ()) {  		termBytesAtt.FillBytesRef ();  		sawRealToken |= tokenBytes.Length > 0;  		// TODO: this is somewhat iffy; today' ShingleFilter  		// sets posLen to the gram count; maybe we should make  		// a separate dedicated att for this?  		int gramCount = posLenAtt.PositionLength;  		Debug.Assert (gramCount <= grams);  		// Safety: make sure the recalculated count "agrees":  		if (CountGrams (tokenBytes) != gramCount) {  			throw new System.ArgumentException ("tokens must not contain separator byte; got token=" + tokenBytes + " but gramCount=" + gramCount + " does not match recalculated count=" + CountGrams (tokenBytes));  		}  		maxEndOffset = Math.Max (maxEndOffset' offsetAtt.EndOffset);  		lastTokens [gramCount - 1] = BytesRef.DeepCopyOf (tokenBytes);  	}  	ts.End ();  	if (!sawRealToken) {  		throw new System.ArgumentException ("no tokens produced by analyzer' or the only tokens were empty strings");  	}  	// Carefully fill last tokens with _ tokens;  	// ShingleFilter appraently won't emit "only hole"  	// tokens:  	int endPosInc = posIncAtt.PositionIncrement;  	// Note this will also be true if input is the empty  	// string (in which case we saw no tokens and  	// maxEndOffset is still -1)' which in fact works out OK  	// because we fill the unigram with an empty BytesRef  	// below:  	bool lastTokenEnded = offsetAtt.EndOffset > maxEndOffset || endPosInc > 0;  	//System.out.println("maxEndOffset=" + maxEndOffset + " vs " + offsetAtt.EndOffset);  	if (lastTokenEnded) {  		//System.out.println("  lastTokenEnded");  		// If user hit space after the last token' then  		// "upgrade" all tokens.  This way "foo " will suggest  		// all bigrams starting w/ foo' and not any unigrams  		// starting with "foo":  		for (int i = grams - 1; i > 0; i--) {  			BytesRef token = lastTokens [i - 1];  			if (token == null) {  				continue;  			}  			token.Grow (token.Length + 1);  			token.Bytes [token.Length] = separator;  			token.Length++;  			lastTokens [i] = token;  		}  		lastTokens [0] = new BytesRef ();  	}  	var arc = new FST.Arc<long?> ();  	var bytesReader = fst.GetBytesReader ();  	// Try highest order models first' and if they return  	// results' return that; else' fallback:  	double backoff = 1.0;  	List<LookupResult> results = new List<LookupResult> (num);  	// We only add a given suffix once' from the highest  	// order model that saw it; for subsequent lower order  	// models we skip it:  	var seen = new HashSet<BytesRef> ();  	for (int gram = grams - 1; gram >= 0; gram--) {  		BytesRef token = lastTokens [gram];  		// Don't make unigram predictions from empty string:  		if (token == null || (token.Length == 0 && key.Length > 0)) {  			// Input didn't have enough tokens:  			//System.out.println("  gram=" + gram + ": skip: not enough input");  			continue;  		}  		if (endPosInc > 0 && gram <= endPosInc) {  			// Skip hole-only predictions; in theory we  			// shouldn't have to do this' but we'd need to fix  			// ShingleFilter to produce only-hole tokens:  			//System.out.println("  break: only holes now");  			break;  		}  		//System.out.println("try " + (gram+1) + " gram token=" + token.utf8ToString());  		// TODO: we could add fuzziness here  		// match the prefix portion exactly  		//Pair<Long'BytesRef> prefixOutput = null;  		long? prefixOutput = null;  		try {  			prefixOutput = LookupPrefix (fst' bytesReader' token' arc);  		} catch (IOException bogus) {  			throw new Exception (bogus.ToString ()' bogus);  		}  		//System.out.println("  prefixOutput=" + prefixOutput);  		if (prefixOutput == null) {  			// This model never saw this prefix' e.g. the  			// trigram model never saw context "purple mushroom"  			backoff *= ALPHA;  			continue;  		}  		// TODO: we could do this division at build time' and  		// bake it into the FST?  		// Denominator for computing scores from current  		// model's predictions:  		long contextCount = totTokens;  		BytesRef lastTokenFragment = null;  		for (int i = token.Length - 1; i >= 0; i--) {  			if (token.Bytes [token.Offset + i] == separator) {  				BytesRef context = new BytesRef (token.Bytes' token.Offset' i);  				long? output = Lucene.Net.Util.Fst.Util.Get (fst' Lucene.Net.Util.Fst.Util.ToInt32sRef (context' new Int32sRef ()));  				Debug.Assert (output != null);  				contextCount = DecodeWeight (output);  				lastTokenFragment = new BytesRef (token.Bytes' token.Offset + i + 1' token.Length - i - 1);  				break;  			}  		}  		BytesRef finalLastToken;  		if (lastTokenFragment == null) {  			finalLastToken = BytesRef.DeepCopyOf (token);  		} else {  			finalLastToken = BytesRef.DeepCopyOf (lastTokenFragment);  		}  		Debug.Assert (finalLastToken.Offset == 0);  		CharsRef spare = new CharsRef ();  		// complete top-N  		Util.Fst.Util.TopResults<long?> completions = null;  		try {  			// Because we store multiple models in one FST  			// (1gram' 2gram' 3gram)' we must restrict the  			// search so that it only considers the current  			// model.  For highest order model' this is not  			// necessary since all completions in the FST  			// must be from this model' but for lower order  			// models we have to filter out the higher order  			// ones:  			// Must do num+seen.size() for queue depth because we may  			// reject up to seen.size() paths in acceptResult():  			Util.Fst.Util.TopNSearcher<long?> searcher = new TopNSearcherAnonymousInnerClassHelper (this' fst' num' num + seen.Count' weightComparer' seen' finalLastToken);  			// since this search is initialized with a single start node   			// it is okay to start with an empty input path here  			searcher.AddStartPaths (arc' prefixOutput' true' new Int32sRef ());  			completions = searcher.Search ();  			Debug.Assert (completions.IsComplete);  		} catch (IOException bogus) {  			throw new Exception (bogus.ToString ()' bogus);  		}  		int prefixLength = token.Length;  		BytesRef suffix = new BytesRef (8);  		//System.out.println("    " + completions.length + " completions");  		foreach (Util.Fst.Util.Result<long?> completion in completions) {  			token.Length = prefixLength;  			// append suffix  			Util.Fst.Util.ToBytesRef (completion.Input' suffix);  			token.Append (suffix);  			//System.out.println("    completion " + token.utf8ToString());  			// Skip this path if a higher-order model already  			// saw/predicted its last token:  			BytesRef lastToken = token;  			for (int i = token.Length - 1; i >= 0; i--) {  				if (token.Bytes [token.Offset + i] == separator) {  					Debug.Assert (token.Length - i - 1 > 0);  					lastToken = new BytesRef (token.Bytes' token.Offset + i + 1' token.Length - i - 1);  					break;  				}  			}  			if (seen.Contains (lastToken)) {  				//System.out.println("      skip dup " + lastToken.utf8ToString());  				goto nextCompletionContinue;  			}  			seen.Add (BytesRef.DeepCopyOf (lastToken));  			spare.Grow (token.Length);  			UnicodeUtil.UTF8toUTF16 (token' spare);  			LookupResult result = new LookupResult (spare.ToString ()' // LUCENENET NOTE: We need to calculate this as decimal because when using double it can sometimes   			// return numbers that are greater than long.MaxValue' which results in a negative long number.  			(long)(long.MaxValue * (decimal)backoff * ((decimal)DecodeWeight (completion.Output)) / contextCount));  			results.Add (result);  			Debug.Assert (results.Count == seen.Count);  			//System.out.println("  add result=" + result);  			nextCompletionContinue:  			;  		}  		backoff *= ALPHA;  	}  	results.Sort (new ComparerAnonymousInnerClassHelper (this));  	if (results.Count > num) {  		results.SubList (num' results.Count).Clear ();  	}  	return results;  } finally {  	IOUtils.CloseWhileHandlingException (ts);  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,FreeTextSuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FreeTextSuggester.cs,DoLookup,The following statement contains a magic number: for (int gram = grams - 1; gram >= 0; gram--) {  	BytesRef token = lastTokens [gram];  	// Don't make unigram predictions from empty string:  	if (token == null || (token.Length == 0 && key.Length > 0)) {  		// Input didn't have enough tokens:  		//System.out.println("  gram=" + gram + ": skip: not enough input");  		continue;  	}  	if (endPosInc > 0 && gram <= endPosInc) {  		// Skip hole-only predictions; in theory we  		// shouldn't have to do this' but we'd need to fix  		// ShingleFilter to produce only-hole tokens:  		//System.out.println("  break: only holes now");  		break;  	}  	//System.out.println("try " + (gram+1) + " gram token=" + token.utf8ToString());  	// TODO: we could add fuzziness here  	// match the prefix portion exactly  	//Pair<Long'BytesRef> prefixOutput = null;  	long? prefixOutput = null;  	try {  		prefixOutput = LookupPrefix (fst' bytesReader' token' arc);  	} catch (IOException bogus) {  		throw new Exception (bogus.ToString ()' bogus);  	}  	//System.out.println("  prefixOutput=" + prefixOutput);  	if (prefixOutput == null) {  		// This model never saw this prefix' e.g. the  		// trigram model never saw context "purple mushroom"  		backoff *= ALPHA;  		continue;  	}  	// TODO: we could do this division at build time' and  	// bake it into the FST?  	// Denominator for computing scores from current  	// model's predictions:  	long contextCount = totTokens;  	BytesRef lastTokenFragment = null;  	for (int i = token.Length - 1; i >= 0; i--) {  		if (token.Bytes [token.Offset + i] == separator) {  			BytesRef context = new BytesRef (token.Bytes' token.Offset' i);  			long? output = Lucene.Net.Util.Fst.Util.Get (fst' Lucene.Net.Util.Fst.Util.ToInt32sRef (context' new Int32sRef ()));  			Debug.Assert (output != null);  			contextCount = DecodeWeight (output);  			lastTokenFragment = new BytesRef (token.Bytes' token.Offset + i + 1' token.Length - i - 1);  			break;  		}  	}  	BytesRef finalLastToken;  	if (lastTokenFragment == null) {  		finalLastToken = BytesRef.DeepCopyOf (token);  	} else {  		finalLastToken = BytesRef.DeepCopyOf (lastTokenFragment);  	}  	Debug.Assert (finalLastToken.Offset == 0);  	CharsRef spare = new CharsRef ();  	// complete top-N  	Util.Fst.Util.TopResults<long?> completions = null;  	try {  		// Because we store multiple models in one FST  		// (1gram' 2gram' 3gram)' we must restrict the  		// search so that it only considers the current  		// model.  For highest order model' this is not  		// necessary since all completions in the FST  		// must be from this model' but for lower order  		// models we have to filter out the higher order  		// ones:  		// Must do num+seen.size() for queue depth because we may  		// reject up to seen.size() paths in acceptResult():  		Util.Fst.Util.TopNSearcher<long?> searcher = new TopNSearcherAnonymousInnerClassHelper (this' fst' num' num + seen.Count' weightComparer' seen' finalLastToken);  		// since this search is initialized with a single start node   		// it is okay to start with an empty input path here  		searcher.AddStartPaths (arc' prefixOutput' true' new Int32sRef ());  		completions = searcher.Search ();  		Debug.Assert (completions.IsComplete);  	} catch (IOException bogus) {  		throw new Exception (bogus.ToString ()' bogus);  	}  	int prefixLength = token.Length;  	BytesRef suffix = new BytesRef (8);  	//System.out.println("    " + completions.length + " completions");  	foreach (Util.Fst.Util.Result<long?> completion in completions) {  		token.Length = prefixLength;  		// append suffix  		Util.Fst.Util.ToBytesRef (completion.Input' suffix);  		token.Append (suffix);  		//System.out.println("    completion " + token.utf8ToString());  		// Skip this path if a higher-order model already  		// saw/predicted its last token:  		BytesRef lastToken = token;  		for (int i = token.Length - 1; i >= 0; i--) {  			if (token.Bytes [token.Offset + i] == separator) {  				Debug.Assert (token.Length - i - 1 > 0);  				lastToken = new BytesRef (token.Bytes' token.Offset + i + 1' token.Length - i - 1);  				break;  			}  		}  		if (seen.Contains (lastToken)) {  			//System.out.println("      skip dup " + lastToken.utf8ToString());  			goto nextCompletionContinue;  		}  		seen.Add (BytesRef.DeepCopyOf (lastToken));  		spare.Grow (token.Length);  		UnicodeUtil.UTF8toUTF16 (token' spare);  		LookupResult result = new LookupResult (spare.ToString ()' // LUCENENET NOTE: We need to calculate this as decimal because when using double it can sometimes   		// return numbers that are greater than long.MaxValue' which results in a negative long number.  		(long)(long.MaxValue * (decimal)backoff * ((decimal)DecodeWeight (completion.Output)) / contextCount));  		results.Add (result);  		Debug.Assert (results.Count == seen.Count);  		//System.out.println("  add result=" + result);  		nextCompletionContinue:  		;  	}  	backoff *= ALPHA;  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,FuzzySuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FuzzySuggester.cs,ToLevenshteinAutomata,The following statement contains a magic number: foreach (Int32sRef path in @ref) {  	if (path.Length <= nonFuzzyPrefix || path.Length < minFuzzyLength) {  		subs [upto] = BasicAutomata.MakeString (path.Int32s' path.Offset' path.Length);  		upto++;  	} else {  		Automaton prefix = BasicAutomata.MakeString (path.Int32s' path.Offset' nonFuzzyPrefix);  		int[] ints = new int[path.Length - nonFuzzyPrefix];  		Array.Copy (path.Int32s' path.Offset + nonFuzzyPrefix' ints' 0' ints.Length);  		// TODO: maybe add alphaMin to LevenshteinAutomata'  		// and pass 1 instead of 0?  We probably don't want  		// to allow the trailing dedup bytes to be  		// edited... but then 0 byte is "in general" allowed  		// on input (but not in UTF8).  		LevenshteinAutomata lev = new LevenshteinAutomata (ints' unicodeAware ? Character.MAX_CODE_POINT : 255' transpositions);  		Automaton levAutomaton = lev.ToAutomaton (maxEdits);  		Automaton combined = BasicOperations.Concatenate (Arrays.AsList (prefix' levAutomaton));  		combined.IsDeterministic = true;  		// its like the special case in concatenate itself' except we cloneExpanded already  		subs [upto] = combined;  		upto++;  	}  }  
Magic Number,Lucene.Net.Search.Suggest.Analyzing,FuzzySuggester,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Analyzing\FuzzySuggester.cs,ToLevenshteinAutomata,The following statement contains a magic number: if (path.Length <= nonFuzzyPrefix || path.Length < minFuzzyLength) {  	subs [upto] = BasicAutomata.MakeString (path.Int32s' path.Offset' path.Length);  	upto++;  } else {  	Automaton prefix = BasicAutomata.MakeString (path.Int32s' path.Offset' nonFuzzyPrefix);  	int[] ints = new int[path.Length - nonFuzzyPrefix];  	Array.Copy (path.Int32s' path.Offset + nonFuzzyPrefix' ints' 0' ints.Length);  	// TODO: maybe add alphaMin to LevenshteinAutomata'  	// and pass 1 instead of 0?  We probably don't want  	// to allow the trailing dedup bytes to be  	// edited... but then 0 byte is "in general" allowed  	// on input (but not in UTF8).  	LevenshteinAutomata lev = new LevenshteinAutomata (ints' unicodeAware ? Character.MAX_CODE_POINT : 255' transpositions);  	Automaton levAutomaton = lev.ToAutomaton (maxEdits);  	Automaton combined = BasicOperations.Concatenate (Arrays.AsList (prefix' levAutomaton));  	combined.IsDeterministic = true;  	// its like the special case in concatenate itself' except we cloneExpanded already  	subs [upto] = combined;  	upto++;  }  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,Encode,The following statement contains a magic number: if (hasContexts) {  	foreach (BytesRef ctx in contexts) {  		requiredLength += 2 + ctx.Length;  	}  	requiredLength += 2;  	// for length of contexts  }  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,Encode,The following statement contains a magic number: if (hasContexts) {  	foreach (BytesRef ctx in contexts) {  		requiredLength += 2 + ctx.Length;  	}  	requiredLength += 2;  	// for length of contexts  }  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,Encode,The following statement contains a magic number: foreach (BytesRef ctx in contexts) {  	requiredLength += 2 + ctx.Length;  }  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,Encode,The following statement contains a magic number: requiredLength += 2 + ctx.Length;  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,Encode,The following statement contains a magic number: requiredLength += 2;  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,Decode,The following statement contains a magic number: tmpInput.SkipBytes (scratch.Length - 8);  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,Decode,The following statement contains a magic number: scratch.Length -= 8;  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodeContexts,The following statement contains a magic number: tmpInput.SkipBytes (scratch.Length - 2);  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodeContexts,The following statement contains a magic number: scratch.Length -= 2;  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodeContexts,The following statement contains a magic number: for (ushort i = 0; i < ctxSetSize; i++) {  	tmpInput.Position = scratch.Length - 2;  	ushort curContextLength = (ushort)tmpInput.ReadInt16 ();  	scratch.Length -= 2;  	tmpInput.Position = scratch.Length - curContextLength;  	BytesRef contextSpare = new BytesRef (curContextLength);  	tmpInput.ReadBytes (contextSpare.Bytes' 0' curContextLength);  	contextSpare.Length = curContextLength;  	contextSet.Add (contextSpare);  	scratch.Length -= curContextLength;  }  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodeContexts,The following statement contains a magic number: for (ushort i = 0; i < ctxSetSize; i++) {  	tmpInput.Position = scratch.Length - 2;  	ushort curContextLength = (ushort)tmpInput.ReadInt16 ();  	scratch.Length -= 2;  	tmpInput.Position = scratch.Length - curContextLength;  	BytesRef contextSpare = new BytesRef (curContextLength);  	tmpInput.ReadBytes (contextSpare.Bytes' 0' curContextLength);  	contextSpare.Length = curContextLength;  	contextSet.Add (contextSpare);  	scratch.Length -= curContextLength;  }  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodeContexts,The following statement contains a magic number: tmpInput.Position = scratch.Length - 2;  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodeContexts,The following statement contains a magic number: scratch.Length -= 2;  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodePayload,The following statement contains a magic number: tmpInput.SkipBytes (scratch.Length - 2);  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodePayload,The following statement contains a magic number: tmpInput.Position = scratch.Length - 2 - payloadLength;  
Magic Number,Lucene.Net.Search.Suggest,SortedInputIterator,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedInputIterator.cs,DecodePayload,The following statement contains a magic number: scratch.Length -= 2;  
Magic Number,Lucene.Net.Search.Suggest,SortedTermFreqIteratorWrapper,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedTermFreqIteratorWrapper.cs,Encode,The following statement contains a magic number: if (spare.Length + 8 >= buffer.Length) {  	buffer = ArrayUtil.Grow (buffer' spare.Length + 8);  }  
Magic Number,Lucene.Net.Search.Suggest,SortedTermFreqIteratorWrapper,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedTermFreqIteratorWrapper.cs,Encode,The following statement contains a magic number: if (spare.Length + 8 >= buffer.Length) {  	buffer = ArrayUtil.Grow (buffer' spare.Length + 8);  }  
Magic Number,Lucene.Net.Search.Suggest,SortedTermFreqIteratorWrapper,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedTermFreqIteratorWrapper.cs,Encode,The following statement contains a magic number: buffer = ArrayUtil.Grow (buffer' spare.Length + 8);  
Magic Number,Lucene.Net.Search.Suggest,SortedTermFreqIteratorWrapper,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedTermFreqIteratorWrapper.cs,Decode,The following statement contains a magic number: tmpInput.SkipBytes (scratch.Length - 8);  
Magic Number,Lucene.Net.Search.Suggest,SortedTermFreqIteratorWrapper,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\SortedTermFreqIteratorWrapper.cs,Decode,The following statement contains a magic number: scratch.Length -= 8;  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionBuilder,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionBuilder.cs,FSTCompletionBuilder,The following statement contains a magic number: if (buckets < 1 || buckets > 255) {  	throw new System.ArgumentException ("Buckets must be >= 1 and <= 255: " + buckets);  }  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionBuilder,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionBuilder.cs,Add,The following statement contains a magic number: if (scratch.Bytes.Length < utf8.Length + 1) {  	scratch.Grow (utf8.Length + 10);  }  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionBuilder,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionBuilder.cs,Add,The following statement contains a magic number: scratch.Grow (utf8.Length + 10);  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The following statement contains a magic number: try {  	byte[] buffer = new byte[0];  	ByteArrayDataOutput output = new ByteArrayDataOutput (buffer);  	BytesRef spare;  	while ((spare = iterator.Next ()) != null) {  		if (spare.Length + 4 >= buffer.Length) {  			buffer = ArrayUtil.Grow (buffer' spare.Length + 4);  		}  		output.Reset (buffer);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		output.WriteBytes (spare.Bytes' spare.Offset' spare.Length);  		writer.Write (buffer' 0' output.Position);  	}  	writer.Dispose ();  	// We don't know the distribution of scores and we need to bucket them' so we'll sort  	// and divide into equal buckets.  	OfflineSorter.SortInfo info = (new OfflineSorter ()).Sort (tempInput' tempSorted);  	tempInput.Delete ();  	FSTCompletionBuilder builder = new FSTCompletionBuilder (buckets' sorter = new ExternalRefSorter (new OfflineSorter ())' sharedTailLength);  	int inputLines = info.Lines;  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	long line = 0;  	int previousBucket = 0;  	int previousScore = 0;  	ByteArrayDataInput input = new ByteArrayDataInput ();  	BytesRef tmp1 = new BytesRef ();  	BytesRef tmp2 = new BytesRef ();  	while (reader.Read (tmp1)) {  		input.Reset (tmp1.Bytes);  		int currentScore = input.ReadInt32 ();  		int bucket;  		if (line > 0 && currentScore == previousScore) {  			bucket = previousBucket;  		} else {  			bucket = (int)(line * buckets / inputLines);  		}  		previousScore = currentScore;  		previousBucket = bucket;  		// Only append the input' discard the weight.  		tmp2.Bytes = tmp1.Bytes;  		tmp2.Offset = input.Position;  		tmp2.Length = tmp1.Length - input.Position;  		builder.Add (tmp2' bucket);  		line++;  		count++;  	}  	// The two FSTCompletions share the same automaton.  	this.higherWeightsCompletion = builder.Build ();  	this.normalCompletion = new FSTCompletion (higherWeightsCompletion.FST' false' exactMatchFirst);  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer' sorter);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer' sorter);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The following statement contains a magic number: try {  	byte[] buffer = new byte[0];  	ByteArrayDataOutput output = new ByteArrayDataOutput (buffer);  	BytesRef spare;  	while ((spare = iterator.Next ()) != null) {  		if (spare.Length + 4 >= buffer.Length) {  			buffer = ArrayUtil.Grow (buffer' spare.Length + 4);  		}  		output.Reset (buffer);  		output.WriteInt32 (EncodeWeight (iterator.Weight));  		output.WriteBytes (spare.Bytes' spare.Offset' spare.Length);  		writer.Write (buffer' 0' output.Position);  	}  	writer.Dispose ();  	// We don't know the distribution of scores and we need to bucket them' so we'll sort  	// and divide into equal buckets.  	OfflineSorter.SortInfo info = (new OfflineSorter ()).Sort (tempInput' tempSorted);  	tempInput.Delete ();  	FSTCompletionBuilder builder = new FSTCompletionBuilder (buckets' sorter = new ExternalRefSorter (new OfflineSorter ())' sharedTailLength);  	int inputLines = info.Lines;  	reader = new OfflineSorter.ByteSequencesReader (tempSorted);  	long line = 0;  	int previousBucket = 0;  	int previousScore = 0;  	ByteArrayDataInput input = new ByteArrayDataInput ();  	BytesRef tmp1 = new BytesRef ();  	BytesRef tmp2 = new BytesRef ();  	while (reader.Read (tmp1)) {  		input.Reset (tmp1.Bytes);  		int currentScore = input.ReadInt32 ();  		int bucket;  		if (line > 0 && currentScore == previousScore) {  			bucket = previousBucket;  		} else {  			bucket = (int)(line * buckets / inputLines);  		}  		previousScore = currentScore;  		previousBucket = bucket;  		// Only append the input' discard the weight.  		tmp2.Bytes = tmp1.Bytes;  		tmp2.Offset = input.Position;  		tmp2.Length = tmp1.Length - input.Position;  		builder.Add (tmp2' bucket);  		line++;  		count++;  	}  	// The two FSTCompletions share the same automaton.  	this.higherWeightsCompletion = builder.Build ();  	this.normalCompletion = new FSTCompletion (higherWeightsCompletion.FST' false' exactMatchFirst);  	success = true;  } finally {  	if (success) {  		IOUtils.Close (reader' writer' sorter);  	} else {  		IOUtils.CloseWhileHandlingException (reader' writer' sorter);  	}  	tempInput.Delete ();  	tempSorted.Delete ();  }  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The following statement contains a magic number: while ((spare = iterator.Next ()) != null) {  	if (spare.Length + 4 >= buffer.Length) {  		buffer = ArrayUtil.Grow (buffer' spare.Length + 4);  	}  	output.Reset (buffer);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	output.WriteBytes (spare.Bytes' spare.Offset' spare.Length);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The following statement contains a magic number: while ((spare = iterator.Next ()) != null) {  	if (spare.Length + 4 >= buffer.Length) {  		buffer = ArrayUtil.Grow (buffer' spare.Length + 4);  	}  	output.Reset (buffer);  	output.WriteInt32 (EncodeWeight (iterator.Weight));  	output.WriteBytes (spare.Bytes' spare.Offset' spare.Length);  	writer.Write (buffer' 0' output.Position);  }  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The following statement contains a magic number: if (spare.Length + 4 >= buffer.Length) {  	buffer = ArrayUtil.Grow (buffer' spare.Length + 4);  }  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The following statement contains a magic number: if (spare.Length + 4 >= buffer.Length) {  	buffer = ArrayUtil.Grow (buffer' spare.Length + 4);  }  
Magic Number,Lucene.Net.Search.Suggest.Fst,FSTCompletionLookup,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Fst\FSTCompletionLookup.cs,Build,The following statement contains a magic number: buffer = ArrayUtil.Grow (buffer' spare.Length + 4);  
Magic Number,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,DeleteNodeRecursion,The following statement contains a magic number: if (deltaHi == deltaLo) {  	if (new Random (1).NextDouble () < 0.5) {  		deltaHi++;  	} else {  		deltaLo++;  	}  }  
Magic Number,Lucene.Net.Search.Suggest.Jaspell,JaspellTernarySearchTrie,F:\newReposMay17\apache_lucenenet\src\Lucene.Net.Suggest\Suggest\Jaspell\JaspellTernarySearchTrie.cs,DeleteNodeRecursion,The following statement contains a magic number: if (new Random (1).NextDouble () < 0.5) {  	deltaHi++;  } else {  	deltaLo++;  }  
