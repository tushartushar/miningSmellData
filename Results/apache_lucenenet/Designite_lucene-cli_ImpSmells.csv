Implementation smell,Namespace,Class,File,Method,Description
Long Method,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The method has 165 lines of code.
Complex Method,Lucene.Net.Cli,DemoSearchFilesCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\demo\demo-search-files\DemoSearchFilesCommand.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Cli,IndexCheckCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\index\index-check\IndexCheckCommand.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,Cyclomatic complexity of the method is 27
Complex Method,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,GetHelpText,Cyclomatic complexity of the method is 11
Long Parameter List,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Option,The method has 5 parameters. Parameters: template' description' optionType' configuration' inherited
Long Statement,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The length of the statement  "                        var symbolOption = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' arg' StringComparison.Ordinal)); " is 125.
Long Statement,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The length of the statement  "                        option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.LongName' longOptionName' StringComparison.Ordinal)); " is 124.
Long Statement,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The length of the statement  "                        option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.ShortName' shortOption[0]' StringComparison.Ordinal)); " is 125.
Long Statement,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The length of the statement  "                            option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' shortOption[0]' StringComparison.Ordinal)); " is 126.
Long Statement,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,GetHelpText,The length of the statement  "                    commandsBuilder.AppendFormat($"Use \"{target.Name} [command] --{OptionHelp.LongName}\" for more information about a command."); " is 127.
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Argument".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Argument".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Argument".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Argument".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,Configuration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Configuration,The constructor "Configuration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,DemoConfiguration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\demo\DemoConfiguration.cs,DemoConfiguration,The constructor "DemoConfiguration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,DemoConfiguration,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\demo\DemoConfiguration.cs,DemoConfiguration,The constructor "DemoConfiguration" calls a virtual method "Option".
Virtual Method Call from Constructor,Lucene.Net.Cli,ConfigurationBase,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\ConfigurationBase.cs,ConfigurationBase,The constructor "ConfigurationBase" calls a virtual method "HelpOption".
Magic Number,Lucene.Net.Cli,AnalysisKuromojiBuildDictionaryCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-kuromoji-build-dictionary\AnalysisKuromojiBuildDictionaryCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(3))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,AnalysisStempelCompileStemsCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\analysis\analysis-stempel-compile-stems\AnalysisStempelCompileStemsCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(2))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,BenchmarkExtractReutersCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\benchmark\benchmark-extract-reuters\BenchmarkExtractReutersCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(2))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,BenchmarkExtractWikipediaCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\benchmark\benchmark-extract-wikipedia\BenchmarkExtractWikipediaCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(2))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,BenchmarkRunTrecEvalCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\benchmark\benchmark-run-trec-eval\BenchmarkRunTrecEvalCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(4))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,DemoIndexFilesCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\demo\demo-index-files\DemoIndexFilesCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(2))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,IndexCopySegmentsCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\index\index-copy-segments\IndexCopySegmentsCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(3))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,IndexDeleteSegmentsCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\index\index-delete-segments\IndexDeleteSegmentsCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(2))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,IndexListTermInfoCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\index\index-list-term-info\IndexListTermInfoCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(3))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,IndexMergeCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\index\index-merge\IndexMergeCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(3))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,IndexSplitCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\index\index-split\IndexSplitCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(2))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,LockStressTestCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\lock\lock-stress-test\LockStressTestCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(7))              {                  return 1;              }
Magic Number,Lucene.Net.Cli,LockVerifyServerCommand,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\commands\lock\lock-verify-server\LockVerifyServerCommand.cs,Run,The following statement contains a magic number: if (!cmd.ValidateArguments(2))              {                  return 1;              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The following statement contains a magic number: for (var index = 0; index < args.Length; index++)              {                  var arg = args[index];                  var processed = false;                  if (!processed && option == null)                  {                      string[] longOption = null;                      string[] shortOption = null;                        if (arg.StartsWith("--"))                      {                          longOption = arg.Substring(2).Split(new[] { ':'' '=' }' 2);                      }                      else if (arg.StartsWith("-"))                      {                          shortOption = arg.Substring(1).Split(new[] { ':'' '=' }' 2);                      }                      else // Look for symbols (such as help option)                      {                          var symbolOption = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' arg' StringComparison.Ordinal));                          if (symbolOption != null)                          {                              shortOption = new string[] { symbolOption.SymbolName' "" };                          }                      }                      if (longOption != null)                      {                          processed = true;                          var longOptionName = longOption[0];                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.LongName' longOptionName' StringComparison.Ordinal));                            if (option == null)                          {                              if (string.IsNullOrEmpty(longOptionName) && !command._throwOnUnexpectedArg && AllowArgumentSeparator)                              {                                  // skip over the '--' argument separator                                  index++;                              }                                HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (longOption.Length == 2)                          {                              if (!option.TryParse(longOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{longOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                      if (shortOption != null)                      {                          processed = true;                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.ShortName' shortOption[0]' StringComparison.Ordinal));                            // If not a short option' try symbol option                          if (option == null)                          {                              option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' shortOption[0]' StringComparison.Ordinal));                          }                            if (option == null)                          {                              HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (shortOption.Length == 2)                          {                              if (!option.TryParse(shortOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{shortOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                  }                    if (!processed && option != null)                  {                      processed = true;                      if (!option.TryParse(arg))                      {                          command.ShowHint();                          throw new CommandParsingException(command' $"Unexpected value '{arg}' for option '{option.LongName}'");                      }                      option = null;                  }                    if (!processed && arguments == null)                  {                      var currentCommand = command;                      foreach (var subcommand in command.Commands)                      {                          if (string.Equals(subcommand.Name' arg' StringComparison.OrdinalIgnoreCase))                          {                              processed = true;                              command = subcommand;                              break;                          }                      }                        // If we detect a subcommand                      if (command != currentCommand)                      {                          processed = true;                      }                  }                  if (!processed)                  {                      if (arguments == null)                      {                          arguments = new CommandArgumentEnumerator(command.Arguments.GetEnumerator());                      }                      if (arguments.MoveNext())                      {                          processed = true;                          arguments.Current.Values.Add(arg);                      }                  }                  if (!processed)                  {                      HandleUnexpectedArg(command' args' index' argTypeName: "command or argument");                      break;                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The following statement contains a magic number: for (var index = 0; index < args.Length; index++)              {                  var arg = args[index];                  var processed = false;                  if (!processed && option == null)                  {                      string[] longOption = null;                      string[] shortOption = null;                        if (arg.StartsWith("--"))                      {                          longOption = arg.Substring(2).Split(new[] { ':'' '=' }' 2);                      }                      else if (arg.StartsWith("-"))                      {                          shortOption = arg.Substring(1).Split(new[] { ':'' '=' }' 2);                      }                      else // Look for symbols (such as help option)                      {                          var symbolOption = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' arg' StringComparison.Ordinal));                          if (symbolOption != null)                          {                              shortOption = new string[] { symbolOption.SymbolName' "" };                          }                      }                      if (longOption != null)                      {                          processed = true;                          var longOptionName = longOption[0];                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.LongName' longOptionName' StringComparison.Ordinal));                            if (option == null)                          {                              if (string.IsNullOrEmpty(longOptionName) && !command._throwOnUnexpectedArg && AllowArgumentSeparator)                              {                                  // skip over the '--' argument separator                                  index++;                              }                                HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (longOption.Length == 2)                          {                              if (!option.TryParse(longOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{longOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                      if (shortOption != null)                      {                          processed = true;                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.ShortName' shortOption[0]' StringComparison.Ordinal));                            // If not a short option' try symbol option                          if (option == null)                          {                              option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' shortOption[0]' StringComparison.Ordinal));                          }                            if (option == null)                          {                              HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (shortOption.Length == 2)                          {                              if (!option.TryParse(shortOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{shortOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                  }                    if (!processed && option != null)                  {                      processed = true;                      if (!option.TryParse(arg))                      {                          command.ShowHint();                          throw new CommandParsingException(command' $"Unexpected value '{arg}' for option '{option.LongName}'");                      }                      option = null;                  }                    if (!processed && arguments == null)                  {                      var currentCommand = command;                      foreach (var subcommand in command.Commands)                      {                          if (string.Equals(subcommand.Name' arg' StringComparison.OrdinalIgnoreCase))                          {                              processed = true;                              command = subcommand;                              break;                          }                      }                        // If we detect a subcommand                      if (command != currentCommand)                      {                          processed = true;                      }                  }                  if (!processed)                  {                      if (arguments == null)                      {                          arguments = new CommandArgumentEnumerator(command.Arguments.GetEnumerator());                      }                      if (arguments.MoveNext())                      {                          processed = true;                          arguments.Current.Values.Add(arg);                      }                  }                  if (!processed)                  {                      HandleUnexpectedArg(command' args' index' argTypeName: "command or argument");                      break;                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The following statement contains a magic number: for (var index = 0; index < args.Length; index++)              {                  var arg = args[index];                  var processed = false;                  if (!processed && option == null)                  {                      string[] longOption = null;                      string[] shortOption = null;                        if (arg.StartsWith("--"))                      {                          longOption = arg.Substring(2).Split(new[] { ':'' '=' }' 2);                      }                      else if (arg.StartsWith("-"))                      {                          shortOption = arg.Substring(1).Split(new[] { ':'' '=' }' 2);                      }                      else // Look for symbols (such as help option)                      {                          var symbolOption = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' arg' StringComparison.Ordinal));                          if (symbolOption != null)                          {                              shortOption = new string[] { symbolOption.SymbolName' "" };                          }                      }                      if (longOption != null)                      {                          processed = true;                          var longOptionName = longOption[0];                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.LongName' longOptionName' StringComparison.Ordinal));                            if (option == null)                          {                              if (string.IsNullOrEmpty(longOptionName) && !command._throwOnUnexpectedArg && AllowArgumentSeparator)                              {                                  // skip over the '--' argument separator                                  index++;                              }                                HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (longOption.Length == 2)                          {                              if (!option.TryParse(longOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{longOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                      if (shortOption != null)                      {                          processed = true;                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.ShortName' shortOption[0]' StringComparison.Ordinal));                            // If not a short option' try symbol option                          if (option == null)                          {                              option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' shortOption[0]' StringComparison.Ordinal));                          }                            if (option == null)                          {                              HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (shortOption.Length == 2)                          {                              if (!option.TryParse(shortOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{shortOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                  }                    if (!processed && option != null)                  {                      processed = true;                      if (!option.TryParse(arg))                      {                          command.ShowHint();                          throw new CommandParsingException(command' $"Unexpected value '{arg}' for option '{option.LongName}'");                      }                      option = null;                  }                    if (!processed && arguments == null)                  {                      var currentCommand = command;                      foreach (var subcommand in command.Commands)                      {                          if (string.Equals(subcommand.Name' arg' StringComparison.OrdinalIgnoreCase))                          {                              processed = true;                              command = subcommand;                              break;                          }                      }                        // If we detect a subcommand                      if (command != currentCommand)                      {                          processed = true;                      }                  }                  if (!processed)                  {                      if (arguments == null)                      {                          arguments = new CommandArgumentEnumerator(command.Arguments.GetEnumerator());                      }                      if (arguments.MoveNext())                      {                          processed = true;                          arguments.Current.Values.Add(arg);                      }                  }                  if (!processed)                  {                      HandleUnexpectedArg(command' args' index' argTypeName: "command or argument");                      break;                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The following statement contains a magic number: for (var index = 0; index < args.Length; index++)              {                  var arg = args[index];                  var processed = false;                  if (!processed && option == null)                  {                      string[] longOption = null;                      string[] shortOption = null;                        if (arg.StartsWith("--"))                      {                          longOption = arg.Substring(2).Split(new[] { ':'' '=' }' 2);                      }                      else if (arg.StartsWith("-"))                      {                          shortOption = arg.Substring(1).Split(new[] { ':'' '=' }' 2);                      }                      else // Look for symbols (such as help option)                      {                          var symbolOption = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' arg' StringComparison.Ordinal));                          if (symbolOption != null)                          {                              shortOption = new string[] { symbolOption.SymbolName' "" };                          }                      }                      if (longOption != null)                      {                          processed = true;                          var longOptionName = longOption[0];                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.LongName' longOptionName' StringComparison.Ordinal));                            if (option == null)                          {                              if (string.IsNullOrEmpty(longOptionName) && !command._throwOnUnexpectedArg && AllowArgumentSeparator)                              {                                  // skip over the '--' argument separator                                  index++;                              }                                HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (longOption.Length == 2)                          {                              if (!option.TryParse(longOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{longOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                      if (shortOption != null)                      {                          processed = true;                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.ShortName' shortOption[0]' StringComparison.Ordinal));                            // If not a short option' try symbol option                          if (option == null)                          {                              option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' shortOption[0]' StringComparison.Ordinal));                          }                            if (option == null)                          {                              HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (shortOption.Length == 2)                          {                              if (!option.TryParse(shortOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{shortOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                  }                    if (!processed && option != null)                  {                      processed = true;                      if (!option.TryParse(arg))                      {                          command.ShowHint();                          throw new CommandParsingException(command' $"Unexpected value '{arg}' for option '{option.LongName}'");                      }                      option = null;                  }                    if (!processed && arguments == null)                  {                      var currentCommand = command;                      foreach (var subcommand in command.Commands)                      {                          if (string.Equals(subcommand.Name' arg' StringComparison.OrdinalIgnoreCase))                          {                              processed = true;                              command = subcommand;                              break;                          }                      }                        // If we detect a subcommand                      if (command != currentCommand)                      {                          processed = true;                      }                  }                  if (!processed)                  {                      if (arguments == null)                      {                          arguments = new CommandArgumentEnumerator(command.Arguments.GetEnumerator());                      }                      if (arguments.MoveNext())                      {                          processed = true;                          arguments.Current.Values.Add(arg);                      }                  }                  if (!processed)                  {                      HandleUnexpectedArg(command' args' index' argTypeName: "command or argument");                      break;                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,Execute,The following statement contains a magic number: for (var index = 0; index < args.Length; index++)              {                  var arg = args[index];                  var processed = false;                  if (!processed && option == null)                  {                      string[] longOption = null;                      string[] shortOption = null;                        if (arg.StartsWith("--"))                      {                          longOption = arg.Substring(2).Split(new[] { ':'' '=' }' 2);                      }                      else if (arg.StartsWith("-"))                      {                          shortOption = arg.Substring(1).Split(new[] { ':'' '=' }' 2);                      }                      else // Look for symbols (such as help option)                      {                          var symbolOption = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' arg' StringComparison.Ordinal));                          if (symbolOption != null)                          {                              shortOption = new string[] { symbolOption.SymbolName' "" };                          }                      }                      if (longOption != null)                      {                          processed = true;                          var longOptionName = longOption[0];                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.LongName' longOptionName' StringComparison.Ordinal));                            if (option == null)                          {                              if (string.IsNullOrEmpty(longOptionName) && !command._throwOnUnexpectedArg && AllowArgumentSeparator)                              {                                  // skip over the '--' argument separator                                  index++;                              }                                HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (longOption.Length == 2)                          {                              if (!option.TryParse(longOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{longOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                      if (shortOption != null)                      {                          processed = true;                          option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.ShortName' shortOption[0]' StringComparison.Ordinal));                            // If not a short option' try symbol option                          if (option == null)                          {                              option = command.GetOptions().SingleOrDefault(opt => string.Equals(opt.SymbolName' shortOption[0]' StringComparison.Ordinal));                          }                            if (option == null)                          {                              HandleUnexpectedArg(command' args' index' argTypeName: "option");                              break;                          }                            // If we find a help/version option' show information and stop parsing                          if (command.OptionHelp == option)                          {                              command.ShowHelp();                              return 0;                          }                          else if (command.OptionVersion == option)                          {                              command.ShowVersion();                              return 0;                          }                            if (shortOption.Length == 2)                          {                              if (!option.TryParse(shortOption[1]))                              {                                  command.ShowHint();                                  throw new CommandParsingException(command' $"Unexpected value '{shortOption[1]}' for option '{option.LongName}'");                              }                              option = null;                          }                          else if (option.OptionType == CommandOptionType.NoValue)                          {                              // No value is needed for this option                              option.TryParse(null);                              option = null;                          }                      }                  }                    if (!processed && option != null)                  {                      processed = true;                      if (!option.TryParse(arg))                      {                          command.ShowHint();                          throw new CommandParsingException(command' $"Unexpected value '{arg}' for option '{option.LongName}'");                      }                      option = null;                  }                    if (!processed && arguments == null)                  {                      var currentCommand = command;                      foreach (var subcommand in command.Commands)                      {                          if (string.Equals(subcommand.Name' arg' StringComparison.OrdinalIgnoreCase))                          {                              processed = true;                              command = subcommand;                              break;                          }                      }                        // If we detect a subcommand                      if (command != currentCommand)                      {                          processed = true;                      }                  }                  if (!processed)                  {                      if (arguments == null)                      {                          arguments = new CommandArgumentEnumerator(command.Arguments.GetEnumerator());                      }                      if (arguments.MoveNext())                      {                          processed = true;                          arguments.Current.Values.Add(arg);                      }                  }                  if (!processed)                  {                      HandleUnexpectedArg(command' args' index' argTypeName: "command or argument");                      break;                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,GetHelpText,The following statement contains a magic number: for (var cmd = this; cmd != null; cmd = cmd.Parent)              {                  headerBuilder.Insert(6' string.Format(" {0}"' cmd.Name));              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,GetHelpText,The following statement contains a magic number: if (arguments.Any())              {                  headerBuilder.Append(" [arguments]");                    argumentsBuilder.AppendLine();                  argumentsBuilder.AppendLine("Arguments:");                  var maxArgLen = arguments.Max(a => a.Name.Length);                  var outputFormat = string.Format("  {{0' -{0}}}{{1}}"' maxArgLen + 2);                  foreach (var arg in arguments)                  {                      argumentsBuilder.AppendFormat(outputFormat' arg.Name' arg.Description);                      argumentsBuilder.AppendLine();                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,GetHelpText,The following statement contains a magic number: if (options.Any())              {                  headerBuilder.Append(" [options]");                    optionsBuilder.AppendLine();                  optionsBuilder.AppendLine("Options:");                  var maxOptLen = options.Max(o => o.Template.Length);                  var outputFormat = string.Format("  {{0' -{0}}}{{1}}"' maxOptLen + 2);                  foreach (var opt in options)                  {                      optionsBuilder.AppendFormat(outputFormat' opt.Template' opt.Description);                      optionsBuilder.AppendLine();                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandLineApplication,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandLineApplication.cs,GetHelpText,The following statement contains a magic number: if (commands.Any())              {                  headerBuilder.Append(" [command]");                    commandsBuilder.AppendLine();                  commandsBuilder.AppendLine("Commands:");                  var maxCmdLen = commands.Max(c => c.Name.Length);                  var outputFormat = string.Format("  {{0' -{0}}}{{1}}"' maxCmdLen + 2);                  foreach (var cmd in commands.OrderBy(c => c.Name))                  {                      commandsBuilder.AppendFormat(outputFormat' cmd.Name' cmd.Description);                      commandsBuilder.AppendLine();                  }                    if (OptionHelp != null)                  {                      commandsBuilder.AppendLine();                      commandsBuilder.AppendFormat($"Use \"{target.Name} [command] --{OptionHelp.LongName}\" for more information about a command.");                      commandsBuilder.AppendLine();                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandOption,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandOption.cs,CommandOption,The following statement contains a magic number: foreach (var part in Template.Split(new[] { ' '' '|' }' StringSplitOptions.RemoveEmptyEntries))              {                  if (part.StartsWith("--"))                  {                      LongName = part.Substring(2);                  }                  else if (part.StartsWith("-"))                  {                      var optName = part.Substring(1);                        // If there is only one char and it is not an English letter' it is a symbol option (e.g. "-?")                      if (optName.Length == 1 && !IsEnglishLetter(optName[0]))                      {                          SymbolName = optName;                      }                      else                      {                          ShortName = optName;                      }                  }                  else if (part.StartsWith("<") && part.EndsWith(">"))                  {                      ValueName = part.Substring(1' part.Length - 2);                  }                  else                  {                      throw new ArgumentException($"Invalid template pattern '{template}'"' nameof(template));                  }              }
Magic Number,Lucene.Net.Cli.CommandLine,CommandOption,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\CommandLine\CommandOption.cs,CommandOption,The following statement contains a magic number: foreach (var part in Template.Split(new[] { ' '' '|' }' StringSplitOptions.RemoveEmptyEntries))              {                  if (part.StartsWith("--"))                  {                      LongName = part.Substring(2);                  }                  else if (part.StartsWith("-"))                  {                      var optName = part.Substring(1);                        // If there is only one char and it is not an English letter' it is a symbol option (e.g. "-?")                      if (optName.Length == 1 && !IsEnglishLetter(optName[0]))                      {                          SymbolName = optName;                      }                      else                      {                          ShortName = optName;                      }                  }                  else if (part.StartsWith("<") && part.EndsWith(">"))                  {                      ValueName = part.Substring(1' part.Length - 2);                  }                  else                  {                      throw new ArgumentException($"Invalid template pattern '{template}'"' nameof(template));                  }              }
Magic Number,Lucene.Net.Cli.SourceCode,ConsolePager,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\SourceCode\ConsolePager.cs,Run,The following statement contains a magic number: try              {                  Console.ForegroundColor = ConsoleColor.Yellow;                  int take = GetWindowHeight();                  int count = 0;                  bool done = false;                  do                  {                      while (count++ < take)                      {                          done = !enumerator.MoveNext();                          if (done) break;                          Out.WriteLine(enumerator.Current);                      }                      count = 0; // Reset                      bool valid = false;                      while (!valid)                      {                          var keyInfo = Console.ReadKey(true);                            switch (keyInfo.KeyChar)                          {                              case 'q': // quit                              case 'x':                                  done = valid = true;                                  break;                              case 'n':                              case ' ':                                  take = GetWindowHeight(); // Get next page                                  valid = true;                                  break;                              case (char)13: // ENTER                                  take = 1; // Get a single line                                  valid = true;                                  break;                          }                      }                  } while (!done);              }              finally              {                  Console.ResetColor();              }
Magic Number,Lucene.Net.Cli.SourceCode,SourceCodeSectionParser,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\SourceCode\SourceCodeSectionParser.cs,ParseSourceCodeFiles,The following statement contains a magic number: using (var reader = new SourceCodeSectionReader(new StreamReader(input' ENCODING' false' 1024' true)))              using (TextWriter writer = new StreamWriter(output' ENCODING' 1024' true))              {                  string line;                  while ((line = reader.ReadLine()) != null)                  {                      writer.WriteLine(line);                  }              }
Magic Number,Lucene.Net.Cli.SourceCode,SourceCodeSectionParser,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\SourceCode\SourceCodeSectionParser.cs,ParseSourceCodeFiles,The following statement contains a magic number: using (var reader = new SourceCodeSectionReader(new StreamReader(input' ENCODING' false' 1024' true)))              using (TextWriter writer = new StreamWriter(output' ENCODING' 1024' true))              {                  string line;                  while ((line = reader.ReadLine()) != null)                  {                      writer.WriteLine(line);                  }              }
Missing Default,Lucene.Net.Cli.SourceCode,ConsolePager,C:\repos\apache_lucenenet\src\dotnet\tools\lucene-cli\SourceCode\ConsolePager.cs,Run,The following switch statement is missing a default case: switch (keyInfo.KeyChar)                          {                              case 'q': // quit                              case 'x':                                  done = valid = true;                                  break;                              case 'n':                              case ' ':                                  take = GetWindowHeight(); // Get next page                                  valid = true;                                  break;                              case (char)13: // ENTER                                  take = 1; // Get a single line                                  valid = true;                                  break;                          }
