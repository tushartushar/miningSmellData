Implementation smell,Namespace,Class,File,Method,Description
Long Method,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The method has 107 lines of code.
Long Statement,ClojureExtension.Parsing,Token,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Token.cs,Equals,The length of the statement  "			return Equals(other._type' _type) && Equals(other._text' _text) && other._startIndex == _startIndex && other._length == _length; " is 128.
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,Next,The following statement contains a magic number: if (currentChar == '(')              {                  nextToken = new Token(TokenType.ListStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ')')              {                  nextToken = new Token(TokenType.ListEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '[')              {                  nextToken = new Token(TokenType.VectorStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ']')              {                  nextToken = new Token(TokenType.VectorEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '{')              {                  nextToken = new Token(TokenType.MapStart' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == '}')              {                  nextToken = new Token(TokenType.MapEnd' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }              else if (currentChar == ':')              {                  _source.Push(currentChar);                  string keyword = ReadKeyword();                  nextToken = new Token(TokenType.Keyword' keyword' _source.CurrentIndex - keyword.Length' keyword.Length);              }              else if (IsString(currentChar' "#_"))              {                  ReadChars(1);                  nextToken = new Token(TokenType.IgnoreReaderMacro' "#_"' _source.CurrentIndex - 2' 2);              }              else if (BuiltInFunctions.Find(f => IsString(currentChar' f)) != null)              {                  string match = BuiltInFunctions.Find(f => IsString(currentChar' f));                  ReadChars(match.Length - 1);                  nextToken = new Token(TokenType.BuiltIn' match' _source.CurrentIndex - match.Length' match.Length);              }              else if (currentChar == '\\' && !IsNextCharWhitespace())              {                  string character = ReadCharacter(currentChar);                  nextToken = new Token(TokenType.Character' character' _source.CurrentIndex - character.Length' character.Length);              }              else if (IsPrefix(currentChar' "0x"))              {                  ReadChars(1);                  string number = "0x" + ReadNumber();                  nextToken = new Token(TokenType.HexNumber' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (Char.IsNumber(currentChar))              {                  _source.Push(currentChar);                  string number = ReadNumber();                  nextToken = new Token(TokenType.Number' number' _source.CurrentIndex - number.Length' number.Length);              }              else if (currentChar == '"')              {                  _source.Push(currentChar);                  string str = ReadString();                  nextToken = new Token(TokenType.String' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsWhitespace(currentChar))              {                  _source.Push(currentChar);                  string str = ReadWhitespace();                  nextToken = new Token(TokenType.Whitespace' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (currentChar == ';')              {                  _source.Push(currentChar);                  string str = ReadComment();                  nextToken = new Token(TokenType.Comment' str' _source.CurrentIndex - str.Length' str.Length);              }              else if (IsString(currentChar' "true"))              {                  ReadChars(3);                  nextToken = new Token(TokenType.Boolean' "true"' _source.CurrentIndex - 4' 4);              }              else if (IsString(currentChar' "false"))              {                  ReadChars(4);                  nextToken = new Token(TokenType.Boolean' "false"' _source.CurrentIndex - 5' 5);              }              else if (IsString(currentChar' "nil"))              {                  ReadChars(2);                  nextToken = new Token(TokenType.Nil' "nil"' _source.CurrentIndex - 3' 3);              }              else if (IsSymbolPrefix(currentChar))              {                  _source.Push(currentChar);                  string str = ReadSymbol();                  nextToken = new Token(TokenType.Symbol' str' _source.CurrentIndex - str.Length' str.Length);              }              else              {                  nextToken = new Token(TokenType.Unknown' currentChar.ToString()' _source.CurrentIndex - 1' 1);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,ReadCharacter,The following statement contains a magic number: if (IsString(currentChar' "\\newline")) return currentChar + ReadChars(7);              else if (IsString(currentChar' "\\space")) return currentChar + ReadChars(5);              else if (IsString(currentChar' "\\tab")) return currentChar + ReadChars(3);
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,ReadCharacter,The following statement contains a magic number: if (IsString(currentChar' "\\newline")) return currentChar + ReadChars(7);              else if (IsString(currentChar' "\\space")) return currentChar + ReadChars(5);              else if (IsString(currentChar' "\\tab")) return currentChar + ReadChars(3);
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,ReadCharacter,The following statement contains a magic number: if (IsString(currentChar' "\\newline")) return currentChar + ReadChars(7);              else if (IsString(currentChar' "\\space")) return currentChar + ReadChars(5);              else if (IsString(currentChar' "\\tab")) return currentChar + ReadChars(3);
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,ReadCharacter,The following statement contains a magic number: if (firstCharacter == "u")              {                  string nextFourCharacters = ReadChars(4);                  if (IsCharacterDefinedByHexDigits(nextFourCharacters)) return currentChar + firstCharacter + nextFourCharacters;                  _source.Push(nextFourCharacters);              }
Magic Number,ClojureExtension.Parsing,Lexer,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Lexer.cs,IsCharacterDefinedByHexDigits,The following statement contains a magic number: if (str.Length != 4) return false;
Magic Number,ClojureExtension.Parsing,Token,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Token.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int result = _type.GetHashCode();  				result = (result*397) ^ (_text != null ? _text.GetHashCode() : 0);  				result = (result*397) ^ _startIndex;  				result = (result*397) ^ _length;  				return result;  			}
Magic Number,ClojureExtension.Parsing,Token,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Token.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int result = _type.GetHashCode();  				result = (result*397) ^ (_text != null ? _text.GetHashCode() : 0);  				result = (result*397) ^ _startIndex;  				result = (result*397) ^ _length;  				return result;  			}
Magic Number,ClojureExtension.Parsing,Token,C:\repos\vsClojure_vsClojure\ClojureExtension.Parsing\Token.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int result = _type.GetHashCode();  				result = (result*397) ^ (_text != null ? _text.GetHashCode() : 0);  				result = (result*397) ^ _startIndex;  				result = (result*397) ^ _length;  				return result;  			}
