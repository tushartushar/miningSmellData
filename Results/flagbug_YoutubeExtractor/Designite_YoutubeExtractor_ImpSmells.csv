Implementation smell,Namespace,Class,File,Method,Description
Complex Method,YoutubeExtractor,Decipherer,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,Cyclomatic complexity of the method is 11
Complex Method,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,Cyclomatic complexity of the method is 10
Long Parameter List,YoutubeExtractor,VideoInfo,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\VideoInfo.cs,VideoInfo,The method has 7 parameters. Parameters: formatCode' videoType' resolution' is3D' audioType' audioBitrate' adaptiveType
Long Statement,YoutubeExtractor,Decipherer,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The length of the statement  "            foreach (var line in lines.Skip(1).Take(lines.Length - 2)) //Matches the funcBody with each cipher method. Only runs till all three are defined. " is 144.
Long Statement,YoutubeExtractor,Decipherer,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The length of the statement  "                string reSlice = string.Format(@"{0}:\bfunction\b\([a]'b\).(\breturn\b)?.?\w+\."' functionIdentifier); //Regex for slice (return or not) " is 136.
Long Statement,YoutubeExtractor,Decipherer,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The length of the statement  "                string reSwap = string.Format(@"{0}:\bfunction\b\(\w+\'\w\).\bvar\b.\bc=a\b"' functionIdentifier); //Regex for the char swap. " is 125.
Long Statement,YoutubeExtractor,Decipherer,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The length of the statement  "                    idReverse = functionIdentifier; //If def matched the regex for reverse then the current function is a defined as the reverse " is 124.
Long Statement,YoutubeExtractor,DownloadUrlResolver,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\DownloadUrlResolver.cs,ExtractDownloadUrls,The length of the statement  "                    string fallbackHost = queries.ContainsKey("fallback_host") ? "&fallback_host=" + queries["fallback_host"] : String.Empty; " is 121.
Long Statement,YoutubeExtractor,VideoInfo,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\VideoInfo.cs,ToString,The length of the statement  "            return string.Format("Full Title: {0}' Type: {1}' Resolution: {2}p"' this.Title + this.VideoExtension' this.VideoType' this.Resolution); " is 136.
Complex Conditional,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The conditional expression  "mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3"  is complex.
Empty Catch Block,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,CloseOutput,The method has an empty catch block.
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,AacAudioExtractor,The following statement contains a magic number: fileStream = new FileStream(path' FileMode.Create' FileAccess.Write' FileShare.Read' 64 * 1024);
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,AacAudioExtractor,The following statement contains a magic number: fileStream = new FileStream(path' FileMode.Create' FileAccess.Write' FileShare.Read' 64 * 1024);
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk[0] == 0)              {                  // Header                  if (chunk.Length < 3)                  {                      return;                  }                    ulong bits = (ulong)BigEndianBitConverter.ToUInt16(chunk' 1) << 48;                    aacProfile = BitHelper.Read(ref bits' 5) - 1;                  sampleRateIndex = BitHelper.Read(ref bits' 4);                  channelConfig = BitHelper.Read(ref bits' 4);                    if (aacProfile < 0 || aacProfile > 3)                      throw new AudioExtractionException("Unsupported AAC profile.");                  if (sampleRateIndex > 12)                      throw new AudioExtractionException("Invalid AAC sample rate index.");                  if (channelConfig > 6)                      throw new AudioExtractionException("Invalid AAC channel configuration.");              }                else              {                  // Audio data                  int dataSize = chunk.Length - 1;                  ulong bits = 0;                    // Reference: WriteADTSHeader from FAAC's bitstream.c                    BitHelper.Write(ref bits' 12' 0xFFF);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 2' 0);                  BitHelper.Write(ref bits' 1' 1);                  BitHelper.Write(ref bits' 2' aacProfile);                  BitHelper.Write(ref bits' 4' sampleRateIndex);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 3' channelConfig);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 1' 0);                  BitHelper.Write(ref bits' 13' 7 + dataSize);                  BitHelper.Write(ref bits' 11' 0x7FF);                  BitHelper.Write(ref bits' 2' 0);                    fileStream.Write(BigEndianBitConverter.GetBytes(bits)' 1' 7);                  fileStream.Write(chunk' 1' dataSize);              }
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: var buff = new byte[8];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[0] = (byte)(value >> 56);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[1] = (byte)(value >> 48);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[2] = (byte)(value >> 40);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[2] = (byte)(value >> 40);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[3] = (byte)(value >> 32);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[3] = (byte)(value >> 32);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[4] = (byte)(value >> 24);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[4] = (byte)(value >> 24);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[5] = (byte)(value >> 16);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[5] = (byte)(value >> 16);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[6] = (byte)(value >> 8);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[6] = (byte)(value >> 8);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[7] = (byte)(value);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: var buff = new byte[4];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[0] = (byte)(value >> 24);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[1] = (byte)(value >> 16);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[2] = (byte)(value >> 8);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[2] = (byte)(value >> 8);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[3] = (byte)(value);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: var buff = new byte[2];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff[0] = (byte)(value >> 8);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt16,The following statement contains a magic number: return (ushort)(value[startIndex] << 8 | value[startIndex + 1]);
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return                  (uint)value[startIndex] << 24 |                  (uint)value[startIndex + 1] << 16 |                  (uint)value[startIndex + 2] << 8 |                  value[startIndex + 3];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return                  (uint)value[startIndex] << 24 |                  (uint)value[startIndex + 1] << 16 |                  (uint)value[startIndex + 2] << 8 |                  value[startIndex + 3];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return                  (uint)value[startIndex] << 24 |                  (uint)value[startIndex + 1] << 16 |                  (uint)value[startIndex + 2] << 8 |                  value[startIndex + 3];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return                  (uint)value[startIndex] << 24 |                  (uint)value[startIndex + 1] << 16 |                  (uint)value[startIndex + 2] << 8 |                  value[startIndex + 3];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return                  (uint)value[startIndex] << 24 |                  (uint)value[startIndex + 1] << 16 |                  (uint)value[startIndex + 2] << 8 |                  value[startIndex + 3];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return                  (ulong)value[startIndex] << 56 |                  (ulong)value[startIndex + 1] << 48 |                  (ulong)value[startIndex + 2] << 40 |                  (ulong)value[startIndex + 3] << 32 |                  (ulong)value[startIndex + 4] << 24 |                  (ulong)value[startIndex + 5] << 16 |                  (ulong)value[startIndex + 6] << 8 |                  value[startIndex + 7];
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,CopyBlock,The following statement contains a magic number: int startByte = offset / 8;
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,CopyBlock,The following statement contains a magic number: int endByte = (offset + length - 1) / 8;
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,CopyBlock,The following statement contains a magic number: int shiftA = offset % 8;
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,CopyBlock,The following statement contains a magic number: int shiftB = 8 - shiftA;
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,CopyBlock,The following statement contains a magic number: var dst = new byte[(length + 7) / 8];
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,CopyBlock,The following statement contains a magic number: var dst = new byte[(length + 7) / 8];
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,CopyBlock,The following statement contains a magic number: dst[dst.Length - 1] &= (byte)(0xFF << dst.Length * 8 - length);
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: int r = (int)(x >> 64 - length);
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: int startByte = offset / 8;
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: int endByte = (offset + length - 1) / 8;
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: int skipBits = offset % 8;
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: for (int i = 0; i <= Math.Min(endByte - startByte' 7); i++)              {                  bits |= (ulong)bytes[startByte + i] << 56 - i * 8;              }
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: for (int i = 0; i <= Math.Min(endByte - startByte' 7); i++)              {                  bits |= (ulong)bytes[startByte + i] << 56 - i * 8;              }
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: for (int i = 0; i <= Math.Min(endByte - startByte' 7); i++)              {                  bits |= (ulong)bytes[startByte + i] << 56 - i * 8;              }
Magic Number,YoutubeExtractor,BitHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\BitHelper.cs,Write,The following statement contains a magic number: ulong mask = 0xFFFFFFFFFFFFFFFF >> 64 - length;
Magic Number,YoutubeExtractor,Decipherer,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The following statement contains a magic number: foreach (var line in lines.Skip(1).Take(lines.Length - 2)) //Matches the funcBody with each cipher method. Only runs till all three are defined.              {                  if (!string.IsNullOrEmpty(idReverse) && !string.IsNullOrEmpty(idSlice) &&                      !string.IsNullOrEmpty(idCharSwap))                  {                      break; //Break loop if all three cipher methods are defined                  }                    functionIdentifier = GetFunctionFromLine(line);                  string reReverse = string.Format(@"{0}:\bfunction\b\(\w+\)"' functionIdentifier); //Regex for reverse (one parameter)                  string reSlice = string.Format(@"{0}:\bfunction\b\([a]'b\).(\breturn\b)?.?\w+\."' functionIdentifier); //Regex for slice (return or not)                  string reSwap = string.Format(@"{0}:\bfunction\b\(\w+\'\w\).\bvar\b.\bc=a\b"' functionIdentifier); //Regex for the char swap.                    if (Regex.Match(js' reReverse).Success)                  {                      idReverse = functionIdentifier; //If def matched the regex for reverse then the current function is a defined as the reverse                  }                    if (Regex.Match(js' reSlice).Success)                  {                      idSlice = functionIdentifier; //If def matched the regex for slice then the current function is defined as the slice.                  }                    if (Regex.Match(js' reSwap).Success)                  {                      idCharSwap = functionIdentifier; //If def matched the regex for charSwap then the current function is defined as swap.                  }              }
Magic Number,YoutubeExtractor,Decipherer,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The following statement contains a magic number: foreach (var line in lines.Skip(1).Take(lines.Length - 2))              {                  Match m;                  functionIdentifier = GetFunctionFromLine(line);                    if ((m = Regex.Match(line' @"\(\w+'(?<index>\d+)\)")).Success && functionIdentifier == idCharSwap)                  {                      operations += "w" + m.Groups["index"].Value + " "; //operation is a swap (w)                  }                    if ((m = Regex.Match(line' @"\(\w+'(?<index>\d+)\)")).Success && functionIdentifier == idSlice)                  {                      operations += "s" + m.Groups["index"].Value + " "; //operation is a slice                  }                    if (functionIdentifier == idReverse) //No regex required for reverse (reverse method has no parameters)                  {                      operations += "r "; //operation is a reverse                  }              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,FlvFile,The following statement contains a magic number: this.fileStream = new FileStream(this.inputPath' FileMode.Open' FileAccess.Read' FileShare.Read' 64 * 1024);
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,FlvFile,The following statement contains a magic number: this.fileStream = new FileStream(this.inputPath' FileMode.Open' FileAccess.Read' FileShare.Read' 64 * 1024);
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ExtractStreams,The following statement contains a magic number: while (fileOffset < fileLength)              {                  if (!ReadTag())                  {                      break;                  }                    if (fileLength - fileOffset < 4)                  {                      break;                  }                    this.ReadUInt32();                    double progress = (this.fileOffset * 1.0 / this.fileLength) * 100;                    if (this.ConversionProgressChanged != null)                  {                      this.ConversionProgressChanged(this' new ProgressEventArgs(progress));                  }              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ExtractStreams,The following statement contains a magic number: while (fileOffset < fileLength)              {                  if (!ReadTag())                  {                      break;                  }                    if (fileLength - fileOffset < 4)                  {                      break;                  }                    this.ReadUInt32();                    double progress = (this.fileOffset * 1.0 / this.fileLength) * 100;                    if (this.ConversionProgressChanged != null)                  {                      this.ConversionProgressChanged(this' new ProgressEventArgs(progress));                  }              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: uint format = mediaInfo >> 4;
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format)              {                  case 14:                  case 2:                      return new Mp3AudioExtractor(this.outputPath);                    case 10:                      return new AacAudioExtractor(this.outputPath);              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format)              {                  case 14:                  case 2:                      return new Mp3AudioExtractor(this.outputPath);                    case 10:                      return new AacAudioExtractor(this.outputPath);              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format)              {                  case 14:                  case 2:                      return new Mp3AudioExtractor(this.outputPath);                    case 10:                      return new AacAudioExtractor(this.outputPath);              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format)              {                  case 1:                      typeStr = "ADPCM";                      break;                    case 6:                  case 5:                  case 4:                      typeStr = "Nellymoser";                      break;                    default:                      typeStr = "format=" + format;                      break;              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format)              {                  case 1:                      typeStr = "ADPCM";                      break;                    case 6:                  case 5:                  case 4:                      typeStr = "Nellymoser";                      break;                    default:                      typeStr = "format=" + format;                      break;              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format)              {                  case 1:                      typeStr = "ADPCM";                      break;                    case 6:                  case 5:                  case 4:                      typeStr = "Nellymoser";                      break;                    default:                      typeStr = "format=" + format;                      break;              }
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ReadTag,The following statement contains a magic number: if (this.fileLength - this.fileOffset < 11)                  return false;
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ReadTag,The following statement contains a magic number: timeStamp |= this.ReadUInt8() << 24;
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ReadUInt24,The following statement contains a magic number: var x = new byte[4];
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ReadUInt24,The following statement contains a magic number: this.fileStream.Read(x' 1' 3);
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ReadUInt24,The following statement contains a magic number: this.fileOffset += 3;
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ReadUInt32,The following statement contains a magic number: var x = new byte[4];
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ReadUInt32,The following statement contains a magic number: this.fileStream.Read(x' 0' 4);
Magic Number,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,ReadUInt32,The following statement contains a magic number: this.fileOffset += 4;
Magic Number,YoutubeExtractor,HttpHelper,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\HttpHelper.cs,ParseQueryString,The following statement contains a magic number: foreach (string vp in Regex.Split(s' "&"))              {                  string[] strings = Regex.Split(vp' "=");                  dictionary.Add(strings[0]' strings.Length == 2 ? UrlDecode(strings[1]) : string.Empty);              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,Mp3AudioExtractor,The following statement contains a magic number: this.fileStream = new FileStream(path' FileMode.Create' FileAccess.Write' FileShare.Read' 64 * 1024);
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,Mp3AudioExtractor,The following statement contains a magic number: this.fileStream = new FileStream(path' FileMode.Create' FileAccess.Write' FileShare.Read' 64 * 1024);
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (this.delayWrite && this.totalFrameLength >= 65536)              {                  this.delayWrite = false;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ?                  (channelMode == 3 ? 17 : 32) :                  (channelMode == 3 ? 9 : 17));
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ?                  (channelMode == 3 ? 17 : 32) :                  (channelMode == 3 ? 9 : 17));
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ?                  (channelMode == 3 ? 17 : 32) :                  (channelMode == 3 ? 9 : 17));
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ?                  (channelMode == 3 ? 17 : 32) :                  (channelMode == 3 ? 9 : 17));
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ?                  (channelMode == 3 ? 17 : 32) :                  (channelMode == 3 ? 9 : 17));
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ?                  (channelMode == 3 ? 17 : 32) :                  (channelMode == 3 ? 9 : 17));
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ?                  (channelMode == 3 ? 17 : 32) :                  (channelMode == 3 ? 9 : 17));
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ?                  (channelMode == 3 ? 17 : 32) :                  (channelMode == 3 ? 9 : 17));
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameLength,The following statement contains a magic number: return (mpegVersion == 3 ? 144 : 72) * bitRate / sampleRate + padding;
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameLength,The following statement contains a magic number: return (mpegVersion == 3 ? 144 : 72) * bitRate / sampleRate + padding;
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameLength,The following statement contains a magic number: return (mpegVersion == 3 ? 144 : 72) * bitRate / sampleRate + padding;
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1BitRate = new[] { 0' 32' 40' 48' 56' 64' 80' 96' 112' 128' 160' 192' 224' 256' 320' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg2XBitRate = new[] { 0' 8' 16' 24' 32' 40' 48' 56' 64' 80' 96' 112' 128' 144' 160' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1SampleRate = new[] { 44100' 48000' 32000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1SampleRate = new[] { 44100' 48000' 32000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg1SampleRate = new[] { 44100' 48000' 32000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg20SampleRate = new[] { 22050' 24000' 16000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg20SampleRate = new[] { 22050' 24000' 16000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg20SampleRate = new[] { 22050' 24000' 16000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg25SampleRate = new[] { 11025' 12000' 8000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg25SampleRate = new[] { 11025' 12000' 8000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: var mpeg25SampleRate = new[] { 11025' 12000' 8000' 0 };
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4)              {                  int mpegVersion' sampleRate' channelMode;                    ulong header = (ulong)BigEndianBitConverter.ToUInt32(buffer' offset) << 32;                    if (BitHelper.Read(ref header' 11) != 0x7FF)                  {                      break;                  }                    mpegVersion = BitHelper.Read(ref header' 2);                  int layer = BitHelper.Read(ref header' 2);                  BitHelper.Read(ref header' 1);                  int bitRate = BitHelper.Read(ref header' 4);                  sampleRate = BitHelper.Read(ref header' 2);                  int padding = BitHelper.Read(ref header' 1);                  BitHelper.Read(ref header' 1);                  channelMode = BitHelper.Read(ref header' 2);                    if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3)                  {                      break;                  }                    bitRate = (mpegVersion == 3 ? mpeg1BitRate[bitRate] : mpeg2XBitRate[bitRate]) * 1000;                    switch (mpegVersion)                  {                      case 2:                          sampleRate = mpeg20SampleRate[sampleRate];                          break;                        case 3:                          sampleRate = mpeg1SampleRate[sampleRate];                          break;                        default:                          sampleRate = mpeg25SampleRate[sampleRate];                          break;                  }                    int frameLenght = GetFrameLength(mpegVersion' bitRate' sampleRate' padding);                    if (frameLenght > length)                  {                      break;                  }                    bool isVbrHeaderFrame = false;                    if (frameOffsets.Count == 0)                  {                      // Check for an existing VBR header just to be safe (I haven't seen any in FLVs)                      int o = offset + GetFrameDataOffset(mpegVersion' channelMode);                        if (BigEndianBitConverter.ToUInt32(buffer' o) == 0x58696E67)                      {                          // "Xing"                          isVbrHeaderFrame = true;                          this.delayWrite = false;                          this.hasVbrHeader = true;                      }                  }                    if (!isVbrHeaderFrame)                  {                      if (this.firstBitRate == 0)                      {                          this.firstBitRate = bitRate;                          this.mpegVersion = mpegVersion;                          this.sampleRate = sampleRate;                          this.channelMode = channelMode;                          this.firstFrameHeader = BigEndianBitConverter.ToUInt32(buffer' offset);                      }                        else if (!this.isVbr && bitRate != this.firstBitRate)                      {                          this.isVbr = true;                            if (!this.hasVbrHeader)                          {                              if (this.delayWrite)                              {                                  this.WriteVbrHeader(true);                                  this.writeVbrHeader = true;                                  this.delayWrite = false;                              }                                else                              {                                  this.warnings.Add("Detected VBR too late' cannot add VBR header.");                              }                          }                      }                  }                    this.frameOffsets.Add(this.totalFrameLength + (uint)offset);                    offset += frameLenght;                  length -= frameLenght;              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: var buffer = new byte[GetFrameLength(this.mpegVersion' 64000' this.sampleRate' 0)];
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder)              {                  uint header = this.firstFrameHeader;                  int dataOffset = GetFrameDataOffset(this.mpegVersion' this.channelMode);                  header &= 0xFFFE0DFF; // Clear CRC' bitrate' and padding fields                  header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12; // 64 kbit/sec                  BitHelper.CopyBytes(buffer' 0' BigEndianBitConverter.GetBytes(header));                  BitHelper.CopyBytes(buffer' dataOffset' BigEndianBitConverter.GetBytes(0x58696E67)); // "Xing"                  BitHelper.CopyBytes(buffer' dataOffset + 4' BigEndianBitConverter.GetBytes((uint)0x7)); // Flags                  BitHelper.CopyBytes(buffer' dataOffset + 8' BigEndianBitConverter.GetBytes((uint)frameOffsets.Count)); // Frame count                  BitHelper.CopyBytes(buffer' dataOffset + 12' BigEndianBitConverter.GetBytes(totalFrameLength)); // File length                    for (int i = 0; i < 100; i++)                  {                      int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);                        buffer[dataOffset + 16 + i] = (byte)(this.frameOffsets[frameIndex] / (double)this.totalFrameLength * 256.0);                  }              }
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: using (WebResponse response = request.GetResponse())              {                  using (Stream source = response.GetResponseStream())                  {                      using (FileStream target = File.Open(this.SavePath' FileMode.Create' FileAccess.Write))                      {                          var buffer = new byte[1024];                          bool cancel = false;                          int bytes;                          int copiedBytes = 0;                            while (!cancel && (bytes = source.Read(buffer' 0' buffer.Length)) > 0)                          {                              target.Write(buffer' 0' bytes);                                copiedBytes += bytes;                                var eventArgs = new ProgressEventArgs((copiedBytes * 1.0 / response.ContentLength) * 100);                                if (this.DownloadProgressChanged != null)                              {                                  this.DownloadProgressChanged(this' eventArgs);                                    if (eventArgs.Cancel)                                  {                                      cancel = true;                                  }                              }                          }                      }                  }              }
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: using (WebResponse response = request.GetResponse())              {                  using (Stream source = response.GetResponseStream())                  {                      using (FileStream target = File.Open(this.SavePath' FileMode.Create' FileAccess.Write))                      {                          var buffer = new byte[1024];                          bool cancel = false;                          int bytes;                          int copiedBytes = 0;                            while (!cancel && (bytes = source.Read(buffer' 0' buffer.Length)) > 0)                          {                              target.Write(buffer' 0' bytes);                                copiedBytes += bytes;                                var eventArgs = new ProgressEventArgs((copiedBytes * 1.0 / response.ContentLength) * 100);                                if (this.DownloadProgressChanged != null)                              {                                  this.DownloadProgressChanged(this' eventArgs);                                    if (eventArgs.Cancel)                                  {                                      cancel = true;                                  }                              }                          }                      }                  }              }
Missing Default,YoutubeExtractor,FlvFile,C:\repos\flagbug_YoutubeExtractor\YoutubeExtractor\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following switch statement is missing a default case: switch (format)              {                  case 14:                  case 2:                      return new Mp3AudioExtractor(this.outputPath);                    case 10:                      return new AacAudioExtractor(this.outputPath);              }
