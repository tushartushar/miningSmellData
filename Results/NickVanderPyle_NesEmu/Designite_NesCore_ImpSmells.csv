Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,Cyclomatic complexity of the method is 62
Long Parameter List,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,NesRom,The method has 5 parameters.
Long Parameter List,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,LogCpuState,The method has 8 parameters.
Long Parameter List,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,LogCpuState,The method has 8 parameters.
Long Parameter List,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,LogCpuState,The method has 7 parameters.
Long Statement,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The length of the statement  "		throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction)); " is 147.
Long Statement,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The length of the statement  "		LogCpuState (programCounterOfInstruction' opCode' valueUshort' _registerX' _accumulator' _cpuFlagN' _cpuFlagSEI' _cpuFlagCLD); " is 126.
Long Statement,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The length of the statement  "		LogCpuState (programCounterOfInstruction' opCode' valueByte' _registerX' _accumulator' _cpuFlagN' _cpuFlagSEI' _cpuFlagCLD); " is 124.
Long Statement,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,LogCpuState,The length of the statement  "	Console.WriteLine ("{0:x2}:{1}\t{2:x2}\tAcc:{4:x2} X:{3:x2} N:{5} SEI:{6} CLD:{7}"' programCounterOfInstruction' opCode' value' registerX' accumulator' Convert.ToInt32 (cpuFlagN)' Convert.ToInt32 (cpuFlagSEI)' Convert.ToInt32 (cpuFlagCLD)); " is 240.
Long Statement,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,LogCpuState,The length of the statement  "	Console.WriteLine ("{0:x2}:{1}\t{2:x2}\tAcc:{4:x2} X:{3:x2} N:{5} SEI:{6} CLD:{7}"' programCounterOfInstruction' opCode' value' registerX' accumulator' Convert.ToInt32 (cpuFlagN)' Convert.ToInt32 (cpuFlagSEI)' Convert.ToInt32 (cpuFlagCLD)); " is 240.
Long Statement,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,LogCpuState,The length of the statement  "	Console.WriteLine ("{0:x2}:{1}\t\tAcc:{3:x2} X:{2:x2} N:{4} SEI:{5} CLD:{6}"' programCounterOfInstruction' opCode' registerX' accumulator' Convert.ToInt32 (cpuFlagN)' Convert.ToInt32 (cpuFlagSEI)' Convert.ToInt32 (cpuFlagCLD)); " is 227.
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: using (var fileStream = fileInfo.OpenRead ()) {  	var isValidNesHeader = true;  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x4E;  	//N  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x45;  	//E  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x53;  	//S  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x1A;  	if (!isValidNesHeader) {  		throw new Exception (string.Format ("{0} does not have a valid NES header."' fileInfo.Name));  	}  	int prgBlockCount = (int)fileStream.ReadByte ();  	int chrBlockCount = (int)fileStream.ReadByte ();  	fileStream.Position += 10;  	Console.WriteLine ("PRG Block Count: {0}"' prgBlockCount);  	Console.WriteLine ("CHR Block Count: {0}"' chrBlockCount);  	var prgBlocks = new byte[prgBlockCount][];  	var chrBlocks = new byte[chrBlockCount][];  	var prgStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < prgBlockCount; ++i) {  		prgBlocks [i] = new byte[16384];  		fileStream.Read (prgBlocks [i]' 0' 0x4000);  	}  	var chrStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < chrBlockCount; ++i) {  		chrBlocks [i] = new byte[8192];  		fileStream.Read (chrBlocks [i]' 0' 8192);  	}  	//There may be a remaining 128 bytes of Title data. Not necessary to read.  	var prgTotalSizeInBytes = prgBlockCount * 0x4000;  	var chrTotalSizeInBytes = chrBlockCount * 0x2000;  	var sizeInBytesOfRomData = prgTotalSizeInBytes + chrTotalSizeInBytes;  	fileStream.Position = 16;  	var romBytes = new byte[sizeInBytesOfRomData];  	var bytesRead = fileStream.Read (romBytes' 0' sizeInBytesOfRomData);  	if (bytesRead != sizeInBytesOfRomData)  		throw new FileLoadException (""' fileInfo.Name);  	return new NesRom (romBytes' prgStartPosition' prgTotalSizeInBytes' chrStartPosition' chrTotalSizeInBytes);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: using (var fileStream = fileInfo.OpenRead ()) {  	var isValidNesHeader = true;  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x4E;  	//N  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x45;  	//E  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x53;  	//S  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x1A;  	if (!isValidNesHeader) {  		throw new Exception (string.Format ("{0} does not have a valid NES header."' fileInfo.Name));  	}  	int prgBlockCount = (int)fileStream.ReadByte ();  	int chrBlockCount = (int)fileStream.ReadByte ();  	fileStream.Position += 10;  	Console.WriteLine ("PRG Block Count: {0}"' prgBlockCount);  	Console.WriteLine ("CHR Block Count: {0}"' chrBlockCount);  	var prgBlocks = new byte[prgBlockCount][];  	var chrBlocks = new byte[chrBlockCount][];  	var prgStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < prgBlockCount; ++i) {  		prgBlocks [i] = new byte[16384];  		fileStream.Read (prgBlocks [i]' 0' 0x4000);  	}  	var chrStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < chrBlockCount; ++i) {  		chrBlocks [i] = new byte[8192];  		fileStream.Read (chrBlocks [i]' 0' 8192);  	}  	//There may be a remaining 128 bytes of Title data. Not necessary to read.  	var prgTotalSizeInBytes = prgBlockCount * 0x4000;  	var chrTotalSizeInBytes = chrBlockCount * 0x2000;  	var sizeInBytesOfRomData = prgTotalSizeInBytes + chrTotalSizeInBytes;  	fileStream.Position = 16;  	var romBytes = new byte[sizeInBytesOfRomData];  	var bytesRead = fileStream.Read (romBytes' 0' sizeInBytesOfRomData);  	if (bytesRead != sizeInBytesOfRomData)  		throw new FileLoadException (""' fileInfo.Name);  	return new NesRom (romBytes' prgStartPosition' prgTotalSizeInBytes' chrStartPosition' chrTotalSizeInBytes);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: using (var fileStream = fileInfo.OpenRead ()) {  	var isValidNesHeader = true;  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x4E;  	//N  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x45;  	//E  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x53;  	//S  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x1A;  	if (!isValidNesHeader) {  		throw new Exception (string.Format ("{0} does not have a valid NES header."' fileInfo.Name));  	}  	int prgBlockCount = (int)fileStream.ReadByte ();  	int chrBlockCount = (int)fileStream.ReadByte ();  	fileStream.Position += 10;  	Console.WriteLine ("PRG Block Count: {0}"' prgBlockCount);  	Console.WriteLine ("CHR Block Count: {0}"' chrBlockCount);  	var prgBlocks = new byte[prgBlockCount][];  	var chrBlocks = new byte[chrBlockCount][];  	var prgStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < prgBlockCount; ++i) {  		prgBlocks [i] = new byte[16384];  		fileStream.Read (prgBlocks [i]' 0' 0x4000);  	}  	var chrStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < chrBlockCount; ++i) {  		chrBlocks [i] = new byte[8192];  		fileStream.Read (chrBlocks [i]' 0' 8192);  	}  	//There may be a remaining 128 bytes of Title data. Not necessary to read.  	var prgTotalSizeInBytes = prgBlockCount * 0x4000;  	var chrTotalSizeInBytes = chrBlockCount * 0x2000;  	var sizeInBytesOfRomData = prgTotalSizeInBytes + chrTotalSizeInBytes;  	fileStream.Position = 16;  	var romBytes = new byte[sizeInBytesOfRomData];  	var bytesRead = fileStream.Read (romBytes' 0' sizeInBytesOfRomData);  	if (bytesRead != sizeInBytesOfRomData)  		throw new FileLoadException (""' fileInfo.Name);  	return new NesRom (romBytes' prgStartPosition' prgTotalSizeInBytes' chrStartPosition' chrTotalSizeInBytes);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: using (var fileStream = fileInfo.OpenRead ()) {  	var isValidNesHeader = true;  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x4E;  	//N  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x45;  	//E  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x53;  	//S  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x1A;  	if (!isValidNesHeader) {  		throw new Exception (string.Format ("{0} does not have a valid NES header."' fileInfo.Name));  	}  	int prgBlockCount = (int)fileStream.ReadByte ();  	int chrBlockCount = (int)fileStream.ReadByte ();  	fileStream.Position += 10;  	Console.WriteLine ("PRG Block Count: {0}"' prgBlockCount);  	Console.WriteLine ("CHR Block Count: {0}"' chrBlockCount);  	var prgBlocks = new byte[prgBlockCount][];  	var chrBlocks = new byte[chrBlockCount][];  	var prgStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < prgBlockCount; ++i) {  		prgBlocks [i] = new byte[16384];  		fileStream.Read (prgBlocks [i]' 0' 0x4000);  	}  	var chrStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < chrBlockCount; ++i) {  		chrBlocks [i] = new byte[8192];  		fileStream.Read (chrBlocks [i]' 0' 8192);  	}  	//There may be a remaining 128 bytes of Title data. Not necessary to read.  	var prgTotalSizeInBytes = prgBlockCount * 0x4000;  	var chrTotalSizeInBytes = chrBlockCount * 0x2000;  	var sizeInBytesOfRomData = prgTotalSizeInBytes + chrTotalSizeInBytes;  	fileStream.Position = 16;  	var romBytes = new byte[sizeInBytesOfRomData];  	var bytesRead = fileStream.Read (romBytes' 0' sizeInBytesOfRomData);  	if (bytesRead != sizeInBytesOfRomData)  		throw new FileLoadException (""' fileInfo.Name);  	return new NesRom (romBytes' prgStartPosition' prgTotalSizeInBytes' chrStartPosition' chrTotalSizeInBytes);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: using (var fileStream = fileInfo.OpenRead ()) {  	var isValidNesHeader = true;  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x4E;  	//N  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x45;  	//E  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x53;  	//S  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x1A;  	if (!isValidNesHeader) {  		throw new Exception (string.Format ("{0} does not have a valid NES header."' fileInfo.Name));  	}  	int prgBlockCount = (int)fileStream.ReadByte ();  	int chrBlockCount = (int)fileStream.ReadByte ();  	fileStream.Position += 10;  	Console.WriteLine ("PRG Block Count: {0}"' prgBlockCount);  	Console.WriteLine ("CHR Block Count: {0}"' chrBlockCount);  	var prgBlocks = new byte[prgBlockCount][];  	var chrBlocks = new byte[chrBlockCount][];  	var prgStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < prgBlockCount; ++i) {  		prgBlocks [i] = new byte[16384];  		fileStream.Read (prgBlocks [i]' 0' 0x4000);  	}  	var chrStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < chrBlockCount; ++i) {  		chrBlocks [i] = new byte[8192];  		fileStream.Read (chrBlocks [i]' 0' 8192);  	}  	//There may be a remaining 128 bytes of Title data. Not necessary to read.  	var prgTotalSizeInBytes = prgBlockCount * 0x4000;  	var chrTotalSizeInBytes = chrBlockCount * 0x2000;  	var sizeInBytesOfRomData = prgTotalSizeInBytes + chrTotalSizeInBytes;  	fileStream.Position = 16;  	var romBytes = new byte[sizeInBytesOfRomData];  	var bytesRead = fileStream.Read (romBytes' 0' sizeInBytesOfRomData);  	if (bytesRead != sizeInBytesOfRomData)  		throw new FileLoadException (""' fileInfo.Name);  	return new NesRom (romBytes' prgStartPosition' prgTotalSizeInBytes' chrStartPosition' chrTotalSizeInBytes);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: using (var fileStream = fileInfo.OpenRead ()) {  	var isValidNesHeader = true;  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x4E;  	//N  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x45;  	//E  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x53;  	//S  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x1A;  	if (!isValidNesHeader) {  		throw new Exception (string.Format ("{0} does not have a valid NES header."' fileInfo.Name));  	}  	int prgBlockCount = (int)fileStream.ReadByte ();  	int chrBlockCount = (int)fileStream.ReadByte ();  	fileStream.Position += 10;  	Console.WriteLine ("PRG Block Count: {0}"' prgBlockCount);  	Console.WriteLine ("CHR Block Count: {0}"' chrBlockCount);  	var prgBlocks = new byte[prgBlockCount][];  	var chrBlocks = new byte[chrBlockCount][];  	var prgStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < prgBlockCount; ++i) {  		prgBlocks [i] = new byte[16384];  		fileStream.Read (prgBlocks [i]' 0' 0x4000);  	}  	var chrStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < chrBlockCount; ++i) {  		chrBlocks [i] = new byte[8192];  		fileStream.Read (chrBlocks [i]' 0' 8192);  	}  	//There may be a remaining 128 bytes of Title data. Not necessary to read.  	var prgTotalSizeInBytes = prgBlockCount * 0x4000;  	var chrTotalSizeInBytes = chrBlockCount * 0x2000;  	var sizeInBytesOfRomData = prgTotalSizeInBytes + chrTotalSizeInBytes;  	fileStream.Position = 16;  	var romBytes = new byte[sizeInBytesOfRomData];  	var bytesRead = fileStream.Read (romBytes' 0' sizeInBytesOfRomData);  	if (bytesRead != sizeInBytesOfRomData)  		throw new FileLoadException (""' fileInfo.Name);  	return new NesRom (romBytes' prgStartPosition' prgTotalSizeInBytes' chrStartPosition' chrTotalSizeInBytes);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: using (var fileStream = fileInfo.OpenRead ()) {  	var isValidNesHeader = true;  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x4E;  	//N  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x45;  	//E  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x53;  	//S  	isValidNesHeader = isValidNesHeader && fileStream.ReadByte () == 0x1A;  	if (!isValidNesHeader) {  		throw new Exception (string.Format ("{0} does not have a valid NES header."' fileInfo.Name));  	}  	int prgBlockCount = (int)fileStream.ReadByte ();  	int chrBlockCount = (int)fileStream.ReadByte ();  	fileStream.Position += 10;  	Console.WriteLine ("PRG Block Count: {0}"' prgBlockCount);  	Console.WriteLine ("CHR Block Count: {0}"' chrBlockCount);  	var prgBlocks = new byte[prgBlockCount][];  	var chrBlocks = new byte[chrBlockCount][];  	var prgStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < prgBlockCount; ++i) {  		prgBlocks [i] = new byte[16384];  		fileStream.Read (prgBlocks [i]' 0' 0x4000);  	}  	var chrStartPosition = (int)fileStream.Position - 16;  	for (var i = 0; i < chrBlockCount; ++i) {  		chrBlocks [i] = new byte[8192];  		fileStream.Read (chrBlocks [i]' 0' 8192);  	}  	//There may be a remaining 128 bytes of Title data. Not necessary to read.  	var prgTotalSizeInBytes = prgBlockCount * 0x4000;  	var chrTotalSizeInBytes = chrBlockCount * 0x2000;  	var sizeInBytesOfRomData = prgTotalSizeInBytes + chrTotalSizeInBytes;  	fileStream.Position = 16;  	var romBytes = new byte[sizeInBytesOfRomData];  	var bytesRead = fileStream.Read (romBytes' 0' sizeInBytesOfRomData);  	if (bytesRead != sizeInBytesOfRomData)  		throw new FileLoadException (""' fileInfo.Name);  	return new NesRom (romBytes' prgStartPosition' prgTotalSizeInBytes' chrStartPosition' chrTotalSizeInBytes);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: fileStream.Position += 10;  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: for (var i = 0; i < prgBlockCount; ++i) {  	prgBlocks [i] = new byte[16384];  	fileStream.Read (prgBlocks [i]' 0' 0x4000);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: prgBlocks [i] = new byte[16384];  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: for (var i = 0; i < chrBlockCount; ++i) {  	chrBlocks [i] = new byte[8192];  	fileStream.Read (chrBlocks [i]' 0' 8192);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: for (var i = 0; i < chrBlockCount; ++i) {  	chrBlocks [i] = new byte[8192];  	fileStream.Read (chrBlocks [i]' 0' 8192);  }  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: chrBlocks [i] = new byte[8192];  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: fileStream.Read (chrBlocks [i]' 0' 8192);  
Magic Number,NesCore,NesRom,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\NesRom.cs,Parse,The following statement contains a magic number: fileStream.Position = 16;  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,SetCpuFlagN,The following statement contains a magic number: _cpuFlagN = value >= 128;  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,SetCpuFlagN,The following statement contains a magic number: _cpuFlagN = value >= 32768;  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: switch (opCode) {  case OpCodes.SEI:  	isValueLess = true;  	_cpuFlagSEI = true;  	_programCounter++;  	break;  case OpCodes.CLD:  	isValueLess = true;  	_cpuFlagCLD = true;  	_programCounter++;  	break;  case OpCodes.LDA_I:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_accumulator = valueByte;  	SetCpuFlagN (_accumulator);  	_programCounter += 2;  	break;  case OpCodes.STA:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_memory.WriteByteToAddress (_accumulator' valueUshort);  	SetCpuFlagN (valueUshort);  	_programCounter += 3;  	break;  case OpCodes.LDX:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_registerX = valueByte;  	SetCpuFlagN (_registerX);  	_programCounter += 2;  	break;  case OpCodes.TXS:  	isValueLess = true;  	_stackPointer = _registerX;  	_programCounter++;  	break;  case OpCodes.LDA_A:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_accumulator = _memory.ReadByte (valueUshort);  	SetCpuFlagN (_accumulator);  	_programCounter += 3;  	break;  case OpCodes.BPL:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	if (!_cpuFlagN) {  		var bplByte = valueByte;  		var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  		//2's complement conversion  		_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  	}  	else {  		_programCounter += 2;  	}  	break;  case OpCodes.JSR:  	is16BitValue = true;  	_stackPointer--;  	_memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	SetCpuFlagN (valueUshort);  	_programCounter = valueUshort;  	break;  default:  	throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction));  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: switch (opCode) {  case OpCodes.SEI:  	isValueLess = true;  	_cpuFlagSEI = true;  	_programCounter++;  	break;  case OpCodes.CLD:  	isValueLess = true;  	_cpuFlagCLD = true;  	_programCounter++;  	break;  case OpCodes.LDA_I:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_accumulator = valueByte;  	SetCpuFlagN (_accumulator);  	_programCounter += 2;  	break;  case OpCodes.STA:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_memory.WriteByteToAddress (_accumulator' valueUshort);  	SetCpuFlagN (valueUshort);  	_programCounter += 3;  	break;  case OpCodes.LDX:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_registerX = valueByte;  	SetCpuFlagN (_registerX);  	_programCounter += 2;  	break;  case OpCodes.TXS:  	isValueLess = true;  	_stackPointer = _registerX;  	_programCounter++;  	break;  case OpCodes.LDA_A:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_accumulator = _memory.ReadByte (valueUshort);  	SetCpuFlagN (_accumulator);  	_programCounter += 3;  	break;  case OpCodes.BPL:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	if (!_cpuFlagN) {  		var bplByte = valueByte;  		var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  		//2's complement conversion  		_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  	}  	else {  		_programCounter += 2;  	}  	break;  case OpCodes.JSR:  	is16BitValue = true;  	_stackPointer--;  	_memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	SetCpuFlagN (valueUshort);  	_programCounter = valueUshort;  	break;  default:  	throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction));  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: switch (opCode) {  case OpCodes.SEI:  	isValueLess = true;  	_cpuFlagSEI = true;  	_programCounter++;  	break;  case OpCodes.CLD:  	isValueLess = true;  	_cpuFlagCLD = true;  	_programCounter++;  	break;  case OpCodes.LDA_I:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_accumulator = valueByte;  	SetCpuFlagN (_accumulator);  	_programCounter += 2;  	break;  case OpCodes.STA:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_memory.WriteByteToAddress (_accumulator' valueUshort);  	SetCpuFlagN (valueUshort);  	_programCounter += 3;  	break;  case OpCodes.LDX:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_registerX = valueByte;  	SetCpuFlagN (_registerX);  	_programCounter += 2;  	break;  case OpCodes.TXS:  	isValueLess = true;  	_stackPointer = _registerX;  	_programCounter++;  	break;  case OpCodes.LDA_A:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_accumulator = _memory.ReadByte (valueUshort);  	SetCpuFlagN (_accumulator);  	_programCounter += 3;  	break;  case OpCodes.BPL:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	if (!_cpuFlagN) {  		var bplByte = valueByte;  		var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  		//2's complement conversion  		_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  	}  	else {  		_programCounter += 2;  	}  	break;  case OpCodes.JSR:  	is16BitValue = true;  	_stackPointer--;  	_memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	SetCpuFlagN (valueUshort);  	_programCounter = valueUshort;  	break;  default:  	throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction));  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: switch (opCode) {  case OpCodes.SEI:  	isValueLess = true;  	_cpuFlagSEI = true;  	_programCounter++;  	break;  case OpCodes.CLD:  	isValueLess = true;  	_cpuFlagCLD = true;  	_programCounter++;  	break;  case OpCodes.LDA_I:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_accumulator = valueByte;  	SetCpuFlagN (_accumulator);  	_programCounter += 2;  	break;  case OpCodes.STA:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_memory.WriteByteToAddress (_accumulator' valueUshort);  	SetCpuFlagN (valueUshort);  	_programCounter += 3;  	break;  case OpCodes.LDX:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_registerX = valueByte;  	SetCpuFlagN (_registerX);  	_programCounter += 2;  	break;  case OpCodes.TXS:  	isValueLess = true;  	_stackPointer = _registerX;  	_programCounter++;  	break;  case OpCodes.LDA_A:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_accumulator = _memory.ReadByte (valueUshort);  	SetCpuFlagN (_accumulator);  	_programCounter += 3;  	break;  case OpCodes.BPL:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	if (!_cpuFlagN) {  		var bplByte = valueByte;  		var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  		//2's complement conversion  		_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  	}  	else {  		_programCounter += 2;  	}  	break;  case OpCodes.JSR:  	is16BitValue = true;  	_stackPointer--;  	_memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	SetCpuFlagN (valueUshort);  	_programCounter = valueUshort;  	break;  default:  	throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction));  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: switch (opCode) {  case OpCodes.SEI:  	isValueLess = true;  	_cpuFlagSEI = true;  	_programCounter++;  	break;  case OpCodes.CLD:  	isValueLess = true;  	_cpuFlagCLD = true;  	_programCounter++;  	break;  case OpCodes.LDA_I:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_accumulator = valueByte;  	SetCpuFlagN (_accumulator);  	_programCounter += 2;  	break;  case OpCodes.STA:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_memory.WriteByteToAddress (_accumulator' valueUshort);  	SetCpuFlagN (valueUshort);  	_programCounter += 3;  	break;  case OpCodes.LDX:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_registerX = valueByte;  	SetCpuFlagN (_registerX);  	_programCounter += 2;  	break;  case OpCodes.TXS:  	isValueLess = true;  	_stackPointer = _registerX;  	_programCounter++;  	break;  case OpCodes.LDA_A:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_accumulator = _memory.ReadByte (valueUshort);  	SetCpuFlagN (_accumulator);  	_programCounter += 3;  	break;  case OpCodes.BPL:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	if (!_cpuFlagN) {  		var bplByte = valueByte;  		var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  		//2's complement conversion  		_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  	}  	else {  		_programCounter += 2;  	}  	break;  case OpCodes.JSR:  	is16BitValue = true;  	_stackPointer--;  	_memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	SetCpuFlagN (valueUshort);  	_programCounter = valueUshort;  	break;  default:  	throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction));  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: switch (opCode) {  case OpCodes.SEI:  	isValueLess = true;  	_cpuFlagSEI = true;  	_programCounter++;  	break;  case OpCodes.CLD:  	isValueLess = true;  	_cpuFlagCLD = true;  	_programCounter++;  	break;  case OpCodes.LDA_I:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_accumulator = valueByte;  	SetCpuFlagN (_accumulator);  	_programCounter += 2;  	break;  case OpCodes.STA:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_memory.WriteByteToAddress (_accumulator' valueUshort);  	SetCpuFlagN (valueUshort);  	_programCounter += 3;  	break;  case OpCodes.LDX:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_registerX = valueByte;  	SetCpuFlagN (_registerX);  	_programCounter += 2;  	break;  case OpCodes.TXS:  	isValueLess = true;  	_stackPointer = _registerX;  	_programCounter++;  	break;  case OpCodes.LDA_A:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_accumulator = _memory.ReadByte (valueUshort);  	SetCpuFlagN (_accumulator);  	_programCounter += 3;  	break;  case OpCodes.BPL:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	if (!_cpuFlagN) {  		var bplByte = valueByte;  		var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  		//2's complement conversion  		_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  	}  	else {  		_programCounter += 2;  	}  	break;  case OpCodes.JSR:  	is16BitValue = true;  	_stackPointer--;  	_memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	SetCpuFlagN (valueUshort);  	_programCounter = valueUshort;  	break;  default:  	throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction));  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: switch (opCode) {  case OpCodes.SEI:  	isValueLess = true;  	_cpuFlagSEI = true;  	_programCounter++;  	break;  case OpCodes.CLD:  	isValueLess = true;  	_cpuFlagCLD = true;  	_programCounter++;  	break;  case OpCodes.LDA_I:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_accumulator = valueByte;  	SetCpuFlagN (_accumulator);  	_programCounter += 2;  	break;  case OpCodes.STA:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_memory.WriteByteToAddress (_accumulator' valueUshort);  	SetCpuFlagN (valueUshort);  	_programCounter += 3;  	break;  case OpCodes.LDX:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_registerX = valueByte;  	SetCpuFlagN (_registerX);  	_programCounter += 2;  	break;  case OpCodes.TXS:  	isValueLess = true;  	_stackPointer = _registerX;  	_programCounter++;  	break;  case OpCodes.LDA_A:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_accumulator = _memory.ReadByte (valueUshort);  	SetCpuFlagN (_accumulator);  	_programCounter += 3;  	break;  case OpCodes.BPL:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	if (!_cpuFlagN) {  		var bplByte = valueByte;  		var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  		//2's complement conversion  		_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  	}  	else {  		_programCounter += 2;  	}  	break;  case OpCodes.JSR:  	is16BitValue = true;  	_stackPointer--;  	_memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	SetCpuFlagN (valueUshort);  	_programCounter = valueUshort;  	break;  default:  	throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction));  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: switch (opCode) {  case OpCodes.SEI:  	isValueLess = true;  	_cpuFlagSEI = true;  	_programCounter++;  	break;  case OpCodes.CLD:  	isValueLess = true;  	_cpuFlagCLD = true;  	_programCounter++;  	break;  case OpCodes.LDA_I:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_accumulator = valueByte;  	SetCpuFlagN (_accumulator);  	_programCounter += 2;  	break;  case OpCodes.STA:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_memory.WriteByteToAddress (_accumulator' valueUshort);  	SetCpuFlagN (valueUshort);  	_programCounter += 3;  	break;  case OpCodes.LDX:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	_registerX = valueByte;  	SetCpuFlagN (_registerX);  	_programCounter += 2;  	break;  case OpCodes.TXS:  	isValueLess = true;  	_stackPointer = _registerX;  	_programCounter++;  	break;  case OpCodes.LDA_A:  	is16BitValue = true;  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	_accumulator = _memory.ReadByte (valueUshort);  	SetCpuFlagN (_accumulator);  	_programCounter += 3;  	break;  case OpCodes.BPL:  	is8BitValue = true;  	valueByte = _memory.ReadByte (_programCounter + 1);  	if (!_cpuFlagN) {  		var bplByte = valueByte;  		var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  		//2's complement conversion  		_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  	}  	else {  		_programCounter += 2;  	}  	break;  case OpCodes.JSR:  	is16BitValue = true;  	_stackPointer--;  	_memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  	valueUshort = _memory.ReadUInt16 (_programCounter + 1);  	SetCpuFlagN (valueUshort);  	_programCounter = valueUshort;  	break;  default:  	throw new NotImplementedException (string.Format ("Not Implemented: OpCode 0x{0:X2}({0:D}) at {1:X2}"' (byte)opCode' programCounterOfInstruction));  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: _programCounter += 2;  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: _programCounter += 3;  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: _programCounter += 2;  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: _programCounter += 3;  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: if (!_cpuFlagN) {  	var bplByte = valueByte;  	var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  	//2's complement conversion  	_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  }  else {  	_programCounter += 2;  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: if (!_cpuFlagN) {  	var bplByte = valueByte;  	var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  	//2's complement conversion  	_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  }  else {  	_programCounter += 2;  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: if (!_cpuFlagN) {  	var bplByte = valueByte;  	var bplJumpNumberOfBytes = (bplByte < 128) ? bplByte : bplByte - 254;  	//2's complement conversion  	_programCounter = (UInt16)(_programCounter + bplJumpNumberOfBytes);  }  else {  	_programCounter += 2;  }  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: _programCounter += 2;  
Magic Number,NesCore,CPU,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\CPU.cs,OneCpuCycle,The following statement contains a magic number: _memory.WriteUInt16ToAddress ((UInt16)(_programCounter + 4)' _stackPointer);  
Magic Number,NesCore,Memory,C:\repos\NickVanderPyle_NesEmu\Source\NesCore\Memory.cs,ReadByte,The following statement contains a magic number: if (fromAddress == 0x2002) {  	//reading PPU status causes high bit to clear  	//http://wiki.nesdev.com/w/index.php/PPU_registers#Status_.28.242002.29_.3C_read  	int ppuRegister = byteRead;  	const int mask = 1 << 7;  	ppuRegister &= ~mask;  	_bytes [fromAddress] = (byte)ppuRegister;  }  
