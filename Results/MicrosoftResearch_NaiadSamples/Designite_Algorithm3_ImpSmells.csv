Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,RenameTwitterByDegree,Cyclomatic complexity of the method is 22
Long Parameter List,Algorithm3.Indices,DenseIntKeyIndex,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Indices\DenseIntKeyIndex.cs,DenseIntKeyIndex,The method has 8 parameters.
Long Parameter List,Algorithm3.Indices,DenseIntKeyIndex,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Indices\DenseIntKeyIndex.cs,DenseIntKeyIndex,The method has 7 parameters.
Long Parameter List,Algorithm3.Indices,DenseKeyIndex,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Indices\DenseKeyIndex.cs,DenseKeyIndex,The method has 8 parameters.
Long Parameter List,Algorithm3.Indices,EmptyKeyIndex,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Indices\EmptyKeyIndex.cs,EmptyKeyIndex,The method has 19 parameters.
Long Parameter List,Algorithm3.Indices,TypedKeyIndex,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Indices\TypedIndex.cs,TypedKeyIndex,The method has 8 parameters.
Long Parameter List,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Main,The method has 17 parameters.
Long Parameter List,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,AllReduce,The method has 13 parameters.
Long Parameter List,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Triangles,The method has 7 parameters.
Long Parameter List,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Rectangles,The method has 10 parameters.
Long Parameter List,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Flags,The method has 10 parameters.
Long Parameter List,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,NewBinaryAzureInterGraphStream,The method has 5 parameters.
Long Parameter List,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,OrientFromLowToHighDegree,The method has 12 parameters.
Long Parameter List,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,AssessWork,The method has 16 parameters.
Long Parameter List,Algorithm3,CustomOperators,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,IndexJoin,The method has 7 parameters.
Long Parameter List,Algorithm3,CustomOperators,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,IndexJoin,The method has 7 parameters.
Long Statement,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Main,The length of the statement  "			graph = controller.NewInterGraphStream (Enumerable.Range (0' parts)' stream => stream.Distinct ().SelectMany (x => string.Format (format' x).ReadEdges ())); " is 156.
Long Statement,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Main,The length of the statement  "		graph = controller.NewInterGraphStream (graph' edges => edges.Where (x => x.First != x.Second).Select (x => x.First < x.Second ? x : x.Second.PairWith (x.First))//.GroupBy(x => true' (k' l) => l.RandomlyRename()) " is 212.
Long Statement,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Main,The length of the statement  "			// triangles.Expand().Where(x => { Console.WriteLine("{0} Triangle observed: {1}"' stopwatch.Elapsed' x); return true; }); " is 122.
Long Statement,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Main,The length of the statement  "			triangles.Select (x => x.Second.Length).Aggregate (x => true' y => y' (x' y) => x + y' (k' sum) => sum' true).Subscribe (x =>  { " is 128.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,AllReduce,The length of the statement  "		}.AsNaiadStream (computation).Aggregate (x => true' x => x' reducer' (b' x) => x).SelectMany (x => Enumerable.Range (0' controller.Configuration.Processes).Select (i => x.PairWith (i))).PartitionBy (x => x.Second * controller.Configuration.WorkerCount).Subscribe ((i' j' x) =>  { " is 279.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Triangles,The length of the statement  "	var triangles = source.GenericJoinLayer (prefixExtenders0).Expand ().Select (x => x.Second).GenericJoinLayer (prefixExtenders1).Expand ().GenericJoinLayer (prefixExtenders2); " is 174.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Rectangles,The length of the statement  "	var rectangles = source.GenericJoinLayer (prefixExtenders0).Expand ().Select (x => x.Second).GenericJoinLayer (prefixExtenders1).Expand ().GenericJoinLayer (prefixExtenders2).Expand ().Where (x => x.First.Second != x.Second).GenericJoinLayer (prefixExtenders3).Expand ().Where (x => x.First.First.First != x.Second); " is 316.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Flags,The length of the statement  "	var flags = source.GenericJoinLayer (prefixExtenders0).Expand ().Select (x => x.Second).GenericJoinLayer (prefixExtenders1).Expand ().GenericJoinLayer (prefixExtenders2).Expand ().GenericJoinLayer (prefixExtenders3).Expand ().Where (x => x.First.First.First != x.Second); " is 271.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadText,The length of the statement  "	return System.IO.File.ReadAllLines (filename).Where (x => !x.StartsWith ("#")).Select (x => x.Split ()).Select (x => Int32.Parse (x [0]).PairWith (Int32.Parse (x [1]))); " is 169.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,OrientFromLowToHighDegree,The length of the statement  "	return edges.Select (x => x.source.WithValue (x.target)).NodeJoin (degrees' (target' degree) => target.WithValue (degree)).Select (x => x.value.node.WithValue (x.node.WithValue (x.value.value)))// (src' (dst' sdeg)) => (dst' (src' sdeg)) " is 237.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,OrientFromLowToHighDegree,The length of the statement  "	.NodeJoin (degrees' (sdeg' degree) => sdeg.node.WithValue (sdeg.value.PairWith (degree))).Select (x => x.value.value.First == x.value.value.Second ? (x.node.index < x.value.node.index ? new Edge (x.node' x.value.node) : new Edge (x.value.node' x.node)) : x.value.value.First < x.value.value.Second ? new Edge (x.value.node' x.node) : new Edge (x.node' x.value.node)).Select (x => x.source.index.PairWith (x.target.index)); " is 422.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,AssessWork,The length of the statement  "	var vals = edges.Select (x => x.source.WithValue (x.target)).NodeJoin (degrees' (target' degree) => target.WithValue (degree)).Select (x => x.value.node.WithValue (x.node.WithValue (x.value.value)))// (src' (dst' sdeg)) => (dst' (src' sdeg)) " is 241.
Long Statement,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,AssessWork,The length of the statement  "	.Select (x => x.value.value.First == x.value.value.Second ? (x.node.index < x.value.node.index ? x.node.WithValue (x.value.value.First) : x.value.node.WithValue (x.value.value.Second)) : x.value.value.First < x.value.value.Second ? x.value.node.WithValue (x.value.value.Second) : x.node.WithValue (x.value.value.First)); " is 320.
Long Statement,Algorithm3,CustomOperators,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,IndexJoin,The length of the statement  "	return stream1.NewBinaryStage (stream2' (i' s) => new IndexJoinVertex<TInput1' TInput2' TKey' TOutput' TTime> (i' s' resultSelector)' null' x => keySelector (x).GetHashCode ()' null' "Join"); " is 191.
Long Statement,Algorithm3,CustomOperators,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,IndexJoin,The length of the statement  "	return stream1.NewBinaryStage (stream2' (i' s) => new IndexJoinVertex2<TInput1' TInput2' TKey' TOutput> (i' s' action)' null' x => keySelector (x).GetHashCode ()' null' "Join"); " is 177.
Long Statement,Algorithm3,CustomOperators,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Expand,The length of the statement  "	return stream.Select (x => x.First.PairWith (new ArraySegment<V> (x.Second))).NewUnaryStage ((i' s) => new Expander<T' V' TTime> (i' s)' null' null' "Expander"); " is 161.
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = new System.IO.BinaryReader (stream)) {  	while (bytesToRead > 0 && returned < limit) {  		var vertex = reader.ReadInt32 ();  		var degree = reader.ReadInt32 ();  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (reader.ReadInt32 ());  		bytesToRead -= 4 * (1 + 1 + degree);  		returned += degree;  		if (returned > threshold + 1000000) {  			Console.WriteLine ("{1}\tRead {0}"' returned' System.DateTime.Now);  			threshold += 1000000;  		}  	}  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = new System.IO.BinaryReader (stream)) {  	while (bytesToRead > 0 && returned < limit) {  		var vertex = reader.ReadInt32 ();  		var degree = reader.ReadInt32 ();  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (reader.ReadInt32 ());  		bytesToRead -= 4 * (1 + 1 + degree);  		returned += degree;  		if (returned > threshold + 1000000) {  			Console.WriteLine ("{1}\tRead {0}"' returned' System.DateTime.Now);  			threshold += 1000000;  		}  	}  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = new System.IO.BinaryReader (stream)) {  	while (bytesToRead > 0 && returned < limit) {  		var vertex = reader.ReadInt32 ();  		var degree = reader.ReadInt32 ();  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (reader.ReadInt32 ());  		bytesToRead -= 4 * (1 + 1 + degree);  		returned += degree;  		if (returned > threshold + 1000000) {  			Console.WriteLine ("{1}\tRead {0}"' returned' System.DateTime.Now);  			threshold += 1000000;  		}  	}  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0 && returned < limit) {  	var vertex = reader.ReadInt32 ();  	var degree = reader.ReadInt32 ();  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (reader.ReadInt32 ());  	bytesToRead -= 4 * (1 + 1 + degree);  	returned += degree;  	if (returned > threshold + 1000000) {  		Console.WriteLine ("{1}\tRead {0}"' returned' System.DateTime.Now);  		threshold += 1000000;  	}  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0 && returned < limit) {  	var vertex = reader.ReadInt32 ();  	var degree = reader.ReadInt32 ();  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (reader.ReadInt32 ());  	bytesToRead -= 4 * (1 + 1 + degree);  	returned += degree;  	if (returned > threshold + 1000000) {  		Console.WriteLine ("{1}\tRead {0}"' returned' System.DateTime.Now);  		threshold += 1000000;  	}  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0 && returned < limit) {  	var vertex = reader.ReadInt32 ();  	var degree = reader.ReadInt32 ();  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (reader.ReadInt32 ());  	bytesToRead -= 4 * (1 + 1 + degree);  	returned += degree;  	if (returned > threshold + 1000000) {  		Console.WriteLine ("{1}\tRead {0}"' returned' System.DateTime.Now);  		threshold += 1000000;  	}  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= 4 * (1 + 1 + degree);  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: if (returned > threshold + 1000000) {  	Console.WriteLine ("{1}\tRead {0}"' returned' System.DateTime.Now);  	threshold += 1000000;  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: if (returned > threshold + 1000000) {  	Console.WriteLine ("{1}\tRead {0}"' returned' System.DateTime.Now);  	threshold += 1000000;  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: threshold += 1000000;  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Main,The following statement contains a magic number: using (var controller = NewController.FromArgs (ref args)) {  	Console.WriteLine ("{0}\tController constructed"' stopwatch.Elapsed);  	InterGraphDataSink<Pair<int' int>> graph;  	var useAzure = false;  	if (useAzure) {  		var container = args [0];  		var prefix = args [1];  		#if false  		                                 graph = controller.NewAzureInterGraphStream(container' prefix' stream => stream.Select(x => x.ParseString()));                     #else  		#if true  		graph = controller.NewNaiadAzureInterGraphStream<Pair<Int32' Int32>> (container' prefix);  		#else  		                    using (var computation = controller.NewComputation())                     {                         //controller.SetConsoleOut(computation.DefaultBlobContainer("naiad-output")' "output-{0}.txt");                         //controller.SetConsoleError(computation.DefaultBlobContainer("naiad-output")' "error-{0}.txt");                          var graphContainer = computation.DefaultBlobContainer(container);                          var data = computation.ReadFromAzureBlobs(graphContainer' prefix' stream => ReadEdges(stream' Int32.MaxValue))                                               //.Where(x => x.First != x.Second)                                               //.Select(x => x.First < x.Second ? x : x.Second.PairWith(x.First))                                               //.Distinct()                                               .WriteBinaryToAzureBlobs(graphContainer' "twitter-oriented/part-{0:000}-{1:000}.bin");                          computation.Activate();                         computation.Join();                     }                      controller.Join();                      return; #endif  		#endif  	}  	else {  		var format = args [0];  		var parts = Int32.Parse (args [1]);  		graph = controller.NewInterGraphStream (Enumerable.Range (0' parts)' stream => stream.Distinct ().SelectMany (x => string.Format (format' x).ReadEdges ()));  	}  	Console.WriteLine ("{0} Graph data loaded."' stopwatch.Elapsed);  	// normalize the graph to remove self-loops' point from smaller id to larger' and remove duplicates.  	#if true  	graph = controller.NewInterGraphStream (graph' edges => edges.Where (x => x.First != x.Second).Select (x => x.First < x.Second ? x : x.Second.PairWith (x.First))//.GroupBy(x => true' (k' l) => l.RandomlyRename())  	.Distinct ());  	#endif  	// symmetrize the graph' just because...  	// graph = controller.NewInterGraphStream(graph' edges => edges.Select(x => x.Second.PairWith(x.First)).Concat(edges));  	Console.WriteLine ("{0} Graph data normalized"' stopwatch.Elapsed);  	// re-orient graph edges from lower undirected degree to larger undirected degree.  	// graph = controller.NewInterGraphStream(graph' edges => edges.GroupBy(x => true' (k'l) => l.RenameByDegree()));  	// graph = controller.NewInterGraphStream(graph' edges => edges.OrientFromLowToHighDegree());  	Console.WriteLine ("{0} Graph data oriented from low to high degree"' stopwatch.Elapsed);  	// we build two indices' one keyed on "no" attributes and one keyed on the first.  	var emptyKeyIndex = graph.ToEmptyIndex (controller' x => x.First);  	var denseKeyIndex = graph.ToDenseKeyIndex (controller' x => x.First' x => x.Second);  	graph.Seal ();  	// perhaps release the memory associated with graph. probably better to make it disposable.  	Console.WriteLine ("{0} Relation prefix indices built"' stopwatch.Elapsed);  	Console.WriteLine ("{0} Starting query construction"' stopwatch.Elapsed);  	using (var computation = controller.NewComputation ()) {  		// we seed the computation with a single "true" record.  		var queryseed = new BatchedDataSource<bool> ();  		var triangles = computation.NewInput (queryseed).Distinct ().Triangles (emptyKeyIndex' denseKeyIndex);  		// optional things to comment/uncomment' based on what sort of output we would like to see.  		// triangles.Where(x => false).Subscribe();  		// triangles.Expand().Where(x => { Console.WriteLine("{0} Triangle observed: {1}"' stopwatch.Elapsed' x); return true; });  		triangles.Select (x => x.Second.Length).Aggregate (x => true' y => y' (x' y) => x + y' (k' sum) => sum' true).Subscribe (x =>  {  			foreach (var y in x)  				Console.WriteLine ("Triangles: {0}"' y);  		});  		queryseed.OnNext ();  		computation.Activate ();  		computation.Sync (0);  		Console.WriteLine ("{0} Synchronized"' stopwatch.Elapsed);  		System.Threading.Thread.Sleep (1000);  		Console.WriteLine ("{0} Starting query execution"' stopwatch.Elapsed);  		queryseed.OnCompleted (true);  		computation.Join ();  	}  	controller.Join ();  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Main,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	// we seed the computation with a single "true" record.  	var queryseed = new BatchedDataSource<bool> ();  	var triangles = computation.NewInput (queryseed).Distinct ().Triangles (emptyKeyIndex' denseKeyIndex);  	// optional things to comment/uncomment' based on what sort of output we would like to see.  	// triangles.Where(x => false).Subscribe();  	// triangles.Expand().Where(x => { Console.WriteLine("{0} Triangle observed: {1}"' stopwatch.Elapsed' x); return true; });  	triangles.Select (x => x.Second.Length).Aggregate (x => true' y => y' (x' y) => x + y' (k' sum) => sum' true).Subscribe (x =>  {  		foreach (var y in x)  			Console.WriteLine ("Triangles: {0}"' y);  	});  	queryseed.OnNext ();  	computation.Activate ();  	computation.Sync (0);  	Console.WriteLine ("{0} Synchronized"' stopwatch.Elapsed);  	System.Threading.Thread.Sleep (1000);  	Console.WriteLine ("{0} Starting query execution"' stopwatch.Elapsed);  	queryseed.OnCompleted (true);  	computation.Join ();  }  
Magic Number,Algorithm3,Program,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,Main,The following statement contains a magic number: System.Threading.Thread.Sleep (1000);  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = System.IO.File.OpenRead (filename)) {  	var bytesToRead = reader.Length;  	while (bytesToRead > 0) {  		// read vertex name and degree  		bytesToRead -= reader.Read (bytes' 0' 8);  		Buffer.BlockCopy (bytes' 0' ints' 0' 8);  		var vertex = ints [0];  		var degree = ints [1];  		if (ints.Length < degree) {  			ints = new int[Math.Max (degree' ints.Length * 2)];  			bytes = new byte[4 * ints.Length];  		}  		// read names of neighbors  		bytesToRead -= reader.Read (bytes' 0' 4 * degree);  		Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (ints [i]);  	}  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = System.IO.File.OpenRead (filename)) {  	var bytesToRead = reader.Length;  	while (bytesToRead > 0) {  		// read vertex name and degree  		bytesToRead -= reader.Read (bytes' 0' 8);  		Buffer.BlockCopy (bytes' 0' ints' 0' 8);  		var vertex = ints [0];  		var degree = ints [1];  		if (ints.Length < degree) {  			ints = new int[Math.Max (degree' ints.Length * 2)];  			bytes = new byte[4 * ints.Length];  		}  		// read names of neighbors  		bytesToRead -= reader.Read (bytes' 0' 4 * degree);  		Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (ints [i]);  	}  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = System.IO.File.OpenRead (filename)) {  	var bytesToRead = reader.Length;  	while (bytesToRead > 0) {  		// read vertex name and degree  		bytesToRead -= reader.Read (bytes' 0' 8);  		Buffer.BlockCopy (bytes' 0' ints' 0' 8);  		var vertex = ints [0];  		var degree = ints [1];  		if (ints.Length < degree) {  			ints = new int[Math.Max (degree' ints.Length * 2)];  			bytes = new byte[4 * ints.Length];  		}  		// read names of neighbors  		bytesToRead -= reader.Read (bytes' 0' 4 * degree);  		Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (ints [i]);  	}  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = System.IO.File.OpenRead (filename)) {  	var bytesToRead = reader.Length;  	while (bytesToRead > 0) {  		// read vertex name and degree  		bytesToRead -= reader.Read (bytes' 0' 8);  		Buffer.BlockCopy (bytes' 0' ints' 0' 8);  		var vertex = ints [0];  		var degree = ints [1];  		if (ints.Length < degree) {  			ints = new int[Math.Max (degree' ints.Length * 2)];  			bytes = new byte[4 * ints.Length];  		}  		// read names of neighbors  		bytesToRead -= reader.Read (bytes' 0' 4 * degree);  		Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (ints [i]);  	}  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = System.IO.File.OpenRead (filename)) {  	var bytesToRead = reader.Length;  	while (bytesToRead > 0) {  		// read vertex name and degree  		bytesToRead -= reader.Read (bytes' 0' 8);  		Buffer.BlockCopy (bytes' 0' ints' 0' 8);  		var vertex = ints [0];  		var degree = ints [1];  		if (ints.Length < degree) {  			ints = new int[Math.Max (degree' ints.Length * 2)];  			bytes = new byte[4 * ints.Length];  		}  		// read names of neighbors  		bytesToRead -= reader.Read (bytes' 0' 4 * degree);  		Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (ints [i]);  	}  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: using (var reader = System.IO.File.OpenRead (filename)) {  	var bytesToRead = reader.Length;  	while (bytesToRead > 0) {  		// read vertex name and degree  		bytesToRead -= reader.Read (bytes' 0' 8);  		Buffer.BlockCopy (bytes' 0' ints' 0' 8);  		var vertex = ints [0];  		var degree = ints [1];  		if (ints.Length < degree) {  			ints = new int[Math.Max (degree' ints.Length * 2)];  			bytes = new byte[4 * ints.Length];  		}  		// read names of neighbors  		bytesToRead -= reader.Read (bytes' 0' 4 * degree);  		Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  		for (int i = 0; i < degree; i++)  			yield return vertex.PairWith (ints [i]);  	}  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// read vertex name and degree  	bytesToRead -= reader.Read (bytes' 0' 8);  	Buffer.BlockCopy (bytes' 0' ints' 0' 8);  	var vertex = ints [0];  	var degree = ints [1];  	if (ints.Length < degree) {  		ints = new int[Math.Max (degree' ints.Length * 2)];  		bytes = new byte[4 * ints.Length];  	}  	// read names of neighbors  	bytesToRead -= reader.Read (bytes' 0' 4 * degree);  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (ints [i]);  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// read vertex name and degree  	bytesToRead -= reader.Read (bytes' 0' 8);  	Buffer.BlockCopy (bytes' 0' ints' 0' 8);  	var vertex = ints [0];  	var degree = ints [1];  	if (ints.Length < degree) {  		ints = new int[Math.Max (degree' ints.Length * 2)];  		bytes = new byte[4 * ints.Length];  	}  	// read names of neighbors  	bytesToRead -= reader.Read (bytes' 0' 4 * degree);  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (ints [i]);  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// read vertex name and degree  	bytesToRead -= reader.Read (bytes' 0' 8);  	Buffer.BlockCopy (bytes' 0' ints' 0' 8);  	var vertex = ints [0];  	var degree = ints [1];  	if (ints.Length < degree) {  		ints = new int[Math.Max (degree' ints.Length * 2)];  		bytes = new byte[4 * ints.Length];  	}  	// read names of neighbors  	bytesToRead -= reader.Read (bytes' 0' 4 * degree);  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (ints [i]);  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// read vertex name and degree  	bytesToRead -= reader.Read (bytes' 0' 8);  	Buffer.BlockCopy (bytes' 0' ints' 0' 8);  	var vertex = ints [0];  	var degree = ints [1];  	if (ints.Length < degree) {  		ints = new int[Math.Max (degree' ints.Length * 2)];  		bytes = new byte[4 * ints.Length];  	}  	// read names of neighbors  	bytesToRead -= reader.Read (bytes' 0' 4 * degree);  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (ints [i]);  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// read vertex name and degree  	bytesToRead -= reader.Read (bytes' 0' 8);  	Buffer.BlockCopy (bytes' 0' ints' 0' 8);  	var vertex = ints [0];  	var degree = ints [1];  	if (ints.Length < degree) {  		ints = new int[Math.Max (degree' ints.Length * 2)];  		bytes = new byte[4 * ints.Length];  	}  	// read names of neighbors  	bytesToRead -= reader.Read (bytes' 0' 4 * degree);  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (ints [i]);  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// read vertex name and degree  	bytesToRead -= reader.Read (bytes' 0' 8);  	Buffer.BlockCopy (bytes' 0' ints' 0' 8);  	var vertex = ints [0];  	var degree = ints [1];  	if (ints.Length < degree) {  		ints = new int[Math.Max (degree' ints.Length * 2)];  		bytes = new byte[4 * ints.Length];  	}  	// read names of neighbors  	bytesToRead -= reader.Read (bytes' 0' 4 * degree);  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  	for (int i = 0; i < degree; i++)  		yield return vertex.PairWith (ints [i]);  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= reader.Read (bytes' 0' 8);  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy (bytes' 0' ints' 0' 8);  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: if (ints.Length < degree) {  	ints = new int[Math.Max (degree' ints.Length * 2)];  	bytes = new byte[4 * ints.Length];  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: if (ints.Length < degree) {  	ints = new int[Math.Max (degree' ints.Length * 2)];  	bytes = new byte[4 * ints.Length];  }  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: ints = new int[Math.Max (degree' ints.Length * 2)];  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: bytes = new byte[4 * ints.Length];  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= reader.Read (bytes' 0' 4 * degree);  
Magic Number,Algorithm3,ExtensionMethods,C:\repos\MicrosoftResearch_NaiadSamples\Join\Algorithm3\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy (bytes' 0' ints' 0' 4 * degree);  
