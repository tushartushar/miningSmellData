Implementation smell,Namespace,Class,File,Method,Description
Long Method,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The method has 136 lines of code.
Long Method,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The method has 247 lines of code.
Long Method,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The method has 147 lines of code.
Long Method,COST,UnionFindVertexPacked,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The method has 105 lines of code.
Long Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The method has 287 lines of code.
Long Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method has 457 lines of code.
Complex Method,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,Cyclomatic complexity of the method is 11
Complex Method,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,Cyclomatic complexity of the method is 14
Complex Method,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,Cyclomatic complexity of the method is 10
Complex Method,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,Cyclomatic complexity of the method is 15
Complex Method,COST,GroupEdgeVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,Cyclomatic complexity of the method is 10
Complex Method,COST,UnionFindVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,Cyclomatic complexity of the method is 10
Complex Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,Cyclomatic complexity of the method is 24
Complex Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,Cyclomatic complexity of the method is 11
Long Parameter List,COST,BufferTrie<TValue>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\BufferTrie.cs,InsertAt,The method has 5 parameters. Parameters: sourceArray' sourceOffset' sourceCount' targetPosition' targetHeight
Long Parameter List,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The method has 5 parameters. Parameters: logn' x' y' rotated' flipped
Long Parameter List,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,rot,The method has 5 parameters. Parameters: logs' x' y' rx' ry
Long Parameter List,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The method has 5 parameters. Parameters: edges' high32Stream' next16Stream' next08Stream' last08Stream
Long Parameter List,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindVertexInts,The method has 5 parameters. Parameters: index' stage' nodes' graphPartsIn' graphPartsOut
Long Parameter List,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindVertexHashTable,The method has 5 parameters. Parameters: index' stage' nodes' graphPartsIn' graphPartsOut
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStepFromDisk,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankFromDisk,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Statement,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The length of the statement  "                    next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]); " is 137.
Long Statement,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The length of the statement  "                    next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]); " is 135.
Long Statement,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The length of the statement  "                for (var read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20)) " is 138.
Long Statement,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The length of the statement  "                for (var read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20)) " is 134.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesHierarchyPerProcess,The length of the statement  "                .NewUnaryStage((i' s) => new GroupEdgeVertex(i' s' localParts * globalParts' localParts * globalParts)' null' null' "GroupEdges"); " is 130.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindStruct,The length of the statement  "            return edges.NewUnaryStage((i' s) => new UnionFindVertexInts(i' s' nodes' graphPartsIn' graphPartsOut)' null' null' "UnionFind"); " is 129.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindHashTable,The length of the statement  "            return edges.NewUnaryStage((i' s) => new UnionFindVertexHashTable(i' s' nodes' graphPartsIn' graphPartsOut)' null' null' "UnionFind"); " is 134.
Long Statement,COST,GroupEdgeVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The length of the statement  "                    // the .Net array growing code throws an exception since it tries to hit 2^31 entries' so explictly allocate an array smaller " is 125.
Long Statement,COST,GroupEdgeVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The length of the statement  "                Console.WriteLine("Worker " + this.VertexId + " part " + (fetched[0].source % sourceParts) + "'" + (fetched[0].target % targetParts) + " " + part); " is 147.
Long Statement,COST,UnionFindVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The length of the statement  "                Console.WriteLine("Worker[{2}]: UnionedFound {1} edges in {0} {3} groups {4} payload"' this.stopwatch.Elapsed' edges' this.VertexId' groups' payloads); " is 151.
Long Statement,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The length of the statement  "                    batchStruct.destination = this.sourcePart % this.graphPartsOut + this.graphPartsOut * (this.targetPart % this.graphPartsOut); " is 125.
Long Statement,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The length of the statement  "                    batchStruct.destination = this.sourcePart % this.graphPartsOut + this.graphPartsOut * (this.targetPart % this.graphPartsOut); " is 125.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,WriteBinaryToFiles,The length of the statement  "            return source.WriteToFiles(format' stream => Microsoft.Research.Naiad.Frameworks.Storage.Utils.GetNaiadWriterObserver<TRecord>(stream' source.ForStage.Computation.Controller.SerializationFormat)); " is 196.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                    computation.OnFrontierChange += (x' y) => { Console.WriteLine(System.DateTime.Now + "\t" + string.Join("' "' y.NewFrontier)); System.GC.GetTotalMemory(true); }; " is 160.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                    computation.OnFrontierChange += (x' y) => { Console.WriteLine(System.DateTime.Now + "\t" + string.Join("' "' y.NewFrontier)); }; " is 128.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase))) " is 134.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                                            .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))) " is 151.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase))) " is 134.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                                            .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))) " is 151.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase))) " is 134.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                                            .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))) " is 151.
Long Statement,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The length of the statement  "            Console.WriteLine("{2}\tRead header of {0} blocks' for {1} edges"' metadata.Length / 3' edges.Length' stopwatch.Elapsed); " is 121.
Long Statement,COST,SequentialWriter<T>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Write,The length of the statement  "                results[(currentIO % results.Length)] = target.BeginWrite(buffer' bufferSize * (currentIO % results.Length)' bufferSize' null' null); " is 133.
Long Statement,COST,SequentialReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Read,The length of the statement  "                    Buffer.BlockCopy(this.buffer' (int)(this.position % this.buffer.Length)' dest' typeSize * (offset + copied)' typeSize * toCopy); " is 128.
Long Statement,COST,SequentialReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Read,The length of the statement  "                            results[nextReadPosition / this.requestLength] = source.BeginRead(this.buffer' nextReadPosition' this.requestLength' null' null); " is 129.
Magic Number,COST,BufferTrie<TValue>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\BufferTrie.cs,InsertAt,The following statement contains a magic number: if (targetHeight < this.Height)              {                  var inserted = 0;                  while (inserted < sourceCount)                  {                      var maxBatchSize = this.BufferLength / 8;                        var available = Math.Min(sourceCount - inserted' maxBatchSize);                        var offset = (targetPosition << this.Bits) + 1;                      var shift = (this.MaxBits - this.Bits * (targetHeight + 1));                      var mask = ((1 << this.Bits) - 1);                        // move some number of records from the source array segment to partitioned buffers.                      for (int i = sourceOffset + inserted; i < sourceOffset + inserted + available; i++)                      {                          var childIndex = offset + ((sourceArray[i].Index >> shift) & mask);                          this.Buffer[this.ChildOffsets[childIndex]++] = sourceArray[i];                      }                        inserted += available;                        // test buffers to see if they lack space.                      for (int i = 0; i < (1 << this.Bits); i++)                      {                          var childIndex = (targetPosition << this.Bits) + i + 1;                          var childCount = this.ChildOffsets[childIndex] - (this.BufferLength * childIndex);                            if (childCount + maxBatchSize >= this.BufferLength)                          {                              this.InsertAt(this.Buffer' this.BufferLength * childIndex' childCount' childIndex' targetHeight + 1);                              this.ChildOffsets[childIndex] -= childCount;                          }                      }                  }              }              else                  this.Action(sourceArray' sourceOffset' sourceCount);
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2d,The following statement contains a magic number: for (var logs = logn - 1; logs >= 0; logs--)              {                  int rx = (x >> logs) & 1;                  int ry = (y >> logs) & 1;                    // map (0'0)' (0'1)' (1'0)' (1'1) to 00' 01' 10' 11.                  d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);                  rot(logs' ref x' ref y' rx' ry);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2d,The following statement contains a magic number: for (var logs = logn - 1; logs >= 0; logs--)              {                  int rx = (x >> logs) & 1;                  int ry = (y >> logs) & 1;                    // map (0'0)' (0'1)' (1'0)' (1'1) to 00' 01' 10' 11.                  d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);                  rot(logs' ref x' ref y' rx' ry);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The following statement contains a magic number: for (var logs = logn - 1; logs >= 0; logs--)              {                  uint rx = (x >> logs) & 1;                  uint ry = (y >> logs) & 1;                    if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 1 - rx;                      ry = 1 - ry;                  }                    // map (0'0)' (0'1)' (1'0)' (1'1) to 00' 01' 10' 11.                  d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);                    if (ry == 0)                  {                      if (rx == 1)                          rotated = !rotated;                        flipped = !flipped;                  }                    // rot(logs' ref x' ref y' rx' ry);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The following statement contains a magic number: for (var logs = logn - 1; logs >= 0; logs--)              {                  uint rx = (x >> logs) & 1;                  uint ry = (y >> logs) & 1;                    if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 1 - rx;                      ry = 1 - ry;                  }                    // map (0'0)' (0'1)' (1'0)' (1'1) to 00' 01' 10' 11.                  d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);                    if (ry == 0)                  {                      if (rx == 1)                          rotated = !rotated;                        flipped = !flipped;                  }                    // rot(logs' ref x' ref y' rx' ry);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: for (var logs = 3; logs >= 0; logs--)              {                  // read out relevant bytes                  var rx = (byte)(x >> (8 * logs)) & 0xFF;                  var ry = (byte)(y >> (8 * logs)) & 0xFF;                    // flip and rotate bytes' if needed                  if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    // update flipped and rotated                  flipped = flipped ^ Flipped[rx][ry];                  rotated = rotated ^ Rotated[rx][ry];                    // look up the transform of these bytes                  var result = (UInt64)Transformed[rx][ry];                    d += result << (16 * logs);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: for (var logs = 3; logs >= 0; logs--)              {                  // read out relevant bytes                  var rx = (byte)(x >> (8 * logs)) & 0xFF;                  var ry = (byte)(y >> (8 * logs)) & 0xFF;                    // flip and rotate bytes' if needed                  if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    // update flipped and rotated                  flipped = flipped ^ Flipped[rx][ry];                  rotated = rotated ^ Rotated[rx][ry];                    // look up the transform of these bytes                  var result = (UInt64)Transformed[rx][ry];                    d += result << (16 * logs);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: for (var logs = 3; logs >= 0; logs--)              {                  // read out relevant bytes                  var rx = (byte)(x >> (8 * logs)) & 0xFF;                  var ry = (byte)(y >> (8 * logs)) & 0xFF;                    // flip and rotate bytes' if needed                  if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    // update flipped and rotated                  flipped = flipped ^ Flipped[rx][ry];                  rotated = rotated ^ Rotated[rx][ry];                    // look up the transform of these bytes                  var result = (UInt64)Transformed[rx][ry];                    d += result << (16 * logs);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: for (var logs = 3; logs >= 0; logs--)              {                  // read out relevant bytes                  var rx = (byte)(x >> (8 * logs)) & 0xFF;                  var ry = (byte)(y >> (8 * logs)) & 0xFF;                    // flip and rotate bytes' if needed                  if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    // update flipped and rotated                  flipped = flipped ^ Flipped[rx][ry];                  rotated = rotated ^ Rotated[rx][ry];                    // look up the transform of these bytes                  var result = (UInt64)Transformed[rx][ry];                    d += result << (16 * logs);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xy,The following statement contains a magic number: for (logs = 0; logs < logn; logs++)              {                  var rx = (int)(t >> 1) & 1;                  var ry = (int)(t ^ rx) & 1;                    rot(logs' ref x' ref y' rx' ry);                    x += rx << logs;                  y += ry << logs;                    t /= 4;              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--)              {                  var trans = (d >> (logs * 16)) & 0xFFFF;                    uint rx = Inverted[2 * trans + 0];                  uint ry = Inverted[2 * trans + 1];                    var flippedUpdate = Flipped[rx][ry];                  var rotatedUpdate = Rotated[rx][ry];                    if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    flipped = flipped ^ flippedUpdate;                  rotated = rotated ^ rotatedUpdate;                    x = (x << 8) + rx;                  y = (y << 8) + ry;              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--)              {                  var trans = (d >> (logs * 16)) & 0xFFFF;                    uint rx = Inverted[2 * trans + 0];                  uint ry = Inverted[2 * trans + 1];                    var flippedUpdate = Flipped[rx][ry];                  var rotatedUpdate = Rotated[rx][ry];                    if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    flipped = flipped ^ flippedUpdate;                  rotated = rotated ^ rotatedUpdate;                    x = (x << 8) + rx;                  y = (y << 8) + ry;              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--)              {                  var trans = (d >> (logs * 16)) & 0xFFFF;                    uint rx = Inverted[2 * trans + 0];                  uint ry = Inverted[2 * trans + 1];                    var flippedUpdate = Flipped[rx][ry];                  var rotatedUpdate = Rotated[rx][ry];                    if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    flipped = flipped ^ flippedUpdate;                  rotated = rotated ^ rotatedUpdate;                    x = (x << 8) + rx;                  y = (y << 8) + ry;              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--)              {                  var trans = (d >> (logs * 16)) & 0xFFFF;                    uint rx = Inverted[2 * trans + 0];                  uint ry = Inverted[2 * trans + 1];                    var flippedUpdate = Flipped[rx][ry];                  var rotatedUpdate = Rotated[rx][ry];                    if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    flipped = flipped ^ flippedUpdate;                  rotated = rotated ^ rotatedUpdate;                    x = (x << 8) + rx;                  y = (y << 8) + ry;              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--)              {                  var trans = (d >> (logs * 16)) & 0xFFFF;                    uint rx = Inverted[2 * trans + 0];                  uint ry = Inverted[2 * trans + 1];                    var flippedUpdate = Flipped[rx][ry];                  var rotatedUpdate = Rotated[rx][ry];                    if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    flipped = flipped ^ flippedUpdate;                  rotated = rotated ^ rotatedUpdate;                    x = (x << 8) + rx;                  y = (y << 8) + ry;              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--)              {                  var trans = (d >> (logs * 16)) & 0xFFFF;                    uint rx = Inverted[2 * trans + 0];                  uint ry = Inverted[2 * trans + 1];                    var flippedUpdate = Flipped[rx][ry];                  var rotatedUpdate = Rotated[rx][ry];                    if (flipped)                  {                      var t = rx;                      rx = ry;                      ry = t;                  }                    if (rotated)                  {                      rx = 0xFF - rx;                      ry = 0xFF - ry;                  }                    flipped = flipped ^ flippedUpdate;                  rotated = rotated ^ rotatedUpdate;                    x = (x << 8) + rx;                  y = (y << 8) + ry;              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: for (int i = 0; i < tests; i++)                  results1[i] = HilbertCurve.xy2d(32' (int)testxs[i]' (int)testys[i]);
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine("Slow encode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: for (int i = 0; i < tests; i++)              {                  int x = 0' y = 0;                  HilbertCurve.d2xy(32' results1[i]' out x' out y);              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine("Slow decode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine("Fast encode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine("Fast decode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Rotated = new bool[256][];
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Flipped = new bool[256][];
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Transformed = new ushort[256][];
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  Rotated[i] = new bool[256];                  Flipped[i] = new bool[256];                  Transformed[i] = new ushort[256];                    for (uint j = 0; j < 256; j++)                  {                      var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);                        Transformed[i][j] = transform;                      Inverted[2 * transform + 0] = (byte)i;                      Inverted[2 * transform + 1] = (byte)j;                  }              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  Rotated[i] = new bool[256];                  Flipped[i] = new bool[256];                  Transformed[i] = new ushort[256];                    for (uint j = 0; j < 256; j++)                  {                      var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);                        Transformed[i][j] = transform;                      Inverted[2 * transform + 0] = (byte)i;                      Inverted[2 * transform + 1] = (byte)j;                  }              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  Rotated[i] = new bool[256];                  Flipped[i] = new bool[256];                  Transformed[i] = new ushort[256];                    for (uint j = 0; j < 256; j++)                  {                      var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);                        Transformed[i][j] = transform;                      Inverted[2 * transform + 0] = (byte)i;                      Inverted[2 * transform + 1] = (byte)j;                  }              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  Rotated[i] = new bool[256];                  Flipped[i] = new bool[256];                  Transformed[i] = new ushort[256];                    for (uint j = 0; j < 256; j++)                  {                      var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);                        Transformed[i][j] = transform;                      Inverted[2 * transform + 0] = (byte)i;                      Inverted[2 * transform + 1] = (byte)j;                  }              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  Rotated[i] = new bool[256];                  Flipped[i] = new bool[256];                  Transformed[i] = new ushort[256];                    for (uint j = 0; j < 256; j++)                  {                      var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);                        Transformed[i][j] = transform;                      Inverted[2 * transform + 0] = (byte)i;                      Inverted[2 * transform + 1] = (byte)j;                  }              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  Rotated[i] = new bool[256];                  Flipped[i] = new bool[256];                  Transformed[i] = new ushort[256];                    for (uint j = 0; j < 256; j++)                  {                      var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);                        Transformed[i][j] = transform;                      Inverted[2 * transform + 0] = (byte)i;                      Inverted[2 * transform + 1] = (byte)j;                  }              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  Rotated[i] = new bool[256];                  Flipped[i] = new bool[256];                  Transformed[i] = new ushort[256];                    for (uint j = 0; j < 256; j++)                  {                      var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);                        Transformed[i][j] = transform;                      Inverted[2 * transform + 0] = (byte)i;                      Inverted[2 * transform + 1] = (byte)j;                  }              }
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  Rotated[i] = new bool[256];                  Flipped[i] = new bool[256];                  Transformed[i] = new ushort[256];                    for (uint j = 0; j < 256; j++)                  {                      var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);                        Transformed[i][j] = transform;                      Inverted[2 * transform + 0] = (byte)i;                      Inverted[2 * transform + 1] = (byte)j;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: this.last08ToRead = new int[high32Buffer.Length / 2];
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader(prefix + "-last08"))              {                  for (int i = 0; i < high32Buffer.Length; i += 2)                  {                      var high32value = high32Buffer[i];                      var high32count = (int)high32Buffer[i + 1];                        var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                      if (readLast08 != last08ToRead[i / 2])                          Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                        var last08Offset = 0;                        // do work for all these dudes                      var xHigh32 = (high32value & 0xFFFF0000) << 0;                      var yHigh32 = (high32value & 0x0000FFFF) << 16;                        for (int j = 0; j < high32count; j++)                      {                          var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                          var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                            var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];                          if (next16count == 0)                              next16count = ((int)ushort.MaxValue) + 1;                            for (int k = 0; k < next16count; k++)                          {                              var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                              var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                                var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];                              if (next08count == 0)                                  next08count = ((int)byte.MaxValue) + 1;                                perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                                last08Offset += next08count;                          }                            next08Offset += 2 * next16count;                      }                        next16Offset += 2 * high32count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach((vertex' degree' offset' neighbors) =>              {                  //if (vertex < 1000000)                  {                      for (int i = 0; i < degree; i++)                      {                          var neighbor = neighbors[offset + i];                          var high32 = (uint)(HilbertCurve.xy2dByte((uint)vertex' (uint)neighbor) >> 32);                            if (!High32.ContainsKey(high32))                              High32.Add(high32' 0);                            High32[high32] = High32[high32] + 1;                      }                  }              });
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (uint i = 0; i < pairs.Length; i++)              {                  // if we would have too many edges' do work                  if (edgeCount + pairs[i].Value > 1 << 29)                  {                      var edges = new ulong[edgeCount];                      var cursor = 0;                        graph.ForEach((vertex' degree' offset' neighbors) =>                      {                          //if (vertex < 1000000)                          {                              for (int j = 0; j < degree; j++)                              {                                  var transform = HilbertCurve.xy2dByte((uint)vertex' (uint)neighbors[offset + j]);                                  if ((transform >> 32) >= pairs[lowIndex].Key && (transform >> 32) < pairs[i].Key)                                      edges[cursor++] = transform;                              }                          }                      });                        if (cursor != edges.Length)                          Console.WriteLine("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);                        Array.Sort(edges);                        Console.WriteLine("About to process {0} high32 blocks"' i - lowIndex);                        // traverse edges in order and write out when interesting things happen.                      WriteTransformed(edges' high32Stream' next16Stream' next08Stream' last08Stream);                        edgeCount = 0;                      lowIndex = i;                  }                    edgeCount += pairs[i].Value;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (uint i = 0; i < pairs.Length; i++)              {                  // if we would have too many edges' do work                  if (edgeCount + pairs[i].Value > 1 << 29)                  {                      var edges = new ulong[edgeCount];                      var cursor = 0;                        graph.ForEach((vertex' degree' offset' neighbors) =>                      {                          //if (vertex < 1000000)                          {                              for (int j = 0; j < degree; j++)                              {                                  var transform = HilbertCurve.xy2dByte((uint)vertex' (uint)neighbors[offset + j]);                                  if ((transform >> 32) >= pairs[lowIndex].Key && (transform >> 32) < pairs[i].Key)                                      edges[cursor++] = transform;                              }                          }                      });                        if (cursor != edges.Length)                          Console.WriteLine("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);                        Array.Sort(edges);                        Console.WriteLine("About to process {0} high32 blocks"' i - lowIndex);                        // traverse edges in order and write out when interesting things happen.                      WriteTransformed(edges' high32Stream' next16Stream' next08Stream' last08Stream);                        edgeCount = 0;                      lowIndex = i;                  }                    edgeCount += pairs[i].Value;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (uint i = 0; i < pairs.Length; i++)              {                  // if we would have too many edges' do work                  if (edgeCount + pairs[i].Value > 1 << 29)                  {                      var edges = new ulong[edgeCount];                      var cursor = 0;                        graph.ForEach((vertex' degree' offset' neighbors) =>                      {                          //if (vertex < 1000000)                          {                              for (int j = 0; j < degree; j++)                              {                                  var transform = HilbertCurve.xy2dByte((uint)vertex' (uint)neighbors[offset + j]);                                  if ((transform >> 32) >= pairs[lowIndex].Key && (transform >> 32) < pairs[i].Key)                                      edges[cursor++] = transform;                              }                          }                      });                        if (cursor != edges.Length)                          Console.WriteLine("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);                        Array.Sort(edges);                        Console.WriteLine("About to process {0} high32 blocks"' i - lowIndex);                        // traverse edges in order and write out when interesting things happen.                      WriteTransformed(edges' high32Stream' next16Stream' next08Stream' last08Stream);                        edgeCount = 0;                      lowIndex = i;                  }                    edgeCount += pairs[i].Value;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach((vertex' degree' offset' neighbors) =>              {                  //if (vertex < 1000000)                  {                      for (int j = 0; j < degree; j++)                      {                          var transform = HilbertCurve.xy2dByte((uint)vertex' (uint)neighbors[offset + j]);                            if ((transform >> 32) >= pairs[lowIndex].Key)                              edges2[cursor2++] = transform;                      }                  }              });
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var high32Prior = (uint)   ((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var next16Prior = (ushort) ((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var next08Prior = (byte)   ((x & 0x000000F0) + ((y & 0x000000F0) >> 4));
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: last08Stream.Write((byte)(((x & 0x0F) << 4) + (y & 0x0F)));
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: for (int i = 1; i < edges.Length; i++)              {                  // recover x and y' to interleave their bits                  HilbertCurve.d2xyByte(edges[i]' out x' out y);                    var high32 = (uint)   ((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));                  var next16 = (ushort) ((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));                  var next08 = (byte)   ((x & 0x000000F0) + ((y & 0x000000F0) >> 4));                    // changes in bits call for writing out                  var high32Change = high32 != high32Prior;                  var next16Change = high32Change || (next16 != next16Prior);                  var next08Change = next16Change || (next08 != next08Prior);                    // write high 32' reset high32count                  if (high32Change)                  {                      high32Stream.Write(high32Prior);                      high32Stream.Write(high32Count);                        high32Prior = high32;                      high32Count = 0;                  }                    // write next 16' reset nex16count' bump high32count                  if (next16Change)                  {                      next16Stream.Write(next16Prior);                      next16Stream.Write((ushort)next16Count);                      high32Count++;                        next16Prior = next16;                      next16Count = 0;                  }                                    // write next 08' reset next08count' bump next16count                  if (next08Change)                  {                      next08Stream.Write(next08Prior);                      next08Stream.Write((byte) next08Count);                      next16Count++;                        next08Prior = next08;                      next08Count = 0;                  }                      // always write the last byte' bump next08count                  last08Stream.Write((byte)(((x & 0x0F) << 4) + (y & 0x0F)));                  next08Count++;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: for (int i = 1; i < edges.Length; i++)              {                  // recover x and y' to interleave their bits                  HilbertCurve.d2xyByte(edges[i]' out x' out y);                    var high32 = (uint)   ((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));                  var next16 = (ushort) ((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));                  var next08 = (byte)   ((x & 0x000000F0) + ((y & 0x000000F0) >> 4));                    // changes in bits call for writing out                  var high32Change = high32 != high32Prior;                  var next16Change = high32Change || (next16 != next16Prior);                  var next08Change = next16Change || (next08 != next08Prior);                    // write high 32' reset high32count                  if (high32Change)                  {                      high32Stream.Write(high32Prior);                      high32Stream.Write(high32Count);                        high32Prior = high32;                      high32Count = 0;                  }                    // write next 16' reset nex16count' bump high32count                  if (next16Change)                  {                      next16Stream.Write(next16Prior);                      next16Stream.Write((ushort)next16Count);                      high32Count++;                        next16Prior = next16;                      next16Count = 0;                  }                                    // write next 08' reset next08count' bump next16count                  if (next08Change)                  {                      next08Stream.Write(next08Prior);                      next08Stream.Write((byte) next08Count);                      next16Count++;                        next08Prior = next08;                      next08Count = 0;                  }                      // always write the last byte' bump next08count                  last08Stream.Write((byte)(((x & 0x0F) << 4) + (y & 0x0F)));                  next08Count++;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: for (int i = 1; i < edges.Length; i++)              {                  // recover x and y' to interleave their bits                  HilbertCurve.d2xyByte(edges[i]' out x' out y);                    var high32 = (uint)   ((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));                  var next16 = (ushort) ((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));                  var next08 = (byte)   ((x & 0x000000F0) + ((y & 0x000000F0) >> 4));                    // changes in bits call for writing out                  var high32Change = high32 != high32Prior;                  var next16Change = high32Change || (next16 != next16Prior);                  var next08Change = next16Change || (next08 != next08Prior);                    // write high 32' reset high32count                  if (high32Change)                  {                      high32Stream.Write(high32Prior);                      high32Stream.Write(high32Count);                        high32Prior = high32;                      high32Count = 0;                  }                    // write next 16' reset nex16count' bump high32count                  if (next16Change)                  {                      next16Stream.Write(next16Prior);                      next16Stream.Write((ushort)next16Count);                      high32Count++;                        next16Prior = next16;                      next16Count = 0;                  }                                    // write next 08' reset next08count' bump next16count                  if (next08Change)                  {                      next08Stream.Write(next08Prior);                      next08Stream.Write((byte) next08Count);                      next16Count++;                        next08Prior = next08;                      next08Count = 0;                  }                      // always write the last byte' bump next08count                  last08Stream.Write((byte)(((x & 0x0F) << 4) + (y & 0x0F)));                  next08Count++;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: for (int i = 1; i < edges.Length; i++)              {                  // recover x and y' to interleave their bits                  HilbertCurve.d2xyByte(edges[i]' out x' out y);                    var high32 = (uint)   ((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));                  var next16 = (ushort) ((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));                  var next08 = (byte)   ((x & 0x000000F0) + ((y & 0x000000F0) >> 4));                    // changes in bits call for writing out                  var high32Change = high32 != high32Prior;                  var next16Change = high32Change || (next16 != next16Prior);                  var next08Change = next16Change || (next08 != next08Prior);                    // write high 32' reset high32count                  if (high32Change)                  {                      high32Stream.Write(high32Prior);                      high32Stream.Write(high32Count);                        high32Prior = high32;                      high32Count = 0;                  }                    // write next 16' reset nex16count' bump high32count                  if (next16Change)                  {                      next16Stream.Write(next16Prior);                      next16Stream.Write((ushort)next16Count);                      high32Count++;                        next16Prior = next16;                      next16Count = 0;                  }                                    // write next 08' reset next08count' bump next16count                  if (next08Change)                  {                      next08Stream.Write(next08Prior);                      next08Stream.Write((byte) next08Count);                      next16Count++;                        next08Prior = next08;                      next08Count = 0;                  }                      // always write the last byte' bump next08count                  last08Stream.Write((byte)(((x & 0x0F) << 4) + (y & 0x0F)));                  next08Count++;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int)high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                    var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var last08ToRead = new int[high32Buffer.Length / 2];
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);                    next16Offset += 2 * high32count;                    var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);                    next08Offset += 2 * next16count;                    last08ToRead[i / 2] = next08count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2)              {                  var high32value = high32Buffer[i];                  var high32count = (int)high32Buffer[i + 1];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);                  if (readLast08 != last08ToRead[i / 2])                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);                    var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            perEdgeAction(xNext08' yNext08' next08count' last08Offset' last08Buffer);                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }                    next16Offset += 2 * high32count;              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var iDegrees = new uint[106000000];
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var oDegrees = new uint[106000000];
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)              {                  var high32value = high32MetaData[i];                  var high32count = (int) high32MetaData[i + 1];                    if (next16Buffer.Length < 2 * high32count)                      next16Buffer = new ushort[2 * high32count];                    var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);                  if (readNext16 != 2 * high32count)                      Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);                      var next16count = 0;                  for (int j = 0; j < high32count; j++)                      next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);                    if (next08Buffer.Length < 2 * next16count)                      next08Buffer = new byte[2 * next16count];                    var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);                  if (readNext08 != 2 * next16count)                      Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);                      var next08count = 0;                  for (int k = 0; k < next16count; k++)                      next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);                    if (last08Buffer.Length < next08count)                      last08Buffer = new byte[next08count];                    var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' next08count);                  if (readLast08 != next08count)                      Console.WriteLine("Read error' last08; requested {0}' read {1}"' next08count' readLast08);                      var next16Offset = 0;                  var next08Offset = 0;                  var last08Offset = 0;                    // do work for all these dudes                  var xHigh32 = (high32value & 0xFFFF0000) << 0;                  var yHigh32 = (high32value & 0x0000FFFF) << 16;                    for (int j = 0; j < high32count; j++)                  {                      var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);                      var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);                        next16count = next16Buffer[next16Offset + 2 * j + 1];                      if (next16count == 0)                          next16count = ((int)ushort.MaxValue) + 1;                        for (int k = 0; k < next16count; k++)                      {                          var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);                          var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);                            next08count = next08Buffer[next08Offset + 2 * k + 1];                          if (next08count == 0)                              next08count = ((int)byte.MaxValue) + 1;                            for (int l = 0; l < next08count; l++)                          {                              var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);                              var y = yNext08 + ((last08Buffer[last08Offset + l] & 0x0F) >> 0);                                iDegrees[y]++;                              oDegrees[x]++;                                edgeCount++;                          }                            last08Offset += next08count;                      }                        next08Offset += 2 * next16count;                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)                  high32Counts += high32MetaData[i + 1];
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: Console.WriteLine("Read {0} high32' expecting {1} next16"' high32MetaData.Length / 2' high32Counts);
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: var next16Buffer = new ushort[1 << 20];
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next16Reader = new UnbufferedIO.SequentialReader(prefix + "-next16"))              {                  for (var read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20))                  {                      next16Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next16Count += next16Buffer[i + 1];                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next16Reader = new UnbufferedIO.SequentialReader(prefix + "-next16"))              {                  for (var read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20))                  {                      next16Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next16Count += next16Buffer[i + 1];                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next16Reader = new UnbufferedIO.SequentialReader(prefix + "-next16"))              {                  for (var read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20))                  {                      next16Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next16Count += next16Buffer[i + 1];                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next16Reader = new UnbufferedIO.SequentialReader(prefix + "-next16"))              {                  for (var read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20))                  {                      next16Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next16Count += next16Buffer[i + 1];                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: var next08Buffer = new byte[1 << 20];
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader(prefix + "-next08"))              {                  for (var read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20))                  {                      next08Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next08Count += next08Buffer[i + 1] == 0 ? 256 : (int) next08Buffer[i + 1];                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader(prefix + "-next08"))              {                  for (var read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20))                  {                      next08Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next08Count += next08Buffer[i + 1] == 0 ? 256 : (int) next08Buffer[i + 1];                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader(prefix + "-next08"))              {                  for (var read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20))                  {                      next08Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next08Count += next08Buffer[i + 1] == 0 ? 256 : (int) next08Buffer[i + 1];                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader(prefix + "-next08"))              {                  for (var read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20))                  {                      next08Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next08Count += next08Buffer[i + 1] == 0 ? 256 : (int) next08Buffer[i + 1];                  }              }
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader(prefix + "-next08"))              {                  for (var read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20))                  {                      next08Total += read / 2;                      for (int i = 0; i < read; i += 2)                          next08Count += next08Buffer[i + 1] == 0 ? 256 : (int) next08Buffer[i + 1];                  }              }
Magic Number,COST,GraphReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GraphReader,The following statement contains a magic number: this.sendBuffer.payload = new Edge[256];
Magic Number,COST,GraphStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int i = 0; i < message.length; i++)                  {                      SingleThreaded.ScanGraph(message.payload[i]' (vertex' degree' offset' edges) =>                      {                          var edgesSent = 0;                          while (edgesSent < degree)                          {                              // if not enough space for an edge' flush.                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                              {                                  this.Output.Send(sendBuffer);                                  sendBuffer.length = 0;                              }                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' degree - edgesSent);                                sendBuffer.payload[sendBuffer.length++] = vertex;                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                              Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                              sendBuffer.length += edgesToSend;                              edgesSent += edgesToSend;                          }                      });                  }
Magic Number,COST,GraphStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int i = 0; i < message.length; i++)                  {                      SingleThreaded.ScanGraph(message.payload[i]' (vertex' degree' offset' edges) =>                      {                          var edgesSent = 0;                          while (edgesSent < degree)                          {                              // if not enough space for an edge' flush.                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                              {                                  this.Output.Send(sendBuffer);                                  sendBuffer.length = 0;                              }                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' degree - edgesSent);                                sendBuffer.payload[sendBuffer.length++] = vertex;                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                              Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                              sendBuffer.length += edgesToSend;                              edgesSent += edgesToSend;                          }                      });                  }
Magic Number,COST,GraphStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GraphStreamReader,The following statement contains a magic number: this.sendBuffer.payload = new int[256];
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: sendBuffer.payload = new int[256];
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,VertexStreamReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int g = 0; g < message.length; g++)                  {                      var prefix = string.Format(message.payload[g]' part' parts);                        using (var nodeReader = System.IO.File.OpenRead(prefix + "-nodes"))                      {                          using (var edgeReader = System.IO.File.OpenRead(prefix + "-edges"))                          {                              var bytes = new byte[256];                              var nodes = new int[(bytes.Length / 4) + 1];                              var edges = new int[(bytes.Length / 4)];                                var vertex = part - parts;                                var nodebytesToRead = nodeReader.Length;                              while (nodebytesToRead > 0)                              {                                  // read names of neighbors' plus next vertex and degree.                                  var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));                                    nodebytesToRead -= nodebytesRead;                                  Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);                                    var edgesToRead = nodes[nodes.Length - 1] - nodes[0];                                  if (edges.Length < edgesToRead)                                  {                                      bytes = new byte[4 * edgesToRead];                                      edges = new int[edgesToRead];                                  }                                    edgeReader.Read(bytes' 0' 4 * edgesToRead);                                  Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);                                    for (int i = 0; i < nodebytesRead / 4; i++)                                  {                                      var degree = (nodes[i + 1] - nodes[i]);                                        if (degree > 0)                                      {                                          var offset = nodes[i] - nodes[0];                                            var edgesSent = 0;                                          while (edgesSent < degree)                                          {                                              // if no room for an edge' just ship it                                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                                              {                                                  this.Output.Send(sendBuffer);                                                  sendBuffer.length = 0;                                              }                                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));                                              sendBuffer.payload[sendBuffer.length++] = vertex;                                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                                                Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                                              sendBuffer.length += edgesToSend;                                                edgesSent += edgesToSend;                                          }                                      }                                        vertex += parts;                                  }                                    nodes[0] = nodes[nodes.Length - 1];                              }                          }                      }                  }
Magic Number,COST,GroupEdgeVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The following statement contains a magic number: if (this.sourceParts == 1)                  {                      // the .Net array growing code throws an exception since it tries to hit 2^31 entries' so explictly allocate an array smaller                      // than that which will fit all the edges' then copy out of it                      var preFetch = new Edge[1900000000];                      int length = 0;                      foreach (var edge in records)                      {                          preFetch[length] = edge;                          ++length;                      }                        fetched = new Edge[length];                      for (int i=0; i<fetched.Length; ++i)                      {                          fetched[i] = preFetch[i];                      }                  }                  else                  {                      fetched = records.ToArray();                  }
Magic Number,COST,GroupEdgeVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The following statement contains a magic number: for (int i = 0; i < cursors.Length; ++i)                  {                      cursors[i] = bufferLength;                      bufferLength = cursors[i] + 2 + counts[sourceIndices[i]];                  }
Magic Number,COST,GroupEdgeVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The following statement contains a magic number: for (int i = 0; i < cursors.Length; ++i)                  {                      sendBuffer[cursors[i]] = sourceIndices[i];                      sendBuffer[cursors[i] + 1] = counts[sourceIndices[i]];                      cursors[i] += 2;                  }
Magic Number,COST,ReformatVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      int bufferLength = message.payload[0].Length;                      BatchStruct batchStruct = new BatchStruct();                      int* batchBuffer = &batchStruct.i00;                      fixed (int* sendBuffer = &message.payload[0][0])                      {                          int thisMessageIndex = 0;                          int cursor = 0;                          while (cursor < bufferLength)                          {                              var source = sendBuffer[cursor];                              var edgesLeft = sendBuffer[cursor + 1];                              cursor += 2;                                while (edgesLeft > 0)                              {                                  if (thisMessageIndex > 253)                                  {                                      if (thisMessageIndex < 256)                                      {                                          batchBuffer[thisMessageIndex] = -1;                                      }                                      output.Send(batchStruct);                                      thisMessageIndex = 0;                                  }                                    var maxDegree = 254 - thisMessageIndex;                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                    batchBuffer[thisMessageIndex] = source;                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                  thisMessageIndex += 2;                                  for (int i = 0; i < thisDegree; ++i)                                  {                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                  }                                  edgesLeft -= thisDegree;                                  cursor += thisDegree;                                  thisMessageIndex += thisDegree;                              }                          }                            if (thisMessageIndex > 0)                          {                              if (thisMessageIndex < 256)                              {                                  batchBuffer[thisMessageIndex] = -1;                              }                              output.Send(batchStruct);                          }                      }                  }
Magic Number,COST,ReformatVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      int bufferLength = message.payload[0].Length;                      BatchStruct batchStruct = new BatchStruct();                      int* batchBuffer = &batchStruct.i00;                      fixed (int* sendBuffer = &message.payload[0][0])                      {                          int thisMessageIndex = 0;                          int cursor = 0;                          while (cursor < bufferLength)                          {                              var source = sendBuffer[cursor];                              var edgesLeft = sendBuffer[cursor + 1];                              cursor += 2;                                while (edgesLeft > 0)                              {                                  if (thisMessageIndex > 253)                                  {                                      if (thisMessageIndex < 256)                                      {                                          batchBuffer[thisMessageIndex] = -1;                                      }                                      output.Send(batchStruct);                                      thisMessageIndex = 0;                                  }                                    var maxDegree = 254 - thisMessageIndex;                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                    batchBuffer[thisMessageIndex] = source;                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                  thisMessageIndex += 2;                                  for (int i = 0; i < thisDegree; ++i)                                  {                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                  }                                  edgesLeft -= thisDegree;                                  cursor += thisDegree;                                  thisMessageIndex += thisDegree;                              }                          }                            if (thisMessageIndex > 0)                          {                              if (thisMessageIndex < 256)                              {                                  batchBuffer[thisMessageIndex] = -1;                              }                              output.Send(batchStruct);                          }                      }                  }
Magic Number,COST,ReformatVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      int bufferLength = message.payload[0].Length;                      BatchStruct batchStruct = new BatchStruct();                      int* batchBuffer = &batchStruct.i00;                      fixed (int* sendBuffer = &message.payload[0][0])                      {                          int thisMessageIndex = 0;                          int cursor = 0;                          while (cursor < bufferLength)                          {                              var source = sendBuffer[cursor];                              var edgesLeft = sendBuffer[cursor + 1];                              cursor += 2;                                while (edgesLeft > 0)                              {                                  if (thisMessageIndex > 253)                                  {                                      if (thisMessageIndex < 256)                                      {                                          batchBuffer[thisMessageIndex] = -1;                                      }                                      output.Send(batchStruct);                                      thisMessageIndex = 0;                                  }                                    var maxDegree = 254 - thisMessageIndex;                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                    batchBuffer[thisMessageIndex] = source;                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                  thisMessageIndex += 2;                                  for (int i = 0; i < thisDegree; ++i)                                  {                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                  }                                  edgesLeft -= thisDegree;                                  cursor += thisDegree;                                  thisMessageIndex += thisDegree;                              }                          }                            if (thisMessageIndex > 0)                          {                              if (thisMessageIndex < 256)                              {                                  batchBuffer[thisMessageIndex] = -1;                              }                              output.Send(batchStruct);                          }                      }                  }
Magic Number,COST,ReformatVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      int bufferLength = message.payload[0].Length;                      BatchStruct batchStruct = new BatchStruct();                      int* batchBuffer = &batchStruct.i00;                      fixed (int* sendBuffer = &message.payload[0][0])                      {                          int thisMessageIndex = 0;                          int cursor = 0;                          while (cursor < bufferLength)                          {                              var source = sendBuffer[cursor];                              var edgesLeft = sendBuffer[cursor + 1];                              cursor += 2;                                while (edgesLeft > 0)                              {                                  if (thisMessageIndex > 253)                                  {                                      if (thisMessageIndex < 256)                                      {                                          batchBuffer[thisMessageIndex] = -1;                                      }                                      output.Send(batchStruct);                                      thisMessageIndex = 0;                                  }                                    var maxDegree = 254 - thisMessageIndex;                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                    batchBuffer[thisMessageIndex] = source;                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                  thisMessageIndex += 2;                                  for (int i = 0; i < thisDegree; ++i)                                  {                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                  }                                  edgesLeft -= thisDegree;                                  cursor += thisDegree;                                  thisMessageIndex += thisDegree;                              }                          }                            if (thisMessageIndex > 0)                          {                              if (thisMessageIndex < 256)                              {                                  batchBuffer[thisMessageIndex] = -1;                              }                              output.Send(batchStruct);                          }                      }                  }
Magic Number,COST,ReformatVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      int bufferLength = message.payload[0].Length;                      BatchStruct batchStruct = new BatchStruct();                      int* batchBuffer = &batchStruct.i00;                      fixed (int* sendBuffer = &message.payload[0][0])                      {                          int thisMessageIndex = 0;                          int cursor = 0;                          while (cursor < bufferLength)                          {                              var source = sendBuffer[cursor];                              var edgesLeft = sendBuffer[cursor + 1];                              cursor += 2;                                while (edgesLeft > 0)                              {                                  if (thisMessageIndex > 253)                                  {                                      if (thisMessageIndex < 256)                                      {                                          batchBuffer[thisMessageIndex] = -1;                                      }                                      output.Send(batchStruct);                                      thisMessageIndex = 0;                                  }                                    var maxDegree = 254 - thisMessageIndex;                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                    batchBuffer[thisMessageIndex] = source;                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                  thisMessageIndex += 2;                                  for (int i = 0; i < thisDegree; ++i)                                  {                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                  }                                  edgesLeft -= thisDegree;                                  cursor += thisDegree;                                  thisMessageIndex += thisDegree;                              }                          }                            if (thisMessageIndex > 0)                          {                              if (thisMessageIndex < 256)                              {                                  batchBuffer[thisMessageIndex] = -1;                              }                              output.Send(batchStruct);                          }                      }                  }
Magic Number,COST,ReformatVertex,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      int bufferLength = message.payload[0].Length;                      BatchStruct batchStruct = new BatchStruct();                      int* batchBuffer = &batchStruct.i00;                      fixed (int* sendBuffer = &message.payload[0][0])                      {                          int thisMessageIndex = 0;                          int cursor = 0;                          while (cursor < bufferLength)                          {                              var source = sendBuffer[cursor];                              var edgesLeft = sendBuffer[cursor + 1];                              cursor += 2;                                while (edgesLeft > 0)                              {                                  if (thisMessageIndex > 253)                                  {                                      if (thisMessageIndex < 256)                                      {                                          batchBuffer[thisMessageIndex] = -1;                                      }                                      output.Send(batchStruct);                                      thisMessageIndex = 0;                                  }                                    var maxDegree = 254 - thisMessageIndex;                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                    batchBuffer[thisMessageIndex] = source;                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                  thisMessageIndex += 2;                                  for (int i = 0; i < thisDegree; ++i)                                  {                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                  }                                  edgesLeft -= thisDegree;                                  cursor += thisDegree;                                  thisMessageIndex += thisDegree;                              }                          }                            if (thisMessageIndex > 0)                          {                              if (thisMessageIndex < 256)                              {                                  batchBuffer[thisMessageIndex] = -1;                              }                              output.Send(batchStruct);                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* buffer = this.bufferMaybeShared;                      {                          int* usedCounts = this.usedCountsMaybeShared;                          {                              int* counts = this.countsMaybeShared;                              {                                  int* countStash = this.countStashMaybeShared;                                  {                                      int* sendBuffer = this.sendBufferMaybeShared;                                      {  #else                      fixed (int* buffer = &this.bufferMaybeShared[0])                      {                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                          {                              fixed (int* counts = &this.countsMaybeShared[0])                              {                                  fixed (int* countStash = &this.countStashMaybeShared[0])                                  {                                      fixed (int* sendBuffer = &this.sendBufferMaybeShared[0])                                      {  #endif                                          int bufferLength = 0;                                          for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var source = usedCounts[i];                                              var thisCount = counts[source];                                              countStash[i] = thisCount;                                              counts[source] = bufferLength;                                              bufferLength += thisCount + 2;                                          }                                            sourcesOut += numberOfUsedCounts;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              var ssource = usedCounts[i];                                              var source = ssource;                                              if (this.graphPartsIn > 0)                                              {                                                  if (source >= targetOffset)                                                  {                                                      source = (source - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      source = source * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[ssource]] = source;                                              sendBuffer[counts[ssource] + 1] = countStash[i];                                              counts[ssource] += 2;                                          }                                            edgesOut += bufferValid;                                            for (int i = 0; i < bufferValid; ++i)                                          {                                              var source = buffer[i * 2];                                              var target = buffer[i * 2 + 1];                                              if (this.graphPartsIn > 0)                                              {                                                  if (target >= targetOffset)                                                  {                                                      target = (target - targetOffset) * this.graphPartsIn + this.targetPart;                                                  }                                                  else                                                  {                                                      target = target * this.graphPartsIn + this.sourcePart;                                                  }                                              }                                              sendBuffer[counts[source]] = target;                                              ++counts[source];                                          }                                            var output = this.Output.GetBufferForTime(time);                                          int* batchBuffer = &batchStruct.i00;                                          int thisMessageIndex = 0;                                          int cursor = 0;                                          while (cursor < bufferLength)                                          {                                              var source = sendBuffer[cursor];                                              var edgesLeft = sendBuffer[cursor + 1];                                              cursor += 2;                                                while (edgesLeft > 0)                                              {                                                  if (thisMessageIndex > 253)                                                  {                                                      if (thisMessageIndex < 256)                                                      {                                                          batchBuffer[thisMessageIndex] = -1;                                                      }                                                      output.Send(batchStruct);                                                      thisMessageIndex = 0;                                                  }                                                    var maxDegree = 254 - thisMessageIndex;                                                    var thisDegree = Math.Min(edgesLeft' maxDegree);                                                    batchBuffer[thisMessageIndex] = source;                                                  batchBuffer[thisMessageIndex + 1] = thisDegree;                                                  thisMessageIndex += 2;                                                  for (int i = 0; i < thisDegree; ++i)                                                  {                                                      batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                                                  }                                                  edgesLeft -= thisDegree;                                                  cursor += thisDegree;                                                  thisMessageIndex += thisDegree;                                              }                                          }                                            if (thisMessageIndex < 256)                                          {                                              batchBuffer[thisMessageIndex] = -1;                                          }                                          output.Send(batchStruct);                                            this.bufferValid = 0;                                            for (int i = 0; i < numberOfUsedCounts; ++i)                                          {                                              counts[usedCounts[i]] = 0;                                          }                                            this.numberOfUsedCounts = 0;                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: if (this.stopwatch == null)                  {                      this.stopwatch = System.Diagnostics.Stopwatch.StartNew();                      this.NotifyAt(message.time);                        var firstSource = message.payload[0].i00;                      var firstTarget = message.payload[0].i02;                        long arraySize;                      if (this.graphPartsIn > 0)                      {                          this.sourcePart = firstSource % this.graphPartsIn;                          this.targetPart = firstTarget % this.graphPartsIn;                          Console.WriteLine("Worker " + part + " doing part " + sourcePart + "'" + targetPart + " of " + this.graphPartsIn);                            if (this.sourcePart == this.targetPart)                          {                              arraySize = this.nodes / this.graphPartsIn;                          }                          else                          {                              arraySize = 2 * this.nodes / this.graphPartsIn;                          }                      }                      else if (this.graphPartsIn < 0)                      {                          int gpIn = -this.graphPartsIn;                          this.sourcePart = firstSource % gpIn;                          this.targetPart = firstTarget % gpIn;                          Console.WriteLine("Worker " + part + " doing interim part " + sourcePart + "'" + targetPart + " of " + gpIn);                          arraySize = this.nodes;                      }                      else                      {                          Console.WriteLine("Worker " + part + " starting " + firstSource + "'" + firstTarget);                          arraySize = this.nodes;                      }    #if UseLargePages                      this.rootsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.ranksMaybeShared = LargePages.AllocateBytes((uint)arraySize);                      this.countsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.usedCountsMaybeShared = LargePages.AllocateInts(200000);                      this.bufferMaybeShared = LargePages.AllocateInts(1200000);                      this.countStashMaybeShared = LargePages.AllocateInts(200000);                      this.sendBufferMaybeShared = LargePages.AllocateInts(600000);                      this.followedBufferMaybeShared = LargePages.AllocateInts(256);  #else                      this.rootsMaybeShared = new int[arraySize];                      this.ranksMaybeShared = new byte[arraySize];                      this.countsMaybeShared = new int[arraySize];                      this.usedCountsMaybeShared = new int[200000];                      this.bufferMaybeShared = new int[1200000];                      this.countStashMaybeShared = new int[200000];                      this.sendBufferMaybeShared = new int[600000];                      this.followedBufferMaybeShared = new int[256];  #endif                      for (int i = 0; i < arraySize; i++)                          this.rootsMaybeShared[i] = i;                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: if (this.stopwatch == null)                  {                      this.stopwatch = System.Diagnostics.Stopwatch.StartNew();                      this.NotifyAt(message.time);                        var firstSource = message.payload[0].i00;                      var firstTarget = message.payload[0].i02;                        long arraySize;                      if (this.graphPartsIn > 0)                      {                          this.sourcePart = firstSource % this.graphPartsIn;                          this.targetPart = firstTarget % this.graphPartsIn;                          Console.WriteLine("Worker " + part + " doing part " + sourcePart + "'" + targetPart + " of " + this.graphPartsIn);                            if (this.sourcePart == this.targetPart)                          {                              arraySize = this.nodes / this.graphPartsIn;                          }                          else                          {                              arraySize = 2 * this.nodes / this.graphPartsIn;                          }                      }                      else if (this.graphPartsIn < 0)                      {                          int gpIn = -this.graphPartsIn;                          this.sourcePart = firstSource % gpIn;                          this.targetPart = firstTarget % gpIn;                          Console.WriteLine("Worker " + part + " doing interim part " + sourcePart + "'" + targetPart + " of " + gpIn);                          arraySize = this.nodes;                      }                      else                      {                          Console.WriteLine("Worker " + part + " starting " + firstSource + "'" + firstTarget);                          arraySize = this.nodes;                      }    #if UseLargePages                      this.rootsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.ranksMaybeShared = LargePages.AllocateBytes((uint)arraySize);                      this.countsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.usedCountsMaybeShared = LargePages.AllocateInts(200000);                      this.bufferMaybeShared = LargePages.AllocateInts(1200000);                      this.countStashMaybeShared = LargePages.AllocateInts(200000);                      this.sendBufferMaybeShared = LargePages.AllocateInts(600000);                      this.followedBufferMaybeShared = LargePages.AllocateInts(256);  #else                      this.rootsMaybeShared = new int[arraySize];                      this.ranksMaybeShared = new byte[arraySize];                      this.countsMaybeShared = new int[arraySize];                      this.usedCountsMaybeShared = new int[200000];                      this.bufferMaybeShared = new int[1200000];                      this.countStashMaybeShared = new int[200000];                      this.sendBufferMaybeShared = new int[600000];                      this.followedBufferMaybeShared = new int[256];  #endif                      for (int i = 0; i < arraySize; i++)                          this.rootsMaybeShared[i] = i;                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: if (this.stopwatch == null)                  {                      this.stopwatch = System.Diagnostics.Stopwatch.StartNew();                      this.NotifyAt(message.time);                        var firstSource = message.payload[0].i00;                      var firstTarget = message.payload[0].i02;                        long arraySize;                      if (this.graphPartsIn > 0)                      {                          this.sourcePart = firstSource % this.graphPartsIn;                          this.targetPart = firstTarget % this.graphPartsIn;                          Console.WriteLine("Worker " + part + " doing part " + sourcePart + "'" + targetPart + " of " + this.graphPartsIn);                            if (this.sourcePart == this.targetPart)                          {                              arraySize = this.nodes / this.graphPartsIn;                          }                          else                          {                              arraySize = 2 * this.nodes / this.graphPartsIn;                          }                      }                      else if (this.graphPartsIn < 0)                      {                          int gpIn = -this.graphPartsIn;                          this.sourcePart = firstSource % gpIn;                          this.targetPart = firstTarget % gpIn;                          Console.WriteLine("Worker " + part + " doing interim part " + sourcePart + "'" + targetPart + " of " + gpIn);                          arraySize = this.nodes;                      }                      else                      {                          Console.WriteLine("Worker " + part + " starting " + firstSource + "'" + firstTarget);                          arraySize = this.nodes;                      }    #if UseLargePages                      this.rootsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.ranksMaybeShared = LargePages.AllocateBytes((uint)arraySize);                      this.countsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.usedCountsMaybeShared = LargePages.AllocateInts(200000);                      this.bufferMaybeShared = LargePages.AllocateInts(1200000);                      this.countStashMaybeShared = LargePages.AllocateInts(200000);                      this.sendBufferMaybeShared = LargePages.AllocateInts(600000);                      this.followedBufferMaybeShared = LargePages.AllocateInts(256);  #else                      this.rootsMaybeShared = new int[arraySize];                      this.ranksMaybeShared = new byte[arraySize];                      this.countsMaybeShared = new int[arraySize];                      this.usedCountsMaybeShared = new int[200000];                      this.bufferMaybeShared = new int[1200000];                      this.countStashMaybeShared = new int[200000];                      this.sendBufferMaybeShared = new int[600000];                      this.followedBufferMaybeShared = new int[256];  #endif                      for (int i = 0; i < arraySize; i++)                          this.rootsMaybeShared[i] = i;                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: if (this.stopwatch == null)                  {                      this.stopwatch = System.Diagnostics.Stopwatch.StartNew();                      this.NotifyAt(message.time);                        var firstSource = message.payload[0].i00;                      var firstTarget = message.payload[0].i02;                        long arraySize;                      if (this.graphPartsIn > 0)                      {                          this.sourcePart = firstSource % this.graphPartsIn;                          this.targetPart = firstTarget % this.graphPartsIn;                          Console.WriteLine("Worker " + part + " doing part " + sourcePart + "'" + targetPart + " of " + this.graphPartsIn);                            if (this.sourcePart == this.targetPart)                          {                              arraySize = this.nodes / this.graphPartsIn;                          }                          else                          {                              arraySize = 2 * this.nodes / this.graphPartsIn;                          }                      }                      else if (this.graphPartsIn < 0)                      {                          int gpIn = -this.graphPartsIn;                          this.sourcePart = firstSource % gpIn;                          this.targetPart = firstTarget % gpIn;                          Console.WriteLine("Worker " + part + " doing interim part " + sourcePart + "'" + targetPart + " of " + gpIn);                          arraySize = this.nodes;                      }                      else                      {                          Console.WriteLine("Worker " + part + " starting " + firstSource + "'" + firstTarget);                          arraySize = this.nodes;                      }    #if UseLargePages                      this.rootsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.ranksMaybeShared = LargePages.AllocateBytes((uint)arraySize);                      this.countsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.usedCountsMaybeShared = LargePages.AllocateInts(200000);                      this.bufferMaybeShared = LargePages.AllocateInts(1200000);                      this.countStashMaybeShared = LargePages.AllocateInts(200000);                      this.sendBufferMaybeShared = LargePages.AllocateInts(600000);                      this.followedBufferMaybeShared = LargePages.AllocateInts(256);  #else                      this.rootsMaybeShared = new int[arraySize];                      this.ranksMaybeShared = new byte[arraySize];                      this.countsMaybeShared = new int[arraySize];                      this.usedCountsMaybeShared = new int[200000];                      this.bufferMaybeShared = new int[1200000];                      this.countStashMaybeShared = new int[200000];                      this.sendBufferMaybeShared = new int[600000];                      this.followedBufferMaybeShared = new int[256];  #endif                      for (int i = 0; i < arraySize; i++)                          this.rootsMaybeShared[i] = i;                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: if (this.stopwatch == null)                  {                      this.stopwatch = System.Diagnostics.Stopwatch.StartNew();                      this.NotifyAt(message.time);                        var firstSource = message.payload[0].i00;                      var firstTarget = message.payload[0].i02;                        long arraySize;                      if (this.graphPartsIn > 0)                      {                          this.sourcePart = firstSource % this.graphPartsIn;                          this.targetPart = firstTarget % this.graphPartsIn;                          Console.WriteLine("Worker " + part + " doing part " + sourcePart + "'" + targetPart + " of " + this.graphPartsIn);                            if (this.sourcePart == this.targetPart)                          {                              arraySize = this.nodes / this.graphPartsIn;                          }                          else                          {                              arraySize = 2 * this.nodes / this.graphPartsIn;                          }                      }                      else if (this.graphPartsIn < 0)                      {                          int gpIn = -this.graphPartsIn;                          this.sourcePart = firstSource % gpIn;                          this.targetPart = firstTarget % gpIn;                          Console.WriteLine("Worker " + part + " doing interim part " + sourcePart + "'" + targetPart + " of " + gpIn);                          arraySize = this.nodes;                      }                      else                      {                          Console.WriteLine("Worker " + part + " starting " + firstSource + "'" + firstTarget);                          arraySize = this.nodes;                      }    #if UseLargePages                      this.rootsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.ranksMaybeShared = LargePages.AllocateBytes((uint)arraySize);                      this.countsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.usedCountsMaybeShared = LargePages.AllocateInts(200000);                      this.bufferMaybeShared = LargePages.AllocateInts(1200000);                      this.countStashMaybeShared = LargePages.AllocateInts(200000);                      this.sendBufferMaybeShared = LargePages.AllocateInts(600000);                      this.followedBufferMaybeShared = LargePages.AllocateInts(256);  #else                      this.rootsMaybeShared = new int[arraySize];                      this.ranksMaybeShared = new byte[arraySize];                      this.countsMaybeShared = new int[arraySize];                      this.usedCountsMaybeShared = new int[200000];                      this.bufferMaybeShared = new int[1200000];                      this.countStashMaybeShared = new int[200000];                      this.sendBufferMaybeShared = new int[600000];                      this.followedBufferMaybeShared = new int[256];  #endif                      for (int i = 0; i < arraySize; i++)                          this.rootsMaybeShared[i] = i;                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: if (this.stopwatch == null)                  {                      this.stopwatch = System.Diagnostics.Stopwatch.StartNew();                      this.NotifyAt(message.time);                        var firstSource = message.payload[0].i00;                      var firstTarget = message.payload[0].i02;                        long arraySize;                      if (this.graphPartsIn > 0)                      {                          this.sourcePart = firstSource % this.graphPartsIn;                          this.targetPart = firstTarget % this.graphPartsIn;                          Console.WriteLine("Worker " + part + " doing part " + sourcePart + "'" + targetPart + " of " + this.graphPartsIn);                            if (this.sourcePart == this.targetPart)                          {                              arraySize = this.nodes / this.graphPartsIn;                          }                          else                          {                              arraySize = 2 * this.nodes / this.graphPartsIn;                          }                      }                      else if (this.graphPartsIn < 0)                      {                          int gpIn = -this.graphPartsIn;                          this.sourcePart = firstSource % gpIn;                          this.targetPart = firstTarget % gpIn;                          Console.WriteLine("Worker " + part + " doing interim part " + sourcePart + "'" + targetPart + " of " + gpIn);                          arraySize = this.nodes;                      }                      else                      {                          Console.WriteLine("Worker " + part + " starting " + firstSource + "'" + firstTarget);                          arraySize = this.nodes;                      }    #if UseLargePages                      this.rootsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.ranksMaybeShared = LargePages.AllocateBytes((uint)arraySize);                      this.countsMaybeShared = LargePages.AllocateInts((uint)arraySize);                      this.usedCountsMaybeShared = LargePages.AllocateInts(200000);                      this.bufferMaybeShared = LargePages.AllocateInts(1200000);                      this.countStashMaybeShared = LargePages.AllocateInts(200000);                      this.sendBufferMaybeShared = LargePages.AllocateInts(600000);                      this.followedBufferMaybeShared = LargePages.AllocateInts(256);  #else                      this.rootsMaybeShared = new int[arraySize];                      this.ranksMaybeShared = new byte[arraySize];                      this.countsMaybeShared = new int[arraySize];                      this.usedCountsMaybeShared = new int[200000];                      this.bufferMaybeShared = new int[1200000];                      this.countStashMaybeShared = new int[200000];                      this.sendBufferMaybeShared = new int[600000];                      this.followedBufferMaybeShared = new int[256];  #endif                      for (int i = 0; i < arraySize; i++)                          this.rootsMaybeShared[i] = i;                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexInts,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int p = 0; p < message.length; ++p)                      {  #if UseLargePages                          int* buffer = this.bufferMaybeShared;                          {                              int* roots = this.rootsMaybeShared;                              {                                  byte* ranks = this.ranksMaybeShared;                                  {                                      int* counts = this.countsMaybeShared;                                      {                                          int* usedCounts = this.usedCountsMaybeShared;                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  int* followedPayload = this.followedBufferMaybeShared;                                                  {  #else                          fixed (int* buffer = &this.bufferMaybeShared[0])                          {                              fixed (int* roots = &this.rootsMaybeShared[0])                              {                                  fixed (byte* ranks = &this.ranksMaybeShared[0])                                  {                                      fixed (int* counts = &this.countsMaybeShared[0])                                      {                                          fixed (int* usedCounts = &this.usedCountsMaybeShared[0])                                          {                                              fixed (int* payload = &message.payload[p].i00)                                              {                                                  fixed (int* followedPayload = &this.followedBufferMaybeShared[0])                                                  {  #endif                                                      int cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          if (this.graphPartsIn > 0)                                                          {                                                              ssource = ssource / this.graphPartsIn;                                                          }                                                          payload[cursor] = ssource;                                                          followedPayload[cursor] = roots[ssource];                                                            var degree = payload[cursor + 1];                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              if (this.graphPartsIn > 0)                                                              {                                                                  ttarget = (ttarget / this.graphPartsIn) + targetOffset;                                                              }                                                              payload[cursor + i] = ttarget;                                                              followedPayload[cursor + i] = roots[ttarget];                                                          }                                                            cursor += degree;                                                      }                                                        cursor = 0;                                                      while (cursor < 256 && payload[cursor] >= 0)                                                      {                                                          var ssource = payload[cursor];                                                          var source = followedPayload[cursor];                                                            // find(vertex)                                                           while (source != roots[source])                                                              source = roots[source];                                                            var degree = payload[cursor + 1];                                                            edgesIn += degree;                                                          ++sourcesIn;                                                            cursor += 2;                                                            for (int i = 0; i < degree; ++i)                                                          {                                                              var ttarget = payload[cursor + i];                                                              var target = followedPayload[cursor + i];                                                                // find(vertex)                                                               while (target != roots[target])                                                                  target = roots[target];                                                                // union(source' target)                                                              if (source != target)                                                              {                                                                  // there may be a tie in ranks                                                                  if (ranks[source] == ranks[target])                                                                  {                                                                      // break ties towards lower ids                                                                      if (source < target)                                                                      {                                                                          ranks[source]++;                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          ranks[target]++;                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                  }                                                                  else                                                                  {                                                                      // attatch lower rank to higher                                                                      if (ranks[source] < ranks[target])                                                                      {                                                                          roots[source] = target;                                                                          source = target;                                                                          buffer[this.bufferValid * 2] = target;                                                                          buffer[this.bufferValid * 2 + 1] = ssource;                                                                          ++this.bufferValid;                                                                          if (counts[target] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = target;                                                                              ++this.numberOfUsedCounts;                                                                              counts[target] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[target];                                                                          }                                                                      }                                                                      else                                                                      {                                                                          roots[target] = source;                                                                          buffer[this.bufferValid * 2] = source;                                                                          buffer[this.bufferValid * 2 + 1] = ttarget;                                                                          ++this.bufferValid;                                                                          if (counts[source] == 0)                                                                          {                                                                              usedCounts[this.numberOfUsedCounts] = source;                                                                              ++this.numberOfUsedCounts;                                                                              counts[source] = 1;                                                                          }                                                                          else                                                                          {                                                                              ++counts[source];                                                                          }                                                                      }                                                                  }                                                              }                                                          }                                                            cursor += degree;                                                            if (this.bufferValid > 100 * 1024)                                                          {                                                              this.SendBuffer(message.time);                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: foreach (KeyValuePair<int' int> count in this.counts)                  {                      var source = count.Key;                      var thisCount = count.Value;                      countStash[source] = bufferLength;                      bufferLength += thisCount + 2;                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: foreach (KeyValuePair<int' int> count in this.counts)                  {                      var source = count.Key;                      sendBuffer[countStash[source]] = source;                      sendBuffer[countStash[source] + 1] = count.Value;                      countStash[source] += 2;                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {                      int* batchBuffer = &batchStruct.i00;                      int thisMessageIndex = 0;                      int cursor = 0;                      while (cursor < bufferLength)                      {                          var source = sendBuffer[cursor];                          var edgesLeft = sendBuffer[cursor + 1];                          cursor += 2;                            while (edgesLeft > 0)                          {                              if (thisMessageIndex > 253)                              {                                  if (thisMessageIndex < 256)                                  {                                      batchBuffer[thisMessageIndex] = -1;                                  }                                  output.Send(batchStruct);                                  thisMessageIndex = 0;                              }                                var maxDegree = 254 - thisMessageIndex;                                var thisDegree = Math.Min(edgesLeft' maxDegree);                                batchBuffer[thisMessageIndex] = source;                              batchBuffer[thisMessageIndex + 1] = thisDegree;                              thisMessageIndex += 2;                              for (int i = 0; i < thisDegree; ++i)                              {                                  batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                              }                              edgesLeft -= thisDegree;                              cursor += thisDegree;                              thisMessageIndex += thisDegree;                          }                      }                        if (thisMessageIndex < 256)                      {                          batchBuffer[thisMessageIndex] = -1;                      }                      output.Send(batchStruct);                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {                      int* batchBuffer = &batchStruct.i00;                      int thisMessageIndex = 0;                      int cursor = 0;                      while (cursor < bufferLength)                      {                          var source = sendBuffer[cursor];                          var edgesLeft = sendBuffer[cursor + 1];                          cursor += 2;                            while (edgesLeft > 0)                          {                              if (thisMessageIndex > 253)                              {                                  if (thisMessageIndex < 256)                                  {                                      batchBuffer[thisMessageIndex] = -1;                                  }                                  output.Send(batchStruct);                                  thisMessageIndex = 0;                              }                                var maxDegree = 254 - thisMessageIndex;                                var thisDegree = Math.Min(edgesLeft' maxDegree);                                batchBuffer[thisMessageIndex] = source;                              batchBuffer[thisMessageIndex + 1] = thisDegree;                              thisMessageIndex += 2;                              for (int i = 0; i < thisDegree; ++i)                              {                                  batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                              }                              edgesLeft -= thisDegree;                              cursor += thisDegree;                              thisMessageIndex += thisDegree;                          }                      }                        if (thisMessageIndex < 256)                      {                          batchBuffer[thisMessageIndex] = -1;                      }                      output.Send(batchStruct);                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {                      int* batchBuffer = &batchStruct.i00;                      int thisMessageIndex = 0;                      int cursor = 0;                      while (cursor < bufferLength)                      {                          var source = sendBuffer[cursor];                          var edgesLeft = sendBuffer[cursor + 1];                          cursor += 2;                            while (edgesLeft > 0)                          {                              if (thisMessageIndex > 253)                              {                                  if (thisMessageIndex < 256)                                  {                                      batchBuffer[thisMessageIndex] = -1;                                  }                                  output.Send(batchStruct);                                  thisMessageIndex = 0;                              }                                var maxDegree = 254 - thisMessageIndex;                                var thisDegree = Math.Min(edgesLeft' maxDegree);                                batchBuffer[thisMessageIndex] = source;                              batchBuffer[thisMessageIndex + 1] = thisDegree;                              thisMessageIndex += 2;                              for (int i = 0; i < thisDegree; ++i)                              {                                  batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                              }                              edgesLeft -= thisDegree;                              cursor += thisDegree;                              thisMessageIndex += thisDegree;                          }                      }                        if (thisMessageIndex < 256)                      {                          batchBuffer[thisMessageIndex] = -1;                      }                      output.Send(batchStruct);                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {                      int* batchBuffer = &batchStruct.i00;                      int thisMessageIndex = 0;                      int cursor = 0;                      while (cursor < bufferLength)                      {                          var source = sendBuffer[cursor];                          var edgesLeft = sendBuffer[cursor + 1];                          cursor += 2;                            while (edgesLeft > 0)                          {                              if (thisMessageIndex > 253)                              {                                  if (thisMessageIndex < 256)                                  {                                      batchBuffer[thisMessageIndex] = -1;                                  }                                  output.Send(batchStruct);                                  thisMessageIndex = 0;                              }                                var maxDegree = 254 - thisMessageIndex;                                var thisDegree = Math.Min(edgesLeft' maxDegree);                                batchBuffer[thisMessageIndex] = source;                              batchBuffer[thisMessageIndex + 1] = thisDegree;                              thisMessageIndex += 2;                              for (int i = 0; i < thisDegree; ++i)                              {                                  batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                              }                              edgesLeft -= thisDegree;                              cursor += thisDegree;                              thisMessageIndex += thisDegree;                          }                      }                        if (thisMessageIndex < 256)                      {                          batchBuffer[thisMessageIndex] = -1;                      }                      output.Send(batchStruct);                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {                      int* batchBuffer = &batchStruct.i00;                      int thisMessageIndex = 0;                      int cursor = 0;                      while (cursor < bufferLength)                      {                          var source = sendBuffer[cursor];                          var edgesLeft = sendBuffer[cursor + 1];                          cursor += 2;                            while (edgesLeft > 0)                          {                              if (thisMessageIndex > 253)                              {                                  if (thisMessageIndex < 256)                                  {                                      batchBuffer[thisMessageIndex] = -1;                                  }                                  output.Send(batchStruct);                                  thisMessageIndex = 0;                              }                                var maxDegree = 254 - thisMessageIndex;                                var thisDegree = Math.Min(edgesLeft' maxDegree);                                batchBuffer[thisMessageIndex] = source;                              batchBuffer[thisMessageIndex + 1] = thisDegree;                              thisMessageIndex += 2;                              for (int i = 0; i < thisDegree; ++i)                              {                                  batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                              }                              edgesLeft -= thisDegree;                              cursor += thisDegree;                              thisMessageIndex += thisDegree;                          }                      }                        if (thisMessageIndex < 256)                      {                          batchBuffer[thisMessageIndex] = -1;                      }                      output.Send(batchStruct);                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: unsafe                  {                      int* batchBuffer = &batchStruct.i00;                      int thisMessageIndex = 0;                      int cursor = 0;                      while (cursor < bufferLength)                      {                          var source = sendBuffer[cursor];                          var edgesLeft = sendBuffer[cursor + 1];                          cursor += 2;                            while (edgesLeft > 0)                          {                              if (thisMessageIndex > 253)                              {                                  if (thisMessageIndex < 256)                                  {                                      batchBuffer[thisMessageIndex] = -1;                                  }                                  output.Send(batchStruct);                                  thisMessageIndex = 0;                              }                                var maxDegree = 254 - thisMessageIndex;                                var thisDegree = Math.Min(edgesLeft' maxDegree);                                batchBuffer[thisMessageIndex] = source;                              batchBuffer[thisMessageIndex + 1] = thisDegree;                              thisMessageIndex += 2;                              for (int i = 0; i < thisDegree; ++i)                              {                                  batchBuffer[thisMessageIndex + i] = sendBuffer[cursor + i];                              }                              edgesLeft -= thisDegree;                              cursor += thisDegree;                              thisMessageIndex += thisDegree;                          }                      }                        if (thisMessageIndex < 256)                      {                          batchBuffer[thisMessageIndex] = -1;                      }                      output.Send(batchStruct);                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: if (this.stopwatch == null)                  {                      this.stopwatch = System.Diagnostics.Stopwatch.StartNew();                      this.NotifyAt(message.time);                        var firstSource = message.payload[0].i00;                      var firstTarget = message.payload[0].i02;                        if (this.graphPartsIn > 0)                      {                          this.sourcePart = firstSource % this.graphPartsIn;                          this.targetPart = firstTarget % this.graphPartsIn;                          Console.WriteLine("Worker " + part + " doing part " + sourcePart + "'" + targetPart + " of " + this.graphPartsIn);                      }                      else if (this.graphPartsIn < 0)                      {                          int gpIn = -this.graphPartsIn;                          this.sourcePart = firstSource % gpIn;                          this.targetPart = firstTarget % gpIn;                          Console.WriteLine("Worker " + part + " doing interim part " + sourcePart + "'" + targetPart + " of " + gpIn);                      }                      else                      {                          Console.WriteLine("Worker " + part + " starting " + firstSource + "'" + firstTarget);                      }                        this.roots = new Dictionary<int' int>();                      this.ranks = new Dictionary<int' byte>();                      this.counts = new Dictionary<int' int>();                      this.buffer = new List<Pair<int' int>>();                      this.countStash = new Dictionary<int' int>();                      this.sendBuffer = new int[600000];                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int p = 0; p < message.length; ++p)                  {                      unsafe                      {                          fixed (int* payload = &message.payload[p].i00)                          {                              int cursor = 0;                              while (cursor < 256 && payload[cursor] >= 0)                              {                                  var ssource = payload[cursor];                                  var source = ssource;                                    if (!roots.ContainsKey(source))                                  {                                      roots[source] = source;                                      ranks[source] = 0;                                  }                                    // find(vertex)                                   while (source != roots[source])                                      source = roots[source];                                    var degree = payload[cursor + 1];                                    edgesIn += degree;                                  ++sourcesIn;                                    cursor += 2;                                    for (int i = 0; i < degree; ++i)                                  {                                      var ttarget = payload[cursor + i];                                      var target = ttarget;                                        if (!roots.ContainsKey(target))                                      {                                          roots[target] = target;                                          ranks[target] = 0;                                      }                                        // find(vertex)                                       while (target != roots[target])                                          target = roots[target];                                        // union(source' target)                                      if (source != target)                                      {                                          // there may be a tie in ranks                                          if (ranks[source] == ranks[target])                                          {                                              // break ties towards lower ids                                              if (source < target)                                              {                                                  ranks[source]++;                                                  roots[target] = source;                                                  buffer.Add(source.PairWith(ttarget));                                                  if (counts.ContainsKey(source))                                                  {                                                      ++counts[source];                                                  }                                                  else                                                  {                                                      counts[source] = 1;                                                  }                                              }                                              else                                              {                                                  ranks[target]++;                                                  roots[source] = target;                                                  source = target;                                                  buffer.Add(target.PairWith(ssource));                                                  if (counts.ContainsKey(target))                                                  {                                                      ++counts[target];                                                  }                                                  else                                                  {                                                      counts[target] = 1;                                                  }                                              }                                          }                                          else                                          {                                              // attatch lower rank to higher                                              if (ranks[source] < ranks[target])                                              {                                                  roots[source] = target;                                                  source = target;                                                  buffer.Add(target.PairWith(ssource));                                                  if (counts.ContainsKey(target))                                                  {                                                      ++counts[target];                                                  }                                                  else                                                  {                                                      counts[target] = 1;                                                  }                                              }                                              else                                              {                                                  roots[target] = source;                                                  buffer.Add(source.PairWith(ttarget));                                                  if (counts.ContainsKey(source))                                                  {                                                      ++counts[source];                                                  }                                                  else                                                  {                                                      counts[source] = 1;                                                  }                                              }                                          }                                      }                                  }                                    cursor += degree;                                    if (this.buffer.Count > 100 * 1024)                                  {                                      this.SendBuffer(message.time);                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int p = 0; p < message.length; ++p)                  {                      unsafe                      {                          fixed (int* payload = &message.payload[p].i00)                          {                              int cursor = 0;                              while (cursor < 256 && payload[cursor] >= 0)                              {                                  var ssource = payload[cursor];                                  var source = ssource;                                    if (!roots.ContainsKey(source))                                  {                                      roots[source] = source;                                      ranks[source] = 0;                                  }                                    // find(vertex)                                   while (source != roots[source])                                      source = roots[source];                                    var degree = payload[cursor + 1];                                    edgesIn += degree;                                  ++sourcesIn;                                    cursor += 2;                                    for (int i = 0; i < degree; ++i)                                  {                                      var ttarget = payload[cursor + i];                                      var target = ttarget;                                        if (!roots.ContainsKey(target))                                      {                                          roots[target] = target;                                          ranks[target] = 0;                                      }                                        // find(vertex)                                       while (target != roots[target])                                          target = roots[target];                                        // union(source' target)                                      if (source != target)                                      {                                          // there may be a tie in ranks                                          if (ranks[source] == ranks[target])                                          {                                              // break ties towards lower ids                                              if (source < target)                                              {                                                  ranks[source]++;                                                  roots[target] = source;                                                  buffer.Add(source.PairWith(ttarget));                                                  if (counts.ContainsKey(source))                                                  {                                                      ++counts[source];                                                  }                                                  else                                                  {                                                      counts[source] = 1;                                                  }                                              }                                              else                                              {                                                  ranks[target]++;                                                  roots[source] = target;                                                  source = target;                                                  buffer.Add(target.PairWith(ssource));                                                  if (counts.ContainsKey(target))                                                  {                                                      ++counts[target];                                                  }                                                  else                                                  {                                                      counts[target] = 1;                                                  }                                              }                                          }                                          else                                          {                                              // attatch lower rank to higher                                              if (ranks[source] < ranks[target])                                              {                                                  roots[source] = target;                                                  source = target;                                                  buffer.Add(target.PairWith(ssource));                                                  if (counts.ContainsKey(target))                                                  {                                                      ++counts[target];                                                  }                                                  else                                                  {                                                      counts[target] = 1;                                                  }                                              }                                              else                                              {                                                  roots[target] = source;                                                  buffer.Add(source.PairWith(ttarget));                                                  if (counts.ContainsKey(source))                                                  {                                                      ++counts[source];                                                  }                                                  else                                                  {                                                      counts[source] = 1;                                                  }                                              }                                          }                                      }                                  }                                    cursor += degree;                                    if (this.buffer.Count > 100 * 1024)                                  {                                      this.SendBuffer(message.time);                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int p = 0; p < message.length; ++p)                  {                      unsafe                      {                          fixed (int* payload = &message.payload[p].i00)                          {                              int cursor = 0;                              while (cursor < 256 && payload[cursor] >= 0)                              {                                  var ssource = payload[cursor];                                  var source = ssource;                                    if (!roots.ContainsKey(source))                                  {                                      roots[source] = source;                                      ranks[source] = 0;                                  }                                    // find(vertex)                                   while (source != roots[source])                                      source = roots[source];                                    var degree = payload[cursor + 1];                                    edgesIn += degree;                                  ++sourcesIn;                                    cursor += 2;                                    for (int i = 0; i < degree; ++i)                                  {                                      var ttarget = payload[cursor + i];                                      var target = ttarget;                                        if (!roots.ContainsKey(target))                                      {                                          roots[target] = target;                                          ranks[target] = 0;                                      }                                        // find(vertex)                                       while (target != roots[target])                                          target = roots[target];                                        // union(source' target)                                      if (source != target)                                      {                                          // there may be a tie in ranks                                          if (ranks[source] == ranks[target])                                          {                                              // break ties towards lower ids                                              if (source < target)                                              {                                                  ranks[source]++;                                                  roots[target] = source;                                                  buffer.Add(source.PairWith(ttarget));                                                  if (counts.ContainsKey(source))                                                  {                                                      ++counts[source];                                                  }                                                  else                                                  {                                                      counts[source] = 1;                                                  }                                              }                                              else                                              {                                                  ranks[target]++;                                                  roots[source] = target;                                                  source = target;                                                  buffer.Add(target.PairWith(ssource));                                                  if (counts.ContainsKey(target))                                                  {                                                      ++counts[target];                                                  }                                                  else                                                  {                                                      counts[target] = 1;                                                  }                                              }                                          }                                          else                                          {                                              // attatch lower rank to higher                                              if (ranks[source] < ranks[target])                                              {                                                  roots[source] = target;                                                  source = target;                                                  buffer.Add(target.PairWith(ssource));                                                  if (counts.ContainsKey(target))                                                  {                                                      ++counts[target];                                                  }                                                  else                                                  {                                                      counts[target] = 1;                                                  }                                              }                                              else                                              {                                                  roots[target] = source;                                                  buffer.Add(source.PairWith(ttarget));                                                  if (counts.ContainsKey(source))                                                  {                                                      ++counts[source];                                                  }                                                  else                                                  {                                                      counts[source] = 1;                                                  }                                              }                                          }                                      }                                  }                                    cursor += degree;                                    if (this.buffer.Count > 100 * 1024)                                  {                                      this.SendBuffer(message.time);                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: for (int p = 0; p < message.length; ++p)                  {                      unsafe                      {                          fixed (int* payload = &message.payload[p].i00)                          {                              int cursor = 0;                              while (cursor < 256 && payload[cursor] >= 0)                              {                                  var ssource = payload[cursor];                                  var source = ssource;                                    if (!roots.ContainsKey(source))                                  {                                      roots[source] = source;                                      ranks[source] = 0;                                  }                                    // find(vertex)                                   while (source != roots[source])                                      source = roots[source];                                    var degree = payload[cursor + 1];                                    edgesIn += degree;                                  ++sourcesIn;                                    cursor += 2;                                    for (int i = 0; i < degree; ++i)                                  {                                      var ttarget = payload[cursor + i];                                      var target = ttarget;                                        if (!roots.ContainsKey(target))                                      {                                          roots[target] = target;                                          ranks[target] = 0;                                      }                                        // find(vertex)                                       while (target != roots[target])                                          target = roots[target];                                        // union(source' target)                                      if (source != target)                                      {                                          // there may be a tie in ranks                                          if (ranks[source] == ranks[target])                                          {                                              // break ties towards lower ids                                              if (source < target)                                              {                                                  ranks[source]++;                                                  roots[target] = source;                                                  buffer.Add(source.PairWith(ttarget));                                                  if (counts.ContainsKey(source))                                                  {                                                      ++counts[source];                                                  }                                                  else                                                  {                                                      counts[source] = 1;                                                  }                                              }                                              else                                              {                                                  ranks[target]++;                                                  roots[source] = target;                                                  source = target;                                                  buffer.Add(target.PairWith(ssource));                                                  if (counts.ContainsKey(target))                                                  {                                                      ++counts[target];                                                  }                                                  else                                                  {                                                      counts[target] = 1;                                                  }                                              }                                          }                                          else                                          {                                              // attatch lower rank to higher                                              if (ranks[source] < ranks[target])                                              {                                                  roots[source] = target;                                                  source = target;                                                  buffer.Add(target.PairWith(ssource));                                                  if (counts.ContainsKey(target))                                                  {                                                      ++counts[target];                                                  }                                                  else                                                  {                                                      counts[target] = 1;                                                  }                                              }                                              else                                              {                                                  roots[target] = source;                                                  buffer.Add(source.PairWith(ttarget));                                                  if (counts.ContainsKey(source))                                                  {                                                      ++counts[source];                                                  }                                                  else                                                  {                                                      counts[source] = 1;                                                  }                                              }                                          }                                      }                                  }                                    cursor += degree;                                    if (this.buffer.Count > 100 * 1024)                                  {                                      this.SendBuffer(message.time);                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexPacked,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: int payloadLength = 256;
Magic Number,COST,UnionFindVertexPacked,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* roots = this.rootsMaybeShared;                      {                          byte* ranks = this.ranksMaybeShared;                          {  #else                      fixed (int* roots = &this.rootsMaybeShared[0])                      {                          fixed (byte* ranks = &this.ranksMaybeShared[0])                          {  #endif                              for (int cs = 0; cs < message.length; ++cs)                              {                                  fixed (int* payload = &message.payload[cs].i00)                                  {                                      var cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var degree = payload[cursor + 1];                                            uint source = (uint)payload[cursor];                                          var munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                          //var munged = source;                                          payload[cursor] = roots[munged];                                          cursor += 2;                                            for (int i = 0; i < degree; i++)                                          {                                              source = (uint)payload[cursor + i];                                              munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                              //munged = source;                                              payload[cursor + i] = roots[munged];                                          }                                            cursor += degree;                                            ++nodesIn;                                          edgesIn += degree;                                      }                                        var output = this.Output.GetBufferForTime(message.time);                                        cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var source = payload[cursor++];                                          while (source != roots[source])                                              source = roots[source];                                            var degree = payload[cursor++];                                          for (int i = 0; i < degree; i++)                                          {                                              var target = payload[cursor++];                                              while (target != roots[target])                                                  target = roots[target];                                                // union(source' target)                                              if (source != target)                                              {                                                  // there may be a tie in ranks                                                  if (ranks[source] == ranks[target])                                                  {                                                      // break ties towards lower ids                                                      if (source < target)                                                      {                                                          ranks[source]++;                                                          roots[target] = source;                                                      }                                                      else                                                      {                                                          ranks[target]++;                                                          roots[source] = target;                                                          source = target;                                                      }                                                  }                                                  else                                                  {                                                      // attatch lower rank to higher                                                      if (ranks[source] < ranks[target])                                                      {                                                          roots[source] = target;                                                          source = target;                                                      }                                                      else                                                          roots[target] = source;                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexPacked,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* roots = this.rootsMaybeShared;                      {                          byte* ranks = this.ranksMaybeShared;                          {  #else                      fixed (int* roots = &this.rootsMaybeShared[0])                      {                          fixed (byte* ranks = &this.ranksMaybeShared[0])                          {  #endif                              for (int cs = 0; cs < message.length; ++cs)                              {                                  fixed (int* payload = &message.payload[cs].i00)                                  {                                      var cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var degree = payload[cursor + 1];                                            uint source = (uint)payload[cursor];                                          var munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                          //var munged = source;                                          payload[cursor] = roots[munged];                                          cursor += 2;                                            for (int i = 0; i < degree; i++)                                          {                                              source = (uint)payload[cursor + i];                                              munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                              //munged = source;                                              payload[cursor + i] = roots[munged];                                          }                                            cursor += degree;                                            ++nodesIn;                                          edgesIn += degree;                                      }                                        var output = this.Output.GetBufferForTime(message.time);                                        cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var source = payload[cursor++];                                          while (source != roots[source])                                              source = roots[source];                                            var degree = payload[cursor++];                                          for (int i = 0; i < degree; i++)                                          {                                              var target = payload[cursor++];                                              while (target != roots[target])                                                  target = roots[target];                                                // union(source' target)                                              if (source != target)                                              {                                                  // there may be a tie in ranks                                                  if (ranks[source] == ranks[target])                                                  {                                                      // break ties towards lower ids                                                      if (source < target)                                                      {                                                          ranks[source]++;                                                          roots[target] = source;                                                      }                                                      else                                                      {                                                          ranks[target]++;                                                          roots[source] = target;                                                          source = target;                                                      }                                                  }                                                  else                                                  {                                                      // attatch lower rank to higher                                                      if (ranks[source] < ranks[target])                                                      {                                                          roots[source] = target;                                                          source = target;                                                      }                                                      else                                                          roots[target] = source;                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexPacked,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* roots = this.rootsMaybeShared;                      {                          byte* ranks = this.ranksMaybeShared;                          {  #else                      fixed (int* roots = &this.rootsMaybeShared[0])                      {                          fixed (byte* ranks = &this.ranksMaybeShared[0])                          {  #endif                              for (int cs = 0; cs < message.length; ++cs)                              {                                  fixed (int* payload = &message.payload[cs].i00)                                  {                                      var cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var degree = payload[cursor + 1];                                            uint source = (uint)payload[cursor];                                          var munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                          //var munged = source;                                          payload[cursor] = roots[munged];                                          cursor += 2;                                            for (int i = 0; i < degree; i++)                                          {                                              source = (uint)payload[cursor + i];                                              munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                              //munged = source;                                              payload[cursor + i] = roots[munged];                                          }                                            cursor += degree;                                            ++nodesIn;                                          edgesIn += degree;                                      }                                        var output = this.Output.GetBufferForTime(message.time);                                        cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var source = payload[cursor++];                                          while (source != roots[source])                                              source = roots[source];                                            var degree = payload[cursor++];                                          for (int i = 0; i < degree; i++)                                          {                                              var target = payload[cursor++];                                              while (target != roots[target])                                                  target = roots[target];                                                // union(source' target)                                              if (source != target)                                              {                                                  // there may be a tie in ranks                                                  if (ranks[source] == ranks[target])                                                  {                                                      // break ties towards lower ids                                                      if (source < target)                                                      {                                                          ranks[source]++;                                                          roots[target] = source;                                                      }                                                      else                                                      {                                                          ranks[target]++;                                                          roots[source] = target;                                                          source = target;                                                      }                                                  }                                                  else                                                  {                                                      // attatch lower rank to higher                                                      if (ranks[source] < ranks[target])                                                      {                                                          roots[source] = target;                                                          source = target;                                                      }                                                      else                                                          roots[target] = source;                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexPacked,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* roots = this.rootsMaybeShared;                      {                          byte* ranks = this.ranksMaybeShared;                          {  #else                      fixed (int* roots = &this.rootsMaybeShared[0])                      {                          fixed (byte* ranks = &this.ranksMaybeShared[0])                          {  #endif                              for (int cs = 0; cs < message.length; ++cs)                              {                                  fixed (int* payload = &message.payload[cs].i00)                                  {                                      var cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var degree = payload[cursor + 1];                                            uint source = (uint)payload[cursor];                                          var munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                          //var munged = source;                                          payload[cursor] = roots[munged];                                          cursor += 2;                                            for (int i = 0; i < degree; i++)                                          {                                              source = (uint)payload[cursor + i];                                              munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                              //munged = source;                                              payload[cursor + i] = roots[munged];                                          }                                            cursor += degree;                                            ++nodesIn;                                          edgesIn += degree;                                      }                                        var output = this.Output.GetBufferForTime(message.time);                                        cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var source = payload[cursor++];                                          while (source != roots[source])                                              source = roots[source];                                            var degree = payload[cursor++];                                          for (int i = 0; i < degree; i++)                                          {                                              var target = payload[cursor++];                                              while (target != roots[target])                                                  target = roots[target];                                                // union(source' target)                                              if (source != target)                                              {                                                  // there may be a tie in ranks                                                  if (ranks[source] == ranks[target])                                                  {                                                      // break ties towards lower ids                                                      if (source < target)                                                      {                                                          ranks[source]++;                                                          roots[target] = source;                                                      }                                                      else                                                      {                                                          ranks[target]++;                                                          roots[source] = target;                                                          source = target;                                                      }                                                  }                                                  else                                                  {                                                      // attatch lower rank to higher                                                      if (ranks[source] < ranks[target])                                                      {                                                          roots[source] = target;                                                          source = target;                                                      }                                                      else                                                          roots[target] = source;                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexPacked,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {  #if UseLargePages                      int* roots = this.rootsMaybeShared;                      {                          byte* ranks = this.ranksMaybeShared;                          {  #else                      fixed (int* roots = &this.rootsMaybeShared[0])                      {                          fixed (byte* ranks = &this.ranksMaybeShared[0])                          {  #endif                              for (int cs = 0; cs < message.length; ++cs)                              {                                  fixed (int* payload = &message.payload[cs].i00)                                  {                                      var cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var degree = payload[cursor + 1];                                            uint source = (uint)payload[cursor];                                          var munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                          //var munged = source;                                          payload[cursor] = roots[munged];                                          cursor += 2;                                            for (int i = 0; i < degree; i++)                                          {                                              source = (uint)payload[cursor + i];                                              munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);                                              //munged = source;                                              payload[cursor + i] = roots[munged];                                          }                                            cursor += degree;                                            ++nodesIn;                                          edgesIn += degree;                                      }                                        var output = this.Output.GetBufferForTime(message.time);                                        cursor = 0;                                      while (cursor < payloadLength && payload[cursor] >= 0)                                      {                                          var source = payload[cursor++];                                          while (source != roots[source])                                              source = roots[source];                                            var degree = payload[cursor++];                                          for (int i = 0; i < degree; i++)                                          {                                              var target = payload[cursor++];                                              while (target != roots[target])                                                  target = roots[target];                                                // union(source' target)                                              if (source != target)                                              {                                                  // there may be a tie in ranks                                                  if (ranks[source] == ranks[target])                                                  {                                                      // break ties towards lower ids                                                      if (source < target)                                                      {                                                          ranks[source]++;                                                          roots[target] = source;                                                      }                                                      else                                                      {                                                          ranks[target]++;                                                          roots[source] = target;                                                          source = target;                                                      }                                                  }                                                  else                                                  {                                                      // attatch lower rank to higher                                                      if (ranks[source] < ranks[target])                                                      {                                                          roots[source] = target;                                                          source = target;                                                      }                                                      else                                                          roots[target] = source;                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,UnionFindVertexPackedHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: int payloadLength = 256;
Magic Number,COST,UnionFindVertexPackedHashTable,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: unsafe                  {                      for (int cs = 0; cs < message.length; ++cs)                      {                          fixed (int* payload = &message.payload[cs].i00)                          {                              var cursor = 0;                              while (cursor < payloadLength && payload[cursor] >= 0)                              {                                  var degree = payload[cursor + 1];                                    var source = payload[cursor];                                  if (!roots.ContainsKey(source))                                  {                                      roots[source] = source;                                      ranks[source] = 0;                                  }                                    payload[cursor] = roots[source];                                  cursor += 2;                                    for (int i = 0; i < degree; i++)                                  {                                      var target = payload[cursor + i];                                      if (!roots.ContainsKey(target))                                      {                                          roots[target] = target;                                          ranks[target] = 0;                                      }                                      payload[cursor + i] = roots[target];                                  }                                    cursor += degree;                                    ++nodesIn;                                  edgesIn += degree;                              }                                var output = this.Output.GetBufferForTime(message.time);                                cursor = 0;                              while (cursor < payloadLength && payload[cursor] >= 0)                              {                                  var source = payload[cursor++];                                  while (source != roots[source])                                      source = roots[source];                                    var degree = payload[cursor++];                                  for (int i = 0; i < degree; i++)                                  {                                      var target = payload[cursor++];                                      while (target != roots[target])                                          target = roots[target];                                        // union(source' target)                                      if (source != target)                                      {                                          // there may be a tie in ranks                                          if (ranks[source] == ranks[target])                                          {                                              // break ties towards lower ids                                              if (source < target)                                              {                                                  ranks[source]++;                                                  roots[target] = source;                                              }                                              else                                              {                                                  ranks[target]++;                                                  roots[source] = target;                                                  source = target;                                              }                                          }                                          else                                          {                                              // attatch lower rank to higher                                              if (ranks[source] < ranks[target])                                              {                                                  roots[source] = target;                                                  source = target;                                              }                                              else                                                  roots[target] = source;                                          }                                      }                                  }                              }                          }                      }                  }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: var ints = new int[2];
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: var bytes = new byte[8];
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= stream.Read(bytes' 0' 8);
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy(bytes' 0' ints' 0' 8);
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0)              {                  // allocate space if needed                  if (ints.Length < degree + 2)                  {                      ints = new int[degree + 2];                      bytes = new byte[ints.Length * 4];                  }                    // read names of neighbors' plus next vertex and degree.                  bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));                  Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));                    // run the user-supplied vertex logic                  for (int i = 0; i < degree; i++)                      yield return new Edge(new Node(vertex)' new Node(ints[i]));                    vertex = ints[degree];                  degree = ints[degree + 1];              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0)              {                  // allocate space if needed                  if (ints.Length < degree + 2)                  {                      ints = new int[degree + 2];                      bytes = new byte[ints.Length * 4];                  }                    // read names of neighbors' plus next vertex and degree.                  bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));                  Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));                    // run the user-supplied vertex logic                  for (int i = 0; i < degree; i++)                      yield return new Edge(new Node(vertex)' new Node(ints[i]));                    vertex = ints[degree];                  degree = ints[degree + 1];              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0)              {                  // allocate space if needed                  if (ints.Length < degree + 2)                  {                      ints = new int[degree + 2];                      bytes = new byte[ints.Length * 4];                  }                    // read names of neighbors' plus next vertex and degree.                  bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));                  Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));                    // run the user-supplied vertex logic                  for (int i = 0; i < degree; i++)                      yield return new Edge(new Node(vertex)' new Node(ints[i]));                    vertex = ints[degree];                  degree = ints[degree + 1];              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0)              {                  // allocate space if needed                  if (ints.Length < degree + 2)                  {                      ints = new int[degree + 2];                      bytes = new byte[ints.Length * 4];                  }                    // read names of neighbors' plus next vertex and degree.                  bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));                  Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));                    // run the user-supplied vertex logic                  for (int i = 0; i < degree; i++)                      yield return new Edge(new Node(vertex)' new Node(ints[i]));                    vertex = ints[degree];                  degree = ints[degree + 1];              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0)              {                  // allocate space if needed                  if (ints.Length < degree + 2)                  {                      ints = new int[degree + 2];                      bytes = new byte[ints.Length * 4];                  }                    // read names of neighbors' plus next vertex and degree.                  bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));                  Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));                    // run the user-supplied vertex logic                  for (int i = 0; i < degree; i++)                      yield return new Edge(new Node(vertex)' new Node(ints[i]));                    vertex = ints[degree];                  degree = ints[degree + 1];              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0)              {                  // allocate space if needed                  if (ints.Length < degree + 2)                  {                      ints = new int[degree + 2];                      bytes = new byte[ints.Length * 4];                  }                    // read names of neighbors' plus next vertex and degree.                  bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));                  Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));                    // run the user-supplied vertex logic                  for (int i = 0; i < degree; i++)                      yield return new Edge(new Node(vertex)' new Node(ints[i]));                    vertex = ints[degree];                  degree = ints[degree + 1];              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0)              {                  // allocate space if needed                  if (ints.Length < degree + 2)                  {                      ints = new int[degree + 2];                      bytes = new byte[ints.Length * 4];                  }                    // read names of neighbors' plus next vertex and degree.                  bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));                  Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));                    // run the user-supplied vertex logic                  for (int i = 0; i < degree; i++)                      yield return new Edge(new Node(vertex)' new Node(ints[i]));                    vertex = ints[degree];                  degree = ints[degree + 1];              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (args.Length < 3)                  throw new Exception("Three arguments required: system' algorithm' dataset");
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var dataset = args[2];
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "partition" && dataset == "twitter")              {                  SingleThreaded.PartitionGraph(twitterFile' 4' (s' t) => (s & 1) + 2 * (t & 1)' dataDir + @"twitter-part-{0}-of-{1}");              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "partition" && dataset == "twitter")              {                  SingleThreaded.PartitionGraph(twitterFile' 4' (s' t) => (s & 1) + 2 * (t & 1)' dataDir + @"twitter-part-{0}-of-{1}");              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "transpose" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  SingleThreaded.TransposeGraph(dataDir + @"twitterfollowers\twitter_rv.bin"' 65000000);                  Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    uint nodes = 0;                  var names = new uint[65000000];                  for (int i = 0; i < names.Length; i++)                      names[i] = uint.MaxValue;                    var idegrees = new int[65000000];                  var odegrees = new int[65000000];                    var edges = 0L;                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      if (names[vertex] == uint.MaxValue)                          names[vertex] = nodes++;                        for (int i = 0; i < degree; i++)                          if (names[neighbors[offset + i]] == uint.MaxValue)                              names[neighbors[offset + i]] = nodes++;                        edges += degree;                  });                    Console.WriteLine("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);                    // allocate enough space for all the edges.                  var hilbertTransformed = new uint[edges];                    var counts = new uint[1 << 20];                  SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });                    Console.WriteLine("{0}\tHilbert regions sized"' stopwatch.Elapsed);                  for (int i = 1; i < counts.Length; i++)                      counts[i + 1] += counts[i];                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });                    for (int i = counts.Length - 1; i > 0; i--)                      counts[i] = counts[i] - 1;                    counts[0] = 0;                    var buffer = new BufferTrie<uint>.Pair[5000000];                    SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });                    Trie.Flush();                    Console.WriteLine("{0}\tEdges partitioned"' stopwatch.Elapsed);                    using (var upper = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-upper")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          if (counts[i] < counts[i + 1])                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32)' out x' out y);                                upper.Write(x);                              upper.Write(y);                              upper.Write(counts[i + 1] - counts[i]);                          }                      }                  }                    using (var lower = new System.IO.BinaryWriter(System.IO.File.OpenWrite("twitter-hilbert-lower")))                  {                      for (uint i = 0; i < counts.Length - 1; i++)                      {                          Array.Sort(hilbertTransformed' (int)counts[i]' (int)(counts[i + 1] - counts[i]));                            for (uint j = counts[i]; j < counts[i + 1]; j++)                          {                              uint x = 0' y = 0;                              HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);                                lower.Write((UInt16)(x & 0xFFFF));                              lower.Write((UInt16)(y & 0xFFFF));                          }                      }                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertpagerank" && dataset == "livejournal")              {                  unsafe                  {                      var stopwatch = System.Diagnostics.Stopwatch.StartNew();                        var nodes = (uint)42000000;    #if UseLargePages                      var srcRanks = LargePages.AllocateFloats(nodes);                      var dstRanks = LargePages.AllocateFloats(nodes);  #else                      var srcRanks = new float[nodes];                      var dstRanks = new float[nodes];  #endif                      for (int i = 0; i < nodes; i++)                          srcRanks[i] = 1.0f;                        SingleThreaded.HilbertPagerank(@"livejournal-hilbert"' dstRanks' srcRanks' nodes' 0.85f);                        Console.WriteLine(stopwatch.Elapsed);                  }                }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertpagerank" && dataset == "twitter")              {                  unsafe                  {                      var stopwatch = System.Diagnostics.Stopwatch.StartNew();                        var nodes = (uint)42000000;    #if UseLargePages                      var srcRanks = LargePages.AllocateFloats(nodes);                      var dstRanks = LargePages.AllocateFloats(nodes);  #else                      var srcRanks = new float[nodes];                      var dstRanks = new float[nodes];  #endif                      for (int i = 0; i < nodes; i++)                          srcRanks[i] = 1.0f;                        SingleThreaded.HilbertPagerank(@"twitter-hilbert"' dstRanks' srcRanks' nodes' 0.85f);                        Console.WriteLine(stopwatch.Elapsed);                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertpagerank" && dataset == "uk-2007-05")              {                  unsafe                  {                      var stopwatch = System.Diagnostics.Stopwatch.StartNew();                        var nodes = (uint)106000000;                        var srcRanks = LargePages.AllocateFloats(nodes);                      var dstRanks = LargePages.AllocateFloats(nodes);                        for (int i = 0; i < nodes; i++)                          srcRanks[i] = 1.0f;                        SingleThreaded.MultiHilbertPagerank(@"uk-2007-05-hilbert"' dstRanks' srcRanks' nodes' 0.85f);                        Console.WriteLine(stopwatch.Elapsed);                  }                }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertunionfind" && dataset == "twitter")              {                  unsafe                  {                      var nodes = (uint)42000000;                        var stopwatch = System.Diagnostics.Stopwatch.StartNew();                      SingleThreaded.HilbertUnionFind2(@"twitter-hilbert"' nodes);                      Console.WriteLine(stopwatch.Elapsed);                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertunionfind" && dataset == "uk-2007-05")              {                  unsafe                  {                      var nodes = (uint)106000000;                        var stopwatch = System.Diagnostics.Stopwatch.StartNew();                      SingleThreaded.MultiHilbertCC(@"uk-2007-05-hilbert"' nodes);                      Console.WriteLine(stopwatch.Elapsed);                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertunionfind" && dataset == "livejournal")              {                  unsafe                  {                      var nodes = (uint)42000000;                        var stopwatch = System.Diagnostics.Stopwatch.StartNew();                      SingleThreaded.HilbertUnionFind(@"livejournal-hilbert-upper"' "livejournal-hilbert-lower"' nodes);                      Console.WriteLine(stopwatch.Elapsed);                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "uk-2007-05")              {                  unsafe                  {                      var stopwatch = System.Diagnostics.Stopwatch.StartNew();                        var nodes = (uint)106000000;    #if UseLargePages                      var srcRanks = LargePages.AllocateFloats(nodes);                      var dstRanks = LargePages.AllocateFloats(nodes);  #else                      var srcRanks = new float[nodes];                      var dstRanks = new float[nodes];  #endif                      SingleThreaded.PageRankFromDisk(ukFile' dstRanks' srcRanks' nodes' 0.85f);                        Console.WriteLine(stopwatch.Elapsed);                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "twitter")              {                  unsafe                  {                      var stopwatch = System.Diagnostics.Stopwatch.StartNew();                        var nodes = (uint)65000000;    #if UseLargePages                      var srcRanks = LargePages.AllocateFloats(nodes);                      var dstRanks = LargePages.AllocateFloats(nodes);  #else                      var srcRanks = new float[nodes];                      var dstRanks = new float[nodes];  #endif                      SingleThreaded.PageRankFromDisk(twitterFile' dstRanks' srcRanks' nodes' 0.85f);                        Console.WriteLine(stopwatch.Elapsed);                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "livejournal")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    unsafe                  {                      var nodes = (uint)65000000;    #if UseLargePages                      var srcRanks = LargePages.AllocateFloats(nodes);                      var dstRanks = LargePages.AllocateFloats(nodes);  #else                      var srcRanks = new float[nodes];                      var dstRanks = new float[nodes];  #endif                      for (int i = 0; i < 20; i++)                      {                          SingleThreaded.PageRankStep(livejournalFile' dstRanks' srcRanks' nodes' 0.85f);                          Console.WriteLine("{0}\tIteration {1}"' stopwatch.Elapsed' i);                      }                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "livejournal")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    unsafe                  {                      var nodes = (uint)65000000;    #if UseLargePages                      var srcRanks = LargePages.AllocateFloats(nodes);                      var dstRanks = LargePages.AllocateFloats(nodes);  #else                      var srcRanks = new float[nodes];                      var dstRanks = new float[nodes];  #endif                      for (int i = 0; i < 20; i++)                      {                          SingleThreaded.PageRankStep(livejournalFile' dstRanks' srcRanks' nodes' 0.85f);                          Console.WriteLine("{0}\tIteration {1}"' stopwatch.Elapsed' i);                      }                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  SingleThreaded.ConnectedComponents(twitterFile' 65000000);                  Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  SingleThreaded.ClumsyCC(ukFile' 106000000);                  Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "livejournal")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  SingleThreaded.ConnectedComponents(livejournalFile' 6500000);                  Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "maximalindependentset" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  SingleThreaded.MaximalIndependentSet(twitterFile' 65000000);                  Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "maximalindependentset" && dataset == "livejournal")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  SingleThreaded.MaximalIndependentSet(livejournalFile' 6500000);                  Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: var dataset = args[2];
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "partition" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      int parts = Int32.Parse(args[3]);                      var format = Path.Combine(dataDir' @"twitter-part-{0}-of-" + (parts * parts).ToString());                        computation.LoadGraph(twitterFile)                                 .Partition(parts' parts)                                 .WriteBinaryToFiles(format);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "repartition" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      int parts = Int32.Parse(args[3]);                        computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "repartition" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      int parts = Int32.Parse(args[3]);                        computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "repartition" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      int parts = Int32.Parse(args[3]);                        computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "twitter")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      computation.OnFrontierChange += (x' y) => { Console.WriteLine(System.DateTime.Now + "\t" + string.Join("' "' y.NewFrontier)); System.GC.GetTotalMemory(true); };                        var edges = System.IO.File.OpenRead(twitterFile)                                                .ReadEdges()                                                .AsNaiadStream(computation);                        edges.PageRank(20' "twitter").Subscribe();                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "livejournal")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      computation.OnFrontierChange += (x' y) => { Console.WriteLine(System.DateTime.Now + "\t" + string.Join("' "' y.NewFrontier)); };                        var edges = System.IO.File.OpenRead(livejournalFile)                                                .ReadEdges()                                                .AsNaiadStream(computation);                        edges.PageRank(20' "livejournal").Subscribe();                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var format = Path.Combine(dataDir' @"uk-2007-05-part-{0}-of-{1}");                        var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();                        computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var format = Path.Combine(dataDir' @"uk-2007-05-part-{0}-of-{1}");                        var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();                        computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var format = Path.Combine(dataDir' @"uk-2007-05-part-{0}-of-{1}");                        var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();                        computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var format = Path.Combine(dataDir' @"uk-2007-05-part-{0}-of-{1}");                        var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();                        computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var format = Path.Combine(dataDir' @"uk-2007-05-part-{0}-of-{1}");                        var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();                        computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var format = Path.Combine(dataDir' @"uk-2007-05-part-{0}-of-{1}");                        var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();                        computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var format = Path.Combine(dataDir' @"uk-2007-05-part-{0}-of-{1}");                        var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();                        computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var format = Path.Combine(dataDir' @"uk-2007-05-part-{0}-of-{1}");                        var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();                        computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter")              {                  using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase)))                  {                      // HDFS needs to be initialized from the main thread before distributed use                      bool exists = hdfs.IsFileExists("/dummy");                  }                    var readWatch = System.Diagnostics.Stopwatch.StartNew();                    using (var controller = NewController.FromConfig(configuration))                  {                      using (var readComputation = controller.NewComputation())                      {                          int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;                          int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;                          int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;                          var format = new Uri(@uriBase + "twitter-40");                          var collection = readComputation                              .ReadHdfsBinaryCollection<Edge>(format);                            Stream<int[]' Epoch> readStuff = null;                            switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }                            var sink = new InterGraphDataSink<int[]>(readStuff);                            readComputation.Activate();                          readComputation.Join();                            Console.WriteLine("Reading done: " + readWatch.Elapsed);                            for (int i = 0; i < 20; ++i)                          {                              var stopwatch = System.Diagnostics.Stopwatch.StartNew();                                using (var computation = controller.NewComputation())                              {                                  var firstStage = computation.NewInput(sink.NewDataSource())                                      .ReformatInts();                                    if (parts * machines * another > 1)                                  {                                      firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);                                  }                                    switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }                                    computation.Activate();                                  computation.Join();                              }                                Console.WriteLine(stopwatch.Elapsed);                          }                      }                        controller.Join();                  }              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "livejournal")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var edges = System.IO.File.OpenRead(livejournalFile)                                                .ReadEdges()                                                .AsNaiadStream(computation);                        edges.UnionFind(5000000)                           .PartitionBy(x => 0)                           .UnionFind(5000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "livejournal")              {                  var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    using (var computation = NewComputation.FromConfig(configuration))                  {                      var edges = System.IO.File.OpenRead(livejournalFile)                                                .ReadEdges()                                                .AsNaiadStream(computation);                        edges.UnionFind(5000000)                           .PartitionBy(x => 0)                           .UnionFind(5000000);                        computation.Activate();                      computation.Join();                  }                    Console.WriteLine(stopwatch.Elapsed);              }
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,Main,The following statement contains a magic number: if (args.Length < 3)                  throw new Exception("Three arguments required: system' algorithm' dataset");
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)                  maxDegree = Math.Max(maxDegree' metadata[i + 1]);
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: var neighbors = new int[2 * maxDegree];
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader(this.filePrefix + "-edges"))              {                  reader.Read(neighbors' 0' neighbors.Length);                    for (int i = 0; i < metadata.Length; i += 2)                  {                      var vertex = metadata[i + 0];                      var degree = metadata[i + 1];                        if (neighborsOffset + degree > neighbors.Length - 1)                      {                          Array.Copy(neighbors' neighborsOffset' neighbors' 0' neighbors.Length - neighborsOffset);                          reader.Read(neighbors' neighbors.Length - neighborsOffset' neighborsOffset);                          neighborsOffset = 0;                      }                        perVertexLogic(vertex' degree' neighborsOffset' neighbors);                      neighborsOffset += degree;                  }              }
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)                  perVertexLogic(metadata[i]' metadata[i + 1]);
Magic Number,COST,MemoryGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < this.metadata.Length; i += 2)                  perVertexLogic(this.metadata[i]' this.metadata[i + 1]);
Magic Number,COST,MemoryGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)              {                  var vertex = metadata[i + 0];                  var degree = metadata[i + 1];                    perVertexLogic(vertex' degree' offset' neighbors);                  offset += degree;              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)                  maxDegree = Math.Max(maxDegree' metadata[i + 1]);
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: var neighbors = new int[2 * maxDegree];
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader(filename + "-edges"))              {                  reader.Read(neighbors' 0' neighbors.Length);                    for (int i = 0; i < metadata.Length; i += 2)                  {                      var vertex = metadata[i + 0];                      var degree = metadata[i + 1];                        if (neighborsOffset + degree > neighbors.Length - 1)                      {                          Array.Copy(neighbors' neighborsOffset' neighbors' 0' neighbors.Length - neighborsOffset);                          reader.Read(neighbors' neighbors.Length - neighborsOffset' neighborsOffset);                          neighborsOffset = 0;                      }                        perVertexLogic(vertex' degree' neighborsOffset' neighbors);                      neighborsOffset += degree;                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)                  perVertexLogic(metadata[i]' metadata[i + 1]);
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)              {                  var vertex = metadata[i + 0];                  var degree = metadata[i + 1];                    perVertexLogic(vertex' degree' offset' neighbors);                  offset += degree;              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3)                  maxCount = Math.Max(maxCount' metadata[i + 2]);
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3)                  maxCount = Math.Max(maxCount' metadata[i + 2]);
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: var edges = new uint[2 * maxCount];
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader(filename + "-lower"))              {                  reader.Read(edges' 0' edges.Length);                    for (int i = 0; i < metadata.Length; i += 3)                  {                      var sourceUpper = metadata[i + 0] << 16;                      var targetUpper = metadata[i + 1] << 16;                        var count = metadata[i + 2];                        if (edgesOffset + count > edges.Length - 1)                      {                          Array.Copy(edges' edgesOffset' edges' 0' edges.Length - edgesOffset);                          reader.Read(edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);                          edgesOffset = 0;                      }                        perVertexLogic(sourceUpper' targetUpper' edgesOffset' count' edges);                      edgesOffset += count;                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader(filename + "-lower"))              {                  reader.Read(edges' 0' edges.Length);                    for (int i = 0; i < metadata.Length; i += 3)                  {                      var sourceUpper = metadata[i + 0] << 16;                      var targetUpper = metadata[i + 1] << 16;                        var count = metadata[i + 2];                        if (edgesOffset + count > edges.Length - 1)                      {                          Array.Copy(edges' edgesOffset' edges' 0' edges.Length - edgesOffset);                          reader.Read(edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);                          edgesOffset = 0;                      }                        perVertexLogic(sourceUpper' targetUpper' edgesOffset' count' edges);                      edgesOffset += count;                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader(filename + "-lower"))              {                  reader.Read(edges' 0' edges.Length);                    for (int i = 0; i < metadata.Length; i += 3)                  {                      var sourceUpper = metadata[i + 0] << 16;                      var targetUpper = metadata[i + 1] << 16;                        var count = metadata[i + 2];                        if (edgesOffset + count > edges.Length - 1)                      {                          Array.Copy(edges' edgesOffset' edges' 0' edges.Length - edgesOffset);                          reader.Read(edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);                          edgesOffset = 0;                      }                        perVertexLogic(sourceUpper' targetUpper' edgesOffset' count' edges);                      edgesOffset += count;                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader(filename + "-lower"))              {                  reader.Read(edges' 0' edges.Length);                    for (int i = 0; i < metadata.Length; i += 3)                  {                      var sourceUpper = metadata[i + 0] << 16;                      var targetUpper = metadata[i + 1] << 16;                        var count = metadata[i + 2];                        if (edgesOffset + count > edges.Length - 1)                      {                          Array.Copy(edges' edgesOffset' edges' 0' edges.Length - edgesOffset);                          reader.Read(edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);                          edgesOffset = 0;                      }                        perVertexLogic(sourceUpper' targetUpper' edgesOffset' count' edges);                      edgesOffset += count;                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3)              {                  var sourceUpper = metadata[i + 0] << 16;                  var targetUpper = metadata[i + 1] << 16;                    var count = metadata[i + 2];                    perVertexLogic(sourceUpper' targetUpper' edgesOffset' count' edges);                  edgesOffset += count;              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3)              {                  var sourceUpper = metadata[i + 0] << 16;                  var targetUpper = metadata[i + 1] << 16;                    var count = metadata[i + 2];                    perVertexLogic(sourceUpper' targetUpper' edgesOffset' count' edges);                  edgesOffset += count;              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3)              {                  var sourceUpper = metadata[i + 0] << 16;                  var targetUpper = metadata[i + 1] << 16;                    var count = metadata[i + 2];                    perVertexLogic(sourceUpper' targetUpper' edgesOffset' count' edges);                  edgesOffset += count;              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3)              {                  var sourceUpper = metadata[i + 0] << 16;                  var targetUpper = metadata[i + 1] << 16;                    var count = metadata[i + 2];                    perVertexLogic(sourceUpper' targetUpper' edgesOffset' count' edges);                  edgesOffset += count;              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,TransposeGraph,The following statement contains a magic number: var buffer = new BufferTrie<int>.Pair[5000000];
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,TransposeGraph,The following statement contains a magic number: var edgeTrie = new BufferTrie<int>(26' (array' offset' length) =>              {                  for (int i = 0; i < length; i++)                      edges[nodes[array[i].Index]++] = array[i].Value;              });
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter(File.OpenWrite(filename + "-nodes")))              {                  using (var edgeWriter = new BinaryWriter(File.OpenWrite(filename + "-edges")))                  {                      using (var reader = new UnbufferedIO.SequentialReader(filename))                      {                          var ints = new int[2];                            var bytesToRead = reader.Length - 8;                            // read vertex name and degree                            reader.Read(ints' 0' 2);                            var vertex = ints[0];                          var degree = ints[1];                            while (bytesToRead > 0)                          {                              // allocate space if needed                              if (ints.Length < degree + 2)                                  ints = new int[degree + 2];                                bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));                                nodeWriter.Write(vertex);                              nodeWriter.Write(degree);                                for (int i = 0; i < degree; i++)                                  edgeWriter.Write(ints[i]);                                vertex = ints[degree];                              degree = ints[degree + 1];                          }                      }                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter(File.OpenWrite(filename + "-nodes")))              {                  using (var edgeWriter = new BinaryWriter(File.OpenWrite(filename + "-edges")))                  {                      using (var reader = new UnbufferedIO.SequentialReader(filename))                      {                          var ints = new int[2];                            var bytesToRead = reader.Length - 8;                            // read vertex name and degree                            reader.Read(ints' 0' 2);                            var vertex = ints[0];                          var degree = ints[1];                            while (bytesToRead > 0)                          {                              // allocate space if needed                              if (ints.Length < degree + 2)                                  ints = new int[degree + 2];                                bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));                                nodeWriter.Write(vertex);                              nodeWriter.Write(degree);                                for (int i = 0; i < degree; i++)                                  edgeWriter.Write(ints[i]);                                vertex = ints[degree];                              degree = ints[degree + 1];                          }                      }                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter(File.OpenWrite(filename + "-nodes")))              {                  using (var edgeWriter = new BinaryWriter(File.OpenWrite(filename + "-edges")))                  {                      using (var reader = new UnbufferedIO.SequentialReader(filename))                      {                          var ints = new int[2];                            var bytesToRead = reader.Length - 8;                            // read vertex name and degree                            reader.Read(ints' 0' 2);                            var vertex = ints[0];                          var degree = ints[1];                            while (bytesToRead > 0)                          {                              // allocate space if needed                              if (ints.Length < degree + 2)                                  ints = new int[degree + 2];                                bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));                                nodeWriter.Write(vertex);                              nodeWriter.Write(degree);                                for (int i = 0; i < degree; i++)                                  edgeWriter.Write(ints[i]);                                vertex = ints[degree];                              degree = ints[degree + 1];                          }                      }                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter(File.OpenWrite(filename + "-nodes")))              {                  using (var edgeWriter = new BinaryWriter(File.OpenWrite(filename + "-edges")))                  {                      using (var reader = new UnbufferedIO.SequentialReader(filename))                      {                          var ints = new int[2];                            var bytesToRead = reader.Length - 8;                            // read vertex name and degree                            reader.Read(ints' 0' 2);                            var vertex = ints[0];                          var degree = ints[1];                            while (bytesToRead > 0)                          {                              // allocate space if needed                              if (ints.Length < degree + 2)                                  ints = new int[degree + 2];                                bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));                                nodeWriter.Write(vertex);                              nodeWriter.Write(degree);                                for (int i = 0; i < degree; i++)                                  edgeWriter.Write(ints[i]);                                vertex = ints[degree];                              degree = ints[degree + 1];                          }                      }                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter(File.OpenWrite(filename + "-nodes")))              {                  using (var edgeWriter = new BinaryWriter(File.OpenWrite(filename + "-edges")))                  {                      using (var reader = new UnbufferedIO.SequentialReader(filename))                      {                          var ints = new int[2];                            var bytesToRead = reader.Length - 8;                            // read vertex name and degree                            reader.Read(ints' 0' 2);                            var vertex = ints[0];                          var degree = ints[1];                            while (bytesToRead > 0)                          {                              // allocate space if needed                              if (ints.Length < degree + 2)                                  ints = new int[degree + 2];                                bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));                                nodeWriter.Write(vertex);                              nodeWriter.Write(degree);                                for (int i = 0; i < degree; i++)                                  edgeWriter.Write(ints[i]);                                vertex = ints[degree];                              degree = ints[degree + 1];                          }                      }                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter(File.OpenWrite(filename + "-nodes")))              {                  using (var edgeWriter = new BinaryWriter(File.OpenWrite(filename + "-edges")))                  {                      using (var reader = new UnbufferedIO.SequentialReader(filename))                      {                          var ints = new int[2];                            var bytesToRead = reader.Length - 8;                            // read vertex name and degree                            reader.Read(ints' 0' 2);                            var vertex = ints[0];                          var degree = ints[1];                            while (bytesToRead > 0)                          {                              // allocate space if needed                              if (ints.Length < degree + 2)                                  ints = new int[degree + 2];                                bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));                                nodeWriter.Write(vertex);                              nodeWriter.Write(degree);                                for (int i = 0; i < degree; i++)                                  edgeWriter.Write(ints[i]);                                vertex = ints[degree];                              degree = ints[degree + 1];                          }                      }                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter(File.OpenWrite(filename + "-nodes")))              {                  using (var edgeWriter = new BinaryWriter(File.OpenWrite(filename + "-edges")))                  {                      using (var reader = new UnbufferedIO.SequentialReader(filename))                      {                          var ints = new int[2];                            var bytesToRead = reader.Length - 8;                            // read vertex name and degree                            reader.Read(ints' 0' 2);                            var vertex = ints[0];                          var degree = ints[1];                            while (bytesToRead > 0)                          {                              // allocate space if needed                              if (ints.Length < degree + 2)                                  ints = new int[degree + 2];                                bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));                                nodeWriter.Write(vertex);                              nodeWriter.Write(degree);                                for (int i = 0; i < degree; i++)                                  edgeWriter.Write(ints[i]);                                vertex = ints[degree];                              degree = ints[degree + 1];                          }                      }                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: scanner.Scan((xUpper' yUpper' count' offset' edges) =>              {                  for (var j = offset; j < offset + count; j++)                      degrees[xUpper + ((edges[j] & 0xF0) >> 4)]++;              });
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++)              {                  var startTime = stopwatch.Elapsed;                    for (int i = 0; i < nodes; i++)                  {                      b[i] = (1.0f - reset) * a[i] / degrees[i];                      a[i] = reset;                  }                    scanner.Scan((xUpper' yUpper' count' offset' edges) =>                  {                          for (var j = offset; j < offset + count; j++)                              a[yUpper + (edges[j] & 0x0F)] += b[xUpper + ((edges[j] & 0xF0) >> 4)];                  });                    Console.WriteLine("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++)              {                  var startTime = stopwatch.Elapsed;                    for (int i = 0; i < nodes; i++)                  {                      b[i] = (1.0f - reset) * a[i] / degrees[i];                      a[i] = reset;                  }                    scanner.Scan((xUpper' yUpper' count' offset' edges) =>                  {                          for (var j = offset; j < offset + count; j++)                              a[yUpper + (edges[j] & 0x0F)] += b[xUpper + ((edges[j] & 0xF0) >> 4)];                  });                    Console.WriteLine("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertCC,The following statement contains a magic number: scanner.Scan((xUpper' yUpper' count' offset' edges) =>              {                  for (int j = 0; j < count; j++)                  {                      var source = (int)(xUpper + ((edges[offset + j] & 0xF0) >> 4));                      var target = (int)(yUpper + ((edges[offset + j] & 0x0F) >> 0));                        if (source != target)                      {                          while (source != roots[source])                              source = roots[source];                            while (target != roots[target])                              target = roots[target];                            // union(source' target)                          if (source != target)                          {                              // there may be a tie in ranks                              if (ranks[source] == ranks[target])                              {                                  // break ties towards lower ids                                  if (source < target)                                  {                                      ranks[source]++;                                      roots[target] = source;                                  }                                  else                                  {                                      ranks[target]++;                                      roots[source] = target;                                  }                              }                              else                              {                                  // attatch lower rank to higher                                  if (ranks[source] < ranks[target])                                      roots[source] = target;                                  else                                      roots[target] = source;                              }                          }                      }                  }              });
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: Console.WriteLine("{2}\tRead header of {0} blocks' for {1} edges"' metadata.Length / 3' edges.Length' stopwatch.Elapsed);
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++)              {                  var startTime = stopwatch.Elapsed;                    for (int i = 0; i < nodes; i++)                  {                      b[i] = (1.0f - reset) * a[i] / degrees[i];                      a[i] = reset;                  }                    ScanGraphHilbert(metadata' edges' (sourceUpper' targetUpper' offset' count' edgeArray) =>                  {                      for (var j = offset; j < offset + count; j++)                          a[targetUpper + (edges[j] >> 16)] += b[sourceUpper + (edges[j] & 0xFFFF)];                  });                    Console.WriteLine("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++)              {                  var startTime = stopwatch.Elapsed;                    for (int i = 0; i < nodes; i++)                  {                      b[i] = (1.0f - reset) * a[i] / degrees[i];                      a[i] = reset;                  }                    ScanGraphHilbert(metadata' edges' (sourceUpper' targetUpper' offset' count' edgeArray) =>                  {                      for (var j = offset; j < offset + count; j++)                          a[targetUpper + (edges[j] >> 16)] += b[sourceUpper + (edges[j] & 0xFFFF)];                  });                    Console.WriteLine("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: ScanGraphHilbert(filename' (srcUpper' tgtUpper' offset' count' edges) =>              {                  for (int i = 0; i < count; i++)                      degrees[srcUpper + (edges[offset + i] >> 16)]++;              });
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++)              {                  var startTime = stopwatch.Elapsed;                    ScanGraphHilbert(filename' (srcUpper' tgtUpper' offset' count' edges) =>                  {                      for (int i = 0; i < count; i++)                          a[tgtUpper + (edges[offset + i] >> 16)] += b[srcUpper + (edges[offset + i] & 0xFFFF)];                  });                    for (int i = 0; i < nodes; i++)                      a[i] = a[i] / degrees[i];                    Console.WriteLine("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++)              {                  var startTime = stopwatch.Elapsed;                    ScanGraphHilbert(filename' (srcUpper' tgtUpper' offset' count' edges) =>                  {                      for (int i = 0; i < count; i++)                          a[tgtUpper + (edges[offset + i] >> 16)] += b[srcUpper + (edges[offset + i] & 0xFFFF)];                  });                    for (int i = 0; i < nodes; i++)                      a[i] = a[i] / degrees[i];                    Console.WriteLine("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead(filenameUpper))              {                  using (var lower = System.IO.File.OpenRead(filenameLower))                  {                      var bytes = new byte[upper.Length];                      upper.Read(bytes' 0' bytes.Length);                        var uppers = new int[bytes.Length / 4];                      Buffer.BlockCopy(bytes' 0' uppers' 0' bytes.Length);                        var maxEdges = 0;                      for (int i = 0; i < uppers.Length; i += 3)                          maxEdges = Math.Max(maxEdges' uppers[i + 2]);                        Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);                        bytes = new byte[8 * maxEdges];                      var lowers = new UInt16[2 * maxEdges];                        var edges = new Int32[2 * maxEdges];    #if UseLargePages                      var roots = LargePages.AllocateInts(nodes);                      var ranks = LargePages.AllocateBytes(nodes);  #else                      var roots = new int[nodes];                      var ranks = new byte[nodes];  #endif                          for (int i = 0; i < nodes; i++)                          roots[i] = i;                        for (int i = 0; i < uppers.Length; i += 3)                      {                          var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);                          Buffer.BlockCopy(bytes' 0' lowers' 0' read);                            var sourceUpper = uppers[i + 0] << 16;                          var targetUpper = uppers[i + 1] << 16;                            var count = uppers[i + 2];                            for (int j = 0; j < count; j++)                          {                              edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];                              edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];                          }                            for (int j = 0; j < count; j++)                          {                              var source = edges[2 * j + 0];                              var target = edges[2 * j + 1];                                if (source != target)                              {                                  while (source != roots[source])                                      source = roots[source];                                    while (target != roots[target])                                      target = roots[target];                                    // union(source' target)                                  if (source != target)                                  {                                      // there may be a tie in ranks                                      if (ranks[source] == ranks[target])                                      {                                          // break ties towards lower ids                                          if (source < target)                                          {                                              ranks[source]++;                                              roots[target] = source;                                          }                                          else                                          {                                              ranks[target]++;                                              roots[source] = target;                                          }                                      }                                      else                                      {                                          // attatch lower rank to higher                                          if (ranks[source] < ranks[target])                                              roots[source] = target;                                          else                                              roots[target] = source;                                      }                                  }                              }                          }                      }                        // path compress all vertices to roots.                      for (int i = 0; i < nodes; i++)                          while (roots[i] != roots[roots[i]])                              roots[i] = roots[roots[i]];                        var counter = 0;                      for (int i = 0; i < nodes; i++)                          if (roots[i] != i)                              counter++;                        Console.WriteLine("Edges found: {0}"' counter);                  }              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind2,The following statement contains a magic number: ScanGraphHilbert(filename' (sourceUpper' targetUpper' offset' count' edges) =>              {                  for (int j = 0; j < count; j++)                  {                      var source = (int)(sourceUpper + (edges[offset + j] & 0xFFFF));                      var target = (int)(targetUpper + (edges[offset + j] >> 16));                        if (source != target)                      {                          while (source != roots[source])                              source = roots[source];                            while (target != roots[target])                              target = roots[target];                            // union(source' target)                          if (source != target)                          {                              // there may be a tie in ranks                              if (ranks[source] == ranks[target])                              {                                  // break ties towards lower ids                                  if (source < target)                                  {                                      ranks[source]++;                                      roots[target] = source;                                  }                                  else                                  {                                      ranks[target]++;                                      roots[source] = target;                                  }                              }                              else                              {                                  // attatch lower rank to higher                                  if (ranks[source] < ranks[target])                                      roots[source] = target;                                  else                                      roots[target] = source;                              }                          }                      }                  }              });
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankFromDisk,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++)              {                  var startTime = stopwatch.Elapsed;                    graph.ForEach((vertex' degree) =>                  {                      b[vertex] = (1.0f - reset) * a[vertex] / degree;                      a[vertex] = reset;                  });                    graph.ForEach((vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          a[neighbors[offset + i]] += b[vertex];                  });                    Console.WriteLine("{0}\tIteration {1}"' stopwatch.Elapsed - startTime' iteration);              }
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++)              {                  var startTime = stopwatch.Elapsed;                    for (int i = 0; i < nodes; i++)                  {                      b[i] = a[i];                      a[i] = 0.0f;                  }                    // apply per-vertex pagerank logic across the graph                  ScanGraph(nodeArray' edgeArray' (vertex' degree' offset' neighbors) =>                  {                      if (b[vertex] > 0.0f)                      {                          var update = (1.0f - reset) * b[vertex] / degree;                          for (int i = 0; i < degree; i++)                              a[neighbors[offset + i]] += update;                      }                  });                    Console.WriteLine("{0}\tIteration {1}"' stopwatch.Elapsed - startTime' iteration);              }
Magic Number,COST,UnbufferedIO,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,ReadFile,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader(filename))              {                  var result = new T[reader.Length / System.Runtime.InteropServices.Marshal.SizeOf(typeof(T))];                    // if the thing to read is bigger than 2GB' Buffer.BlockCopy will choke (yay 32 bits)                  if (((Int64)result.Length) * System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) > Int32.MaxValue)                  {                      var intermediate = new T[1 << 20];                      var cursor = 0;                        while (reader.Read(intermediate' 0' intermediate.Length) > 0)                      {                           Array.Copy(intermediate' 0' result' cursor' Math.Min(intermediate.Length' result.Length - cursor));                          cursor += intermediate.Length;                      }                  }                  else                      reader.Read(result' 0' result.Length);                    return result;              }
Magic Number,COST,SequentialWriter<T>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Close,The following statement contains a magic number: System.Buffer.BlockCopy(typedBuffer' 0' buffer' 0' offset * 4);
Magic Number,COST,SequentialWriter<T>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Close,The following statement contains a magic number: using (var file = new FileStream(filename' FileMode.Append' FileAccess.Write' FileShare.None))                      file.Write(buffer' 0' offset * 4);
Magic Number,COST,SequentialWriter<T>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialWriter,The following statement contains a magic number: target = new FileStream(filename' FileMode.OpenOrCreate' FileAccess.Write' FileShare.None' 8' FileOptions.Asynchronous | FileOptions.SequentialScan | FileOptions.WriteThrough);
Magic Number,COST,SequentialWriter<T>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialWriter,The following statement contains a magic number: results = new IAsyncResult[4];
Magic Number,COST,SequentialReader<T>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialReader,The following statement contains a magic number: source = new FileStream(filename' FileMode.OpenOrCreate' FileAccess.Read' FileShare.None' 8' FileOptions.Asynchronous | FileOptions.SequentialScan | FileOptions.WriteThrough | (FileOptions)0x20000000);
Magic Number,COST,SequentialReader<T>,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialReader,The following statement contains a magic number: requestLength = 1 << 20;
Magic Number,COST,SequentialReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialReader,The following statement contains a magic number: this.source = new FileStream(filename' FileMode.OpenOrCreate' FileAccess.Read' FileShare.ReadWrite' 8' options);
Magic Number,COST,SequentialReader,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialReader,The following statement contains a magic number: this.requestLength = 1 << 24;
Duplicate Code,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((146' 207)' (282' 343)' (413' 474))
Duplicate Code,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((146' 212)' (413' 479))
Duplicate Code,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((215' 265)' (346' 396))
