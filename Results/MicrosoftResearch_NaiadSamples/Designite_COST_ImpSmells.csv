Implementation smell,Namespace,Class,File,Method,Description
Long Method,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The method has 136 lines of code.
Long Method,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The method has 247 lines of code.
Long Method,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The method has 147 lines of code.
Long Method,COST,UnionFindVertexPacked,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The method has 105 lines of code.
Long Method,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The method has 287 lines of code.
Long Method,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method has 457 lines of code.
Complex Method,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,Cyclomatic complexity of the method is 11
Complex Method,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,Cyclomatic complexity of the method is 14
Complex Method,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,Cyclomatic complexity of the method is 10
Complex Method,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,Cyclomatic complexity of the method is 15
Complex Method,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,Cyclomatic complexity of the method is 9
Complex Method,COST,GroupEdgeVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,Cyclomatic complexity of the method is 10
Complex Method,COST,UnionFindVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,Cyclomatic complexity of the method is 11
Complex Method,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ConvertFromText,Cyclomatic complexity of the method is 8
Complex Method,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,Cyclomatic complexity of the method is 28
Complex Method,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,Cyclomatic complexity of the method is 49
Complex Method,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,Cyclomatic complexity of the method is 17
Complex Method,COST,SequentialReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Read,Cyclomatic complexity of the method is 8
Long Parameter List,COST,BufferTrie<TValue>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\BufferTrie.cs,InsertAt,The method has 5 parameters. Parameters: sourceArray' sourceOffset' sourceCount' targetPosition' targetHeight
Long Parameter List,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The method has 5 parameters. Parameters: logn' x' y' rotated' flipped
Long Parameter List,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,rot,The method has 5 parameters. Parameters: logs' x' y' rx' ry
Long Parameter List,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The method has 5 parameters. Parameters: edges' high32Stream' next16Stream' next08Stream' last08Stream
Long Parameter List,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindVertexInts,The method has 5 parameters. Parameters: index' stage' nodes' graphPartsIn' graphPartsOut
Long Parameter List,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindVertexHashTable,The method has 5 parameters. Parameters: index' stage' nodes' graphPartsIn' graphPartsOut
Long Parameter List,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStepFromDisk,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankFromDisk,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Parameter List,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The method has 5 parameters. Parameters: filename' a' b' nodes' reset
Long Statement,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The length of the statement  "                    next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]); " is 137.
Long Statement,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The length of the statement  "                    next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]); " is 135.
Long Statement,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The length of the statement  "                for (var read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort>(next16Buffer' 0' 1 << 20)) " is 138.
Long Statement,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The length of the statement  "                for (var read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte>(next08Buffer' 0' 1 << 20)) " is 134.
Long Statement,COST,NaiadImplementations,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesHierarchyPerProcess,The length of the statement  "                .NewUnaryStage((i' s) => new GroupEdgeVertex(i' s' localParts * globalParts' localParts * globalParts)' null' null' "GroupEdges"); " is 130.
Long Statement,COST,NaiadImplementations,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindStruct,The length of the statement  "            return edges.NewUnaryStage((i' s) => new UnionFindVertexInts(i' s' nodes' graphPartsIn' graphPartsOut)' null' null' "UnionFind"); " is 129.
Long Statement,COST,NaiadImplementations,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindHashTable,The length of the statement  "            return edges.NewUnaryStage((i' s) => new UnionFindVertexHashTable(i' s' nodes' graphPartsIn' graphPartsOut)' null' null' "UnionFind"); " is 134.
Long Statement,COST,GroupEdgeVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The length of the statement  "                    // the .Net array growing code throws an exception since it tries to hit 2^31 entries' so explictly allocate an array smaller " is 125.
Long Statement,COST,GroupEdgeVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The length of the statement  "                Console.WriteLine("Worker " + this.VertexId + " part " + (fetched[0].source % sourceParts) + "'" + (fetched[0].target % targetParts) + " " + part); " is 147.
Long Statement,COST,UnionFindVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The length of the statement  "                Console.WriteLine("Worker[{2}]: UnionedFound {1} edges in {0} {3} groups {4} payload"' this.stopwatch.Elapsed' edges' this.VertexId' groups' payloads); " is 151.
Long Statement,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The length of the statement  "                    batchStruct.destination = this.sourcePart % this.graphPartsOut + this.graphPartsOut * (this.targetPart % this.graphPartsOut); " is 125.
Long Statement,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The length of the statement  "                    batchStruct.destination = this.sourcePart % this.graphPartsOut + this.graphPartsOut * (this.targetPart % this.graphPartsOut); " is 125.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,WriteBinaryToFiles,The length of the statement  "            return source.WriteToFiles(format' stream => Microsoft.Research.Naiad.Frameworks.Storage.Utils.GetNaiadWriterObserver<TRecord>(stream' source.ForStage.Computation.Controller.SerializationFormat)); " is 196.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                    computation.OnFrontierChange += (x' y) => { Console.WriteLine(System.DateTime.Now + "\t" + string.Join("' "' y.NewFrontier)); System.GC.GetTotalMemory(true); }; " is 160.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                    computation.OnFrontierChange += (x' y) => { Console.WriteLine(System.DateTime.Now + "\t" + string.Join("' "' y.NewFrontier)); }; " is 128.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase))) " is 134.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                                            .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))) " is 151.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase))) " is 134.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                                            .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))) " is 151.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance(new Uri(uriBase))) " is 134.
Long Statement,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "                                            .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))) " is 151.
Long Statement,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The length of the statement  "            Console.WriteLine("{2}\tRead header of {0} blocks' for {1} edges"' metadata.Length / 3' edges.Length' stopwatch.Elapsed); " is 121.
Long Statement,COST,SequentialWriter<T>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Write,The length of the statement  "                results[(currentIO % results.Length)] = target.BeginWrite(buffer' bufferSize * (currentIO % results.Length)' bufferSize' null' null); " is 133.
Long Statement,COST,SequentialReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Read,The length of the statement  "                    Buffer.BlockCopy(this.buffer' (int)(this.position % this.buffer.Length)' dest' typeSize * (offset + copied)' typeSize * toCopy); " is 128.
Long Statement,COST,SequentialReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Read,The length of the statement  "                            results[nextReadPosition / this.requestLength] = source.BeginRead(this.buffer' nextReadPosition' this.requestLength' null' null); " is 129.
Magic Number,COST,BufferTrie<TValue>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\BufferTrie.cs,InsertAt,The following statement contains a magic number: var maxBatchSize = this.BufferLength / 8;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2d,The following statement contains a magic number: d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2d,The following statement contains a magic number: d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The following statement contains a magic number: d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The following statement contains a magic number: d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: var rx = (byte)(x >> (8 * logs)) & 0xFF;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: var ry = (byte)(y >> (8 * logs)) & 0xFF;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: d += result << (16 * logs);
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xy,The following statement contains a magic number: t /= 4;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: var trans = (d >> (logs * 16)) & 0xFFFF;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: uint rx = Inverted[2 * trans + 0];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: uint ry = Inverted[2 * trans + 1];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: x = (x << 8) + rx;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: y = (y << 8) + ry;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: results1[i] = HilbertCurve.xy2d(32' (int)testxs[i]' (int)testys[i]);
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine("Slow encode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: HilbertCurve.d2xy(32' results1[i]' out x' out y);
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine("Slow decode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine("Fast encode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine("Fast decode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Rotated = new bool[256][];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Flipped = new bool[256][];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Transformed = new ushort[256][];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Rotated[i] = new bool[256];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Flipped[i] = new bool[256];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Transformed[i] = new ushort[256];
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: var transform = (UInt16)HilbertCurve.xy2dAlt(8' i' j' ref Rotated[i][j]' ref Flipped[i][j]);
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted[2 * transform + 0] = (byte)i;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted[2 * transform + 1] = (byte)j;
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: j < 256
Magic Number,COST,HilbertCurve,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: i < 256
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: this.last08ToRead = new int[high32Buffer.Length / 2];
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next16Offset += 2 * high32count;
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next08Offset += 2 * next16count;
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: last08ToRead[i / 2] = next08count;
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: readLast08 != last08ToRead[i / 2]
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yHigh32 = (high32value & 0x0000FFFF) << 16;
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var next16count = (int)next16Buffer[next16Offset + 2 * j + 1];
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var next08count = (int)next08Buffer[next08Offset + 2 * k + 1];
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08Offset += 2 * next16count;
Magic Number,COST,MultiHilbertScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16Offset += 2 * high32count;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach((vertex' degree' offset' neighbors) =>              {                  //if (vertex < 1000000)                  {                      for (int i = 0; i < degree; i++)                      {                          var neighbor = neighbors[offset + i];                          var high32 = (uint)(HilbertCurve.xy2dByte((uint)vertex' (uint)neighbor) >> 32);                            if (!High32.ContainsKey(high32))                              High32.Add(high32' 0);                            High32[high32] = High32[high32] + 1;                      }                  }              });
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach((vertex' degree' offset' neighbors) =>                      {                          //if (vertex < 1000000)                          {                              for (int j = 0; j < degree; j++)                              {                                  var transform = HilbertCurve.xy2dByte((uint)vertex' (uint)neighbors[offset + j]);                                  if ((transform >> 32) >= pairs[lowIndex].Key && (transform >> 32) < pairs[i].Key)                                      edges[cursor++] = transform;                              }                          }                      });
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach((vertex' degree' offset' neighbors) =>                      {                          //if (vertex < 1000000)                          {                              for (int j = 0; j < degree; j++)                              {                                  var transform = HilbertCurve.xy2dByte((uint)vertex' (uint)neighbors[offset + j]);                                  if ((transform >> 32) >= pairs[lowIndex].Key && (transform >> 32) < pairs[i].Key)                                      edges[cursor++] = transform;                              }                          }                      });
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: edgeCount + pairs[i].Value > 1 << 29
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach((vertex' degree' offset' neighbors) =>              {                  //if (vertex < 1000000)                  {                      for (int j = 0; j < degree; j++)                      {                          var transform = HilbertCurve.xy2dByte((uint)vertex' (uint)neighbors[offset + j]);                            if ((transform >> 32) >= pairs[lowIndex].Key)                              edges2[cursor2++] = transform;                      }                  }              });
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var high32Prior = (uint)   ((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var next16Prior = (ushort) ((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var next08Prior = (byte)   ((x & 0x000000F0) + ((y & 0x000000F0) >> 4));
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: last08Stream.Write((byte)(((x & 0x0F) << 4) + (y & 0x0F)));
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var high32 = (uint)   ((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var next16 = (ushort) ((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: var next08 = (byte)   ((x & 0x000000F0) + ((y & 0x000000F0) >> 4));
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: last08Stream.Write((byte)(((x & 0x0F) << 4) + (y & 0x0F)));
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16Buffer = new ushort[2 * high32count];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16Buffer.Length < 2 * high32count
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: readNext16 != 2 * high32count
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16count += (int)(next16Buffer[2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08Buffer = new byte[2 * next16count];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08Buffer.Length < 2 * next16count
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: readNext08 != 2 * next16count
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08count += (int)(next08Buffer[2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yHigh32 = (high32value & 0x0000FFFF) << 16;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var xNext16 = xHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yNext16 = yHigh32 + (uint) ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16count = next16Buffer[next16Offset + 2 * j + 1];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var xNext08 = xNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: var yNext08 = yNext16 + (uint) ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08count = next08Buffer[next08Offset + 2 * k + 1];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08Offset += 2 * next16count;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var last08ToRead = new int[high32Buffer.Length / 2];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next16count += (int)(next16Buffer[next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer[next16Offset + 2 * j + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next16Offset += 2 * high32count;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next08count += (int)(next08Buffer[next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer[next08Offset + 2 * k + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next08Offset += 2 * next16count;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: last08ToRead[i / 2] = next08count;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var readLast08 = last08Reader.Read<byte>(last08Buffer' 0' last08ToRead[i / 2]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: Console.WriteLine("Read error' last08; requested {0}' read {1}"' last08ToRead[i / 2]' readLast08);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: readLast08 != last08ToRead[i / 2]
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var yHigh32 = (high32value & 0x0000FFFF) << 16;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var xNext16 = xHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var yNext16 = yHigh32 + (uint)((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var next16count = (int) next16Buffer[next16Offset + 2 * j + 1];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var xNext08 = xNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var yNext08 = yNext16 + (uint)((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: var next08count = (int) next08Buffer[next08Offset + 2 * k + 1];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next08Offset += 2 * next16count;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next16Offset += 2 * high32count;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var iDegrees = new uint[106000000];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var oDegrees = new uint[106000000];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16Buffer = new ushort[2 * high32count];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16Buffer.Length < 2 * high32count
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var readNext16 = next16Reader.Read<ushort>(next16Buffer' 0' 2 * high32count);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: Console.WriteLine("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: readNext16 != 2 * high32count
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16count += (int) (next16Buffer[2 * j + 1] == 0 ? ((uint) ushort.MaxValue) + 1 : next16Buffer[2 * j + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08Buffer = new byte[2 * next16count];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08Buffer.Length < 2 * next16count
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var readNext08 = next08Reader.Read<byte>(next08Buffer' 0' 2 * next16count);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: Console.WriteLine("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: readNext08 != 2 * next16count
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08count += (int) (next08Buffer[2 * k + 1] == 0 ? ((uint) byte.MaxValue) + 1 : next08Buffer[2 * k + 1]);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var yHigh32 = (high32value & 0x0000FFFF) << 16;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var xNext16 = xHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0xFF00) << 0);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var yNext16 = yHigh32 + ((next16Buffer[next16Offset + 2 * j] & 0x00FF) << 8);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16count = next16Buffer[next16Offset + 2 * j + 1];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var xNext08 = xNext16 + ((next08Buffer[next08Offset + 2 * k] & 0xF0) << 0);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var yNext08 = yNext16 + ((next08Buffer[next08Offset + 2 * k] & 0x0F) << 4);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08count = next08Buffer[next08Offset + 2 * k + 1];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: var x = xNext08 + ((last08Buffer[last08Offset + l] & 0xF0) >> 4);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08Offset += 2 * next16count;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: Console.WriteLine("Read {0} high32' expecting {1} next16"' high32MetaData.Length / 2' high32Counts);
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: var next16Buffer = new ushort[1 << 20];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: next16Total += read / 2;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: var next08Buffer = new byte[1 << 20];
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: next08Total += read / 2;
Magic Number,COST,HilbertConversion,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: next08Count += next08Buffer[i + 1] == 0 ? 256 : (int) next08Buffer[i + 1];
Magic Number,COST,NaiadImplementations,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,PageRank,The following statement contains a magic number: var start = degrees.Select(x => x.node.WithValue(0.15f))                                 .PartitionBy(x => x.node.index);
Magic Number,COST,NaiadImplementations,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,PageRankStep,The following statement contains a magic number: return ranks.NodeJoin(degrees' (rank' degree) => degree > 0 ? rank * (0.85f / degree) : 0.0f)                          .GraphReduce(edges' (x' y) => x + y' false)                          .Where(x => x.value > 0.0f);
Magic Number,COST,GraphReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GraphReader,The following statement contains a magic number: this.sendBuffer.payload = new Edge[256];
Magic Number,COST,GraphStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: SingleThreaded.ScanGraph(message.payload[i]' (vertex' degree' offset' edges) =>                      {                          var edgesSent = 0;                          while (edgesSent < degree)                          {                              // if not enough space for an edge' flush.                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                              {                                  this.Output.Send(sendBuffer);                                  sendBuffer.length = 0;                              }                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' degree - edgesSent);                                sendBuffer.payload[sendBuffer.length++] = vertex;                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                              Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                              sendBuffer.length += edgesToSend;                              edgesSent += edgesToSend;                          }                      });
Magic Number,COST,GraphStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: SingleThreaded.ScanGraph(message.payload[i]' (vertex' degree' offset' edges) =>                      {                          var edgesSent = 0;                          while (edgesSent < degree)                          {                              // if not enough space for an edge' flush.                              if (sendBuffer.payload.Length - sendBuffer.length < 3)                              {                                  this.Output.Send(sendBuffer);                                  sendBuffer.length = 0;                              }                                var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' degree - edgesSent);                                sendBuffer.payload[sendBuffer.length++] = vertex;                              sendBuffer.payload[sendBuffer.length++] = edgesToSend;                              Array.Copy(edges' offset + edgesSent' sendBuffer.payload' sendBuffer.length' edgesToSend);                              sendBuffer.length += edgesToSend;                              edgesSent += edgesToSend;                          }                      });
Magic Number,COST,GraphStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GraphStreamReader,The following statement contains a magic number: this.sendBuffer.payload = new int[256];
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: sendBuffer.payload = new int[256];
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: var bytes = new byte[256];
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: var nodes = new int[(bytes.Length / 4) + 1];
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: var edges = new int[(bytes.Length / 4)];
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: var nodebytesRead = nodeReader.Read(bytes' 0' 4 * (nodes.Length - 1));
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: Buffer.BlockCopy(bytes' 0' nodes' 4' nodebytesRead);
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: bytes = new byte[4 * edgesToRead];
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: edgeReader.Read(bytes' 0' 4 * edgesToRead);
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: Buffer.BlockCopy(bytes' 0' edges' 0' 4 * edgesToRead);
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: sendBuffer.payload.Length - sendBuffer.length < 3
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: var edgesToSend = Math.Min(sendBuffer.payload.Length - sendBuffer.length - 2' (degree - edgesSent));
Magic Number,COST,VertexStreamReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: i < nodebytesRead / 4
Magic Number,COST,GroupEdgeVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The following statement contains a magic number: var preFetch = new Edge[1900000000];
Magic Number,COST,GroupEdgeVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The following statement contains a magic number: bufferLength = cursors[i] + 2 + counts[sourceIndices[i]];
Magic Number,COST,GroupEdgeVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnNotify,The following statement contains a magic number: cursors[i] += 2;
Magic Number,COST,ReformatVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor += 2;
Magic Number,COST,ReformatVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: thisMessageIndex < 256
Magic Number,COST,ReformatVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: thisMessageIndex > 253
Magic Number,COST,ReformatVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: var maxDegree = 254 - thisMessageIndex;
Magic Number,COST,ReformatVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: thisMessageIndex += 2;
Magic Number,COST,ReformatVertex,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: thisMessageIndex < 256
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: bufferLength += thisCount + 2;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: counts[ssource] += 2;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: var source = buffer[i * 2];
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: var target = buffer[i * 2 + 1];
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: cursor += 2;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: thisMessageIndex < 256
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: thisMessageIndex > 253
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: var maxDegree = 254 - thisMessageIndex;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: thisMessageIndex += 2;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: thisMessageIndex < 256
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.usedCountsMaybeShared = new int[200000];
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.bufferMaybeShared = new int[1200000];
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.countStashMaybeShared = new int[200000];
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.sendBufferMaybeShared = new int[600000];
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.followedBufferMaybeShared = new int[256];
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor += 2;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor < 256 && payload[cursor] >= 0
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor += 2;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: buffer[this.bufferValid * 2] = source;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: buffer[this.bufferValid * 2 + 1] = ttarget;
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.bufferValid > 100 * 1024
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.bufferValid > 100 * 1024
Magic Number,COST,UnionFindVertexInts,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor < 256 && payload[cursor] >= 0
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: bufferLength += thisCount + 2;
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: countStash[source] += 2;
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: cursor += 2;
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: thisMessageIndex < 256
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: thisMessageIndex > 253
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: var maxDegree = 254 - thisMessageIndex;
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: thisMessageIndex += 2;
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,SendBuffer,The following statement contains a magic number: thisMessageIndex < 256
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.sendBuffer = new int[600000];
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor += 2;
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.buffer.Count > 100 * 1024
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: this.buffer.Count > 100 * 1024
Magic Number,COST,UnionFindVertexHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor < 256 && payload[cursor] >= 0
Magic Number,COST,UnionFindVertexPacked,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: int payloadLength = 256;
Magic Number,COST,UnionFindVertexPacked,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: var munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);
Magic Number,COST,UnionFindVertexPacked,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: var munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);
Magic Number,COST,UnionFindVertexPacked,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor += 2;
Magic Number,COST,UnionFindVertexPacked,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);
Magic Number,COST,UnionFindVertexPacked,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: munged = (source & 0xfff00000) | ((source & 0x000ff000) >> 12) | ((source & 0x00000fff) << 8);
Magic Number,COST,UnionFindVertexPackedHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: int payloadLength = 256;
Magic Number,COST,UnionFindVertexPackedHashTable,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,OnReceive,The following statement contains a magic number: cursor += 2;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: var ints = new int[2];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: var bytes = new byte[8];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= stream.Read(bytes' 0' 8);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy(bytes' 0' ints' 0' 8);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: ints = new int[degree + 2];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytes = new byte[ints.Length * 4];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: ints.Length < degree + 2
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= stream.Read(bytes' 0' 4 * (degree + 2));
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy(bytes' 0' ints' 0' 4 * (degree + 2));
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: args.Length < 3
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var dataset = args[2];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.PartitionGraph(twitterFile' 4' (s' t) => (s & 1) + 2 * (t & 1)' dataDir + @"twitter-part-{0}-of-{1}");
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.PartitionGraph(twitterFile' 4' (s' t) => (s & 1) + 2 * (t & 1)' dataDir + @"twitter-part-{0}-of-{1}");
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.TransposeGraph(dataDir + @"twitterfollowers\twitter_rv.bin"' 65000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var names = new uint[65000000];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var idegrees = new int[65000000];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var odegrees = new int[65000000];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var counts = new uint[1 << 20];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                          counts[HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]) >> 32]++;                  });
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var Trie = new BufferTrie<uint>(20' (array' offset' length) =>                  {                      for (int i = offset; i < offset + length; i++)                          hilbertTransformed[counts[array[i].Index]++] = array[i].Value;                  });
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var buffer = new BufferTrie<uint>.Pair[5000000];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ScanGraph(twitterFile' (vertex' degree' offset' neighbors) =>                  {                      for (int i = 0; i < degree; i++)                      {                          var result = HilbertCurve.xy2dByte(names[vertex]' names[neighbors[offset + i]]);                            buffer[i] = new BufferTrie<uint>.Pair((int)(result >> 32)' (uint)(result & 0xFFFF));                      }                        Trie.Insert(buffer' 0' degree);                  });
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: HilbertCurve.d2xyByte((i << 32)' out x' out y);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: HilbertCurve.d2xyByte((i << 32) + hilbertTransformed[j]' out x' out y);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)42000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.HilbertPagerank(@"livejournal-hilbert"' dstRanks' srcRanks' nodes' 0.85f);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)42000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.HilbertPagerank(@"twitter-hilbert"' dstRanks' srcRanks' nodes' 0.85f);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)106000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.MultiHilbertPagerank(@"uk-2007-05-hilbert"' dstRanks' srcRanks' nodes' 0.85f);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)42000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)106000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)42000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)106000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.PageRankFromDisk(ukFile' dstRanks' srcRanks' nodes' 0.85f);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)65000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.PageRankFromDisk(twitterFile' dstRanks' srcRanks' nodes' 0.85f);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: var nodes = (uint)65000000;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.PageRankStep(livejournalFile' dstRanks' srcRanks' nodes' 0.85f);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: i < 20
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ConnectedComponents(twitterFile' 65000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ClumsyCC(ukFile' 106000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ConnectedComponents(livejournalFile' 6500000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.MaximalIndependentSet(twitterFile' 65000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.MaximalIndependentSet(livejournalFile' 6500000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: var dataset = args[2];
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int parts = Int32.Parse(args[3]);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int parts = Int32.Parse(args[3]);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.ReadHdfsBinaryCollection<Edge>(new Uri(uriBase + "twitter-10"))                                 .Partition(parts' parts)                                 .WriteHdfsBinary(new Uri(uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: edges.PageRank(20' "twitter").Subscribe();
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: edges.PageRank(20' "livejournal").Subscribe();
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: var extraInput = new[] { string.Format(format' 3' 4) }.AsNaiadStream(computation)                                                     .PartitionBy(x => 3)                                                     .ReadGraph();
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph(format' 3' 4)                                 .UnionFind(106000000)                                 .PartitionBy(x => 3)                                 .Concat(extraInput)                                 .UnionFind(106000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage = firstStage                                          .UnionFindStruct(65000000' parts * machines * another' machines * another);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hhp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: i < 20
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: var firstStage = computation.NewInput(sink.NewDataSource())                                             .ReformatInts()                                             .UnionFindHashTable(65000000' parts * machines * another' machines * another);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFind(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFind(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFind(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFind(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindStruct(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFind(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindStruct(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindStruct(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFind(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: i < 20
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int parts = (args.Length > 4) ? Int32.Parse(args[4]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int machines = (args.Length > 5) ? Int32.Parse(args[5]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: int another = (args.Length > 6) ? Int32.Parse(args[6]) : 1;
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                          {                              case "sp":                                  readStuff = collection.GroupEdgesSingleProcess(parts' parts);                                  break;                                case "pp":                                  readStuff = collection.GroupEdgesPartsPerProcess(parts' parts' 16);                                  break;                                case "op":                                  readStuff = collection.GroupEdgesOnePerProcess(parts' parts' 16);                                  break;                                case "hp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines' 16);                                  break;                                case "hhp":                                  readStuff = collection.GroupEdgesHierarchyPerProcess(parts' machines * another' 16);                                  break;                                default:                                  throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                          }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage = firstStage                                          .UnionFindHashTable(65000000' parts * machines * another' machines * another);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args[3])                                  {                                      case "sp":                                          firstStage                                              .PartitionBy(x => parts * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "pp":                                          firstStage                                              .PartitionBy(x => 16 * parts)                                              .UnionFindHashTable(65000000);                                          break;                                        case "op":                                          firstStage                                              .PartitionBy(x => 16 * (parts * parts))                                              .UnionFindHashTable(65000000);                                          break;                                        case "hp":                                          if (parts * parts < 16)                                          {                                              firstStage                                                  .PartitionBy(x => 16 * x.destination + (parts * parts))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * (machines * machines))                                                  .UnionFindHashTable(65000000);                                          }                                          else                                          {                                              firstStage                                                  .PartitionBy(x => 16 * (x.destination + (machines * machines)))                                                  .UnionFindHashTable(65000000' 0' 0)                                                  .PartitionBy(x => 16 * ((machines * machines) + (machines * machines)))                                                  .UnionFindHashTable(65000000);                                          }                                          break;                                        case "hhp":                                          firstStage                                              .PartitionBy(x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines)))                                              .UnionFindHashTable(65000000' -machines * another' another)                                              .PartitionBy(x => 16 * (x.destination + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000' -another' 1)                                              .PartitionBy(x => 16 * ((another * another) + (another * another) + (machines * machines * another * another)))                                              .UnionFindHashTable(65000000);                                          break;                                        default:                                          throw new ApplicationException("Grouping type must be sp' pp' op' hp or hpp");                                  }
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: i < 20
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: edges.UnionFind(5000000)                           .PartitionBy(x => 0)                           .UnionFind(5000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: edges.UnionFind(5000000)                           .PartitionBy(x => 0)                           .UnionFind(5000000);
Magic Number,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,Main,The following statement contains a magic number: args.Length < 3
Magic Number,COST,FileGraphScanner,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: var neighbors = new int[2 * maxDegree];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: var neighbors = new int[2 * maxDegree];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: maxCount = Math.Max(maxCount' metadata[i + 2]);
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: var edges = new uint[2 * maxCount];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: var sourceUpper = metadata[i + 0] << 16;
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: var targetUpper = metadata[i + 1] << 16;
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: var count = metadata[i + 2];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: var sourceUpper = metadata[i + 0] << 16;
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: var targetUpper = metadata[i + 1] << 16;
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: var count = metadata[i + 2];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,TransposeGraph,The following statement contains a magic number: var buffer = new BufferTrie<int>.Pair[5000000];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,TransposeGraph,The following statement contains a magic number: var edgeTrie = new BufferTrie<int>(26' (array' offset' length) =>              {                  for (int i = 0; i < length; i++)                      edges[nodes[array[i].Index]++] = array[i].Value;              });
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: var ints = new int[2];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: var bytesToRead = reader.Length - 8;
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: reader.Read(ints' 0' 2);
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: ints = new int[degree + 2];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: ints.Length < degree + 2
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: bytesToRead -= 4 * reader.Read(ints' 0' (degree + 2));
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: scanner.Scan((xUpper' yUpper' count' offset' edges) =>              {                  for (var j = offset; j < offset + count; j++)                      degrees[xUpper + ((edges[j] & 0xF0) >> 4)]++;              });
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: scanner.Scan((xUpper' yUpper' count' offset' edges) =>                  {                          for (var j = offset; j < offset + count; j++)                              a[yUpper + (edges[j] & 0x0F)] += b[xUpper + ((edges[j] & 0xF0) >> 4)];                  });
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: iteration < 20
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertCC,The following statement contains a magic number: scanner.Scan((xUpper' yUpper' count' offset' edges) =>              {                  for (int j = 0; j < count; j++)                  {                      var source = (int)(xUpper + ((edges[offset + j] & 0xF0) >> 4));                      var target = (int)(yUpper + ((edges[offset + j] & 0x0F) >> 0));                        if (source != target)                      {                          while (source != roots[source])                              source = roots[source];                            while (target != roots[target])                              target = roots[target];                            // union(source' target)                          if (source != target)                          {                              // there may be a tie in ranks                              if (ranks[source] == ranks[target])                              {                                  // break ties towards lower ids                                  if (source < target)                                  {                                      ranks[source]++;                                      roots[target] = source;                                  }                                  else                                  {                                      ranks[target]++;                                      roots[source] = target;                                  }                              }                              else                              {                                  // attatch lower rank to higher                                  if (ranks[source] < ranks[target])                                      roots[source] = target;                                  else                                      roots[target] = source;                              }                          }                      }                  }              });
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: Console.WriteLine("{2}\tRead header of {0} blocks' for {1} edges"' metadata.Length / 3' edges.Length' stopwatch.Elapsed);
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: ScanGraphHilbert(metadata' edges' (sourceUpper' targetUpper' offset' count' edgeArray) =>                  {                      for (var j = offset; j < offset + count; j++)                          a[targetUpper + (edges[j] >> 16)] += b[sourceUpper + (edges[j] & 0xFFFF)];                  });
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: iteration < 20
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: ScanGraphHilbert(filename' (srcUpper' tgtUpper' offset' count' edges) =>              {                  for (int i = 0; i < count; i++)                      degrees[srcUpper + (edges[offset + i] >> 16)]++;              });
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: ScanGraphHilbert(filename' (srcUpper' tgtUpper' offset' count' edges) =>                  {                      for (int i = 0; i < count; i++)                          a[tgtUpper + (edges[offset + i] >> 16)] += b[srcUpper + (edges[offset + i] & 0xFFFF)];                  });
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: iteration < 20
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var uppers = new int[bytes.Length / 4];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: maxEdges = Math.Max(maxEdges' uppers[i + 2]);
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: Console.WriteLine("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: bytes = new byte[8 * maxEdges];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var lowers = new UInt16[2 * maxEdges];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var edges = new Int32[2 * maxEdges];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var read = lower.Read(bytes' 0' 4 * uppers[i + 2]);
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var sourceUpper = uppers[i + 0] << 16;
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var targetUpper = uppers[i + 1] << 16;
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var count = uppers[i + 2];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: edges[2 * j + 0] = roots[sourceUpper + lowers[2 * j + 0]];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: edges[2 * j + 1] = roots[targetUpper + lowers[2 * j + 1]];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var source = edges[2 * j + 0];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: var target = edges[2 * j + 1];
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind2,The following statement contains a magic number: ScanGraphHilbert(filename' (sourceUpper' targetUpper' offset' count' edges) =>              {                  for (int j = 0; j < count; j++)                  {                      var source = (int)(sourceUpper + (edges[offset + j] & 0xFFFF));                      var target = (int)(targetUpper + (edges[offset + j] >> 16));                        if (source != target)                      {                          while (source != roots[source])                              source = roots[source];                            while (target != roots[target])                              target = roots[target];                            // union(source' target)                          if (source != target)                          {                              // there may be a tie in ranks                              if (ranks[source] == ranks[target])                              {                                  // break ties towards lower ids                                  if (source < target)                                  {                                      ranks[source]++;                                      roots[target] = source;                                  }                                  else                                  {                                      ranks[target]++;                                      roots[source] = target;                                  }                              }                              else                              {                                  // attatch lower rank to higher                                  if (ranks[source] < ranks[target])                                      roots[source] = target;                                  else                                      roots[target] = source;                              }                          }                      }                  }              });
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankFromDisk,The following statement contains a magic number: iteration < 20
Magic Number,COST,SingleThreaded,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The following statement contains a magic number: iteration < 20
Magic Number,COST,UnbufferedIO,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,ReadFile,The following statement contains a magic number: var intermediate = new T[1 << 20];
Magic Number,COST,SequentialWriter<T>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Close,The following statement contains a magic number: System.Buffer.BlockCopy(typedBuffer' 0' buffer' 0' offset * 4);
Magic Number,COST,SequentialWriter<T>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,Close,The following statement contains a magic number: file.Write(buffer' 0' offset * 4);
Magic Number,COST,SequentialWriter<T>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialWriter,The following statement contains a magic number: target = new FileStream(filename' FileMode.OpenOrCreate' FileAccess.Write' FileShare.None' 8' FileOptions.Asynchronous | FileOptions.SequentialScan | FileOptions.WriteThrough);
Magic Number,COST,SequentialWriter<T>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialWriter,The following statement contains a magic number: results = new IAsyncResult[4];
Magic Number,COST,SequentialReader<T>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialReader,The following statement contains a magic number: source = new FileStream(filename' FileMode.OpenOrCreate' FileAccess.Read' FileShare.None' 8' FileOptions.Asynchronous | FileOptions.SequentialScan | FileOptions.WriteThrough | (FileOptions)0x20000000);
Magic Number,COST,SequentialReader<T>,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialReader,The following statement contains a magic number: requestLength = 1 << 20;
Magic Number,COST,SequentialReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialReader,The following statement contains a magic number: this.source = new FileStream(filename' FileMode.OpenOrCreate' FileAccess.Read' FileShare.ReadWrite' 8' options);
Magic Number,COST,SequentialReader,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,SequentialReader,The following statement contains a magic number: this.requestLength = 1 << 24;
Duplicate Code,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((146' 207)' (282' 343)' (413' 474))
Duplicate Code,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((146' 212)' (413' 479))
Duplicate Code,COST,Program,D:\research\architectureSmells\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((215' 265)' (346' 396))
