Implementation smell,Namespace,Class,File,Method,Description
Long Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The method has 248 lines of code.
Long Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method has 324 lines of code.
Complex Method,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,Cyclomatic complexity of the method is 15
Complex Method,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,Cyclomatic complexity of the method is 9
Complex Method,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,Cyclomatic complexity of the method is 16
Complex Method,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,Cyclomatic complexity of the method is 12
Complex Method,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,Cyclomatic complexity of the method is 17
Complex Method,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,Cyclomatic complexity of the method is 13
Complex Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ConvertFromText,Cyclomatic complexity of the method is 14
Complex Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ConvertFromUK2007,Cyclomatic complexity of the method is 9
Complex Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,Cyclomatic complexity of the method is 36
Complex Method,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,Cyclomatic complexity of the method is 155
Complex Method,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,Cyclomatic complexity of the method is 11
Complex Method,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertCC,Cyclomatic complexity of the method is 8
Complex Method,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,Cyclomatic complexity of the method is 26
Complex Method,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind2,Cyclomatic complexity of the method is 8
Complex Method,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ClumsyCC,Cyclomatic complexity of the method is 8
Long Parameter List,COST,BufferTrie,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\BufferTrie.cs,InsertAt,The method has 5 parameters.
Long Parameter List,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The method has 5 parameters.
Long Parameter List,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,rot,The method has 5 parameters.
Long Parameter List,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The method has 14 parameters.
Long Parameter List,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The method has 5 parameters.
Long Parameter List,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The method has 7 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,LoadGraph,The method has 5 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,LoadVertexStream,The method has 5 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,Partition,The method has 6 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesSingleProcess,The method has 6 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesPartsPerProcess,The method has 7 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesHierarchyPerProcess,The method has 7 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesOnePerProcess,The method has 7 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindStruct,The method has 6 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindHashTable,The method has 6 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,PageRank,The method has 17 parameters.
Long Parameter List,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,PageRankStep,The method has 8 parameters.
Long Parameter List,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,WriteToFiles,The method has 8 parameters.
Long Parameter List,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The method has 19 parameters.
Long Parameter List,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method has 44 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PartitionGraph,The method has 8 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,TransposeGraph,The method has 13 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The method has 15 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertCC,The method has 7 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The method has 15 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The method has 15 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind2,The method has 7 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The method has 9 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStepFromDisk,The method has 9 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankFromDisk,The method has 11 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The method has 9 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ClumsyCC,The method has 6 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConnectedComponents,The method has 6 parameters.
Long Parameter List,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MaximalIndependentSet,The method has 6 parameters.
Long Statement,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The length of the statement  "			next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]); " is 139.
Long Statement,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The length of the statement  "			next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]); " is 137.
Long Statement,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The length of the statement  "		for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) { " is 142.
Long Statement,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The length of the statement  "		for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) { " is 138.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,LoadGraph,The length of the statement  "	return Enumerable.Range (0' count).AsNaiadStream (computation).Distinct ().Select (x => string.Format (prefix' x' outof)).ReadGraph (); " is 135.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,LoadVertexStream,The length of the statement  "	return Enumerable.Range (0' count).AsNaiadStream (computation).Distinct ().Select (x => string.Format (prefix' x' outof)).ReadVertexStream (); " is 142.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,Partition,The length of the statement  "	return edges.PartitionBy (e => (e.source % sourceParts) + sourceParts * (e.target % targetParts)).NewUnaryStage ((i' s) => new SortEdgeVertex (i' s)' null' null' "SortEdges"); " is 175.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesSingleProcess,The length of the statement  "	return edges.PartitionBy (e => ((e.source % sourceParts) + sourceParts * (e.target % targetParts))).NewUnaryStage ((i' s) => new GroupEdgeVertex (i' s' sourceParts' targetParts)' null' null' "GroupEdges"); " is 205.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesPartsPerProcess,The length of the statement  "	return edges.PartitionBy (e => ((e.source % sourceParts) + threads * (e.target % targetParts))).NewUnaryStage ((i' s) => new GroupEdgeVertex (i' s' sourceParts' targetParts)' null' null' "GroupEdges"); " is 201.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesHierarchyPerProcess,The length of the statement  "	return edges.PartitionBy (e => ((e.source % globalParts) + globalParts * (e.target % globalParts)) * threads + (((e.source / globalParts) % localParts) + localParts * ((e.target / globalParts) % localParts))).NewUnaryStage ((i' s) => new GroupEdgeVertex (i' s' localParts * globalParts' localParts * globalParts)' null' null' "GroupEdges"); " is 340.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,GroupEdgesOnePerProcess,The length of the statement  "	return edges.PartitionBy (e => threads * ((e.source % sourceParts) + sourceParts * (e.target % targetParts))).NewUnaryStage ((i' s) => new GroupEdgeVertex (i' s' sourceParts' targetParts)' null' null' "GroupEdges"); " is 215.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindStruct,The length of the statement  "	return edges.NewUnaryStage ((i' s) => new UnionFindVertexInts (i' s' nodes' graphPartsIn' graphPartsOut)' null' null' "UnionFind"); " is 131.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,UnionFindHashTable,The length of the statement  "	return edges.NewUnaryStage ((i' s) => new UnionFindVertexHashTable (i' s' nodes' graphPartsIn' graphPartsOut)' null' null' "UnionFind"); " is 136.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,PageRank,The length of the statement  "		edges = edges.Select (x => x.target.WithValue (x.source)).FilterBy (degrees.Select (x => x.node)).Select (x => new Edge (x.value' x.node)); " is 139.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,PageRank,The length of the statement  "	var ranks = start.IterateAndAccumulate ((lc' deltas) => deltas.PageRankStep (lc.EnterLoop (degrees)' lc.EnterLoop (edges))' x => x.node.index' iterations' "PageRank").Concat (start)// add initial ranks in for correctness. " is 221.
Long Statement,COST,NaiadImplementations,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\NaiadImplementations.cs,PageRankStep,The length of the statement  "	return ranks.NodeJoin (degrees' (rank' degree) => degree > 0 ? rank * (0.85f / degree) : 0.0f).GraphReduce (edges' (x' y) => x + y' false).Where (x => x.value > 0.0f); " is 167.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,WriteToFiles,The length of the statement  "				writers.Add (workerid' writer (new FileStream (string.Format (format' source.ForStage.Computation.Controller.Configuration.ProcessID' workerid)' FileMode.Create' FileAccess.Read))); " is 181.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,WriteBinaryToFiles,The length of the statement  "	return source.WriteToFiles (format' stream => Microsoft.Research.Naiad.Frameworks.Storage.Utils.GetNaiadWriterObserver<TRecord> (stream' source.ForStage.Computation.Controller.SerializationFormat)); " is 198.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "			computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L); " is 208.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "				var newEdges = edges.RenameUsing (renamer' edge => edge.source).Select (x => new Edge (x.node' x.value.target)).RenameUsing (renamer' edge => edge.target).Select (x => new Edge (x.value.source' x.node)); " is 203.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "			computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000); " is 122.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "		using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) { " is 138.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "								firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000); " is 167.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "								firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000); " is 201.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "							firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000); " is 499.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "		using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) { " is 138.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "						var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another); " is 156.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "								firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000); " is 167.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "								firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000); " is 201.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "							firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000); " is 499.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "		using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) { " is 138.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "								firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000); " is 179.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "								firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000); " is 213.
Long Statement,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The length of the statement  "							firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000); " is 514.
Long Statement,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PartitionGraph,The length of the statement  "		nodeStreams [i] = new System.IO.BinaryWriter (System.IO.File.OpenWrite (string.Format (newFormat + "-nodes"' i' parts))); " is 121.
Long Statement,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PartitionGraph,The length of the statement  "		edgeStreams [i] = new System.IO.BinaryWriter (System.IO.File.OpenWrite (string.Format (newFormat + "-edges"' i' parts))); " is 121.
Long Statement,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The length of the statement  "	Console.WriteLine ("{2}\tRead header of {0} blocks' for {1} edges"' metadata.Length / 3' edges.Length' stopwatch.Elapsed); " is 122.
Magic Number,COST,BufferTrie,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\BufferTrie.cs,InsertAt,The following statement contains a magic number: if (targetHeight < this.Height) {  	var inserted = 0;  	while (inserted < sourceCount) {  		var maxBatchSize = this.BufferLength / 8;  		var available = Math.Min (sourceCount - inserted' maxBatchSize);  		var offset = (targetPosition << this.Bits) + 1;  		var shift = (this.MaxBits - this.Bits * (targetHeight + 1));  		var mask = ((1 << this.Bits) - 1);  		// move some number of records from the source array segment to partitioned buffers.  		for (int i = sourceOffset + inserted; i < sourceOffset + inserted + available; i++) {  			var childIndex = offset + ((sourceArray [i].Index >> shift) & mask);  			this.Buffer [this.ChildOffsets [childIndex]++] = sourceArray [i];  		}  		inserted += available;  		// test buffers to see if they lack space.  		for (int i = 0; i < (1 << this.Bits); i++) {  			var childIndex = (targetPosition << this.Bits) + i + 1;  			var childCount = this.ChildOffsets [childIndex] - (this.BufferLength * childIndex);  			if (childCount + maxBatchSize >= this.BufferLength) {  				this.InsertAt (this.Buffer' this.BufferLength * childIndex' childCount' childIndex' targetHeight + 1);  				this.ChildOffsets [childIndex] -= childCount;  			}  		}  	}  }  else  	this.Action (sourceArray' sourceOffset' sourceCount);  
Magic Number,COST,BufferTrie,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\BufferTrie.cs,InsertAt,The following statement contains a magic number: while (inserted < sourceCount) {  	var maxBatchSize = this.BufferLength / 8;  	var available = Math.Min (sourceCount - inserted' maxBatchSize);  	var offset = (targetPosition << this.Bits) + 1;  	var shift = (this.MaxBits - this.Bits * (targetHeight + 1));  	var mask = ((1 << this.Bits) - 1);  	// move some number of records from the source array segment to partitioned buffers.  	for (int i = sourceOffset + inserted; i < sourceOffset + inserted + available; i++) {  		var childIndex = offset + ((sourceArray [i].Index >> shift) & mask);  		this.Buffer [this.ChildOffsets [childIndex]++] = sourceArray [i];  	}  	inserted += available;  	// test buffers to see if they lack space.  	for (int i = 0; i < (1 << this.Bits); i++) {  		var childIndex = (targetPosition << this.Bits) + i + 1;  		var childCount = this.ChildOffsets [childIndex] - (this.BufferLength * childIndex);  		if (childCount + maxBatchSize >= this.BufferLength) {  			this.InsertAt (this.Buffer' this.BufferLength * childIndex' childCount' childIndex' targetHeight + 1);  			this.ChildOffsets [childIndex] -= childCount;  		}  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2d,The following statement contains a magic number: for (var logs = logn - 1; logs >= 0; logs--) {  	int rx = (x >> logs) & 1;  	int ry = (y >> logs) & 1;  	// map (0'0)' (0'1)' (1'0)' (1'1) to 00' 01' 10' 11.  	d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);  	rot (logs' ref x' ref y' rx' ry);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2d,The following statement contains a magic number: for (var logs = logn - 1; logs >= 0; logs--) {  	int rx = (x >> logs) & 1;  	int ry = (y >> logs) & 1;  	// map (0'0)' (0'1)' (1'0)' (1'1) to 00' 01' 10' 11.  	d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);  	rot (logs' ref x' ref y' rx' ry);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2d,The following statement contains a magic number: d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2d,The following statement contains a magic number: d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The following statement contains a magic number: for (var logs = logn - 1; logs >= 0; logs--) {  	uint rx = (x >> logs) & 1;  	uint ry = (y >> logs) & 1;  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 1 - rx;  		ry = 1 - ry;  	}  	// map (0'0)' (0'1)' (1'0)' (1'1) to 00' 01' 10' 11.  	d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);  	if (ry == 0) {  		if (rx == 1)  			rotated = !rotated;  		flipped = !flipped;  	}  	// rot(logs' ref x' ref y' rx' ry);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The following statement contains a magic number: for (var logs = logn - 1; logs >= 0; logs--) {  	uint rx = (x >> logs) & 1;  	uint ry = (y >> logs) & 1;  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 1 - rx;  		ry = 1 - ry;  	}  	// map (0'0)' (0'1)' (1'0)' (1'1) to 00' 01' 10' 11.  	d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);  	if (ry == 0) {  		if (rx == 1)  			rotated = !rotated;  		flipped = !flipped;  	}  	// rot(logs' ref x' ref y' rx' ry);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The following statement contains a magic number: d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dAlt,The following statement contains a magic number: d += (((Int64)1) << (2 * logs)) * ((3 * rx) ^ ry);  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: for (var logs = 3; logs >= 0; logs--) {  	// read out relevant bytes  	var rx = (byte)(x >> (8 * logs)) & 0xFF;  	var ry = (byte)(y >> (8 * logs)) & 0xFF;  	// flip and rotate bytes' if needed  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	// update flipped and rotated  	flipped = flipped ^ Flipped [rx] [ry];  	rotated = rotated ^ Rotated [rx] [ry];  	// look up the transform of these bytes  	var result = (UInt64)Transformed [rx] [ry];  	d += result << (16 * logs);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: for (var logs = 3; logs >= 0; logs--) {  	// read out relevant bytes  	var rx = (byte)(x >> (8 * logs)) & 0xFF;  	var ry = (byte)(y >> (8 * logs)) & 0xFF;  	// flip and rotate bytes' if needed  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	// update flipped and rotated  	flipped = flipped ^ Flipped [rx] [ry];  	rotated = rotated ^ Rotated [rx] [ry];  	// look up the transform of these bytes  	var result = (UInt64)Transformed [rx] [ry];  	d += result << (16 * logs);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: for (var logs = 3; logs >= 0; logs--) {  	// read out relevant bytes  	var rx = (byte)(x >> (8 * logs)) & 0xFF;  	var ry = (byte)(y >> (8 * logs)) & 0xFF;  	// flip and rotate bytes' if needed  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	// update flipped and rotated  	flipped = flipped ^ Flipped [rx] [ry];  	rotated = rotated ^ Rotated [rx] [ry];  	// look up the transform of these bytes  	var result = (UInt64)Transformed [rx] [ry];  	d += result << (16 * logs);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: for (var logs = 3; logs >= 0; logs--) {  	// read out relevant bytes  	var rx = (byte)(x >> (8 * logs)) & 0xFF;  	var ry = (byte)(y >> (8 * logs)) & 0xFF;  	// flip and rotate bytes' if needed  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	// update flipped and rotated  	flipped = flipped ^ Flipped [rx] [ry];  	rotated = rotated ^ Rotated [rx] [ry];  	// look up the transform of these bytes  	var result = (UInt64)Transformed [rx] [ry];  	d += result << (16 * logs);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,xy2dByte,The following statement contains a magic number: d += result << (16 * logs);  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xy,The following statement contains a magic number: for (logs = 0; logs < logn; logs++) {  	var rx = (int)(t >> 1) & 1;  	var ry = (int)(t ^ rx) & 1;  	rot (logs' ref x' ref y' rx' ry);  	x += rx << logs;  	y += ry << logs;  	t /= 4;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xy,The following statement contains a magic number: t /= 4;  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--) {  	var trans = (d >> (logs * 16)) & 0xFFFF;  	uint rx = Inverted [2 * trans + 0];  	uint ry = Inverted [2 * trans + 1];  	var flippedUpdate = Flipped [rx] [ry];  	var rotatedUpdate = Rotated [rx] [ry];  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	flipped = flipped ^ flippedUpdate;  	rotated = rotated ^ rotatedUpdate;  	x = (x << 8) + rx;  	y = (y << 8) + ry;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--) {  	var trans = (d >> (logs * 16)) & 0xFFFF;  	uint rx = Inverted [2 * trans + 0];  	uint ry = Inverted [2 * trans + 1];  	var flippedUpdate = Flipped [rx] [ry];  	var rotatedUpdate = Rotated [rx] [ry];  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	flipped = flipped ^ flippedUpdate;  	rotated = rotated ^ rotatedUpdate;  	x = (x << 8) + rx;  	y = (y << 8) + ry;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--) {  	var trans = (d >> (logs * 16)) & 0xFFFF;  	uint rx = Inverted [2 * trans + 0];  	uint ry = Inverted [2 * trans + 1];  	var flippedUpdate = Flipped [rx] [ry];  	var rotatedUpdate = Rotated [rx] [ry];  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	flipped = flipped ^ flippedUpdate;  	rotated = rotated ^ rotatedUpdate;  	x = (x << 8) + rx;  	y = (y << 8) + ry;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--) {  	var trans = (d >> (logs * 16)) & 0xFFFF;  	uint rx = Inverted [2 * trans + 0];  	uint ry = Inverted [2 * trans + 1];  	var flippedUpdate = Flipped [rx] [ry];  	var rotatedUpdate = Rotated [rx] [ry];  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	flipped = flipped ^ flippedUpdate;  	rotated = rotated ^ rotatedUpdate;  	x = (x << 8) + rx;  	y = (y << 8) + ry;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--) {  	var trans = (d >> (logs * 16)) & 0xFFFF;  	uint rx = Inverted [2 * trans + 0];  	uint ry = Inverted [2 * trans + 1];  	var flippedUpdate = Flipped [rx] [ry];  	var rotatedUpdate = Rotated [rx] [ry];  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	flipped = flipped ^ flippedUpdate;  	rotated = rotated ^ rotatedUpdate;  	x = (x << 8) + rx;  	y = (y << 8) + ry;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: for (int logs = 3; logs >= 0; logs--) {  	var trans = (d >> (logs * 16)) & 0xFFFF;  	uint rx = Inverted [2 * trans + 0];  	uint ry = Inverted [2 * trans + 1];  	var flippedUpdate = Flipped [rx] [ry];  	var rotatedUpdate = Rotated [rx] [ry];  	if (flipped) {  		var t = rx;  		rx = ry;  		ry = t;  	}  	if (rotated) {  		rx = 0xFF - rx;  		ry = 0xFF - ry;  	}  	flipped = flipped ^ flippedUpdate;  	rotated = rotated ^ rotatedUpdate;  	x = (x << 8) + rx;  	y = (y << 8) + ry;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: x = (x << 8) + rx;  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,d2xyByte,The following statement contains a magic number: y = (y << 8) + ry;  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: for (int i = 0; i < tests; i++)  	results1 [i] = HilbertCurve.xy2d (32' (int)testxs [i]' (int)testys [i]);  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: results1 [i] = HilbertCurve.xy2d (32' (int)testxs [i]' (int)testys [i]);  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine ("Slow encode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: for (int i = 0; i < tests; i++) {  	int x = 0' y = 0;  	HilbertCurve.d2xy (32' results1 [i]' out x' out y);  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: HilbertCurve.d2xy (32' results1 [i]' out x' out y);  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine ("Slow decode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine ("Fast encode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Test,The following statement contains a magic number: Console.WriteLine ("Fast decode:\t{0:0.00}ns/record"' stopwatch.ElapsedMilliseconds / (tests / 1000000.0));  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Rotated = new bool[256][];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Flipped = new bool[256][];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Transformed = new ushort[256][];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted = new byte[256 * 256 * 2];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	Rotated [i] = new bool[256];  	Flipped [i] = new bool[256];  	Transformed [i] = new ushort[256];  	for (uint j = 0; j < 256; j++) {  		var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  		Transformed [i] [j] = transform;  		Inverted [2 * transform + 0] = (byte)i;  		Inverted [2 * transform + 1] = (byte)j;  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	Rotated [i] = new bool[256];  	Flipped [i] = new bool[256];  	Transformed [i] = new ushort[256];  	for (uint j = 0; j < 256; j++) {  		var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  		Transformed [i] [j] = transform;  		Inverted [2 * transform + 0] = (byte)i;  		Inverted [2 * transform + 1] = (byte)j;  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	Rotated [i] = new bool[256];  	Flipped [i] = new bool[256];  	Transformed [i] = new ushort[256];  	for (uint j = 0; j < 256; j++) {  		var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  		Transformed [i] [j] = transform;  		Inverted [2 * transform + 0] = (byte)i;  		Inverted [2 * transform + 1] = (byte)j;  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	Rotated [i] = new bool[256];  	Flipped [i] = new bool[256];  	Transformed [i] = new ushort[256];  	for (uint j = 0; j < 256; j++) {  		var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  		Transformed [i] [j] = transform;  		Inverted [2 * transform + 0] = (byte)i;  		Inverted [2 * transform + 1] = (byte)j;  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	Rotated [i] = new bool[256];  	Flipped [i] = new bool[256];  	Transformed [i] = new ushort[256];  	for (uint j = 0; j < 256; j++) {  		var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  		Transformed [i] [j] = transform;  		Inverted [2 * transform + 0] = (byte)i;  		Inverted [2 * transform + 1] = (byte)j;  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	Rotated [i] = new bool[256];  	Flipped [i] = new bool[256];  	Transformed [i] = new ushort[256];  	for (uint j = 0; j < 256; j++) {  		var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  		Transformed [i] [j] = transform;  		Inverted [2 * transform + 0] = (byte)i;  		Inverted [2 * transform + 1] = (byte)j;  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	Rotated [i] = new bool[256];  	Flipped [i] = new bool[256];  	Transformed [i] = new ushort[256];  	for (uint j = 0; j < 256; j++) {  		var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  		Transformed [i] [j] = transform;  		Inverted [2 * transform + 0] = (byte)i;  		Inverted [2 * transform + 1] = (byte)j;  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	Rotated [i] = new bool[256];  	Flipped [i] = new bool[256];  	Transformed [i] = new ushort[256];  	for (uint j = 0; j < 256; j++) {  		var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  		Transformed [i] [j] = transform;  		Inverted [2 * transform + 0] = (byte)i;  		Inverted [2 * transform + 1] = (byte)j;  	}  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Rotated [i] = new bool[256];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Flipped [i] = new bool[256];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Transformed [i] = new ushort[256];  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint j = 0; j < 256; j++) {  	var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  	Transformed [i] [j] = transform;  	Inverted [2 * transform + 0] = (byte)i;  	Inverted [2 * transform + 1] = (byte)j;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint j = 0; j < 256; j++) {  	var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  	Transformed [i] [j] = transform;  	Inverted [2 * transform + 0] = (byte)i;  	Inverted [2 * transform + 1] = (byte)j;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint j = 0; j < 256; j++) {  	var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  	Transformed [i] [j] = transform;  	Inverted [2 * transform + 0] = (byte)i;  	Inverted [2 * transform + 1] = (byte)j;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: for (uint j = 0; j < 256; j++) {  	var transform = (UInt16)HilbertCurve.xy2dAlt (8' i' j' ref Rotated [i] [j]' ref Flipped [i] [j]);  	Transformed [i] [j] = transform;  	Inverted [2 * transform + 0] = (byte)i;  	Inverted [2 * transform + 1] = (byte)j;  }  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted [2 * transform + 0] = (byte)i;  
Magic Number,COST,HilbertCurve,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,HilbertCurve,The following statement contains a magic number: Inverted [2 * transform + 1] = (byte)j;  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: this.last08ToRead = new int[high32Buffer.Length / 2];  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: i += 2
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int j = 0; j < high32count; j++)  	next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int j = 0; j < high32count; j++)  	next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next16Offset += 2 * high32count;  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int k = 0; k < next16count; k++)  	next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: for (int k = 0; k < next16count; k++)  	next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: next08Offset += 2 * next16count;  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,MultiHilbertScanner,The following statement contains a magic number: last08ToRead [i / 2] = next08count;  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: using (var last08Reader = new UnbufferedIO.SequentialReader (prefix + "-last08")) {  	for (int i = 0; i < high32Buffer.Length; i += 2) {  		var high32value = high32Buffer [i];  		var high32count = (int)high32Buffer [i + 1];  		var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  		if (readLast08 != last08ToRead [i / 2])  			Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  		var last08Offset = 0;  		// do work for all these dudes  		var xHigh32 = (high32value & 0xFFFF0000) << 0;  		var yHigh32 = (high32value & 0x0000FFFF) << 16;  		for (int j = 0; j < high32count; j++) {  			var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  			var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  			var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  			if (next16count == 0)  				next16count = ((int)ushort.MaxValue) + 1;  			for (int k = 0; k < next16count; k++) {  				var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  				var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  				var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  				if (next08count == 0)  					next08count = ((int)byte.MaxValue) + 1;  				perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  				last08Offset += next08count;  			}  			next08Offset += 2 * next16count;  		}  		next16Offset += 2 * high32count;  	}  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: i += 2
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (readLast08 != last08ToRead [i / 2])  	Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (readLast08 != last08ToRead [i / 2])  	Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08Offset += 2 * next16count;  
Magic Number,COST,MultiHilbertScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16Offset += 2 * high32count;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach ((vertex' degree' offset' neighbors) =>  {  	//if (vertex < 1000000)  	{  		for (int i = 0; i < degree; i++) {  			var neighbor = neighbors [offset + i];  			var high32 = (uint)(HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbor) >> 32);  			if (!High32.ContainsKey (high32))  				High32.Add (high32' 0);  			High32 [high32] = High32 [high32] + 1;  		}  	}  });  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (int i = 0; i < degree; i++) {  	var neighbor = neighbors [offset + i];  	var high32 = (uint)(HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbor) >> 32);  	if (!High32.ContainsKey (high32))  		High32.Add (high32' 0);  	High32 [high32] = High32 [high32] + 1;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (uint i = 0; i < pairs.Length; i++) {  	// if we would have too many edges' do work  	if (edgeCount + pairs [i].Value > 1 << 29) {  		var edges = new ulong[edgeCount];  		var cursor = 0;  		graph.ForEach ((vertex' degree' offset' neighbors) =>  {  			//if (vertex < 1000000)  			{  				for (int j = 0; j < degree; j++) {  					var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  					if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  						edges [cursor++] = transform;  				}  			}  		});  		if (cursor != edges.Length)  			Console.WriteLine ("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);  		Array.Sort (edges);  		Console.WriteLine ("About to process {0} high32 blocks"' i - lowIndex);  		// traverse edges in order and write out when interesting things happen.  		WriteTransformed (edges' high32Stream' next16Stream' next08Stream' last08Stream);  		edgeCount = 0;  		lowIndex = i;  	}  	edgeCount += pairs [i].Value;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (uint i = 0; i < pairs.Length; i++) {  	// if we would have too many edges' do work  	if (edgeCount + pairs [i].Value > 1 << 29) {  		var edges = new ulong[edgeCount];  		var cursor = 0;  		graph.ForEach ((vertex' degree' offset' neighbors) =>  {  			//if (vertex < 1000000)  			{  				for (int j = 0; j < degree; j++) {  					var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  					if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  						edges [cursor++] = transform;  				}  			}  		});  		if (cursor != edges.Length)  			Console.WriteLine ("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);  		Array.Sort (edges);  		Console.WriteLine ("About to process {0} high32 blocks"' i - lowIndex);  		// traverse edges in order and write out when interesting things happen.  		WriteTransformed (edges' high32Stream' next16Stream' next08Stream' last08Stream);  		edgeCount = 0;  		lowIndex = i;  	}  	edgeCount += pairs [i].Value;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (uint i = 0; i < pairs.Length; i++) {  	// if we would have too many edges' do work  	if (edgeCount + pairs [i].Value > 1 << 29) {  		var edges = new ulong[edgeCount];  		var cursor = 0;  		graph.ForEach ((vertex' degree' offset' neighbors) =>  {  			//if (vertex < 1000000)  			{  				for (int j = 0; j < degree; j++) {  					var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  					if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  						edges [cursor++] = transform;  				}  			}  		});  		if (cursor != edges.Length)  			Console.WriteLine ("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);  		Array.Sort (edges);  		Console.WriteLine ("About to process {0} high32 blocks"' i - lowIndex);  		// traverse edges in order and write out when interesting things happen.  		WriteTransformed (edges' high32Stream' next16Stream' next08Stream' last08Stream);  		edgeCount = 0;  		lowIndex = i;  	}  	edgeCount += pairs [i].Value;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: if (edgeCount + pairs [i].Value > 1 << 29) {  	var edges = new ulong[edgeCount];  	var cursor = 0;  	graph.ForEach ((vertex' degree' offset' neighbors) =>  {  		//if (vertex < 1000000)  		{  			for (int j = 0; j < degree; j++) {  				var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  				if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  					edges [cursor++] = transform;  			}  		}  	});  	if (cursor != edges.Length)  		Console.WriteLine ("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);  	Array.Sort (edges);  	Console.WriteLine ("About to process {0} high32 blocks"' i - lowIndex);  	// traverse edges in order and write out when interesting things happen.  	WriteTransformed (edges' high32Stream' next16Stream' next08Stream' last08Stream);  	edgeCount = 0;  	lowIndex = i;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: if (edgeCount + pairs [i].Value > 1 << 29) {  	var edges = new ulong[edgeCount];  	var cursor = 0;  	graph.ForEach ((vertex' degree' offset' neighbors) =>  {  		//if (vertex < 1000000)  		{  			for (int j = 0; j < degree; j++) {  				var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  				if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  					edges [cursor++] = transform;  			}  		}  	});  	if (cursor != edges.Length)  		Console.WriteLine ("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);  	Array.Sort (edges);  	Console.WriteLine ("About to process {0} high32 blocks"' i - lowIndex);  	// traverse edges in order and write out when interesting things happen.  	WriteTransformed (edges' high32Stream' next16Stream' next08Stream' last08Stream);  	edgeCount = 0;  	lowIndex = i;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: if (edgeCount + pairs [i].Value > 1 << 29) {  	var edges = new ulong[edgeCount];  	var cursor = 0;  	graph.ForEach ((vertex' degree' offset' neighbors) =>  {  		//if (vertex < 1000000)  		{  			for (int j = 0; j < degree; j++) {  				var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  				if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  					edges [cursor++] = transform;  			}  		}  	});  	if (cursor != edges.Length)  		Console.WriteLine ("Somehow read the wrong number of edges {0} vs {1}"' cursor' edges.Length);  	Array.Sort (edges);  	Console.WriteLine ("About to process {0} high32 blocks"' i - lowIndex);  	// traverse edges in order and write out when interesting things happen.  	WriteTransformed (edges' high32Stream' next16Stream' next08Stream' last08Stream);  	edgeCount = 0;  	lowIndex = i;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach ((vertex' degree' offset' neighbors) =>  {  	//if (vertex < 1000000)  	{  		for (int j = 0; j < degree; j++) {  			var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  			if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  				edges [cursor++] = transform;  		}  	}  });  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach ((vertex' degree' offset' neighbors) =>  {  	//if (vertex < 1000000)  	{  		for (int j = 0; j < degree; j++) {  			var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  			if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  				edges [cursor++] = transform;  		}  	}  });  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (int j = 0; j < degree; j++) {  	var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  	if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  		edges [cursor++] = transform;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (int j = 0; j < degree; j++) {  	var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  	if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  		edges [cursor++] = transform;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  	edges [cursor++] = transform;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: if ((transform >> 32) >= pairs [lowIndex].Key && (transform >> 32) < pairs [i].Key)  	edges [cursor++] = transform;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: graph.ForEach ((vertex' degree' offset' neighbors) =>  {  	//if (vertex < 1000000)  	{  		for (int j = 0; j < degree; j++) {  			var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  			if ((transform >> 32) >= pairs [lowIndex].Key)  				edges2 [cursor2++] = transform;  		}  	}  });  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: for (int j = 0; j < degree; j++) {  	var transform = HilbertCurve.xy2dByte ((uint)vertex' (uint)neighbors [offset + j]);  	if ((transform >> 32) >= pairs [lowIndex].Key)  		edges2 [cursor2++] = transform;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ConvertToHilbert,The following statement contains a magic number: if ((transform >> 32) >= pairs [lowIndex].Key)  	edges2 [cursor2++] = transform;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: last08Stream.Write ((byte)(((x & 0x0F) << 4) + (y & 0x0F)));  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: for (int i = 1; i < edges.Length; i++) {  	// recover x and y' to interleave their bits  	HilbertCurve.d2xyByte (edges [i]' out x' out y);  	var high32 = (uint)((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));  	var next16 = (ushort)((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));  	var next08 = (byte)((x & 0x000000F0) + ((y & 0x000000F0) >> 4));  	// changes in bits call for writing out  	var high32Change = high32 != high32Prior;  	var next16Change = high32Change || (next16 != next16Prior);  	var next08Change = next16Change || (next08 != next08Prior);  	// write high 32' reset high32count  	if (high32Change) {  		high32Stream.Write (high32Prior);  		high32Stream.Write (high32Count);  		high32Prior = high32;  		high32Count = 0;  	}  	// write next 16' reset nex16count' bump high32count  	if (next16Change) {  		next16Stream.Write (next16Prior);  		next16Stream.Write ((ushort)next16Count);  		high32Count++;  		next16Prior = next16;  		next16Count = 0;  	}  	// write next 08' reset next08count' bump next16count  	if (next08Change) {  		next08Stream.Write (next08Prior);  		next08Stream.Write ((byte)next08Count);  		next16Count++;  		next08Prior = next08;  		next08Count = 0;  	}  	// always write the last byte' bump next08count  	last08Stream.Write ((byte)(((x & 0x0F) << 4) + (y & 0x0F)));  	next08Count++;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: for (int i = 1; i < edges.Length; i++) {  	// recover x and y' to interleave their bits  	HilbertCurve.d2xyByte (edges [i]' out x' out y);  	var high32 = (uint)((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));  	var next16 = (ushort)((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));  	var next08 = (byte)((x & 0x000000F0) + ((y & 0x000000F0) >> 4));  	// changes in bits call for writing out  	var high32Change = high32 != high32Prior;  	var next16Change = high32Change || (next16 != next16Prior);  	var next08Change = next16Change || (next08 != next08Prior);  	// write high 32' reset high32count  	if (high32Change) {  		high32Stream.Write (high32Prior);  		high32Stream.Write (high32Count);  		high32Prior = high32;  		high32Count = 0;  	}  	// write next 16' reset nex16count' bump high32count  	if (next16Change) {  		next16Stream.Write (next16Prior);  		next16Stream.Write ((ushort)next16Count);  		high32Count++;  		next16Prior = next16;  		next16Count = 0;  	}  	// write next 08' reset next08count' bump next16count  	if (next08Change) {  		next08Stream.Write (next08Prior);  		next08Stream.Write ((byte)next08Count);  		next16Count++;  		next08Prior = next08;  		next08Count = 0;  	}  	// always write the last byte' bump next08count  	last08Stream.Write ((byte)(((x & 0x0F) << 4) + (y & 0x0F)));  	next08Count++;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: for (int i = 1; i < edges.Length; i++) {  	// recover x and y' to interleave their bits  	HilbertCurve.d2xyByte (edges [i]' out x' out y);  	var high32 = (uint)((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));  	var next16 = (ushort)((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));  	var next08 = (byte)((x & 0x000000F0) + ((y & 0x000000F0) >> 4));  	// changes in bits call for writing out  	var high32Change = high32 != high32Prior;  	var next16Change = high32Change || (next16 != next16Prior);  	var next08Change = next16Change || (next08 != next08Prior);  	// write high 32' reset high32count  	if (high32Change) {  		high32Stream.Write (high32Prior);  		high32Stream.Write (high32Count);  		high32Prior = high32;  		high32Count = 0;  	}  	// write next 16' reset nex16count' bump high32count  	if (next16Change) {  		next16Stream.Write (next16Prior);  		next16Stream.Write ((ushort)next16Count);  		high32Count++;  		next16Prior = next16;  		next16Count = 0;  	}  	// write next 08' reset next08count' bump next16count  	if (next08Change) {  		next08Stream.Write (next08Prior);  		next08Stream.Write ((byte)next08Count);  		next16Count++;  		next08Prior = next08;  		next08Count = 0;  	}  	// always write the last byte' bump next08count  	last08Stream.Write ((byte)(((x & 0x0F) << 4) + (y & 0x0F)));  	next08Count++;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: for (int i = 1; i < edges.Length; i++) {  	// recover x and y' to interleave their bits  	HilbertCurve.d2xyByte (edges [i]' out x' out y);  	var high32 = (uint)((x & 0xFFFF0000) + ((y & 0xFFFF0000) >> 16));  	var next16 = (ushort)((x & 0x0000FF00) + ((y & 0x0000FF00) >> 8));  	var next08 = (byte)((x & 0x000000F0) + ((y & 0x000000F0) >> 4));  	// changes in bits call for writing out  	var high32Change = high32 != high32Prior;  	var next16Change = high32Change || (next16 != next16Prior);  	var next08Change = next16Change || (next08 != next08Prior);  	// write high 32' reset high32count  	if (high32Change) {  		high32Stream.Write (high32Prior);  		high32Stream.Write (high32Count);  		high32Prior = high32;  		high32Count = 0;  	}  	// write next 16' reset nex16count' bump high32count  	if (next16Change) {  		next16Stream.Write (next16Prior);  		next16Stream.Write ((ushort)next16Count);  		high32Count++;  		next16Prior = next16;  		next16Count = 0;  	}  	// write next 08' reset next08count' bump next16count  	if (next08Change) {  		next08Stream.Write (next08Prior);  		next08Stream.Write ((byte)next08Count);  		next16Count++;  		next08Prior = next08;  		next08Count = 0;  	}  	// always write the last byte' bump next08count  	last08Stream.Write ((byte)(((x & 0x0F) << 4) + (y & 0x0F)));  	next08Count++;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,WriteTransformed,The following statement contains a magic number: last08Stream.Write ((byte)(((x & 0x0F) << 4) + (y & 0x0F)));  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: i += 2
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (next16Buffer.Length < 2 * high32count)  	next16Buffer = new ushort[2 * high32count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (next16Buffer.Length < 2 * high32count)  	next16Buffer = new ushort[2 * high32count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16Buffer = new ushort[2 * high32count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (readNext16 != 2 * high32count)  	Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (readNext16 != 2 * high32count)  	Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++)  	next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++)  	next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (next08Buffer.Length < 2 * next16count)  	next08Buffer = new byte[2 * next16count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (next08Buffer.Length < 2 * next16count)  	next08Buffer = new byte[2 * next16count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08Buffer = new byte[2 * next16count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (readNext08 != 2 * next16count)  	Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: if (readNext08 != 2 * next16count)  	Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++)  	next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++)  	next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next16count = next16Buffer [next16Offset + 2 * j + 1];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08count = next08Buffer [next08Offset + 2 * k + 1];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,Scan,The following statement contains a magic number: next08Offset += 2 * next16count;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  	next16Offset += 2 * high32count;  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  	next08Offset += 2 * next16count;  	last08ToRead [i / 2] = next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: i += 2
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++)  	next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++)  	next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next16count += (int)(next16Buffer [next16Offset + 2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [next16Offset + 2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next16Offset += 2 * high32count;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int k = 0; k < next16count; k++)  	next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int k = 0; k < next16count; k++)  	next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next08count += (int)(next08Buffer [next08Offset + 2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [next08Offset + 2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next08Offset += 2 * next16count;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: last08ToRead [i / 2] = next08count;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int i = 0; i < high32Buffer.Length; i += 2) {  	var high32value = high32Buffer [i];  	var high32count = (int)high32Buffer [i + 1];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' last08ToRead [i / 2]);  	if (readLast08 != last08ToRead [i / 2])  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  	next16Offset += 2 * high32count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: i += 2
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: if (readLast08 != last08ToRead [i / 2])  	Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: if (readLast08 != last08ToRead [i / 2])  	Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: Console.WriteLine ("Read error' last08; requested {0}' read {1}"' last08ToRead [i / 2]' readLast08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + (uint)((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	var next16count = (int)next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + (uint)((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	var next08count = (int)next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	perEdgeAction (xNext08' yNext08' next08count' last08Offset' last08Buffer);  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next08Offset += 2 * next16count;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,ScanAlt,The following statement contains a magic number: next16Offset += 2 * high32count;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2) {  	var high32value = high32MetaData [i];  	var high32count = (int)high32MetaData [i + 1];  	if (next16Buffer.Length < 2 * high32count)  		next16Buffer = new ushort[2 * high32count];  	var readNext16 = next16Reader.Read<ushort> (next16Buffer' 0' 2 * high32count);  	if (readNext16 != 2 * high32count)  		Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  	var next16count = 0;  	for (int j = 0; j < high32count; j++)  		next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  	if (next08Buffer.Length < 2 * next16count)  		next08Buffer = new byte[2 * next16count];  	var readNext08 = next08Reader.Read<byte> (next08Buffer' 0' 2 * next16count);  	if (readNext08 != 2 * next16count)  		Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  	var next08count = 0;  	for (int k = 0; k < next16count; k++)  		next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  	if (last08Buffer.Length < next08count)  		last08Buffer = new byte[next08count];  	var readLast08 = last08Reader.Read<byte> (last08Buffer' 0' next08count);  	if (readLast08 != next08count)  		Console.WriteLine ("Read error' last08; requested {0}' read {1}"' next08count' readLast08);  	var next16Offset = 0;  	var next08Offset = 0;  	var last08Offset = 0;  	// do work for all these dudes  	var xHigh32 = (high32value & 0xFFFF0000) << 0;  	var yHigh32 = (high32value & 0x0000FFFF) << 16;  	for (int j = 0; j < high32count; j++) {  		var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  		var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  		next16count = next16Buffer [next16Offset + 2 * j + 1];  		if (next16count == 0)  			next16count = ((int)ushort.MaxValue) + 1;  		for (int k = 0; k < next16count; k++) {  			var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  			var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  			next08count = next08Buffer [next08Offset + 2 * k + 1];  			if (next08count == 0)  				next08count = ((int)byte.MaxValue) + 1;  			for (int l = 0; l < next08count; l++) {  				var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  				var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  				iDegrees [y]++;  				oDegrees [x]++;  				edgeCount++;  			}  			last08Offset += next08count;  		}  		next08Offset += 2 * next16count;  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: i += 2
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: if (next16Buffer.Length < 2 * high32count)  	next16Buffer = new ushort[2 * high32count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: if (next16Buffer.Length < 2 * high32count)  	next16Buffer = new ushort[2 * high32count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16Buffer = new ushort[2 * high32count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: if (readNext16 != 2 * high32count)  	Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: if (readNext16 != 2 * high32count)  	Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: Console.WriteLine ("Read error' next16; requested {0}' read {1}"' 2 * high32count' readNext16);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++)  	next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++)  	next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16count += (int)(next16Buffer [2 * j + 1] == 0 ? ((uint)ushort.MaxValue) + 1 : next16Buffer [2 * j + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: if (next08Buffer.Length < 2 * next16count)  	next08Buffer = new byte[2 * next16count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: if (next08Buffer.Length < 2 * next16count)  	next08Buffer = new byte[2 * next16count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08Buffer = new byte[2 * next16count];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: if (readNext08 != 2 * next16count)  	Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: if (readNext08 != 2 * next16count)  	Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: Console.WriteLine ("Read error' next08; requested {0}' read {1}"' 2 * next16count' readNext08);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int k = 0; k < next16count; k++)  	next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int k = 0; k < next16count; k++)  	next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08count += (int)(next08Buffer [2 * k + 1] == 0 ? ((uint)byte.MaxValue) + 1 : next08Buffer [2 * k + 1]);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int j = 0; j < high32count; j++) {  	var xNext16 = xHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0xFF00) << 0);  	var yNext16 = yHigh32 + ((next16Buffer [next16Offset + 2 * j] & 0x00FF) << 8);  	next16count = next16Buffer [next16Offset + 2 * j + 1];  	if (next16count == 0)  		next16count = ((int)ushort.MaxValue) + 1;  	for (int k = 0; k < next16count; k++) {  		var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  		var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  		next08count = next08Buffer [next08Offset + 2 * k + 1];  		if (next08count == 0)  			next08count = ((int)byte.MaxValue) + 1;  		for (int l = 0; l < next08count; l++) {  			var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  			var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  			iDegrees [y]++;  			oDegrees [x]++;  			edgeCount++;  		}  		last08Offset += next08count;  	}  	next08Offset += 2 * next16count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next16count = next16Buffer [next16Offset + 2 * j + 1];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	for (int l = 0; l < next08count; l++) {  		var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  		var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  		iDegrees [y]++;  		oDegrees [x]++;  		edgeCount++;  	}  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	for (int l = 0; l < next08count; l++) {  		var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  		var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  		iDegrees [y]++;  		oDegrees [x]++;  		edgeCount++;  	}  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	for (int l = 0; l < next08count; l++) {  		var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  		var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  		iDegrees [y]++;  		oDegrees [x]++;  		edgeCount++;  	}  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	for (int l = 0; l < next08count; l++) {  		var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  		var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  		iDegrees [y]++;  		oDegrees [x]++;  		edgeCount++;  	}  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int k = 0; k < next16count; k++) {  	var xNext08 = xNext16 + ((next08Buffer [next08Offset + 2 * k] & 0xF0) << 0);  	var yNext08 = yNext16 + ((next08Buffer [next08Offset + 2 * k] & 0x0F) << 4);  	next08count = next08Buffer [next08Offset + 2 * k + 1];  	if (next08count == 0)  		next08count = ((int)byte.MaxValue) + 1;  	for (int l = 0; l < next08count; l++) {  		var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  		var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  		iDegrees [y]++;  		oDegrees [x]++;  		edgeCount++;  	}  	last08Offset += next08count;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08count = next08Buffer [next08Offset + 2 * k + 1];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: for (int l = 0; l < next08count; l++) {  	var x = xNext08 + ((last08Buffer [last08Offset + l] & 0xF0) >> 4);  	var y = yNext08 + ((last08Buffer [last08Offset + l] & 0x0F) >> 0);  	iDegrees [y]++;  	oDegrees [x]++;  	edgeCount++;  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformed,The following statement contains a magic number: next08Offset += 2 * next16count;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (int i = 0; i < high32MetaData.Length; i += 2)  	high32Counts += high32MetaData [i + 1];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: i += 2
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: Console.WriteLine ("Read {0} high32' expecting {1} next16"' high32MetaData.Length / 2' high32Counts);  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next16Reader = new UnbufferedIO.SequentialReader (prefix + "-next16")) {  	for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) {  		next16Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next16Count += next16Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next16Reader = new UnbufferedIO.SequentialReader (prefix + "-next16")) {  	for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) {  		next16Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next16Count += next16Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next16Reader = new UnbufferedIO.SequentialReader (prefix + "-next16")) {  	for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) {  		next16Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next16Count += next16Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next16Reader = new UnbufferedIO.SequentialReader (prefix + "-next16")) {  	for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) {  		next16Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next16Count += next16Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) {  	next16Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next16Count += next16Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) {  	next16Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next16Count += next16Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) {  	next16Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next16Count += next16Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20); read > 0; read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)) {  	next16Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next16Count += next16Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: read = next16Reader.Read<ushort> (next16Buffer' 0' 1 << 20)
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: next16Total += read / 2;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (int i = 0; i < read; i += 2)  	next16Count += next16Buffer [i + 1];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: i += 2
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader (prefix + "-next08")) {  	for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  		next08Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader (prefix + "-next08")) {  	for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  		next08Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader (prefix + "-next08")) {  	for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  		next08Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader (prefix + "-next08")) {  	for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  		next08Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: using (var next08Reader = new UnbufferedIO.SequentialReader (prefix + "-next08")) {  	for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  		next08Total += read / 2;  		for (int i = 0; i < read; i += 2)  			next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  	}  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  	next08Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  	next08Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  	next08Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  	next08Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (var read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20); read > 0; read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)) {  	next08Total += read / 2;  	for (int i = 0; i < read; i += 2)  		next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  }  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: read = next08Reader.Read<byte> (next08Buffer' 0' 1 << 20)
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: next08Total += read / 2;  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (int i = 0; i < read; i += 2)  	next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: for (int i = 0; i < read; i += 2)  	next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: i += 2
Magic Number,COST,HilbertConversion,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\HilbertCurve.cs,TestTransformedAlt,The following statement contains a magic number: next08Count += next08Buffer [i + 1] == 0 ? 256 : (int)next08Buffer [i + 1];  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= stream.Read (bytes' 0' 8);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy (bytes' 0' ints' 0' 8);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2) {  		ints = new int[degree + 2];  		bytes = new byte[ints.Length * 4];  	}  	// read names of neighbors' plus next vertex and degree.  	bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  	// run the user-supplied vertex logic  	for (int i = 0; i < degree; i++)  		yield return new Edge (new Node (vertex)' new Node (ints [i]));  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2) {  		ints = new int[degree + 2];  		bytes = new byte[ints.Length * 4];  	}  	// read names of neighbors' plus next vertex and degree.  	bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  	// run the user-supplied vertex logic  	for (int i = 0; i < degree; i++)  		yield return new Edge (new Node (vertex)' new Node (ints [i]));  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2) {  		ints = new int[degree + 2];  		bytes = new byte[ints.Length * 4];  	}  	// read names of neighbors' plus next vertex and degree.  	bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  	// run the user-supplied vertex logic  	for (int i = 0; i < degree; i++)  		yield return new Edge (new Node (vertex)' new Node (ints [i]));  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2) {  		ints = new int[degree + 2];  		bytes = new byte[ints.Length * 4];  	}  	// read names of neighbors' plus next vertex and degree.  	bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  	// run the user-supplied vertex logic  	for (int i = 0; i < degree; i++)  		yield return new Edge (new Node (vertex)' new Node (ints [i]));  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2) {  		ints = new int[degree + 2];  		bytes = new byte[ints.Length * 4];  	}  	// read names of neighbors' plus next vertex and degree.  	bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  	// run the user-supplied vertex logic  	for (int i = 0; i < degree; i++)  		yield return new Edge (new Node (vertex)' new Node (ints [i]));  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2) {  		ints = new int[degree + 2];  		bytes = new byte[ints.Length * 4];  	}  	// read names of neighbors' plus next vertex and degree.  	bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  	// run the user-supplied vertex logic  	for (int i = 0; i < degree; i++)  		yield return new Edge (new Node (vertex)' new Node (ints [i]));  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2) {  		ints = new int[degree + 2];  		bytes = new byte[ints.Length * 4];  	}  	// read names of neighbors' plus next vertex and degree.  	bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  	Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  	// run the user-supplied vertex logic  	for (int i = 0; i < degree; i++)  		yield return new Edge (new Node (vertex)' new Node (ints [i]));  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: if (ints.Length < degree + 2) {  	ints = new int[degree + 2];  	bytes = new byte[ints.Length * 4];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: if (ints.Length < degree + 2) {  	ints = new int[degree + 2];  	bytes = new byte[ints.Length * 4];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: if (ints.Length < degree + 2) {  	ints = new int[degree + 2];  	bytes = new byte[ints.Length * 4];  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: ints = new int[degree + 2];  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytes = new byte[ints.Length * 4];  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: bytesToRead -= stream.Read (bytes' 0' 4 * (degree + 2));  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ReadEdges,The following statement contains a magic number: Buffer.BlockCopy (bytes' 0' ints' 0' 4 * (degree + 2));  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (args.Length < 3)  	throw new Exception ("Three arguments required: system' algorithm' dataset");  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "partition" && dataset == "twitter") {  	SingleThreaded.PartitionGraph (twitterFile' 4' (s' t) => (s & 1) + 2 * (t & 1)' dataDir + @"twitter-part-{0}-of-{1}");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "partition" && dataset == "twitter") {  	SingleThreaded.PartitionGraph (twitterFile' 4' (s' t) => (s & 1) + 2 * (t & 1)' dataDir + @"twitter-part-{0}-of-{1}");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.PartitionGraph (twitterFile' 4' (s' t) => (s & 1) + 2 * (t & 1)' dataDir + @"twitter-part-{0}-of-{1}");  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.PartitionGraph (twitterFile' 4' (s' t) => (s & 1) + 2 * (t & 1)' dataDir + @"twitter-part-{0}-of-{1}");  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "transpose" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.TransposeGraph (dataDir + @"twitterfollowers\twitter_rv.bin"' 65000000);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.TransposeGraph (dataDir + @"twitterfollowers\twitter_rv.bin"' 65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertlayout" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	uint nodes = 0;  	var names = new uint[65000000];  	for (int i = 0; i < names.Length; i++)  		names [i] = uint.MaxValue;  	var idegrees = new int[65000000];  	var odegrees = new int[65000000];  	var edges = 0L;  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		if (names [vertex] == uint.MaxValue)  			names [vertex] = nodes++;  		for (int i = 0; i < degree; i++)  			if (names [neighbors [offset + i]] == uint.MaxValue)  				names [neighbors [offset + i]] = nodes++;  		edges += degree;  	});  	Console.WriteLine ("{2}\tNodes: {0}\tEdges: {1}"' nodes' edges' stopwatch.Elapsed);  	// allocate enough space for all the edges.  	var hilbertTransformed = new uint[edges];  	var counts = new uint[1 << 20];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  	});  	Console.WriteLine ("{0}\tHilbert regions sized"' stopwatch.Elapsed);  	for (int i = 1; i < counts.Length; i++)  		counts [i + 1] += counts [i];  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var Trie = new BufferTrie<uint> (20' (array' offset' length) =>  {  		for (int i = offset; i < offset + length; i++)  			hilbertTransformed [counts [array [i].Index]++] = array [i].Value;  	});  	for (int i = counts.Length - 1; i > 0; i--)  		counts [i] = counts [i] - 1;  	counts [0] = 0;  	var buffer = new BufferTrie<uint>.Pair[5000000];  	SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++) {  			var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  			buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  		}  		Trie.Insert (buffer' 0' degree);  	});  	Trie.Flush ();  	Console.WriteLine ("{0}\tEdges partitioned"' stopwatch.Elapsed);  	using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			if (counts [i] < counts [i + 1]) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32)' out x' out y);  				upper.Write (x);  				upper.Write (y);  				upper.Write (counts [i + 1] - counts [i]);  			}  		}  	}  	using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  		for (uint i = 0; i < counts.Length - 1; i++) {  			Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  			for (uint j = counts [i]; j < counts [i + 1]; j++) {  				uint x = 0' y = 0;  				HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  				lower.Write ((UInt16)(x & 0xFFFF));  				lower.Write ((UInt16)(y & 0xFFFF));  			}  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  	for (int i = 0; i < degree; i++)  		counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  });  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: for (int i = 0; i < degree; i++)  	counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: counts [HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]) >> 32]++;  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ScanGraph (twitterFile' (vertex' degree' offset' neighbors) =>  {  	for (int i = 0; i < degree; i++) {  		var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  		buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  	}  	Trie.Insert (buffer' 0' degree);  });  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: for (int i = 0; i < degree; i++) {  	var result = HilbertCurve.xy2dByte (names [vertex]' names [neighbors [offset + i]]);  	buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: buffer [i] = new BufferTrie<uint>.Pair ((int)(result >> 32)' (uint)(result & 0xFFFF));  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: using (var upper = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-upper"))) {  	for (uint i = 0; i < counts.Length - 1; i++) {  		if (counts [i] < counts [i + 1]) {  			uint x = 0' y = 0;  			HilbertCurve.d2xyByte ((i << 32)' out x' out y);  			upper.Write (x);  			upper.Write (y);  			upper.Write (counts [i + 1] - counts [i]);  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: for (uint i = 0; i < counts.Length - 1; i++) {  	if (counts [i] < counts [i + 1]) {  		uint x = 0' y = 0;  		HilbertCurve.d2xyByte ((i << 32)' out x' out y);  		upper.Write (x);  		upper.Write (y);  		upper.Write (counts [i + 1] - counts [i]);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (counts [i] < counts [i + 1]) {  	uint x = 0' y = 0;  	HilbertCurve.d2xyByte ((i << 32)' out x' out y);  	upper.Write (x);  	upper.Write (y);  	upper.Write (counts [i + 1] - counts [i]);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: HilbertCurve.d2xyByte ((i << 32)' out x' out y);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: using (var lower = new System.IO.BinaryWriter (System.IO.File.OpenWrite ("twitter-hilbert-lower"))) {  	for (uint i = 0; i < counts.Length - 1; i++) {  		Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  		for (uint j = counts [i]; j < counts [i + 1]; j++) {  			uint x = 0' y = 0;  			HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  			lower.Write ((UInt16)(x & 0xFFFF));  			lower.Write ((UInt16)(y & 0xFFFF));  		}  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: for (uint i = 0; i < counts.Length - 1; i++) {  	Array.Sort (hilbertTransformed' (int)counts [i]' (int)(counts [i + 1] - counts [i]));  	for (uint j = counts [i]; j < counts [i + 1]; j++) {  		uint x = 0' y = 0;  		HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  		lower.Write ((UInt16)(x & 0xFFFF));  		lower.Write ((UInt16)(y & 0xFFFF));  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: for (uint j = counts [i]; j < counts [i + 1]; j++) {  	uint x = 0' y = 0;  	HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  	lower.Write ((UInt16)(x & 0xFFFF));  	lower.Write ((UInt16)(y & 0xFFFF));  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: HilbertCurve.d2xyByte ((i << 32) + hilbertTransformed [j]' out x' out y);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertpagerank" && dataset == "livejournal") {  	unsafe {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		var nodes = (uint)42000000;  		#if UseLargePages  		var srcRanks = LargePages.AllocateFloats (nodes);  		var dstRanks = LargePages.AllocateFloats (nodes);  		#else  		                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			srcRanks [i] = 1.0f;  		SingleThreaded.HilbertPagerank (@"livejournal-hilbert"' dstRanks' srcRanks' nodes' 0.85f);  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	var nodes = (uint)42000000;  	#if UseLargePages  	var srcRanks = LargePages.AllocateFloats (nodes);  	var dstRanks = LargePages.AllocateFloats (nodes);  	#else  	                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		srcRanks [i] = 1.0f;  	SingleThreaded.HilbertPagerank (@"livejournal-hilbert"' dstRanks' srcRanks' nodes' 0.85f);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertpagerank" && dataset == "twitter") {  	unsafe {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		var nodes = (uint)42000000;  		#if UseLargePages  		var srcRanks = LargePages.AllocateFloats (nodes);  		var dstRanks = LargePages.AllocateFloats (nodes);  		#else  		                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			srcRanks [i] = 1.0f;  		SingleThreaded.HilbertPagerank (@"twitter-hilbert"' dstRanks' srcRanks' nodes' 0.85f);  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	var nodes = (uint)42000000;  	#if UseLargePages  	var srcRanks = LargePages.AllocateFloats (nodes);  	var dstRanks = LargePages.AllocateFloats (nodes);  	#else  	                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		srcRanks [i] = 1.0f;  	SingleThreaded.HilbertPagerank (@"twitter-hilbert"' dstRanks' srcRanks' nodes' 0.85f);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertpagerank" && dataset == "uk-2007-05") {  	unsafe {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		var nodes = (uint)106000000;  		var srcRanks = LargePages.AllocateFloats (nodes);  		var dstRanks = LargePages.AllocateFloats (nodes);  		for (int i = 0; i < nodes; i++)  			srcRanks [i] = 1.0f;  		SingleThreaded.MultiHilbertPagerank (@"uk-2007-05-hilbert"' dstRanks' srcRanks' nodes' 0.85f);  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	var nodes = (uint)106000000;  	var srcRanks = LargePages.AllocateFloats (nodes);  	var dstRanks = LargePages.AllocateFloats (nodes);  	for (int i = 0; i < nodes; i++)  		srcRanks [i] = 1.0f;  	SingleThreaded.MultiHilbertPagerank (@"uk-2007-05-hilbert"' dstRanks' srcRanks' nodes' 0.85f);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertunionfind" && dataset == "twitter") {  	unsafe {  		var nodes = (uint)42000000;  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		SingleThreaded.HilbertUnionFind2 (@"twitter-hilbert"' nodes);  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var nodes = (uint)42000000;  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.HilbertUnionFind2 (@"twitter-hilbert"' nodes);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertunionfind" && dataset == "uk-2007-05") {  	unsafe {  		var nodes = (uint)106000000;  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		SingleThreaded.MultiHilbertCC (@"uk-2007-05-hilbert"' nodes);  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var nodes = (uint)106000000;  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.MultiHilbertCC (@"uk-2007-05-hilbert"' nodes);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "hilbertunionfind" && dataset == "livejournal") {  	unsafe {  		var nodes = (uint)42000000;  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		SingleThreaded.HilbertUnionFind (@"livejournal-hilbert-upper"' "livejournal-hilbert-lower"' nodes);  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var nodes = (uint)42000000;  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.HilbertUnionFind (@"livejournal-hilbert-upper"' "livejournal-hilbert-lower"' nodes);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "uk-2007-05") {  	unsafe {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		var nodes = (uint)106000000;  		#if UseLargePages  		var srcRanks = LargePages.AllocateFloats (nodes);  		var dstRanks = LargePages.AllocateFloats (nodes);  		#else  		                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  		SingleThreaded.PageRankFromDisk (ukFile' dstRanks' srcRanks' nodes' 0.85f);  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	var nodes = (uint)106000000;  	#if UseLargePages  	var srcRanks = LargePages.AllocateFloats (nodes);  	var dstRanks = LargePages.AllocateFloats (nodes);  	#else  	                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  	SingleThreaded.PageRankFromDisk (ukFile' dstRanks' srcRanks' nodes' 0.85f);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "twitter") {  	unsafe {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		var nodes = (uint)65000000;  		#if UseLargePages  		var srcRanks = LargePages.AllocateFloats (nodes);  		var dstRanks = LargePages.AllocateFloats (nodes);  		#else  		                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  		SingleThreaded.PageRankFromDisk (twitterFile' dstRanks' srcRanks' nodes' 0.85f);  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	var nodes = (uint)65000000;  	#if UseLargePages  	var srcRanks = LargePages.AllocateFloats (nodes);  	var dstRanks = LargePages.AllocateFloats (nodes);  	#else  	                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  	SingleThreaded.PageRankFromDisk (twitterFile' dstRanks' srcRanks' nodes' 0.85f);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "livejournal") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	unsafe {  		var nodes = (uint)65000000;  		#if UseLargePages  		var srcRanks = LargePages.AllocateFloats (nodes);  		var dstRanks = LargePages.AllocateFloats (nodes);  		#else  		                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  		for (int i = 0; i < 20; i++) {  			SingleThreaded.PageRankStep (livejournalFile' dstRanks' srcRanks' nodes' 0.85f);  			Console.WriteLine ("{0}\tIteration {1}"' stopwatch.Elapsed' i);  		}  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "livejournal") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	unsafe {  		var nodes = (uint)65000000;  		#if UseLargePages  		var srcRanks = LargePages.AllocateFloats (nodes);  		var dstRanks = LargePages.AllocateFloats (nodes);  		#else  		                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  		for (int i = 0; i < 20; i++) {  			SingleThreaded.PageRankStep (livejournalFile' dstRanks' srcRanks' nodes' 0.85f);  			Console.WriteLine ("{0}\tIteration {1}"' stopwatch.Elapsed' i);  		}  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var nodes = (uint)65000000;  	#if UseLargePages  	var srcRanks = LargePages.AllocateFloats (nodes);  	var dstRanks = LargePages.AllocateFloats (nodes);  	#else  	                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  	for (int i = 0; i < 20; i++) {  		SingleThreaded.PageRankStep (livejournalFile' dstRanks' srcRanks' nodes' 0.85f);  		Console.WriteLine ("{0}\tIteration {1}"' stopwatch.Elapsed' i);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: unsafe {  	var nodes = (uint)65000000;  	#if UseLargePages  	var srcRanks = LargePages.AllocateFloats (nodes);  	var dstRanks = LargePages.AllocateFloats (nodes);  	#else  	                    var srcRanks = new float[nodes];                     var dstRanks = new float[nodes]; #endif  	for (int i = 0; i < 20; i++) {  		SingleThreaded.PageRankStep (livejournalFile' dstRanks' srcRanks' nodes' 0.85f);  		Console.WriteLine ("{0}\tIteration {1}"' stopwatch.Elapsed' i);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: for (int i = 0; i < 20; i++) {  	SingleThreaded.PageRankStep (livejournalFile' dstRanks' srcRanks' nodes' 0.85f);  	Console.WriteLine ("{0}\tIteration {1}"' stopwatch.Elapsed' i);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.ConnectedComponents (twitterFile' 65000000);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ConnectedComponents (twitterFile' 65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.ClumsyCC (ukFile' 106000000);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ClumsyCC (ukFile' 106000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "livejournal") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.ConnectedComponents (livejournalFile' 6500000);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.ConnectedComponents (livejournalFile' 6500000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "maximalindependentset" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.MaximalIndependentSet (twitterFile' 65000000);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.MaximalIndependentSet (twitterFile' 65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: if (algorithm == "maximalindependentset" && dataset == "livejournal") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	SingleThreaded.MaximalIndependentSet (livejournalFile' 6500000);  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteSingleThreaded,The following statement contains a magic number: SingleThreaded.MaximalIndependentSet (livejournalFile' 6500000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "partition" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		int parts = Int32.Parse (args [3]);  		var format = Path.Combine (dataDir' @"twitter-part-{0}-of-" + (parts * parts).ToString ());  		computation.LoadGraph (twitterFile).Partition (parts' parts).WriteBinaryToFiles (format);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	int parts = Int32.Parse (args [3]);  	var format = Path.Combine (dataDir' @"twitter-part-{0}-of-" + (parts * parts).ToString ());  	computation.LoadGraph (twitterFile).Partition (parts' parts).WriteBinaryToFiles (format);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "repartition" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		int parts = Int32.Parse (args [3]);  		computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "repartition" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		int parts = Int32.Parse (args [3]);  		computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "repartition" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		int parts = Int32.Parse (args [3]);  		computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	int parts = Int32.Parse (args [3]);  	computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	int parts = Int32.Parse (args [3]);  	computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	int parts = Int32.Parse (args [3]);  	computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.ReadHdfsBinaryCollection<Edge> (new Uri (uriBase + "twitter-10")).Partition (parts' parts).WriteHdfsBinary (new Uri (uriBase + "twitter-" + parts)' 1024 * 1024' -1L' 100L * 1024L * 1024L * 1024L);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "twitter") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		computation.OnFrontierChange += (x' y) =>  {  			Console.WriteLine (System.DateTime.Now + "\t" + string.Join ("' "' y.NewFrontier));  			System.GC.GetTotalMemory (true);  		};  		var edges = System.IO.File.OpenRead (twitterFile).ReadEdges ().AsNaiadStream (computation);  		edges.PageRank (20' "twitter").Subscribe ();  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	computation.OnFrontierChange += (x' y) =>  {  		Console.WriteLine (System.DateTime.Now + "\t" + string.Join ("' "' y.NewFrontier));  		System.GC.GetTotalMemory (true);  	};  	var edges = System.IO.File.OpenRead (twitterFile).ReadEdges ().AsNaiadStream (computation);  	edges.PageRank (20' "twitter").Subscribe ();  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: edges.PageRank (20' "twitter").Subscribe ();  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "pagerank" && dataset == "livejournal") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		computation.OnFrontierChange += (x' y) =>  {  			Console.WriteLine (System.DateTime.Now + "\t" + string.Join ("' "' y.NewFrontier));  		};  		var edges = System.IO.File.OpenRead (livejournalFile).ReadEdges ().AsNaiadStream (computation);  		edges.PageRank (20' "livejournal").Subscribe ();  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	computation.OnFrontierChange += (x' y) =>  {  		Console.WriteLine (System.DateTime.Now + "\t" + string.Join ("' "' y.NewFrontier));  	};  	var edges = System.IO.File.OpenRead (livejournalFile).ReadEdges ().AsNaiadStream (computation);  	edges.PageRank (20' "livejournal").Subscribe ();  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: edges.PageRank (20' "livejournal").Subscribe ();  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  		var extraInput = new[] {  			string.Format (format' 3' 4)  		}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  		computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  		var extraInput = new[] {  			string.Format (format' 3' 4)  		}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  		computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  		var extraInput = new[] {  			string.Format (format' 3' 4)  		}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  		computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  		var extraInput = new[] {  			string.Format (format' 3' 4)  		}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  		computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  		var extraInput = new[] {  			string.Format (format' 3' 4)  		}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  		computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  		var extraInput = new[] {  			string.Format (format' 3' 4)  		}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  		computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  		var extraInput = new[] {  			string.Format (format' 3' 4)  		}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  		computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "uk-2007-05") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  		var extraInput = new[] {  			string.Format (format' 3' 4)  		}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  		computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  	var extraInput = new[] {  		string.Format (format' 3' 4)  	}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  	computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  	var extraInput = new[] {  		string.Format (format' 3' 4)  	}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  	computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  	var extraInput = new[] {  		string.Format (format' 3' 4)  	}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  	computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  	var extraInput = new[] {  		string.Format (format' 3' 4)  	}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  	computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  	var extraInput = new[] {  		string.Format (format' 3' 4)  	}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  	computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  	var extraInput = new[] {  		string.Format (format' 3' 4)  	}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  	computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  	var extraInput = new[] {  		string.Format (format' 3' 4)  	}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  	computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var format = Path.Combine (dataDir' @"uk-2007-05-part-{0}-of-{1}");  	var extraInput = new[] {  		string.Format (format' 3' 4)  	}.AsNaiadStream (computation).PartitionBy (x => 3).ReadGraph ();  	computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: computation.LoadGraph (format' 3' 4).UnionFind (106000000).PartitionBy (x => 3).Concat (extraInput).UnionFind (106000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * machines * another > 1) {  	firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage = firstStage.UnionFindStruct (65000000' parts * machines * another' machines * another);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hhp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtablecc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ().UnionFindHashTable (65000000' parts * machines * another' machines * another);  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => parts * parts).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * parts).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindStruct (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindStruct (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindStruct (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFind (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "hashtableonlycc" && dataset == "twitter") {  	using (Microsoft.Research.Peloponnese.Hdfs.HdfsInstance hdfs = new Microsoft.Research.Peloponnese.Hdfs.HdfsInstance (new Uri (uriBase))) {  		// HDFS needs to be initialized from the main thread before distributed use  		bool exists = hdfs.IsFileExists ("/dummy");  	}  	var readWatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var controller = NewController.FromConfig (configuration)) {  		using (var readComputation = controller.NewComputation ()) {  			int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  			int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  			int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  			var format = new Uri (@uriBase + "twitter-40");  			var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  			Stream<int[]' Epoch> readStuff = null;  			switch (args [3]) {  			case "sp":  				readStuff = collection.GroupEdgesSingleProcess (parts' parts);  				break;  			case "pp":  				readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  				break;  			case "op":  				readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  				break;  			case "hp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  				break;  			case "hhp":  				readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			var sink = new InterGraphDataSink<int[]> (readStuff);  			readComputation.Activate ();  			readComputation.Join ();  			Console.WriteLine ("Reading done: " + readWatch.Elapsed);  			for (int i = 0; i < 20; ++i) {  				var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  				using (var computation = controller.NewComputation ()) {  					var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  					if (parts * machines * another > 1) {  						firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  					}  					switch (args [3]) {  					case "sp":  						firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  						break;  					case "pp":  						firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  						break;  					case "op":  						firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  						break;  					case "hp":  						if (parts * parts < 16) {  							firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  						}  						else {  							firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  						}  						break;  					case "hhp":  						firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  						break;  					default:  						throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  					}  					computation.Activate ();  					computation.Join ();  				}  				Console.WriteLine (stopwatch.Elapsed);  			}  		}  		controller.Join ();  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var controller = NewController.FromConfig (configuration)) {  	using (var readComputation = controller.NewComputation ()) {  		int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  		int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  		int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  		var format = new Uri (@uriBase + "twitter-40");  		var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  		Stream<int[]' Epoch> readStuff = null;  		switch (args [3]) {  		case "sp":  			readStuff = collection.GroupEdgesSingleProcess (parts' parts);  			break;  		case "pp":  			readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  			break;  		case "op":  			readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  			break;  		case "hp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  			break;  		case "hhp":  			readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		var sink = new InterGraphDataSink<int[]> (readStuff);  		readComputation.Activate ();  		readComputation.Join ();  		Console.WriteLine ("Reading done: " + readWatch.Elapsed);  		for (int i = 0; i < 20; ++i) {  			var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  			using (var computation = controller.NewComputation ()) {  				var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  				if (parts * machines * another > 1) {  					firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  				}  				switch (args [3]) {  				case "sp":  					firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  					break;  				case "pp":  					firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  					break;  				case "op":  					firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  					break;  				case "hp":  					if (parts * parts < 16) {  						firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  					}  					else {  						firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  					}  					break;  				case "hhp":  					firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  					break;  				default:  					throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  				}  				computation.Activate ();  				computation.Join ();  			}  			Console.WriteLine (stopwatch.Elapsed);  		}  	}  	controller.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var readComputation = controller.NewComputation ()) {  	int parts = (args.Length > 4) ? Int32.Parse (args [4]) : 1;  	int machines = (args.Length > 5) ? Int32.Parse (args [5]) : 1;  	int another = (args.Length > 6) ? Int32.Parse (args [6]) : 1;  	var format = new Uri (@uriBase + "twitter-40");  	var collection = readComputation.ReadHdfsBinaryCollection<Edge> (format);  	Stream<int[]' Epoch> readStuff = null;  	switch (args [3]) {  	case "sp":  		readStuff = collection.GroupEdgesSingleProcess (parts' parts);  		break;  	case "pp":  		readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  		break;  	case "op":  		readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  		break;  	case "hp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  		break;  	case "hhp":  		readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	var sink = new InterGraphDataSink<int[]> (readStuff);  	readComputation.Activate ();  	readComputation.Join ();  	Console.WriteLine ("Reading done: " + readWatch.Elapsed);  	for (int i = 0; i < 20; ++i) {  		var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  		using (var computation = controller.NewComputation ()) {  			var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  			if (parts * machines * another > 1) {  				firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  			}  			switch (args [3]) {  			case "sp":  				firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  				break;  			case "pp":  				firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  				break;  			case "op":  				firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  				break;  			case "hp":  				if (parts * parts < 16) {  					firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  				}  				else {  					firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  				}  				break;  			case "hhp":  				firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  				break;  			default:  				throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  			}  			computation.Activate ();  			computation.Join ();  		}  		Console.WriteLine (stopwatch.Elapsed);  	}  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	readStuff = collection.GroupEdgesSingleProcess (parts' parts);  	break;  case "pp":  	readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  	break;  case "op":  	readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  	break;  case "hp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  	break;  case "hhp":  	readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesPartsPerProcess (parts' parts' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesOnePerProcess (parts' parts' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: readStuff = collection.GroupEdgesHierarchyPerProcess (parts' machines * another' 16);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: for (int i = 0; i < 20; ++i) {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = controller.NewComputation ()) {  		var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  		if (parts * machines * another > 1) {  			firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  		}  		switch (args [3]) {  		case "sp":  			firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  			break;  		case "pp":  			firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  			break;  		case "op":  			firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  			break;  		case "hp":  			if (parts * parts < 16) {  				firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  			}  			else {  				firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  			}  			break;  		case "hhp":  			firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  			break;  		default:  			throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  		}  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = controller.NewComputation ()) {  	var firstStage = computation.NewInput (sink.NewDataSource ()).ReformatInts ();  	if (parts * machines * another > 1) {  		firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  	}  	switch (args [3]) {  	case "sp":  		firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  		break;  	case "pp":  		firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  		break;  	case "op":  		firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  		break;  	case "hp":  		if (parts * parts < 16) {  			firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  		}  		else {  			firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  		}  		break;  	case "hhp":  		firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  		break;  	default:  		throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  	}  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * machines * another > 1) {  	firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage = firstStage.UnionFindHashTable (65000000' parts * machines * another' machines * another);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: switch (args [3]) {  case "sp":  	firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  	break;  case "pp":  	firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  	break;  case "op":  	firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  	break;  case "hp":  	if (parts * parts < 16) {  		firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  	}  	else {  		firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  	}  	break;  case "hhp":  	firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  	break;  default:  	throw new ApplicationException ("Grouping type must be sp' pp' op' hp or hpp");  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => parts * parts).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * parts).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (parts * parts)).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (parts * parts < 16) {  	firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  }  else {  	firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * x.destination + (parts * parts)).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * (machines * machines)).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * (x.destination + (machines * machines))).UnionFindHashTable (65000000' 0' 0).PartitionBy (x => 16 * ((machines * machines) + (machines * machines))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: firstStage.PartitionBy (x => 16 * ((x.destination / (machines * machines)) + (machines * machines * another * another)) + (x.destination % (machines * machines))).UnionFindHashTable (65000000' -machines * another' another).PartitionBy (x => 16 * (x.destination + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000' -another' 1).PartitionBy (x => 16 * ((another * another) + (another * another) + (machines * machines * another * another))).UnionFindHashTable (65000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "livejournal") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var edges = System.IO.File.OpenRead (livejournalFile).ReadEdges ().AsNaiadStream (computation);  		edges.UnionFind (5000000).PartitionBy (x => 0).UnionFind (5000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: if (algorithm == "connectedcomponents" && dataset == "livejournal") {  	var stopwatch = System.Diagnostics.Stopwatch.StartNew ();  	using (var computation = NewComputation.FromConfig (configuration)) {  		var edges = System.IO.File.OpenRead (livejournalFile).ReadEdges ().AsNaiadStream (computation);  		edges.UnionFind (5000000).PartitionBy (x => 0).UnionFind (5000000);  		computation.Activate ();  		computation.Join ();  	}  	Console.WriteLine (stopwatch.Elapsed);  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var edges = System.IO.File.OpenRead (livejournalFile).ReadEdges ().AsNaiadStream (computation);  	edges.UnionFind (5000000).PartitionBy (x => 0).UnionFind (5000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: using (var computation = NewComputation.FromConfig (configuration)) {  	var edges = System.IO.File.OpenRead (livejournalFile).ReadEdges ().AsNaiadStream (computation);  	edges.UnionFind (5000000).PartitionBy (x => 0).UnionFind (5000000);  	computation.Activate ();  	computation.Join ();  }  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: edges.UnionFind (5000000).PartitionBy (x => 0).UnionFind (5000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The following statement contains a magic number: edges.UnionFind (5000000).PartitionBy (x => 0).UnionFind (5000000);  
Magic Number,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,Main,The following statement contains a magic number: if (args.Length < 3)  	throw new Exception ("Three arguments required: system' algorithm' dataset");  
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)  	maxDegree = Math.Max (maxDegree' metadata [i + 1]);  
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: i += 2
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (this.filePrefix + "-edges")) {  	reader.Read (neighbors' 0' neighbors.Length);  	for (int i = 0; i < metadata.Length; i += 2) {  		var vertex = metadata [i + 0];  		var degree = metadata [i + 1];  		if (neighborsOffset + degree > neighbors.Length - 1) {  			Array.Copy (neighbors' neighborsOffset' neighbors' 0' neighbors.Length - neighborsOffset);  			reader.Read (neighbors' neighbors.Length - neighborsOffset' neighborsOffset);  			neighborsOffset = 0;  		}  		perVertexLogic (vertex' degree' neighborsOffset' neighbors);  		neighborsOffset += degree;  	}  }  
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2) {  	var vertex = metadata [i + 0];  	var degree = metadata [i + 1];  	if (neighborsOffset + degree > neighbors.Length - 1) {  		Array.Copy (neighbors' neighborsOffset' neighbors' 0' neighbors.Length - neighborsOffset);  		reader.Read (neighbors' neighbors.Length - neighborsOffset' neighborsOffset);  		neighborsOffset = 0;  	}  	perVertexLogic (vertex' degree' neighborsOffset' neighbors);  	neighborsOffset += degree;  }  
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: i += 2
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)  	perVertexLogic (metadata [i]' metadata [i + 1]);  
Magic Number,COST,FileGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: i += 2
Magic Number,COST,MemoryGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < this.metadata.Length; i += 2)  	perVertexLogic (this.metadata [i]' this.metadata [i + 1]);  
Magic Number,COST,MemoryGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: i += 2
Magic Number,COST,MemoryGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2) {  	var vertex = metadata [i + 0];  	var degree = metadata [i + 1];  	perVertexLogic (vertex' degree' offset' neighbors);  	offset += degree;  }  
Magic Number,COST,MemoryGraphScanner,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ForEach,The following statement contains a magic number: i += 2
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)  	maxDegree = Math.Max (maxDegree' metadata [i + 1]);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: i += 2
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename + "-edges")) {  	reader.Read (neighbors' 0' neighbors.Length);  	for (int i = 0; i < metadata.Length; i += 2) {  		var vertex = metadata [i + 0];  		var degree = metadata [i + 1];  		if (neighborsOffset + degree > neighbors.Length - 1) {  			Array.Copy (neighbors' neighborsOffset' neighbors' 0' neighbors.Length - neighborsOffset);  			reader.Read (neighbors' neighbors.Length - neighborsOffset' neighborsOffset);  			neighborsOffset = 0;  		}  		perVertexLogic (vertex' degree' neighborsOffset' neighbors);  		neighborsOffset += degree;  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2) {  	var vertex = metadata [i + 0];  	var degree = metadata [i + 1];  	if (neighborsOffset + degree > neighbors.Length - 1) {  		Array.Copy (neighbors' neighborsOffset' neighbors' 0' neighbors.Length - neighborsOffset);  		reader.Read (neighbors' neighbors.Length - neighborsOffset' neighborsOffset);  		neighborsOffset = 0;  	}  	perVertexLogic (vertex' degree' neighborsOffset' neighbors);  	neighborsOffset += degree;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: i += 2
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2)  	perVertexLogic (metadata [i]' metadata [i + 1]);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: i += 2
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 2) {  	var vertex = metadata [i + 0];  	var degree = metadata [i + 1];  	perVertexLogic (vertex' degree' offset' neighbors);  	offset += degree;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraph,The following statement contains a magic number: i += 2
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3)  	maxCount = Math.Max (maxCount' metadata [i + 2]);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3)  	maxCount = Math.Max (maxCount' metadata [i + 2]);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: i += 3
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: maxCount = Math.Max (maxCount' metadata [i + 2]);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename + "-lower")) {  	reader.Read (edges' 0' edges.Length);  	for (int i = 0; i < metadata.Length; i += 3) {  		var sourceUpper = metadata [i + 0] << 16;  		var targetUpper = metadata [i + 1] << 16;  		var count = metadata [i + 2];  		if (edgesOffset + count > edges.Length - 1) {  			Array.Copy (edges' edgesOffset' edges' 0' edges.Length - edgesOffset);  			reader.Read (edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);  			edgesOffset = 0;  		}  		perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  		edgesOffset += count;  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename + "-lower")) {  	reader.Read (edges' 0' edges.Length);  	for (int i = 0; i < metadata.Length; i += 3) {  		var sourceUpper = metadata [i + 0] << 16;  		var targetUpper = metadata [i + 1] << 16;  		var count = metadata [i + 2];  		if (edgesOffset + count > edges.Length - 1) {  			Array.Copy (edges' edgesOffset' edges' 0' edges.Length - edgesOffset);  			reader.Read (edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);  			edgesOffset = 0;  		}  		perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  		edgesOffset += count;  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename + "-lower")) {  	reader.Read (edges' 0' edges.Length);  	for (int i = 0; i < metadata.Length; i += 3) {  		var sourceUpper = metadata [i + 0] << 16;  		var targetUpper = metadata [i + 1] << 16;  		var count = metadata [i + 2];  		if (edgesOffset + count > edges.Length - 1) {  			Array.Copy (edges' edgesOffset' edges' 0' edges.Length - edgesOffset);  			reader.Read (edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);  			edgesOffset = 0;  		}  		perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  		edgesOffset += count;  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename + "-lower")) {  	reader.Read (edges' 0' edges.Length);  	for (int i = 0; i < metadata.Length; i += 3) {  		var sourceUpper = metadata [i + 0] << 16;  		var targetUpper = metadata [i + 1] << 16;  		var count = metadata [i + 2];  		if (edgesOffset + count > edges.Length - 1) {  			Array.Copy (edges' edgesOffset' edges' 0' edges.Length - edgesOffset);  			reader.Read (edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);  			edgesOffset = 0;  		}  		perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  		edgesOffset += count;  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3) {  	var sourceUpper = metadata [i + 0] << 16;  	var targetUpper = metadata [i + 1] << 16;  	var count = metadata [i + 2];  	if (edgesOffset + count > edges.Length - 1) {  		Array.Copy (edges' edgesOffset' edges' 0' edges.Length - edgesOffset);  		reader.Read (edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);  		edgesOffset = 0;  	}  	perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  	edgesOffset += count;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3) {  	var sourceUpper = metadata [i + 0] << 16;  	var targetUpper = metadata [i + 1] << 16;  	var count = metadata [i + 2];  	if (edgesOffset + count > edges.Length - 1) {  		Array.Copy (edges' edgesOffset' edges' 0' edges.Length - edgesOffset);  		reader.Read (edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);  		edgesOffset = 0;  	}  	perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  	edgesOffset += count;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3) {  	var sourceUpper = metadata [i + 0] << 16;  	var targetUpper = metadata [i + 1] << 16;  	var count = metadata [i + 2];  	if (edgesOffset + count > edges.Length - 1) {  		Array.Copy (edges' edgesOffset' edges' 0' edges.Length - edgesOffset);  		reader.Read (edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);  		edgesOffset = 0;  	}  	perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  	edgesOffset += count;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3) {  	var sourceUpper = metadata [i + 0] << 16;  	var targetUpper = metadata [i + 1] << 16;  	var count = metadata [i + 2];  	if (edgesOffset + count > edges.Length - 1) {  		Array.Copy (edges' edgesOffset' edges' 0' edges.Length - edgesOffset);  		reader.Read (edges' (int)(edges.Length - edgesOffset)' (int)edgesOffset);  		edgesOffset = 0;  	}  	perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  	edgesOffset += count;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: i += 3
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3) {  	var sourceUpper = metadata [i + 0] << 16;  	var targetUpper = metadata [i + 1] << 16;  	var count = metadata [i + 2];  	perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  	edgesOffset += count;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3) {  	var sourceUpper = metadata [i + 0] << 16;  	var targetUpper = metadata [i + 1] << 16;  	var count = metadata [i + 2];  	perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  	edgesOffset += count;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3) {  	var sourceUpper = metadata [i + 0] << 16;  	var targetUpper = metadata [i + 1] << 16;  	var count = metadata [i + 2];  	perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  	edgesOffset += count;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: for (int i = 0; i < metadata.Length; i += 3) {  	var sourceUpper = metadata [i + 0] << 16;  	var targetUpper = metadata [i + 1] << 16;  	var count = metadata [i + 2];  	perVertexLogic (sourceUpper' targetUpper' edgesOffset' count' edges);  	edgesOffset += count;  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ScanGraphHilbert,The following statement contains a magic number: i += 3
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter (File.OpenWrite (filename + "-nodes"))) {  	using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  		using (var reader = new UnbufferedIO.SequentialReader (filename)) {  			var ints = new int[2];  			var bytesToRead = reader.Length - 8;  			// read vertex name and degree  			reader.Read (ints' 0' 2);  			var vertex = ints [0];  			var degree = ints [1];  			while (bytesToRead > 0) {  				// allocate space if needed  				if (ints.Length < degree + 2)  					ints = new int[degree + 2];  				bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  				nodeWriter.Write (vertex);  				nodeWriter.Write (degree);  				for (int i = 0; i < degree; i++)  					edgeWriter.Write (ints [i]);  				vertex = ints [degree];  				degree = ints [degree + 1];  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter (File.OpenWrite (filename + "-nodes"))) {  	using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  		using (var reader = new UnbufferedIO.SequentialReader (filename)) {  			var ints = new int[2];  			var bytesToRead = reader.Length - 8;  			// read vertex name and degree  			reader.Read (ints' 0' 2);  			var vertex = ints [0];  			var degree = ints [1];  			while (bytesToRead > 0) {  				// allocate space if needed  				if (ints.Length < degree + 2)  					ints = new int[degree + 2];  				bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  				nodeWriter.Write (vertex);  				nodeWriter.Write (degree);  				for (int i = 0; i < degree; i++)  					edgeWriter.Write (ints [i]);  				vertex = ints [degree];  				degree = ints [degree + 1];  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter (File.OpenWrite (filename + "-nodes"))) {  	using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  		using (var reader = new UnbufferedIO.SequentialReader (filename)) {  			var ints = new int[2];  			var bytesToRead = reader.Length - 8;  			// read vertex name and degree  			reader.Read (ints' 0' 2);  			var vertex = ints [0];  			var degree = ints [1];  			while (bytesToRead > 0) {  				// allocate space if needed  				if (ints.Length < degree + 2)  					ints = new int[degree + 2];  				bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  				nodeWriter.Write (vertex);  				nodeWriter.Write (degree);  				for (int i = 0; i < degree; i++)  					edgeWriter.Write (ints [i]);  				vertex = ints [degree];  				degree = ints [degree + 1];  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter (File.OpenWrite (filename + "-nodes"))) {  	using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  		using (var reader = new UnbufferedIO.SequentialReader (filename)) {  			var ints = new int[2];  			var bytesToRead = reader.Length - 8;  			// read vertex name and degree  			reader.Read (ints' 0' 2);  			var vertex = ints [0];  			var degree = ints [1];  			while (bytesToRead > 0) {  				// allocate space if needed  				if (ints.Length < degree + 2)  					ints = new int[degree + 2];  				bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  				nodeWriter.Write (vertex);  				nodeWriter.Write (degree);  				for (int i = 0; i < degree; i++)  					edgeWriter.Write (ints [i]);  				vertex = ints [degree];  				degree = ints [degree + 1];  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter (File.OpenWrite (filename + "-nodes"))) {  	using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  		using (var reader = new UnbufferedIO.SequentialReader (filename)) {  			var ints = new int[2];  			var bytesToRead = reader.Length - 8;  			// read vertex name and degree  			reader.Read (ints' 0' 2);  			var vertex = ints [0];  			var degree = ints [1];  			while (bytesToRead > 0) {  				// allocate space if needed  				if (ints.Length < degree + 2)  					ints = new int[degree + 2];  				bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  				nodeWriter.Write (vertex);  				nodeWriter.Write (degree);  				for (int i = 0; i < degree; i++)  					edgeWriter.Write (ints [i]);  				vertex = ints [degree];  				degree = ints [degree + 1];  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter (File.OpenWrite (filename + "-nodes"))) {  	using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  		using (var reader = new UnbufferedIO.SequentialReader (filename)) {  			var ints = new int[2];  			var bytesToRead = reader.Length - 8;  			// read vertex name and degree  			reader.Read (ints' 0' 2);  			var vertex = ints [0];  			var degree = ints [1];  			while (bytesToRead > 0) {  				// allocate space if needed  				if (ints.Length < degree + 2)  					ints = new int[degree + 2];  				bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  				nodeWriter.Write (vertex);  				nodeWriter.Write (degree);  				for (int i = 0; i < degree; i++)  					edgeWriter.Write (ints [i]);  				vertex = ints [degree];  				degree = ints [degree + 1];  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var nodeWriter = new BinaryWriter (File.OpenWrite (filename + "-nodes"))) {  	using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  		using (var reader = new UnbufferedIO.SequentialReader (filename)) {  			var ints = new int[2];  			var bytesToRead = reader.Length - 8;  			// read vertex name and degree  			reader.Read (ints' 0' 2);  			var vertex = ints [0];  			var degree = ints [1];  			while (bytesToRead > 0) {  				// allocate space if needed  				if (ints.Length < degree + 2)  					ints = new int[degree + 2];  				bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  				nodeWriter.Write (vertex);  				nodeWriter.Write (degree);  				for (int i = 0; i < degree; i++)  					edgeWriter.Write (ints [i]);  				vertex = ints [degree];  				degree = ints [degree + 1];  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  	using (var reader = new UnbufferedIO.SequentialReader (filename)) {  		var ints = new int[2];  		var bytesToRead = reader.Length - 8;  		// read vertex name and degree  		reader.Read (ints' 0' 2);  		var vertex = ints [0];  		var degree = ints [1];  		while (bytesToRead > 0) {  			// allocate space if needed  			if (ints.Length < degree + 2)  				ints = new int[degree + 2];  			bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  			nodeWriter.Write (vertex);  			nodeWriter.Write (degree);  			for (int i = 0; i < degree; i++)  				edgeWriter.Write (ints [i]);  			vertex = ints [degree];  			degree = ints [degree + 1];  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  	using (var reader = new UnbufferedIO.SequentialReader (filename)) {  		var ints = new int[2];  		var bytesToRead = reader.Length - 8;  		// read vertex name and degree  		reader.Read (ints' 0' 2);  		var vertex = ints [0];  		var degree = ints [1];  		while (bytesToRead > 0) {  			// allocate space if needed  			if (ints.Length < degree + 2)  				ints = new int[degree + 2];  			bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  			nodeWriter.Write (vertex);  			nodeWriter.Write (degree);  			for (int i = 0; i < degree; i++)  				edgeWriter.Write (ints [i]);  			vertex = ints [degree];  			degree = ints [degree + 1];  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  	using (var reader = new UnbufferedIO.SequentialReader (filename)) {  		var ints = new int[2];  		var bytesToRead = reader.Length - 8;  		// read vertex name and degree  		reader.Read (ints' 0' 2);  		var vertex = ints [0];  		var degree = ints [1];  		while (bytesToRead > 0) {  			// allocate space if needed  			if (ints.Length < degree + 2)  				ints = new int[degree + 2];  			bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  			nodeWriter.Write (vertex);  			nodeWriter.Write (degree);  			for (int i = 0; i < degree; i++)  				edgeWriter.Write (ints [i]);  			vertex = ints [degree];  			degree = ints [degree + 1];  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  	using (var reader = new UnbufferedIO.SequentialReader (filename)) {  		var ints = new int[2];  		var bytesToRead = reader.Length - 8;  		// read vertex name and degree  		reader.Read (ints' 0' 2);  		var vertex = ints [0];  		var degree = ints [1];  		while (bytesToRead > 0) {  			// allocate space if needed  			if (ints.Length < degree + 2)  				ints = new int[degree + 2];  			bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  			nodeWriter.Write (vertex);  			nodeWriter.Write (degree);  			for (int i = 0; i < degree; i++)  				edgeWriter.Write (ints [i]);  			vertex = ints [degree];  			degree = ints [degree + 1];  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  	using (var reader = new UnbufferedIO.SequentialReader (filename)) {  		var ints = new int[2];  		var bytesToRead = reader.Length - 8;  		// read vertex name and degree  		reader.Read (ints' 0' 2);  		var vertex = ints [0];  		var degree = ints [1];  		while (bytesToRead > 0) {  			// allocate space if needed  			if (ints.Length < degree + 2)  				ints = new int[degree + 2];  			bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  			nodeWriter.Write (vertex);  			nodeWriter.Write (degree);  			for (int i = 0; i < degree; i++)  				edgeWriter.Write (ints [i]);  			vertex = ints [degree];  			degree = ints [degree + 1];  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  	using (var reader = new UnbufferedIO.SequentialReader (filename)) {  		var ints = new int[2];  		var bytesToRead = reader.Length - 8;  		// read vertex name and degree  		reader.Read (ints' 0' 2);  		var vertex = ints [0];  		var degree = ints [1];  		while (bytesToRead > 0) {  			// allocate space if needed  			if (ints.Length < degree + 2)  				ints = new int[degree + 2];  			bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  			nodeWriter.Write (vertex);  			nodeWriter.Write (degree);  			for (int i = 0; i < degree; i++)  				edgeWriter.Write (ints [i]);  			vertex = ints [degree];  			degree = ints [degree + 1];  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var edgeWriter = new BinaryWriter (File.OpenWrite (filename + "-edges"))) {  	using (var reader = new UnbufferedIO.SequentialReader (filename)) {  		var ints = new int[2];  		var bytesToRead = reader.Length - 8;  		// read vertex name and degree  		reader.Read (ints' 0' 2);  		var vertex = ints [0];  		var degree = ints [1];  		while (bytesToRead > 0) {  			// allocate space if needed  			if (ints.Length < degree + 2)  				ints = new int[degree + 2];  			bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  			nodeWriter.Write (vertex);  			nodeWriter.Write (degree);  			for (int i = 0; i < degree; i++)  				edgeWriter.Write (ints [i]);  			vertex = ints [degree];  			degree = ints [degree + 1];  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename)) {  	var ints = new int[2];  	var bytesToRead = reader.Length - 8;  	// read vertex name and degree  	reader.Read (ints' 0' 2);  	var vertex = ints [0];  	var degree = ints [1];  	while (bytesToRead > 0) {  		// allocate space if needed  		if (ints.Length < degree + 2)  			ints = new int[degree + 2];  		bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  		nodeWriter.Write (vertex);  		nodeWriter.Write (degree);  		for (int i = 0; i < degree; i++)  			edgeWriter.Write (ints [i]);  		vertex = ints [degree];  		degree = ints [degree + 1];  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename)) {  	var ints = new int[2];  	var bytesToRead = reader.Length - 8;  	// read vertex name and degree  	reader.Read (ints' 0' 2);  	var vertex = ints [0];  	var degree = ints [1];  	while (bytesToRead > 0) {  		// allocate space if needed  		if (ints.Length < degree + 2)  			ints = new int[degree + 2];  		bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  		nodeWriter.Write (vertex);  		nodeWriter.Write (degree);  		for (int i = 0; i < degree; i++)  			edgeWriter.Write (ints [i]);  		vertex = ints [degree];  		degree = ints [degree + 1];  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename)) {  	var ints = new int[2];  	var bytesToRead = reader.Length - 8;  	// read vertex name and degree  	reader.Read (ints' 0' 2);  	var vertex = ints [0];  	var degree = ints [1];  	while (bytesToRead > 0) {  		// allocate space if needed  		if (ints.Length < degree + 2)  			ints = new int[degree + 2];  		bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  		nodeWriter.Write (vertex);  		nodeWriter.Write (degree);  		for (int i = 0; i < degree; i++)  			edgeWriter.Write (ints [i]);  		vertex = ints [degree];  		degree = ints [degree + 1];  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename)) {  	var ints = new int[2];  	var bytesToRead = reader.Length - 8;  	// read vertex name and degree  	reader.Read (ints' 0' 2);  	var vertex = ints [0];  	var degree = ints [1];  	while (bytesToRead > 0) {  		// allocate space if needed  		if (ints.Length < degree + 2)  			ints = new int[degree + 2];  		bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  		nodeWriter.Write (vertex);  		nodeWriter.Write (degree);  		for (int i = 0; i < degree; i++)  			edgeWriter.Write (ints [i]);  		vertex = ints [degree];  		degree = ints [degree + 1];  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename)) {  	var ints = new int[2];  	var bytesToRead = reader.Length - 8;  	// read vertex name and degree  	reader.Read (ints' 0' 2);  	var vertex = ints [0];  	var degree = ints [1];  	while (bytesToRead > 0) {  		// allocate space if needed  		if (ints.Length < degree + 2)  			ints = new int[degree + 2];  		bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  		nodeWriter.Write (vertex);  		nodeWriter.Write (degree);  		for (int i = 0; i < degree; i++)  			edgeWriter.Write (ints [i]);  		vertex = ints [degree];  		degree = ints [degree + 1];  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename)) {  	var ints = new int[2];  	var bytesToRead = reader.Length - 8;  	// read vertex name and degree  	reader.Read (ints' 0' 2);  	var vertex = ints [0];  	var degree = ints [1];  	while (bytesToRead > 0) {  		// allocate space if needed  		if (ints.Length < degree + 2)  			ints = new int[degree + 2];  		bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  		nodeWriter.Write (vertex);  		nodeWriter.Write (degree);  		for (int i = 0; i < degree; i++)  			edgeWriter.Write (ints [i]);  		vertex = ints [degree];  		degree = ints [degree + 1];  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename)) {  	var ints = new int[2];  	var bytesToRead = reader.Length - 8;  	// read vertex name and degree  	reader.Read (ints' 0' 2);  	var vertex = ints [0];  	var degree = ints [1];  	while (bytesToRead > 0) {  		// allocate space if needed  		if (ints.Length < degree + 2)  			ints = new int[degree + 2];  		bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  		nodeWriter.Write (vertex);  		nodeWriter.Write (degree);  		for (int i = 0; i < degree; i++)  			edgeWriter.Write (ints [i]);  		vertex = ints [degree];  		degree = ints [degree + 1];  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: reader.Read (ints' 0' 2);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2)  		ints = new int[degree + 2];  	bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  	nodeWriter.Write (vertex);  	nodeWriter.Write (degree);  	for (int i = 0; i < degree; i++)  		edgeWriter.Write (ints [i]);  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2)  		ints = new int[degree + 2];  	bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  	nodeWriter.Write (vertex);  	nodeWriter.Write (degree);  	for (int i = 0; i < degree; i++)  		edgeWriter.Write (ints [i]);  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2)  		ints = new int[degree + 2];  	bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  	nodeWriter.Write (vertex);  	nodeWriter.Write (degree);  	for (int i = 0; i < degree; i++)  		edgeWriter.Write (ints [i]);  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: while (bytesToRead > 0) {  	// allocate space if needed  	if (ints.Length < degree + 2)  		ints = new int[degree + 2];  	bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  	nodeWriter.Write (vertex);  	nodeWriter.Write (degree);  	for (int i = 0; i < degree; i++)  		edgeWriter.Write (ints [i]);  	vertex = ints [degree];  	degree = ints [degree + 1];  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: if (ints.Length < degree + 2)  	ints = new int[degree + 2];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: if (ints.Length < degree + 2)  	ints = new int[degree + 2];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: ints = new int[degree + 2];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,ConvertGraph,The following statement contains a magic number: bytesToRead -= 4 * reader.Read (ints' 0' (degree + 2));  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: scanner.Scan ((xUpper' yUpper' count' offset' edges) =>  {  	for (var j = offset; j < offset + count; j++)  		degrees [xUpper + ((edges [j] & 0xF0) >> 4)]++;  });  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: for (var j = offset; j < offset + count; j++)  	degrees [xUpper + ((edges [j] & 0xF0) >> 4)]++;  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: degrees [xUpper + ((edges [j] & 0xF0) >> 4)]++;  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++) {  	var startTime = stopwatch.Elapsed;  	for (int i = 0; i < nodes; i++) {  		b [i] = (1.0f - reset) * a [i] / degrees [i];  		a [i] = reset;  	}  	scanner.Scan ((xUpper' yUpper' count' offset' edges) =>  {  		for (var j = offset; j < offset + count; j++)  			a [yUpper + (edges [j] & 0x0F)] += b [xUpper + ((edges [j] & 0xF0) >> 4)];  	});  	Console.WriteLine ("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++) {  	var startTime = stopwatch.Elapsed;  	for (int i = 0; i < nodes; i++) {  		b [i] = (1.0f - reset) * a [i] / degrees [i];  		a [i] = reset;  	}  	scanner.Scan ((xUpper' yUpper' count' offset' edges) =>  {  		for (var j = offset; j < offset + count; j++)  			a [yUpper + (edges [j] & 0x0F)] += b [xUpper + ((edges [j] & 0xF0) >> 4)];  	});  	Console.WriteLine ("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: scanner.Scan ((xUpper' yUpper' count' offset' edges) =>  {  	for (var j = offset; j < offset + count; j++)  		a [yUpper + (edges [j] & 0x0F)] += b [xUpper + ((edges [j] & 0xF0) >> 4)];  });  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: for (var j = offset; j < offset + count; j++)  	a [yUpper + (edges [j] & 0x0F)] += b [xUpper + ((edges [j] & 0xF0) >> 4)];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertPagerank,The following statement contains a magic number: a [yUpper + (edges [j] & 0x0F)] += b [xUpper + ((edges [j] & 0xF0) >> 4)];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertCC,The following statement contains a magic number: scanner.Scan ((xUpper' yUpper' count' offset' edges) =>  {  	for (int j = 0; j < count; j++) {  		var source = (int)(xUpper + ((edges [offset + j] & 0xF0) >> 4));  		var target = (int)(yUpper + ((edges [offset + j] & 0x0F) >> 0));  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  });  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,MultiHilbertCC,The following statement contains a magic number: for (int j = 0; j < count; j++) {  	var source = (int)(xUpper + ((edges [offset + j] & 0xF0) >> 4));  	var target = (int)(yUpper + ((edges [offset + j] & 0x0F) >> 0));  	if (source != target) {  		while (source != roots [source])  			source = roots [source];  		while (target != roots [target])  			target = roots [target];  		// union(source' target)  		if (source != target) {  			// there may be a tie in ranks  			if (ranks [source] == ranks [target]) {  				// break ties towards lower ids  				if (source < target) {  					ranks [source]++;  					roots [target] = source;  				}  				else {  					ranks [target]++;  					roots [source] = target;  				}  			}  			else {  				// attatch lower rank to higher  				if (ranks [source] < ranks [target])  					roots [source] = target;  				else  					roots [target] = source;  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: Console.WriteLine ("{2}\tRead header of {0} blocks' for {1} edges"' metadata.Length / 3' edges.Length' stopwatch.Elapsed);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++) {  	var startTime = stopwatch.Elapsed;  	for (int i = 0; i < nodes; i++) {  		b [i] = (1.0f - reset) * a [i] / degrees [i];  		a [i] = reset;  	}  	ScanGraphHilbert (metadata' edges' (sourceUpper' targetUpper' offset' count' edgeArray) =>  {  		for (var j = offset; j < offset + count; j++)  			a [targetUpper + (edges [j] >> 16)] += b [sourceUpper + (edges [j] & 0xFFFF)];  	});  	Console.WriteLine ("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++) {  	var startTime = stopwatch.Elapsed;  	for (int i = 0; i < nodes; i++) {  		b [i] = (1.0f - reset) * a [i] / degrees [i];  		a [i] = reset;  	}  	ScanGraphHilbert (metadata' edges' (sourceUpper' targetUpper' offset' count' edgeArray) =>  {  		for (var j = offset; j < offset + count; j++)  			a [targetUpper + (edges [j] >> 16)] += b [sourceUpper + (edges [j] & 0xFFFF)];  	});  	Console.WriteLine ("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: ScanGraphHilbert (metadata' edges' (sourceUpper' targetUpper' offset' count' edgeArray) =>  {  	for (var j = offset; j < offset + count; j++)  		a [targetUpper + (edges [j] >> 16)] += b [sourceUpper + (edges [j] & 0xFFFF)];  });  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: for (var j = offset; j < offset + count; j++)  	a [targetUpper + (edges [j] >> 16)] += b [sourceUpper + (edges [j] & 0xFFFF)];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerank,The following statement contains a magic number: a [targetUpper + (edges [j] >> 16)] += b [sourceUpper + (edges [j] & 0xFFFF)];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: ScanGraphHilbert (filename' (srcUpper' tgtUpper' offset' count' edges) =>  {  	for (int i = 0; i < count; i++)  		degrees [srcUpper + (edges [offset + i] >> 16)]++;  });  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: for (int i = 0; i < count; i++)  	degrees [srcUpper + (edges [offset + i] >> 16)]++;  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: degrees [srcUpper + (edges [offset + i] >> 16)]++;  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++) {  	var startTime = stopwatch.Elapsed;  	ScanGraphHilbert (filename' (srcUpper' tgtUpper' offset' count' edges) =>  {  		for (int i = 0; i < count; i++)  			a [tgtUpper + (edges [offset + i] >> 16)] += b [srcUpper + (edges [offset + i] & 0xFFFF)];  	});  	for (int i = 0; i < nodes; i++)  		a [i] = a [i] / degrees [i];  	Console.WriteLine ("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++) {  	var startTime = stopwatch.Elapsed;  	ScanGraphHilbert (filename' (srcUpper' tgtUpper' offset' count' edges) =>  {  		for (int i = 0; i < count; i++)  			a [tgtUpper + (edges [offset + i] >> 16)] += b [srcUpper + (edges [offset + i] & 0xFFFF)];  	});  	for (int i = 0; i < nodes; i++)  		a [i] = a [i] / degrees [i];  	Console.WriteLine ("{0}\tIteration {1} in {2}"' stopwatch.Elapsed' iteration' stopwatch.Elapsed - startTime);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: ScanGraphHilbert (filename' (srcUpper' tgtUpper' offset' count' edges) =>  {  	for (int i = 0; i < count; i++)  		a [tgtUpper + (edges [offset + i] >> 16)] += b [srcUpper + (edges [offset + i] & 0xFFFF)];  });  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: for (int i = 0; i < count; i++)  	a [tgtUpper + (edges [offset + i] >> 16)] += b [srcUpper + (edges [offset + i] & 0xFFFF)];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertPagerankFromDisk,The following statement contains a magic number: a [tgtUpper + (edges [offset + i] >> 16)] += b [srcUpper + (edges [offset + i] & 0xFFFF)];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var upper = System.IO.File.OpenRead (filenameUpper)) {  	using (var lower = System.IO.File.OpenRead (filenameLower)) {  		var bytes = new byte[upper.Length];  		upper.Read (bytes' 0' bytes.Length);  		var uppers = new int[bytes.Length / 4];  		Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  		var maxEdges = 0;  		for (int i = 0; i < uppers.Length; i += 3)  			maxEdges = Math.Max (maxEdges' uppers [i + 2]);  		Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  		bytes = new byte[8 * maxEdges];  		var lowers = new UInt16[2 * maxEdges];  		var edges = new Int32[2 * maxEdges];  		#if UseLargePages  		var roots = LargePages.AllocateInts (nodes);  		var ranks = LargePages.AllocateBytes (nodes);  		#else  		                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  		for (int i = 0; i < nodes; i++)  			roots [i] = i;  		for (int i = 0; i < uppers.Length; i += 3) {  			var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  			Buffer.BlockCopy (bytes' 0' lowers' 0' read);  			var sourceUpper = uppers [i + 0] << 16;  			var targetUpper = uppers [i + 1] << 16;  			var count = uppers [i + 2];  			for (int j = 0; j < count; j++) {  				edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  				edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  			}  			for (int j = 0; j < count; j++) {  				var source = edges [2 * j + 0];  				var target = edges [2 * j + 1];  				if (source != target) {  					while (source != roots [source])  						source = roots [source];  					while (target != roots [target])  						target = roots [target];  					// union(source' target)  					if (source != target) {  						// there may be a tie in ranks  						if (ranks [source] == ranks [target]) {  							// break ties towards lower ids  							if (source < target) {  								ranks [source]++;  								roots [target] = source;  							}  							else {  								ranks [target]++;  								roots [source] = target;  							}  						}  						else {  							// attatch lower rank to higher  							if (ranks [source] < ranks [target])  								roots [source] = target;  							else  								roots [target] = source;  						}  					}  				}  			}  		}  		// path compress all vertices to roots.  		for (int i = 0; i < nodes; i++)  			while (roots [i] != roots [roots [i]])  				roots [i] = roots [roots [i]];  		var counter = 0;  		for (int i = 0; i < nodes; i++)  			if (roots [i] != i)  				counter++;  		Console.WriteLine ("Edges found: {0}"' counter);  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: using (var lower = System.IO.File.OpenRead (filenameLower)) {  	var bytes = new byte[upper.Length];  	upper.Read (bytes' 0' bytes.Length);  	var uppers = new int[bytes.Length / 4];  	Buffer.BlockCopy (bytes' 0' uppers' 0' bytes.Length);  	var maxEdges = 0;  	for (int i = 0; i < uppers.Length; i += 3)  		maxEdges = Math.Max (maxEdges' uppers [i + 2]);  	Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  	bytes = new byte[8 * maxEdges];  	var lowers = new UInt16[2 * maxEdges];  	var edges = new Int32[2 * maxEdges];  	#if UseLargePages  	var roots = LargePages.AllocateInts (nodes);  	var ranks = LargePages.AllocateBytes (nodes);  	#else  	                    var roots = new int[nodes];                     var ranks = new byte[nodes]; #endif  	for (int i = 0; i < nodes; i++)  		roots [i] = i;  	for (int i = 0; i < uppers.Length; i += 3) {  		var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  		Buffer.BlockCopy (bytes' 0' lowers' 0' read);  		var sourceUpper = uppers [i + 0] << 16;  		var targetUpper = uppers [i + 1] << 16;  		var count = uppers [i + 2];  		for (int j = 0; j < count; j++) {  			edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  			edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  		}  		for (int j = 0; j < count; j++) {  			var source = edges [2 * j + 0];  			var target = edges [2 * j + 1];  			if (source != target) {  				while (source != roots [source])  					source = roots [source];  				while (target != roots [target])  					target = roots [target];  				// union(source' target)  				if (source != target) {  					// there may be a tie in ranks  					if (ranks [source] == ranks [target]) {  						// break ties towards lower ids  						if (source < target) {  							ranks [source]++;  							roots [target] = source;  						}  						else {  							ranks [target]++;  							roots [source] = target;  						}  					}  					else {  						// attatch lower rank to higher  						if (ranks [source] < ranks [target])  							roots [source] = target;  						else  							roots [target] = source;  					}  				}  			}  		}  	}  	// path compress all vertices to roots.  	for (int i = 0; i < nodes; i++)  		while (roots [i] != roots [roots [i]])  			roots [i] = roots [roots [i]];  	var counter = 0;  	for (int i = 0; i < nodes; i++)  		if (roots [i] != i)  			counter++;  	Console.WriteLine ("Edges found: {0}"' counter);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3)  	maxEdges = Math.Max (maxEdges' uppers [i + 2]);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3)  	maxEdges = Math.Max (maxEdges' uppers [i + 2]);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: i += 3
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: maxEdges = Math.Max (maxEdges' uppers [i + 2]);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: Console.WriteLine ("{1}\tRead header of {0} blocks"' uppers.Length / 3' stopwatch.Elapsed);  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: bytes = new byte[8 * maxEdges];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int i = 0; i < uppers.Length; i += 3) {  	var read = lower.Read (bytes' 0' 4 * uppers [i + 2]);  	Buffer.BlockCopy (bytes' 0' lowers' 0' read);  	var sourceUpper = uppers [i + 0] << 16;  	var targetUpper = uppers [i + 1] << 16;  	var count = uppers [i + 2];  	for (int j = 0; j < count; j++) {  		edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  		edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  	}  	for (int j = 0; j < count; j++) {  		var source = edges [2 * j + 0];  		var target = edges [2 * j + 1];  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: i += 3
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int j = 0; j < count; j++) {  	edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  	edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int j = 0; j < count; j++) {  	edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  	edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int j = 0; j < count; j++) {  	edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  	edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int j = 0; j < count; j++) {  	edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  	edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: edges [2 * j + 0] = roots [sourceUpper + lowers [2 * j + 0]];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: edges [2 * j + 1] = roots [targetUpper + lowers [2 * j + 1]];  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int j = 0; j < count; j++) {  	var source = edges [2 * j + 0];  	var target = edges [2 * j + 1];  	if (source != target) {  		while (source != roots [source])  			source = roots [source];  		while (target != roots [target])  			target = roots [target];  		// union(source' target)  		if (source != target) {  			// there may be a tie in ranks  			if (ranks [source] == ranks [target]) {  				// break ties towards lower ids  				if (source < target) {  					ranks [source]++;  					roots [target] = source;  				}  				else {  					ranks [target]++;  					roots [source] = target;  				}  			}  			else {  				// attatch lower rank to higher  				if (ranks [source] < ranks [target])  					roots [source] = target;  				else  					roots [target] = source;  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind,The following statement contains a magic number: for (int j = 0; j < count; j++) {  	var source = edges [2 * j + 0];  	var target = edges [2 * j + 1];  	if (source != target) {  		while (source != roots [source])  			source = roots [source];  		while (target != roots [target])  			target = roots [target];  		// union(source' target)  		if (source != target) {  			// there may be a tie in ranks  			if (ranks [source] == ranks [target]) {  				// break ties towards lower ids  				if (source < target) {  					ranks [source]++;  					roots [target] = source;  				}  				else {  					ranks [target]++;  					roots [source] = target;  				}  			}  			else {  				// attatch lower rank to higher  				if (ranks [source] < ranks [target])  					roots [source] = target;  				else  					roots [target] = source;  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind2,The following statement contains a magic number: ScanGraphHilbert (filename' (sourceUpper' targetUpper' offset' count' edges) =>  {  	for (int j = 0; j < count; j++) {  		var source = (int)(sourceUpper + (edges [offset + j] & 0xFFFF));  		var target = (int)(targetUpper + (edges [offset + j] >> 16));  		if (source != target) {  			while (source != roots [source])  				source = roots [source];  			while (target != roots [target])  				target = roots [target];  			// union(source' target)  			if (source != target) {  				// there may be a tie in ranks  				if (ranks [source] == ranks [target]) {  					// break ties towards lower ids  					if (source < target) {  						ranks [source]++;  						roots [target] = source;  					}  					else {  						ranks [target]++;  						roots [source] = target;  					}  				}  				else {  					// attatch lower rank to higher  					if (ranks [source] < ranks [target])  						roots [source] = target;  					else  						roots [target] = source;  				}  			}  		}  	}  });  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,HilbertUnionFind2,The following statement contains a magic number: for (int j = 0; j < count; j++) {  	var source = (int)(sourceUpper + (edges [offset + j] & 0xFFFF));  	var target = (int)(targetUpper + (edges [offset + j] >> 16));  	if (source != target) {  		while (source != roots [source])  			source = roots [source];  		while (target != roots [target])  			target = roots [target];  		// union(source' target)  		if (source != target) {  			// there may be a tie in ranks  			if (ranks [source] == ranks [target]) {  				// break ties towards lower ids  				if (source < target) {  					ranks [source]++;  					roots [target] = source;  				}  				else {  					ranks [target]++;  					roots [source] = target;  				}  			}  			else {  				// attatch lower rank to higher  				if (ranks [source] < ranks [target])  					roots [source] = target;  				else  					roots [target] = source;  			}  		}  	}  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankFromDisk,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++) {  	var startTime = stopwatch.Elapsed;  	graph.ForEach ((vertex' degree) =>  {  		b [vertex] = (1.0f - reset) * a [vertex] / degree;  		a [vertex] = reset;  	});  	graph.ForEach ((vertex' degree' offset' neighbors) =>  {  		for (int i = 0; i < degree; i++)  			a [neighbors [offset + i]] += b [vertex];  	});  	Console.WriteLine ("{0}\tIteration {1}"' stopwatch.Elapsed - startTime' iteration);  }  
Magic Number,COST,SingleThreaded,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\SingleThreaded.cs,PageRankStep,The following statement contains a magic number: for (int iteration = 0; iteration < 20; iteration++) {  	var startTime = stopwatch.Elapsed;  	for (int i = 0; i < nodes; i++) {  		b [i] = a [i];  		a [i] = 0.0f;  	}  	// apply per-vertex pagerank logic across the graph  	ScanGraph (nodeArray' edgeArray' (vertex' degree' offset' neighbors) =>  {  		if (b [vertex] > 0.0f) {  			var update = (1.0f - reset) * b [vertex] / degree;  			for (int i = 0; i < degree; i++)  				a [neighbors [offset + i]] += update;  		}  	});  	Console.WriteLine ("{0}\tIteration {1}"' stopwatch.Elapsed - startTime' iteration);  }  
Magic Number,COST,UnbufferedIO,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,ReadFile,The following statement contains a magic number: using (var reader = new UnbufferedIO.SequentialReader (filename)) {  	var result = new T[reader.Length / System.Runtime.InteropServices.Marshal.SizeOf (typeof(T))];  	// if the thing to read is bigger than 2GB' Buffer.BlockCopy will choke (yay 32 bits)  	if (((Int64)result.Length) * System.Runtime.InteropServices.Marshal.SizeOf (typeof(T)) > Int32.MaxValue) {  		var intermediate = new T[1 << 20];  		var cursor = 0;  		while (reader.Read (intermediate' 0' intermediate.Length) > 0) {  			Array.Copy (intermediate' 0' result' cursor' Math.Min (intermediate.Length' result.Length - cursor));  			cursor += intermediate.Length;  		}  	}  	else  		reader.Read (result' 0' result.Length);  	return result;  }  
Magic Number,COST,UnbufferedIO,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\UnbufferedIO.cs,ReadFile,The following statement contains a magic number: if (((Int64)result.Length) * System.Runtime.InteropServices.Marshal.SizeOf (typeof(T)) > Int32.MaxValue) {  	var intermediate = new T[1 << 20];  	var cursor = 0;  	while (reader.Read (intermediate' 0' intermediate.Length) > 0) {  		Array.Copy (intermediate' 0' result' cursor' Math.Min (intermediate.Length' result.Length - cursor));  		cursor += intermediate.Length;  	}  }  else  	reader.Read (result' 0' result.Length);  
Duplicate Code,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((86' 124)' (163' 201)' (237' 275))
Duplicate Code,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((86' 126)' (237' 277))
Duplicate Code,COST,Program,C:\repos\MicrosoftResearch_NaiadSamples\COST\COST\Program.cs,ExecuteNaiad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((129' 150)' (203' 224))
