Implementation smell,Namespace,Class,File,Method,Description
Long Method,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,The method has 179 lines of code.
Complex Method,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,Cyclomatic complexity of the method is 17
Complex Method,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,CompactHelper,Cyclomatic complexity of the method is 9
Complex Method,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,CollapseEdge,Cyclomatic complexity of the method is 14
Complex Method,Plankton,PlanktonMesh,C:\repos\meshmash_Plankton\src\Plankton\PlanktonMesh.cs,Dual,Cyclomatic complexity of the method is 13
Complex Method,Plankton,PlanktonVertexList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonVertexList.cs,SplitVertex,Cyclomatic complexity of the method is 10
Long Statement,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,TriangleSplitEdge,The length of the statement  "            _mesh.Vertices[point_on_edge].X = 0.5F * (_mesh.Vertices[this[index].StartVertex].X + _mesh.Vertices[this.EndVertex(new_halfedge)].X); " is 134.
Long Statement,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,TriangleSplitEdge,The length of the statement  "            _mesh.Vertices[point_on_edge].Y = 0.5F * (_mesh.Vertices[this[index].StartVertex].Y + _mesh.Vertices[this.EndVertex(new_halfedge)].Y); " is 134.
Long Statement,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,TriangleSplitEdge,The length of the statement  "            _mesh.Vertices[point_on_edge].Z = 0.5F * (_mesh.Vertices[this[index].StartVertex].Z + _mesh.Vertices[this.EndVertex(new_halfedge)].Z); " is 134.
Long Statement,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,TriangleSplitEdge,The length of the statement  "            int new_face2 = _mesh.Faces.SplitFace(this.GetPairHalfedge(index)' this[this[this.GetPairHalfedge(index)].NextHalfedge].NextHalfedge); " is 134.
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,The following statement contains a magic number: if (n < 3) return -1;
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,The following statement contains a magic number: for (int i = 0' ii = 1; i < n; i++' ii++' ii %= n)              {                  //int v1 = array[i];                  int v2 = array[ii];                  int id = 0;                  if (is_new[i])  id += 1; // first is new                  if (is_new[ii]) id += 2; // second is new                                    // Check for non-manifold vertex case' i.e. both current halfedges are new                  // but the vertex between them is already part of another face. This vertex                  // will have TWO OR MORE outgoing boundary halfedges! (Not strictly allowed'                  // but it could happen if faces are added in an UGLY order.)                  // TODO: If a mesh has non-manifold vertices perhaps it should be considered                  // INVALID. Any operations performed on such a mesh cannot be relied upon to                  // perform correctly as the adjacency information may not be correct.                  // (More reading: http://www.pointclouds.org/blog/nvcs/)                  if (id == 3 && vs[v2].OutgoingHalfedge > -1) id++; // id == 4                                    if (id > 0) // At least one of the halfedge pairs is new...                  {                      // Link outer halfedges                      int outer_prev = -1' outer_next = -1;                      switch (id)                      {                          case 1: // first is new' second is old                              // iterate through halfedges clockwise around vertex #v2 until boundary                              outer_prev = hs[loop[ii]].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 2: // second is new' first is old                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs[loop[i]].NextHalfedge;                              break;                          case 3: // both are new                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 4: // both are new (non-manifold vertex)                              // We have TWO boundaries to take care of here: first...                              outer_prev = hs[vs[v2].OutgoingHalfedge].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              hs[outer_prev].NextHalfedge = outer_next;                              hs[outer_next].PrevHalfedge = outer_prev;                              // and second...                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = vs[v2].OutgoingHalfedge;                              break;                      }                      // outer_{prev'next} should now be set' so store links in HDS                      if (outer_prev > -1 && outer_next > -1)                      {                          hs[outer_prev].NextHalfedge = outer_next;                          hs[outer_next].PrevHalfedge = outer_prev;                      }                                            // Link inner halfedges                      hs[loop[i]].NextHalfedge = loop[ii];                      hs[loop[ii]].PrevHalfedge = loop[i];                                            // ensure vertex->outgoing is boundary if vertex is boundary                      if (is_new[i]) // first is new                      {                          vs[v2].OutgoingHalfedge = loop[i] + 1;                      }                  }                  else // both old (non-manifold vertex trickery below)                  {                      // In the case that v2 links to the current second halfedge' creating a                      // face here will redefine v2 as a non-boundary vertex. Do a quick lap of                      // v2's other outgoing halfedges in case one of them is still a boundary                      // (as will be the case if v2 was non-manifold).                      if (vs[v2].OutgoingHalfedge == loop[ii])                      {                          foreach (int h in hs.GetVertexCirculator(loop[ii]).Skip(1))                          {                              if (hs[h].AdjacentFace < 0)                              {                                  vs[v2].OutgoingHalfedge = h;                                  break;                              }                          }                      }                      // If inner loop exists' but for some reason it's not already linked                      // (non-manifold vertex) make loop[i] adjacent to loop[ii]. Tidy up other                      // halfedge links such that all outgoing halfedges remain visible to v2.                      if (hs[loop[i]].NextHalfedge != loop[ii] || hs[loop[ii]].PrevHalfedge != loop[i])                      {                          int next = hs[loop[i]].NextHalfedge;                          int prev = hs[loop[ii]].PrevHalfedge;                          // Find another boundary at this vertex to link 'next' and 'prev' into.                          try                          {                              int boundary = hs.GetVertexCirculator(loop[ii]).Skip(1)                                  .First(h => hs[h].AdjacentFace < 0);                              hs.MakeConsecutive(loop[i]' loop[ii]);                              hs.MakeConsecutive(hs[boundary].PrevHalfedge' next);                              hs.MakeConsecutive(prev' boundary);                          }                          // If no other boundary is found' something must be wrong...                          catch (InvalidOperationException)                          {                              throw new InvalidOperationException(string.Format(                                  "Failed to relink halfedges around vertex #{0} during creation of face #{1}"' v2' this.Count));                          }                      }                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,The following statement contains a magic number: for (int i = 0' ii = 1; i < n; i++' ii++' ii %= n)              {                  //int v1 = array[i];                  int v2 = array[ii];                  int id = 0;                  if (is_new[i])  id += 1; // first is new                  if (is_new[ii]) id += 2; // second is new                                    // Check for non-manifold vertex case' i.e. both current halfedges are new                  // but the vertex between them is already part of another face. This vertex                  // will have TWO OR MORE outgoing boundary halfedges! (Not strictly allowed'                  // but it could happen if faces are added in an UGLY order.)                  // TODO: If a mesh has non-manifold vertices perhaps it should be considered                  // INVALID. Any operations performed on such a mesh cannot be relied upon to                  // perform correctly as the adjacency information may not be correct.                  // (More reading: http://www.pointclouds.org/blog/nvcs/)                  if (id == 3 && vs[v2].OutgoingHalfedge > -1) id++; // id == 4                                    if (id > 0) // At least one of the halfedge pairs is new...                  {                      // Link outer halfedges                      int outer_prev = -1' outer_next = -1;                      switch (id)                      {                          case 1: // first is new' second is old                              // iterate through halfedges clockwise around vertex #v2 until boundary                              outer_prev = hs[loop[ii]].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 2: // second is new' first is old                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs[loop[i]].NextHalfedge;                              break;                          case 3: // both are new                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 4: // both are new (non-manifold vertex)                              // We have TWO boundaries to take care of here: first...                              outer_prev = hs[vs[v2].OutgoingHalfedge].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              hs[outer_prev].NextHalfedge = outer_next;                              hs[outer_next].PrevHalfedge = outer_prev;                              // and second...                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = vs[v2].OutgoingHalfedge;                              break;                      }                      // outer_{prev'next} should now be set' so store links in HDS                      if (outer_prev > -1 && outer_next > -1)                      {                          hs[outer_prev].NextHalfedge = outer_next;                          hs[outer_next].PrevHalfedge = outer_prev;                      }                                            // Link inner halfedges                      hs[loop[i]].NextHalfedge = loop[ii];                      hs[loop[ii]].PrevHalfedge = loop[i];                                            // ensure vertex->outgoing is boundary if vertex is boundary                      if (is_new[i]) // first is new                      {                          vs[v2].OutgoingHalfedge = loop[i] + 1;                      }                  }                  else // both old (non-manifold vertex trickery below)                  {                      // In the case that v2 links to the current second halfedge' creating a                      // face here will redefine v2 as a non-boundary vertex. Do a quick lap of                      // v2's other outgoing halfedges in case one of them is still a boundary                      // (as will be the case if v2 was non-manifold).                      if (vs[v2].OutgoingHalfedge == loop[ii])                      {                          foreach (int h in hs.GetVertexCirculator(loop[ii]).Skip(1))                          {                              if (hs[h].AdjacentFace < 0)                              {                                  vs[v2].OutgoingHalfedge = h;                                  break;                              }                          }                      }                      // If inner loop exists' but for some reason it's not already linked                      // (non-manifold vertex) make loop[i] adjacent to loop[ii]. Tidy up other                      // halfedge links such that all outgoing halfedges remain visible to v2.                      if (hs[loop[i]].NextHalfedge != loop[ii] || hs[loop[ii]].PrevHalfedge != loop[i])                      {                          int next = hs[loop[i]].NextHalfedge;                          int prev = hs[loop[ii]].PrevHalfedge;                          // Find another boundary at this vertex to link 'next' and 'prev' into.                          try                          {                              int boundary = hs.GetVertexCirculator(loop[ii]).Skip(1)                                  .First(h => hs[h].AdjacentFace < 0);                              hs.MakeConsecutive(loop[i]' loop[ii]);                              hs.MakeConsecutive(hs[boundary].PrevHalfedge' next);                              hs.MakeConsecutive(prev' boundary);                          }                          // If no other boundary is found' something must be wrong...                          catch (InvalidOperationException)                          {                              throw new InvalidOperationException(string.Format(                                  "Failed to relink halfedges around vertex #{0} during creation of face #{1}"' v2' this.Count));                          }                      }                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,The following statement contains a magic number: for (int i = 0' ii = 1; i < n; i++' ii++' ii %= n)              {                  //int v1 = array[i];                  int v2 = array[ii];                  int id = 0;                  if (is_new[i])  id += 1; // first is new                  if (is_new[ii]) id += 2; // second is new                                    // Check for non-manifold vertex case' i.e. both current halfedges are new                  // but the vertex between them is already part of another face. This vertex                  // will have TWO OR MORE outgoing boundary halfedges! (Not strictly allowed'                  // but it could happen if faces are added in an UGLY order.)                  // TODO: If a mesh has non-manifold vertices perhaps it should be considered                  // INVALID. Any operations performed on such a mesh cannot be relied upon to                  // perform correctly as the adjacency information may not be correct.                  // (More reading: http://www.pointclouds.org/blog/nvcs/)                  if (id == 3 && vs[v2].OutgoingHalfedge > -1) id++; // id == 4                                    if (id > 0) // At least one of the halfedge pairs is new...                  {                      // Link outer halfedges                      int outer_prev = -1' outer_next = -1;                      switch (id)                      {                          case 1: // first is new' second is old                              // iterate through halfedges clockwise around vertex #v2 until boundary                              outer_prev = hs[loop[ii]].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 2: // second is new' first is old                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs[loop[i]].NextHalfedge;                              break;                          case 3: // both are new                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 4: // both are new (non-manifold vertex)                              // We have TWO boundaries to take care of here: first...                              outer_prev = hs[vs[v2].OutgoingHalfedge].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              hs[outer_prev].NextHalfedge = outer_next;                              hs[outer_next].PrevHalfedge = outer_prev;                              // and second...                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = vs[v2].OutgoingHalfedge;                              break;                      }                      // outer_{prev'next} should now be set' so store links in HDS                      if (outer_prev > -1 && outer_next > -1)                      {                          hs[outer_prev].NextHalfedge = outer_next;                          hs[outer_next].PrevHalfedge = outer_prev;                      }                                            // Link inner halfedges                      hs[loop[i]].NextHalfedge = loop[ii];                      hs[loop[ii]].PrevHalfedge = loop[i];                                            // ensure vertex->outgoing is boundary if vertex is boundary                      if (is_new[i]) // first is new                      {                          vs[v2].OutgoingHalfedge = loop[i] + 1;                      }                  }                  else // both old (non-manifold vertex trickery below)                  {                      // In the case that v2 links to the current second halfedge' creating a                      // face here will redefine v2 as a non-boundary vertex. Do a quick lap of                      // v2's other outgoing halfedges in case one of them is still a boundary                      // (as will be the case if v2 was non-manifold).                      if (vs[v2].OutgoingHalfedge == loop[ii])                      {                          foreach (int h in hs.GetVertexCirculator(loop[ii]).Skip(1))                          {                              if (hs[h].AdjacentFace < 0)                              {                                  vs[v2].OutgoingHalfedge = h;                                  break;                              }                          }                      }                      // If inner loop exists' but for some reason it's not already linked                      // (non-manifold vertex) make loop[i] adjacent to loop[ii]. Tidy up other                      // halfedge links such that all outgoing halfedges remain visible to v2.                      if (hs[loop[i]].NextHalfedge != loop[ii] || hs[loop[ii]].PrevHalfedge != loop[i])                      {                          int next = hs[loop[i]].NextHalfedge;                          int prev = hs[loop[ii]].PrevHalfedge;                          // Find another boundary at this vertex to link 'next' and 'prev' into.                          try                          {                              int boundary = hs.GetVertexCirculator(loop[ii]).Skip(1)                                  .First(h => hs[h].AdjacentFace < 0);                              hs.MakeConsecutive(loop[i]' loop[ii]);                              hs.MakeConsecutive(hs[boundary].PrevHalfedge' next);                              hs.MakeConsecutive(prev' boundary);                          }                          // If no other boundary is found' something must be wrong...                          catch (InvalidOperationException)                          {                              throw new InvalidOperationException(string.Format(                                  "Failed to relink halfedges around vertex #{0} during creation of face #{1}"' v2' this.Count));                          }                      }                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,The following statement contains a magic number: for (int i = 0' ii = 1; i < n; i++' ii++' ii %= n)              {                  //int v1 = array[i];                  int v2 = array[ii];                  int id = 0;                  if (is_new[i])  id += 1; // first is new                  if (is_new[ii]) id += 2; // second is new                                    // Check for non-manifold vertex case' i.e. both current halfedges are new                  // but the vertex between them is already part of another face. This vertex                  // will have TWO OR MORE outgoing boundary halfedges! (Not strictly allowed'                  // but it could happen if faces are added in an UGLY order.)                  // TODO: If a mesh has non-manifold vertices perhaps it should be considered                  // INVALID. Any operations performed on such a mesh cannot be relied upon to                  // perform correctly as the adjacency information may not be correct.                  // (More reading: http://www.pointclouds.org/blog/nvcs/)                  if (id == 3 && vs[v2].OutgoingHalfedge > -1) id++; // id == 4                                    if (id > 0) // At least one of the halfedge pairs is new...                  {                      // Link outer halfedges                      int outer_prev = -1' outer_next = -1;                      switch (id)                      {                          case 1: // first is new' second is old                              // iterate through halfedges clockwise around vertex #v2 until boundary                              outer_prev = hs[loop[ii]].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 2: // second is new' first is old                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs[loop[i]].NextHalfedge;                              break;                          case 3: // both are new                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 4: // both are new (non-manifold vertex)                              // We have TWO boundaries to take care of here: first...                              outer_prev = hs[vs[v2].OutgoingHalfedge].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              hs[outer_prev].NextHalfedge = outer_next;                              hs[outer_next].PrevHalfedge = outer_prev;                              // and second...                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = vs[v2].OutgoingHalfedge;                              break;                      }                      // outer_{prev'next} should now be set' so store links in HDS                      if (outer_prev > -1 && outer_next > -1)                      {                          hs[outer_prev].NextHalfedge = outer_next;                          hs[outer_next].PrevHalfedge = outer_prev;                      }                                            // Link inner halfedges                      hs[loop[i]].NextHalfedge = loop[ii];                      hs[loop[ii]].PrevHalfedge = loop[i];                                            // ensure vertex->outgoing is boundary if vertex is boundary                      if (is_new[i]) // first is new                      {                          vs[v2].OutgoingHalfedge = loop[i] + 1;                      }                  }                  else // both old (non-manifold vertex trickery below)                  {                      // In the case that v2 links to the current second halfedge' creating a                      // face here will redefine v2 as a non-boundary vertex. Do a quick lap of                      // v2's other outgoing halfedges in case one of them is still a boundary                      // (as will be the case if v2 was non-manifold).                      if (vs[v2].OutgoingHalfedge == loop[ii])                      {                          foreach (int h in hs.GetVertexCirculator(loop[ii]).Skip(1))                          {                              if (hs[h].AdjacentFace < 0)                              {                                  vs[v2].OutgoingHalfedge = h;                                  break;                              }                          }                      }                      // If inner loop exists' but for some reason it's not already linked                      // (non-manifold vertex) make loop[i] adjacent to loop[ii]. Tidy up other                      // halfedge links such that all outgoing halfedges remain visible to v2.                      if (hs[loop[i]].NextHalfedge != loop[ii] || hs[loop[ii]].PrevHalfedge != loop[i])                      {                          int next = hs[loop[i]].NextHalfedge;                          int prev = hs[loop[ii]].PrevHalfedge;                          // Find another boundary at this vertex to link 'next' and 'prev' into.                          try                          {                              int boundary = hs.GetVertexCirculator(loop[ii]).Skip(1)                                  .First(h => hs[h].AdjacentFace < 0);                              hs.MakeConsecutive(loop[i]' loop[ii]);                              hs.MakeConsecutive(hs[boundary].PrevHalfedge' next);                              hs.MakeConsecutive(prev' boundary);                          }                          // If no other boundary is found' something must be wrong...                          catch (InvalidOperationException)                          {                              throw new InvalidOperationException(string.Format(                                  "Failed to relink halfedges around vertex #{0} during creation of face #{1}"' v2' this.Count));                          }                      }                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,The following statement contains a magic number: for (int i = 0' ii = 1; i < n; i++' ii++' ii %= n)              {                  //int v1 = array[i];                  int v2 = array[ii];                  int id = 0;                  if (is_new[i])  id += 1; // first is new                  if (is_new[ii]) id += 2; // second is new                                    // Check for non-manifold vertex case' i.e. both current halfedges are new                  // but the vertex between them is already part of another face. This vertex                  // will have TWO OR MORE outgoing boundary halfedges! (Not strictly allowed'                  // but it could happen if faces are added in an UGLY order.)                  // TODO: If a mesh has non-manifold vertices perhaps it should be considered                  // INVALID. Any operations performed on such a mesh cannot be relied upon to                  // perform correctly as the adjacency information may not be correct.                  // (More reading: http://www.pointclouds.org/blog/nvcs/)                  if (id == 3 && vs[v2].OutgoingHalfedge > -1) id++; // id == 4                                    if (id > 0) // At least one of the halfedge pairs is new...                  {                      // Link outer halfedges                      int outer_prev = -1' outer_next = -1;                      switch (id)                      {                          case 1: // first is new' second is old                              // iterate through halfedges clockwise around vertex #v2 until boundary                              outer_prev = hs[loop[ii]].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 2: // second is new' first is old                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs[loop[i]].NextHalfedge;                              break;                          case 3: // both are new                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 4: // both are new (non-manifold vertex)                              // We have TWO boundaries to take care of here: first...                              outer_prev = hs[vs[v2].OutgoingHalfedge].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              hs[outer_prev].NextHalfedge = outer_next;                              hs[outer_next].PrevHalfedge = outer_prev;                              // and second...                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = vs[v2].OutgoingHalfedge;                              break;                      }                      // outer_{prev'next} should now be set' so store links in HDS                      if (outer_prev > -1 && outer_next > -1)                      {                          hs[outer_prev].NextHalfedge = outer_next;                          hs[outer_next].PrevHalfedge = outer_prev;                      }                                            // Link inner halfedges                      hs[loop[i]].NextHalfedge = loop[ii];                      hs[loop[ii]].PrevHalfedge = loop[i];                                            // ensure vertex->outgoing is boundary if vertex is boundary                      if (is_new[i]) // first is new                      {                          vs[v2].OutgoingHalfedge = loop[i] + 1;                      }                  }                  else // both old (non-manifold vertex trickery below)                  {                      // In the case that v2 links to the current second halfedge' creating a                      // face here will redefine v2 as a non-boundary vertex. Do a quick lap of                      // v2's other outgoing halfedges in case one of them is still a boundary                      // (as will be the case if v2 was non-manifold).                      if (vs[v2].OutgoingHalfedge == loop[ii])                      {                          foreach (int h in hs.GetVertexCirculator(loop[ii]).Skip(1))                          {                              if (hs[h].AdjacentFace < 0)                              {                                  vs[v2].OutgoingHalfedge = h;                                  break;                              }                          }                      }                      // If inner loop exists' but for some reason it's not already linked                      // (non-manifold vertex) make loop[i] adjacent to loop[ii]. Tidy up other                      // halfedge links such that all outgoing halfedges remain visible to v2.                      if (hs[loop[i]].NextHalfedge != loop[ii] || hs[loop[ii]].PrevHalfedge != loop[i])                      {                          int next = hs[loop[i]].NextHalfedge;                          int prev = hs[loop[ii]].PrevHalfedge;                          // Find another boundary at this vertex to link 'next' and 'prev' into.                          try                          {                              int boundary = hs.GetVertexCirculator(loop[ii]).Skip(1)                                  .First(h => hs[h].AdjacentFace < 0);                              hs.MakeConsecutive(loop[i]' loop[ii]);                              hs.MakeConsecutive(hs[boundary].PrevHalfedge' next);                              hs.MakeConsecutive(prev' boundary);                          }                          // If no other boundary is found' something must be wrong...                          catch (InvalidOperationException)                          {                              throw new InvalidOperationException(string.Format(                                  "Failed to relink halfedges around vertex #{0} during creation of face #{1}"' v2' this.Count));                          }                      }                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,MergeFaces,The following statement contains a magic number: if (3 > _mesh.Vertices.GetHalfedges(hs[index].StartVertex).Length) { return -1; }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,MergeFaces,The following statement contains a magic number: if (3 > _mesh.Vertices.GetHalfedges(hs[pair].StartVertex).Length) { return -1; }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,Stellate,The following statement contains a magic number: for (int i = 0; i < FaceHalfEdges.Length; i++)              {                  int ThisHalfEdge = FaceHalfEdges[i];                  if(i<FaceHalfEdges.Length-1)                  {                      //link the edge to the ingoing spoke' and the ingoing spoke to the outgoing one                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + i*2 + 3);                      _mesh.Halfedges.MakeConsecutive(CountBefore + (i*2) + 3' CountBefore + (i*2));                      //set the AdjacentFace of the ingoing spoke                                      _mesh.Halfedges[CountBefore + (i * 2) + 3].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }                  else                  {                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + 1);                      _mesh.Halfedges.MakeConsecutive(CountBefore + 1' CountBefore + (i*2));                      _mesh.Halfedges[CountBefore + 1].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,Stellate,The following statement contains a magic number: for (int i = 0; i < FaceHalfEdges.Length; i++)              {                  int ThisHalfEdge = FaceHalfEdges[i];                  if(i<FaceHalfEdges.Length-1)                  {                      //link the edge to the ingoing spoke' and the ingoing spoke to the outgoing one                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + i*2 + 3);                      _mesh.Halfedges.MakeConsecutive(CountBefore + (i*2) + 3' CountBefore + (i*2));                      //set the AdjacentFace of the ingoing spoke                                      _mesh.Halfedges[CountBefore + (i * 2) + 3].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }                  else                  {                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + 1);                      _mesh.Halfedges.MakeConsecutive(CountBefore + 1' CountBefore + (i*2));                      _mesh.Halfedges[CountBefore + 1].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,Stellate,The following statement contains a magic number: for (int i = 0; i < FaceHalfEdges.Length; i++)              {                  int ThisHalfEdge = FaceHalfEdges[i];                  if(i<FaceHalfEdges.Length-1)                  {                      //link the edge to the ingoing spoke' and the ingoing spoke to the outgoing one                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + i*2 + 3);                      _mesh.Halfedges.MakeConsecutive(CountBefore + (i*2) + 3' CountBefore + (i*2));                      //set the AdjacentFace of the ingoing spoke                                      _mesh.Halfedges[CountBefore + (i * 2) + 3].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }                  else                  {                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + 1);                      _mesh.Halfedges.MakeConsecutive(CountBefore + 1' CountBefore + (i*2));                      _mesh.Halfedges[CountBefore + 1].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,Stellate,The following statement contains a magic number: for (int i = 0; i < FaceHalfEdges.Length; i++)              {                  int ThisHalfEdge = FaceHalfEdges[i];                  if(i<FaceHalfEdges.Length-1)                  {                      //link the edge to the ingoing spoke' and the ingoing spoke to the outgoing one                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + i*2 + 3);                      _mesh.Halfedges.MakeConsecutive(CountBefore + (i*2) + 3' CountBefore + (i*2));                      //set the AdjacentFace of the ingoing spoke                                      _mesh.Halfedges[CountBefore + (i * 2) + 3].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }                  else                  {                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + 1);                      _mesh.Halfedges.MakeConsecutive(CountBefore + 1' CountBefore + (i*2));                      _mesh.Halfedges[CountBefore + 1].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,Stellate,The following statement contains a magic number: for (int i = 0; i < FaceHalfEdges.Length; i++)              {                  int ThisHalfEdge = FaceHalfEdges[i];                  if(i<FaceHalfEdges.Length-1)                  {                      //link the edge to the ingoing spoke' and the ingoing spoke to the outgoing one                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + i*2 + 3);                      _mesh.Halfedges.MakeConsecutive(CountBefore + (i*2) + 3' CountBefore + (i*2));                      //set the AdjacentFace of the ingoing spoke                                      _mesh.Halfedges[CountBefore + (i * 2) + 3].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }                  else                  {                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + 1);                      _mesh.Halfedges.MakeConsecutive(CountBefore + 1' CountBefore + (i*2));                      _mesh.Halfedges[CountBefore + 1].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,Stellate,The following statement contains a magic number: for (int i = 0; i < FaceHalfEdges.Length; i++)              {                  int ThisHalfEdge = FaceHalfEdges[i];                  if(i<FaceHalfEdges.Length-1)                  {                      //link the edge to the ingoing spoke' and the ingoing spoke to the outgoing one                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + i*2 + 3);                      _mesh.Halfedges.MakeConsecutive(CountBefore + (i*2) + 3' CountBefore + (i*2));                      //set the AdjacentFace of the ingoing spoke                                      _mesh.Halfedges[CountBefore + (i * 2) + 3].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }                  else                  {                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + 1);                      _mesh.Halfedges.MakeConsecutive(CountBefore + 1' CountBefore + (i*2));                      _mesh.Halfedges[CountBefore + 1].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,Stellate,The following statement contains a magic number: for (int i = 0; i < FaceHalfEdges.Length; i++)              {                  int ThisHalfEdge = FaceHalfEdges[i];                  if(i<FaceHalfEdges.Length-1)                  {                      //link the edge to the ingoing spoke' and the ingoing spoke to the outgoing one                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + i*2 + 3);                      _mesh.Halfedges.MakeConsecutive(CountBefore + (i*2) + 3' CountBefore + (i*2));                      //set the AdjacentFace of the ingoing spoke                                      _mesh.Halfedges[CountBefore + (i * 2) + 3].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }                  else                  {                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + 1);                      _mesh.Halfedges.MakeConsecutive(CountBefore + 1' CountBefore + (i*2));                      _mesh.Halfedges[CountBefore + 1].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }              }
Magic Number,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,Stellate,The following statement contains a magic number: for (int i = 0; i < FaceHalfEdges.Length; i++)              {                  int ThisHalfEdge = FaceHalfEdges[i];                  if(i<FaceHalfEdges.Length-1)                  {                      //link the edge to the ingoing spoke' and the ingoing spoke to the outgoing one                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + i*2 + 3);                      _mesh.Halfedges.MakeConsecutive(CountBefore + (i*2) + 3' CountBefore + (i*2));                      //set the AdjacentFace of the ingoing spoke                                      _mesh.Halfedges[CountBefore + (i * 2) + 3].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }                  else                  {                      _mesh.Halfedges.MakeConsecutive(ThisHalfEdge' CountBefore + 1);                      _mesh.Halfedges.MakeConsecutive(CountBefore + 1' CountBefore + (i*2));                      _mesh.Halfedges[CountBefore + 1].AdjacentFace = _mesh.Halfedges[ThisHalfEdge].AdjacentFace;                  }              }
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,CompactHelper,The following statement contains a magic number: if (marker % 2 > 0) { throw new InvalidOperationException("Halfedge count was odd after compaction"); }
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,GetVertexCirculator,The following statement contains a magic number: do              {                  yield return h;                  h = this[this.GetPairHalfedge(h)].NextHalfedge;                  if (h < 0) { throw new InvalidOperationException("Unset index' cannot continue."); }                  if (count++ > 999) { throw new InvalidOperationException("Runaway vertex circulator"); }              }              while (h != halfedgeIndex);
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,GetFaceCirculator,The following statement contains a magic number: do              {                  yield return h;                  h = this[h].NextHalfedge;                  if (h < 0) { throw new InvalidOperationException("Unset index' cannot continue."); }                  if (count++ > 999) { throw new InvalidOperationException("Runaway face circulator."); }              }              while (h != halfedgeIndex);
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,GetPairHalfedge,The following statement contains a magic number: return halfedgeIndex % 2 == 0 ? halfedgeIndex + 1 : halfedgeIndex - 1;
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,GetLengths,The following statement contains a magic number: for (int i = 0; i < this.Count; i += 2)              {                  double EdgeLength = GetLength(i);                  Lengths[i] = EdgeLength;                  Lengths[i + 1] = EdgeLength;              }
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,CollapseEdge,The following statement contains a magic number: if (f >= 0 && fs.GetHalfedges(f).Length == 3) { allowed++; }
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,CollapseEdge,The following statement contains a magic number: if (f_pair >= 0 && fs.GetHalfedges(f_pair).Length == 3) { allowed++; }
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,CollapseEdge,The following statement contains a magic number: if (f > -1 && this.GetFaceCirculator(next).Count() < 3)              {                  if (fs.MergeFaces(this.GetPairHalfedge(next)) < 0) { fs.RemoveFace(f); }              }
Magic Number,Plankton,PlanktonHalfEdgeList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonHalfedgeList.cs,CollapseEdge,The following statement contains a magic number: if (f_pair > -1 && !this[pair_prev].IsUnused && this.GetFaceCirculator(pair_prev).Count() < 3)              {                  if (fs.MergeFaces(this.GetPairHalfedge(pair_prev)) < 0) { fs.RemoveFace(f_pair); }              }
Magic Number,Plankton,PlanktonMesh,C:\repos\meshmash_Plankton\src\Plankton\PlanktonMesh.cs,Volume,The following statement contains a magic number: for (int i = 0; i < this.Faces.Count; i++)              {                  int[] FaceVerts = this.Faces.GetFaceVertices(i);                  int EdgeCount = FaceVerts.Length;                  if (EdgeCount == 3)                  {                      PlanktonXYZ P = this.Vertices[FaceVerts[0]].ToXYZ();                      PlanktonXYZ Q = this.Vertices[FaceVerts[1]].ToXYZ();                      PlanktonXYZ R = this.Vertices[FaceVerts[2]].ToXYZ();                      //get the signed volume of the tetrahedron formed by the triangle and the origin                      VolumeSum += (1 / 6d) * (                             P.X * Q.Y * R.Z +                             P.Y * Q.Z * R.X +                             P.Z * Q.X * R.Y -                             P.X * Q.Z * R.Y -                             P.Y * Q.X * R.Z -                             P.Z * Q.Y * R.X);                  }                  else                  {                      PlanktonXYZ P = this._faces.GetFaceCenter(i);                      for (int j = 0; j < EdgeCount; j++)                      {                          PlanktonXYZ Q = this.Vertices[FaceVerts[j]].ToXYZ();                          PlanktonXYZ R = this.Vertices[FaceVerts[(j + 1) % EdgeCount]].ToXYZ();                          VolumeSum += (1 / 6d) * (                              P.X * Q.Y * R.Z +                               P.Y * Q.Z * R.X +                               P.Z * Q.X * R.Y -                               P.X * Q.Z * R.Y -                               P.Y * Q.X * R.Z -                               P.Z * Q.Y * R.X);                      }                  }              }
Magic Number,Plankton,PlanktonMesh,C:\repos\meshmash_Plankton\src\Plankton\PlanktonMesh.cs,Volume,The following statement contains a magic number: for (int i = 0; i < this.Faces.Count; i++)              {                  int[] FaceVerts = this.Faces.GetFaceVertices(i);                  int EdgeCount = FaceVerts.Length;                  if (EdgeCount == 3)                  {                      PlanktonXYZ P = this.Vertices[FaceVerts[0]].ToXYZ();                      PlanktonXYZ Q = this.Vertices[FaceVerts[1]].ToXYZ();                      PlanktonXYZ R = this.Vertices[FaceVerts[2]].ToXYZ();                      //get the signed volume of the tetrahedron formed by the triangle and the origin                      VolumeSum += (1 / 6d) * (                             P.X * Q.Y * R.Z +                             P.Y * Q.Z * R.X +                             P.Z * Q.X * R.Y -                             P.X * Q.Z * R.Y -                             P.Y * Q.X * R.Z -                             P.Z * Q.Y * R.X);                  }                  else                  {                      PlanktonXYZ P = this._faces.GetFaceCenter(i);                      for (int j = 0; j < EdgeCount; j++)                      {                          PlanktonXYZ Q = this.Vertices[FaceVerts[j]].ToXYZ();                          PlanktonXYZ R = this.Vertices[FaceVerts[(j + 1) % EdgeCount]].ToXYZ();                          VolumeSum += (1 / 6d) * (                              P.X * Q.Y * R.Z +                               P.Y * Q.Z * R.X +                               P.Z * Q.X * R.Y -                               P.X * Q.Z * R.Y -                               P.Y * Q.X * R.Z -                               P.Z * Q.Y * R.X);                      }                  }              }
Magic Number,Plankton,PlanktonVertexList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonVertexList.cs,EraseCenterVertex,The following statement contains a magic number: foreach (int h in vertexHalfedges)              {                  v = _mesh.Halfedges.EndVertex(h);                  if (this.GetHalfedges(v).Length < 3)                      throw new ArgumentException("Vertex in 1-ring is 2-valent");              }
Missing Default,Plankton,PlanktonFaceList,C:\repos\meshmash_Plankton\src\Plankton\PlanktonFaceList.cs,AddFace,The following switch statement is missing a default case: switch (id)                      {                          case 1: // first is new' second is old                              // iterate through halfedges clockwise around vertex #v2 until boundary                              outer_prev = hs[loop[ii]].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 2: // second is new' first is old                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs[loop[i]].NextHalfedge;                              break;                          case 3: // both are new                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = hs.GetPairHalfedge(loop[i]);                              break;                          case 4: // both are new (non-manifold vertex)                              // We have TWO boundaries to take care of here: first...                              outer_prev = hs[vs[v2].OutgoingHalfedge].PrevHalfedge;                              outer_next = hs.GetPairHalfedge(loop[i]);                              hs[outer_prev].NextHalfedge = outer_next;                              hs[outer_next].PrevHalfedge = outer_prev;                              // and second...                              outer_prev = hs.GetPairHalfedge(loop[ii]);                              outer_next = vs[v2].OutgoingHalfedge;                              break;                      }
