Implementation smell,Namespace,Class,File,Method,Description
Long Method,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The method has 162 lines of code.
Complex Method,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,Cyclomatic complexity of the method is 26
Long Statement,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,RegisterInputParams,The length of the statement  "            pManager.AddParameter(new GH_PlanktonMeshParam()' "PMesh"' "PMesh"' "The input PlanktonMesh to decompose"' GH_ParamAccess.item); " is 128.
Long Statement,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,RegisterOutputParams,The length of the statement  "            pManager.Register_IntegerParam("Vertex_Outgoing_Halfedge"' "V_He"' "One of the outgoing halfedges for each vertex"' GH_ParamAccess.list); " is 137.
Long Statement,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,RegisterOutputParams,The length of the statement  "            pManager.Register_IntegerParam("Halfedge_StartVertex"' "He_V"' "The starting vertex of each halfedge"' GH_ParamAccess.list); " is 124.
Long Statement,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,RegisterOutputParams,The length of the statement  "            pManager.Register_IntegerParam("Halfedge_AdjacentFace"' "He_F"' "The face bordered by each halfedge (or -1 if it is adjacent to a boundary)"' GH_ParamAccess.list); " is 163.
Long Statement,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,RegisterOutputParams,The length of the statement  "            pManager.Register_IntegerParam("Halfedge_NextHalfedge"' "He_Nxt"' "The next halfedge around the same face"' GH_ParamAccess.list); " is 129.
Long Statement,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,RegisterOutputParams,The length of the statement  "            pManager.Register_IntegerParam("Halfedge_PrevHalfedge"' "He_Prv"' "The previous halfedge around the same face"' GH_ParamAccess.list); " is 133.
Long Statement,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,RegisterOutputParams,The length of the statement  "            pManager.Register_IntegerParam("Halfedge_Pair"' "He_P"' "The halfedge joining the same 2 vertices in the opposite direction"' GH_ParamAccess.list); " is 147.
Long Statement,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,MoveVertex,The length of the statement  "            return vertexList.SetVertex(index' vertexList[index].X + vector.X' vertexList[index].Y + vector.Y' vertexList[index].Z + vector.Z); " is 131.
Magic Number,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,SolveInstance,The following statement contains a magic number: DA.SetDataList(2' StartV);
Magic Number,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,SolveInstance,The following statement contains a magic number: DA.SetDataList(3' AdjF);
Magic Number,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,SolveInstance,The following statement contains a magic number: DA.SetDataList(4' Next);
Magic Number,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,SolveInstance,The following statement contains a magic number: DA.SetDataList(5' Prev);
Magic Number,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,SolveInstance,The following statement contains a magic number: DA.SetDataList(6' Pair);
Magic Number,PlanktonGh,DecomposePlankton,C:\repos\meshmash_Plankton\src\PlanktonGh\DecomposePlankton.cs,SolveInstance,The following statement contains a magic number: DA.SetDataList(7' FaceEdge);
Magic Number,PlanktonGh,GH_PlanktonMesh,C:\repos\meshmash_Plankton\src\PlanktonGh\GH_PlanktonMesh.cs,DrawViewportMeshes,The following statement contains a magic number: if (args.Pipeline.SupportsShading)              {                  var c = args.Material.Diffuse;                  c = System.Drawing.Color.FromArgb((int)(args.Material.Transparency * 255)'                      c);                    args.Pipeline.DrawMeshShaded(_mesh' args.Material);              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToPlanktonMesh,The following statement contains a magic number: for (int i = 0; i < (pMesh.Halfedges.Count); i += 2)              {                  int[] EndNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i + 1].StartVertex' true);                  for (int j = 0; j < EndNeighbours.Length; j++)                  {                      if(EndNeighbours[j] == pMesh.Halfedges[i].StartVertex)                      {                          int EndOfNextHalfedge = EndNeighbours[(j - 1 + EndNeighbours.Length) % EndNeighbours.Length];                          int StartOfPrevOfPairHalfedge = EndNeighbours[(j + 1) % EndNeighbours.Length];                            int NextEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'EndOfNextHalfedge);                          int PrevPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i + 1].StartVertex'StartOfPrevOfPairHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextEdge).I == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2;                          } else {                              pMesh.Halfedges[i].NextHalfedge = NextEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevPairEdge).J == pMesh.Halfedges[i + 1].StartVertex) {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].PrevHalfedge = PrevPairEdge * 2+1;                          }                          break;                      }                  }                    int[] StartNeighbours = source.TopologyVertices.ConnectedTopologyVertices(pMesh.Halfedges[i].StartVertex' true);                  for (int j = 0; j < StartNeighbours.Length; j++)                  {                      if (StartNeighbours[j] == pMesh.Halfedges[i+1].StartVertex)                      {                          int EndOfNextOfPairHalfedge = StartNeighbours[(j - 1 + StartNeighbours.Length) % StartNeighbours.Length];                          int StartOfPrevHalfedge = StartNeighbours[(j + 1) % StartNeighbours.Length];                            int NextPairEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' EndOfNextOfPairHalfedge);                          int PrevEdge = source.TopologyEdges.GetEdgeIndex(pMesh.Halfedges[i].StartVertex' StartOfPrevHalfedge);                            if (source.TopologyEdges.GetTopologyVertices(NextPairEdge).I == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2;                          } else {                              pMesh.Halfedges[i + 1].NextHalfedge = NextPairEdge * 2 + 1;                          }                            if (source.TopologyEdges.GetTopologyVertices(PrevEdge).J == pMesh.Halfedges[i].StartVertex) {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2;                          } else {                              pMesh.Halfedges[i].PrevHalfedge = PrevEdge * 2 + 1;                          }                          break;                      }                  }              }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToRhinoMesh,The following statement contains a magic number: for (int i = 0; i < source.Faces.Count; i++)              {                  int[] fvs = source.Faces.GetFaceVertices(i);                  if (fvs.Length == 3)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]);                  }                  else if (fvs.Length == 4)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]' fvs[3]);                  }                  else if (fvs.Length > 4)                  {                      // triangulate about face center (fan)                      var fc = source.Faces.GetFaceCenter(i);                      rMesh.Vertices.Add(fc.X' fc.Y' fc.Z);                      for (int j = 0; j < fvs.Length; j++)                      {                          rMesh.Faces.AddFace(fvs[j]' fvs[(j + 1) % fvs.Length]' rMesh.Vertices.Count - 1);                      }                  }                          }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToRhinoMesh,The following statement contains a magic number: for (int i = 0; i < source.Faces.Count; i++)              {                  int[] fvs = source.Faces.GetFaceVertices(i);                  if (fvs.Length == 3)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]);                  }                  else if (fvs.Length == 4)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]' fvs[3]);                  }                  else if (fvs.Length > 4)                  {                      // triangulate about face center (fan)                      var fc = source.Faces.GetFaceCenter(i);                      rMesh.Vertices.Add(fc.X' fc.Y' fc.Z);                      for (int j = 0; j < fvs.Length; j++)                      {                          rMesh.Faces.AddFace(fvs[j]' fvs[(j + 1) % fvs.Length]' rMesh.Vertices.Count - 1);                      }                  }                          }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToRhinoMesh,The following statement contains a magic number: for (int i = 0; i < source.Faces.Count; i++)              {                  int[] fvs = source.Faces.GetFaceVertices(i);                  if (fvs.Length == 3)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]);                  }                  else if (fvs.Length == 4)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]' fvs[3]);                  }                  else if (fvs.Length > 4)                  {                      // triangulate about face center (fan)                      var fc = source.Faces.GetFaceCenter(i);                      rMesh.Vertices.Add(fc.X' fc.Y' fc.Z);                      for (int j = 0; j < fvs.Length; j++)                      {                          rMesh.Faces.AddFace(fvs[j]' fvs[(j + 1) % fvs.Length]' rMesh.Vertices.Count - 1);                      }                  }                          }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToRhinoMesh,The following statement contains a magic number: for (int i = 0; i < source.Faces.Count; i++)              {                  int[] fvs = source.Faces.GetFaceVertices(i);                  if (fvs.Length == 3)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]);                  }                  else if (fvs.Length == 4)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]' fvs[3]);                  }                  else if (fvs.Length > 4)                  {                      // triangulate about face center (fan)                      var fc = source.Faces.GetFaceCenter(i);                      rMesh.Vertices.Add(fc.X' fc.Y' fc.Z);                      for (int j = 0; j < fvs.Length; j++)                      {                          rMesh.Faces.AddFace(fvs[j]' fvs[(j + 1) % fvs.Length]' rMesh.Vertices.Count - 1);                      }                  }                          }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToRhinoMesh,The following statement contains a magic number: for (int i = 0; i < source.Faces.Count; i++)              {                  int[] fvs = source.Faces.GetFaceVertices(i);                  if (fvs.Length == 3)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]);                  }                  else if (fvs.Length == 4)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]' fvs[3]);                  }                  else if (fvs.Length > 4)                  {                      // triangulate about face center (fan)                      var fc = source.Faces.GetFaceCenter(i);                      rMesh.Vertices.Add(fc.X' fc.Y' fc.Z);                      for (int j = 0; j < fvs.Length; j++)                      {                          rMesh.Faces.AddFace(fvs[j]' fvs[(j + 1) % fvs.Length]' rMesh.Vertices.Count - 1);                      }                  }                          }
Magic Number,PlanktonGh,RhinoSupport,C:\repos\meshmash_Plankton\src\PlanktonGh\RhinoSupport.cs,ToRhinoMesh,The following statement contains a magic number: for (int i = 0; i < source.Faces.Count; i++)              {                  int[] fvs = source.Faces.GetFaceVertices(i);                  if (fvs.Length == 3)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]);                  }                  else if (fvs.Length == 4)                  {                      rMesh.Faces.AddFace(fvs[0]' fvs[1]' fvs[2]' fvs[3]);                  }                  else if (fvs.Length > 4)                  {                      // triangulate about face center (fan)                      var fc = source.Faces.GetFaceCenter(i);                      rMesh.Vertices.Add(fc.X' fc.Y' fc.Z);                      for (int j = 0; j < fvs.Length; j++)                      {                          rMesh.Faces.AddFace(fvs[j]' fvs[(j + 1) % fvs.Length]' rMesh.Vertices.Count - 1);                      }                  }                          }
Missing Default,PlanktonGh,GH_PlanktonMeshParam,C:\repos\meshmash_Plankton\src\PlanktonGh\GH_PlanktonMeshParam.cs,DrawViewportWires,The following switch statement is missing a default case: switch (args.Document.PreviewMode)              {                  case GH_PreviewMode.Wireframe:                      Preview_DrawWires(args);                      break;                  case GH_PreviewMode.Shaded:                      if (CentralSettings.PreviewMeshEdges)                      {                          Preview_DrawWires(args);                      }                      break;              }
