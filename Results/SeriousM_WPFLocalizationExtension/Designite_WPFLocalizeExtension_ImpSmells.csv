Implementation smell,Namespace,Class,File,Method,Description
Long Method,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,The method has 201 lines of code.
Complex Method,WPFLocalizeExtension.Engine,ObjectDependencyManager,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\ObjectDependencyManager.cs,CleanUp,Cyclomatic complexity of the method is 8
Complex Method,WPFLocalizeExtension.Extensions,FELoc,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\FELoc.cs,FormatOutput,Cyclomatic complexity of the method is 8
Complex Method,WPFLocalizeExtension.Extensions,LocExtension,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\LocExtension.cs,ResourceChanged,Cyclomatic complexity of the method is 9
Complex Method,WPFLocalizeExtension.Extensions,LocExtension,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\LocExtension.cs,FormatOutput,Cyclomatic complexity of the method is 9
Complex Method,WPFLocalizeExtension.Providers,ParentChangedNotifierHelper,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ParentChangedNotifierHelper.cs,GetValueOrRegisterParentNotifier,Cyclomatic complexity of the method is 12
Complex Method,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,Cyclomatic complexity of the method is 19
Long Parameter List,WPFLocalizeExtension.Extensions,LocExtension,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\LocExtension.cs,GetLocalizedValue,The method has 5 parameters. Parameters: key' targetCulture' target' converter' converterParameter
Long Identifier,WPFLocalizeExtension.Engine,GapTextControl,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\GapTextControl.cs,OnGapsChanged,The length of the parameter dependencyPropertyChangedEventArgs is 34.
Long Identifier,WPFLocalizeExtension.Engine,GapTextControl,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\GapTextControl.cs,,The length of the parameter IgnoreDuplicateStringReferencesProperty is 39.
Long Identifier,WPFLocalizeExtension.Engine,GapTextControl,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\GapTextControl.cs,,The length of the parameter IgnoreDuplicateControlReferencesProperty is 40.
Long Identifier,WPFLocalizeExtension.Engine,LocalizeDictionary,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\LocalizeDictionary.cs,,The length of the parameter IncludeInvariantCultureProperty is 31.
Long Statement,WPFLocalizeExtension.Engine,GapTextControl,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\GapTextControl.cs,OnContentChanged,The length of the statement  "                // allowed according to https://msdn.microsoft.com/de-de/library/system.windows.documents.inlinecollection%28v=vs.110%29.aspx are " is 129.
Long Statement,WPFLocalizeExtension.Engine,GapTextControl,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\GapTextControl.cs,OnContentChanged,The length of the statement  "                // Inline' String (creates an implicit Run)' UIElement (creates an implicit InlineUIContainer with the supplied UIElement inside)'  " is 130.
Long Statement,WPFLocalizeExtension.Engine,LocalizeDictionary,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\LocalizeDictionary.cs,AvailableCulturesCollectionChanged,The length of the statement  "                if (!_includeInvariantCulture && MergedAvailableCultures.Count > 1 && MergedAvailableCultures.Contains(CultureInfo.InvariantCulture)) " is 133.
Long Statement,WPFLocalizeExtension.Engine,LocalizeDictionary,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\LocalizeDictionary.cs,GetIsInDesignMode,The length of the statement  "                        _isInDesignMode = (bool)Dispatcher.Invoke(DispatcherPriority.Normal' TimeSpan.FromMilliseconds(100)' new Func<bool>(GetIsInDesignMode)); " is 136.
Long Statement,WPFLocalizeExtension.Engine,ParentNotifiers,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\ParentNotifiers.cs,Add,The length of the statement  "			_inner.Add(new TypedWeakReference<DependencyObject>(target)' new TypedWeakReference<ParentChangedNotifier>(parentChangedNotifier)); " is 131.
Long Statement,WPFLocalizeExtension.Engine,SafeTargetInfo,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\SafeTargetInfo.cs,FromTargetInfo,The length of the statement  "            return new SafeTargetInfo(targetInfo.TargetObject' targetInfo.TargetProperty' targetInfo.TargetPropertyType' targetInfo.TargetPropertyIndex); " is 141.
Long Statement,WPFLocalizeExtension.Extensions,FELoc,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\FELoc.cs,FormatOutput,The length of the statement  "            string resKeyNameProp = LocalizeDictionary.Instance.GetFullyQualifiedResourceKey(epName + LocalizeDictionary.GetSeparation(targetObject) + epProp' targetObject); " is 161.
Long Statement,WPFLocalizeExtension.Extensions,LocExtension,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\LocExtension.cs,FormatOutput,The length of the statement  "                var resKeyNameProp = LocalizeDictionary.Instance.GetFullyQualifiedResourceKey(epName + LocalizeDictionary.GetSeparation(targetObject) + epProp' targetObject); " is 158.
Long Statement,WPFLocalizeExtension.Extensions,LocExtension,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\LocExtension.cs,SetBinding,The length of the statement  "            var result = ProvideValue(new SimpleProvideValueServiceProvider(targetObject' targetProperty' targetPropertyType' targetPropertyIndex)); " is 136.
Long Statement,WPFLocalizeExtension.Providers,CSVEmbeddedLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVEmbeddedLocalizationProvider.cs,GetAssembly,The length of the statement  "            return target?.GetValueOrRegisterParentNotifier<string>(DefaultAssemblyProperty' ParentChangedAction' _parentNotifiers);  " is 120.
Long Statement,WPFLocalizeExtension.Providers,CSVEmbeddedLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVEmbeddedLocalizationProvider.cs,GetDictionary,The length of the statement  "            return target?.GetValueOrRegisterParentNotifier<string>(DefaultDictionaryProperty' ParentChangedAction' _parentNotifiers); " is 122.
Long Statement,WPFLocalizeExtension.Providers,CSVEmbeddedLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVEmbeddedLocalizationProvider.cs,GetLocalizedObject,The length of the statement  "                    filename = assemblyInAppDomain.GetManifestResourceNames().FirstOrDefault(r => r.Contains($"{dictionary}{(string.IsNullOrEmpty(culture.Name) ? "" : "-")}{culture.Name}")); " is 170.
Long Statement,WPFLocalizeExtension.Providers,CSVEmbeddedLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVEmbeddedLocalizationProvider.cs,GetLocalizedObject,The length of the statement  "                        using (var reader = new StreamReader(assemblyInAppDomain.GetManifestResourceStream(filename) ?? throw new InvalidOperationException()' Encoding.Default)) " is 153.
Long Statement,WPFLocalizeExtension.Providers,CSVLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProvider.cs,GetDictionary,The length of the statement  "            return target?.GetValueOrRegisterParentNotifier<string>(DefaultDictionaryProperty' ParentChangedAction' _parentNotifiers); " is 122.
Long Statement,WPFLocalizeExtension.Providers,CSVLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProvider.cs,GetAssembly,The length of the statement  "            return target?.GetValueOrRegisterParentNotifier<string>(CSVEmbeddedLocalizationProvider.DefaultAssemblyProperty' ParentChangedAction' _parentNotifiers); " is 152.
Long Statement,WPFLocalizeExtension.Providers,CSVLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProvider.cs,GetLocalizedObject,The length of the statement  "                csvPath = Path.Combine(csvDirectory' dictionary + (string.IsNullOrEmpty(culture.Name) ? "" : "." + culture.Name) + ".csv"); " is 123.
Long Statement,WPFLocalizeExtension.Providers,CSVLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProvider.cs,GetLocalizedObject,The length of the statement  "                    OnProviderError(target' key' "A file for the provided culture " + culture.EnglishName + " does not exist at " + csvPath + "."); " is 127.
Long Statement,WPFLocalizeExtension.Providers,ParentChangedNotifierHelper,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ParentChangedNotifierHelper.cs,GetValueOrRegisterParentNotifier,The length of the statement  "		        // If this failed' try again using the Parent property (sometimes this is not covered by the VisualTreeHelper class :-P. " is 120.
Long Statement,WPFLocalizeExtension.Providers,ParentChangedNotifierHelper,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ParentChangedNotifierHelper.cs,GetValue,The length of the statement  "                    // If this failed' try again using the Parent property (sometimes this is not covered by the VisualTreeHelper class :-P. " is 120.
Long Statement,WPFLocalizeExtension.Providers,ParentChangedNotifierHelper,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ParentChangedNotifierHelper.cs,GetValueOrRegisterParentNotifier,The length of the statement  "            return target.GetValueOrRegisterParentNotifier(depObj => depObj.GetValueSync<T>(property)' parentChangedAction' parentNotifiers); " is 129.
Long Statement,WPFLocalizeExtension.Providers,ParentChangedNotifierHelper,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ParentChangedNotifierHelper.cs,GetParent,The length of the statement  "            return (DependencyObject)depObj.Dispatcher.Invoke(new Func<DependencyObject>(() => GetParentInternal(depObj' isVisualTree))); " is 125.
Long Statement,WPFLocalizeExtension.Providers,ResxLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProvider.cs,GetAssembly,The length of the statement  "            var assembly = target.GetValueOrRegisterParentNotifier<string>(DefaultAssemblyProperty' ParentChangedAction' _parentNotifiers); " is 127.
Long Statement,WPFLocalizeExtension.Providers,ResxLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProvider.cs,GetDictionary,The length of the statement  "            var dictionary = target.GetValueOrRegisterParentNotifier<string>(DefaultDictionaryProperty' ParentChangedAction' _parentNotifiers); " is 131.
Long Statement,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,IsFileOfInterest,The length of the statement  "            if (!(f.EndsWith(".resx"' StringComparison.OrdinalIgnoreCase) || f.EndsWith(".resources.dll"' StringComparison.OrdinalIgnoreCase) || " is 132.
Long Statement,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,The length of the statement  "                // Get the directory of the executing assembly (some strange path in the middle of nowhere on the disk and attach "\tmp"' e.g.: " is 127.
Long Statement,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,The length of the statement  "                var assemblyDir = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? throw new InvalidOperationException()' "tmp"); " is 144.
Long Statement,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,The length of the statement  "                // The proposed approach of Andras (http://wpflocalizeextension.codeplex.com/discussions/66098?ProjectName=wpflocalizeextension) " is 128.
Long Statement,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,The length of the statement  "                    if (availableResource.EndsWith(resManagerNameToSearch) && possiblePrefixes.Any(p => availableResource.StartsWith(p + "."))) " is 123.
Long Statement,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,The length of the statement  "                    throw new ArgumentException(string.Format("No resource manager for dictionary '{0}' in assembly '{1}' found! ({1}.{0})"' resourceDictionary' resourceAssembly)); " is 160.
Complex Conditional,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,IsFileOfInterest,The conditional expression  "!(f.EndsWith(".resx"' StringComparison.OrdinalIgnoreCase) || f.EndsWith(".resources.dll"' StringComparison.OrdinalIgnoreCase) ||                    f.EndsWith(".resources"' StringComparison.OrdinalIgnoreCase)) &&                  !dir.Equals(Path.GetDirectoryName(f)' StringComparison.OrdinalIgnoreCase)"  is complex.
Empty Catch Block,WPFLocalizeExtension.Engine,EnumComboBox,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\EnumComboBox.cs,SetType,The method has an empty catch block.
Empty Catch Block,WPFLocalizeExtension.Engine,GapTextControl,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\GapTextControl.cs,OnContentChanged,The method has an empty catch block.
Empty Catch Block,WPFLocalizeExtension.Providers,CSVLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProviderBase.cs,OnProviderChanged,The method has an empty catch block.
Empty Catch Block,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,The method has an empty catch block.
Empty Catch Block,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,GetResourceManager,The method has an empty catch block.
Empty Catch Block,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,OnProviderChanged,The method has an empty catch block.
Magic Number,WPFLocalizeExtension.Engine,GapTextControl,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\GapTextControl.cs,OnContentChanged,The following statement contains a magic number: if (FormatString != null)              {                  var matchedUpToIndex = 0;                    // 1) determine which items are to be used as string and which are to be inserted as controls:                  // allowed according to https://msdn.microsoft.com/de-de/library/system.windows.documents.inlinecollection%28v=vs.110%29.aspx are                  // Inline' String (creates an implicit Run)' UIElement (creates an implicit InlineUIContainer with the supplied UIElement inside)'                   if (Gaps != null)                  {                      var match = Regex.Match(FormatString' RegexPattern);                        while (match.Success)                      {                          // Handle match here...                          var wholeMatch = match.Groups[0].Value; // contains string and simple placeholder at the end.                          var formatStringPartial = match.Groups[1].Value;                          // has still to be formatted TODO or even better bound accordingly by lex:loc binding                          var itemIndex = int.Parse(match.Groups[2].Value);                          // it's secure to parse an int here as this follows from the regex.                            matchedUpToIndex += wholeMatch.Length;                            // get next match:                          match = match.NextMatch();                            // add the inlines:                          // 1) the prefix that is formatted with the whole gaps parameters:                          _theTextBlock.Inlines.Add(string.Format(formatStringPartial' Gaps));                            // Check availability of a classified gap.                          if (Gaps.Count <= itemIndex)                              continue;                          var gap = Gaps[itemIndex];                            // 2) the item encoded in the placeholder:                          try                          {                              if (gap is UIElement element)                              {                                  var item = DeepCopy(element);                                  _theTextBlock.Inlines.Add(item);                              }                              else if (gap is Inline)                              {                                  var item = DeepCopy((Inline)gap);                                  _theTextBlock.Inlines.Add(item);                              }                              else if (gap != null)                                  _theTextBlock.Inlines.Add(gap.ToString());                          }                          catch (Exception)                          {                              // break for now                          }                      }                  }                    // add the remaining part:                  _theTextBlock.Inlines.Add(string.Format(FormatString.Substring(matchedUpToIndex)' Gaps));                                    InvalidateVisual();              }              else              {                  throw new Exception("FormatString is not a string!");              }
Magic Number,WPFLocalizeExtension.Engine,LocalizeDictionary,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Engine\LocalizeDictionary.cs,GetIsInDesignMode,The following statement contains a magic number: lock (SyncRoot)              {                  if (_isInDesignMode.HasValue)                      return _isInDesignMode.Value;                    if (Dispatcher?.Thread == null || !Dispatcher.Thread.IsAlive)                  {                      _isInDesignMode = false;                      return _isInDesignMode.Value;                  }                    if (!Dispatcher.CheckAccess())                  {                      try                      {                          _isInDesignMode = (bool)Dispatcher.Invoke(DispatcherPriority.Normal' TimeSpan.FromMilliseconds(100)' new Func<bool>(GetIsInDesignMode));                      }                      catch (Exception)                      {                          _isInDesignMode = default(bool);                      }                                            return _isInDesignMode.Value;                  }                  _isInDesignMode = DesignerProperties.GetIsInDesignMode(this);                  return _isInDesignMode.Value;              }
Magic Number,WPFLocalizeExtension.Extensions,LocTextExtension,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\Compatibility.cs,FormatOutput,The following statement contains a magic number: try              {                  // add some format segments' in case that the main text contains format place holders like {0}                  textMain = string.Format(                      LocalizeDictionary.Instance.SpecificCulture'                      textMain'                      _formatSegments[0] ?? string.Empty'                      _formatSegments[1] ?? string.Empty'                      _formatSegments[2] ?? string.Empty'                      _formatSegments[3] ?? string.Empty'                      _formatSegments[4] ?? string.Empty);              }              catch (FormatException)              {                  // if a format exception was thrown' change the text to an error string                  textMain = "TextFormatError: Max 5 Format PlaceHolders! {0} to {4}";              }
Magic Number,WPFLocalizeExtension.Extensions,LocTextExtension,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\Compatibility.cs,FormatOutput,The following statement contains a magic number: try              {                  // add some format segments' in case that the main text contains format place holders like {0}                  textMain = string.Format(                      LocalizeDictionary.Instance.SpecificCulture'                      textMain'                      _formatSegments[0] ?? string.Empty'                      _formatSegments[1] ?? string.Empty'                      _formatSegments[2] ?? string.Empty'                      _formatSegments[3] ?? string.Empty'                      _formatSegments[4] ?? string.Empty);              }              catch (FormatException)              {                  // if a format exception was thrown' change the text to an error string                  textMain = "TextFormatError: Max 5 Format PlaceHolders! {0} to {4}";              }
Magic Number,WPFLocalizeExtension.Extensions,LocTextExtension,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Extensions\Compatibility.cs,FormatOutput,The following statement contains a magic number: try              {                  // add some format segments' in case that the main text contains format place holders like {0}                  textMain = string.Format(                      LocalizeDictionary.Instance.SpecificCulture'                      textMain'                      _formatSegments[0] ?? string.Empty'                      _formatSegments[1] ?? string.Empty'                      _formatSegments[2] ?? string.Empty'                      _formatSegments[3] ?? string.Empty'                      _formatSegments[4] ?? string.Empty);              }              catch (FormatException)              {                  // if a format exception was thrown' change the text to an error string                  textMain = "TextFormatError: Max 5 Format PlaceHolders! {0} to {4}";              }
Magic Number,WPFLocalizeExtension.Providers,CSVEmbeddedLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVEmbeddedLocalizationProvider.cs,GetLocalizedObject,The following statement contains a magic number: foreach (var assemblyInAppDomain in loadedAssemblies)              {                      // get the assembly name object                      var assemblyName = new AssemblyName(assemblyInAppDomain.FullName);                          // check if the name of the assembly is the seached one                  if (assemblyName.Name == assembly)                  {                      //filename = assemblyInAppDomain.GetManifestResourceNames().Where(r => r.Contains(dictionary)).FirstOrDefault();                      filename = assemblyInAppDomain.GetManifestResourceNames().FirstOrDefault(r => r.Contains($"{dictionary}{(string.IsNullOrEmpty(culture.Name) ? "" : "-")}{culture.Name}"));                      if (filename != null)                      {                          using (var reader = new StreamReader(assemblyInAppDomain.GetManifestResourceStream(filename) ?? throw new InvalidOperationException()' Encoding.Default))                          {                              if (HasHeader && !reader.EndOfStream)                                  reader.ReadLine();                                // Read each line and split it.                              while (!reader.EndOfStream)                              {                                  var line = reader.ReadLine();                                  if (line != null)                                  {                                      var parts = line.Split(";".ToCharArray());                                        if (parts.Length < 2)                                          continue;                                        // Check the key (1st column).                                      if (parts[0] != key)                                          continue;                                        // Get the value (2nd column).                                      ret = parts[1];                                  }                                  break;                              }                          }                      }                  }              }
Magic Number,WPFLocalizeExtension.Providers,CSVLocalizationProvider,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProvider.cs,GetLocalizedObject,The following statement contains a magic number: using (var reader = new StreamReader(csvPath' Encoding.Default))              {                  // Skip the header if needed.                  if (HasHeader && !reader.EndOfStream)                      reader.ReadLine();                    // Read each line and split it.                  while (!reader.EndOfStream)                  {                      var line = reader.ReadLine();                      if (line != null)                      {                          var parts = line.Split(";".ToCharArray());                            if (parts.Length < 2)                              continue;                            // Check the key (1st column).                          if (parts[0] != key)                              continue;                            // Get the value (2nd column).                          ret = parts[1];                      }                      break;                  }              }
Magic Number,WPFLocalizeExtension.Providers,CSVLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProviderBase.cs,ParseKey,The following statement contains a magic number: if (!string.IsNullOrEmpty(inKey))              {                  var split = inKey.Trim().Split(":".ToCharArray());                    // assembly:dict:key                  if (split.Length == 3)                  {                      outAssembly = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outDict = !string.IsNullOrEmpty(split[1]) ? split[1] : null;                      outKey = split[2];                  }                    // dict:key                  if (split.Length == 2)                  {                      outDict = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outKey = split[1];                  }                    // key                  if (split.Length == 1)                      outKey = split[0];              }
Magic Number,WPFLocalizeExtension.Providers,CSVLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProviderBase.cs,ParseKey,The following statement contains a magic number: if (!string.IsNullOrEmpty(inKey))              {                  var split = inKey.Trim().Split(":".ToCharArray());                    // assembly:dict:key                  if (split.Length == 3)                  {                      outAssembly = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outDict = !string.IsNullOrEmpty(split[1]) ? split[1] : null;                      outKey = split[2];                  }                    // dict:key                  if (split.Length == 2)                  {                      outDict = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outKey = split[1];                  }                    // key                  if (split.Length == 1)                      outKey = split[0];              }
Magic Number,WPFLocalizeExtension.Providers,CSVLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\CSVLocalizationProviderBase.cs,ParseKey,The following statement contains a magic number: if (!string.IsNullOrEmpty(inKey))              {                  var split = inKey.Trim().Split(":".ToCharArray());                    // assembly:dict:key                  if (split.Length == 3)                  {                      outAssembly = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outDict = !string.IsNullOrEmpty(split[1]) ? split[1] : null;                      outKey = split[2];                  }                    // dict:key                  if (split.Length == 2)                  {                      outDict = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outKey = split[1];                  }                    // key                  if (split.Length == 1)                      outKey = split[0];              }
Magic Number,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,ParseKey,The following statement contains a magic number: if (!string.IsNullOrEmpty(inKey))              {                  var split = inKey.Trim().Split(":".ToCharArray());                    // assembly:dict:key                  if (split.Length == 3)                  {                      outAssembly = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outDict = !string.IsNullOrEmpty(split[1]) ? split[1] : null;                      outKey = split[2];                  }                    // dict:key                  if (split.Length == 2)                  {                      outDict = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outKey = split[1];                  }                    // key                  if (split.Length == 1)                  {                      outKey = split[0];                  }              }
Magic Number,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,ParseKey,The following statement contains a magic number: if (!string.IsNullOrEmpty(inKey))              {                  var split = inKey.Trim().Split(":".ToCharArray());                    // assembly:dict:key                  if (split.Length == 3)                  {                      outAssembly = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outDict = !string.IsNullOrEmpty(split[1]) ? split[1] : null;                      outKey = split[2];                  }                    // dict:key                  if (split.Length == 2)                  {                      outDict = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outKey = split[1];                  }                    // key                  if (split.Length == 1)                  {                      outKey = split[0];                  }              }
Magic Number,WPFLocalizeExtension.Providers,ResxLocalizationProviderBase,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\Providers\ResxLocalizationProviderBase.cs,ParseKey,The following statement contains a magic number: if (!string.IsNullOrEmpty(inKey))              {                  var split = inKey.Trim().Split(":".ToCharArray());                    // assembly:dict:key                  if (split.Length == 3)                  {                      outAssembly = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outDict = !string.IsNullOrEmpty(split[1]) ? split[1] : null;                      outKey = split[2];                  }                    // dict:key                  if (split.Length == 2)                  {                      outDict = !string.IsNullOrEmpty(split[0]) ? split[0] : null;                      outKey = split[1];                  }                    // key                  if (split.Length == 1)                  {                      outKey = split[0];                  }              }
Magic Number,WPFLocalizeExtension.TypeConverters,ThicknessConverter,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\TypeConverters\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string s)              {                  var parts = s.Split("'".ToCharArray());                    switch (parts.Length)                  {                      case 1:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          result = new Thickness(d1);                          break;                        case 2:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          result = new Thickness(d1' d2' d1' d2);                          break;                        case 4:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          double.TryParse(parts[2]' NumberStyles.Any' culture' out d3);                          double.TryParse(parts[3]' NumberStyles.Any' culture' out d4);                          result = new Thickness(d1' d2' d3' d4);                          break;                  }              }
Magic Number,WPFLocalizeExtension.TypeConverters,ThicknessConverter,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\TypeConverters\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string s)              {                  var parts = s.Split("'".ToCharArray());                    switch (parts.Length)                  {                      case 1:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          result = new Thickness(d1);                          break;                        case 2:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          result = new Thickness(d1' d2' d1' d2);                          break;                        case 4:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          double.TryParse(parts[2]' NumberStyles.Any' culture' out d3);                          double.TryParse(parts[3]' NumberStyles.Any' culture' out d4);                          result = new Thickness(d1' d2' d3' d4);                          break;                  }              }
Magic Number,WPFLocalizeExtension.TypeConverters,ThicknessConverter,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\TypeConverters\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string s)              {                  var parts = s.Split("'".ToCharArray());                    switch (parts.Length)                  {                      case 1:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          result = new Thickness(d1);                          break;                        case 2:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          result = new Thickness(d1' d2' d1' d2);                          break;                        case 4:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          double.TryParse(parts[2]' NumberStyles.Any' culture' out d3);                          double.TryParse(parts[3]' NumberStyles.Any' culture' out d4);                          result = new Thickness(d1' d2' d3' d4);                          break;                  }              }
Magic Number,WPFLocalizeExtension.TypeConverters,ThicknessConverter,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\TypeConverters\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string s)              {                  var parts = s.Split("'".ToCharArray());                    switch (parts.Length)                  {                      case 1:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          result = new Thickness(d1);                          break;                        case 2:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          result = new Thickness(d1' d2' d1' d2);                          break;                        case 4:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          double.TryParse(parts[2]' NumberStyles.Any' culture' out d3);                          double.TryParse(parts[3]' NumberStyles.Any' culture' out d4);                          result = new Thickness(d1' d2' d3' d4);                          break;                  }              }
Missing Default,WPFLocalizeExtension.TypeConverters,ThicknessConverter,C:\repos\SeriousM_WPFLocalizationExtension\WPFLocalizeExtension\TypeConverters\ThicknessConverter.cs,ConvertFrom,The following switch statement is missing a default case: switch (parts.Length)                  {                      case 1:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          result = new Thickness(d1);                          break;                        case 2:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          result = new Thickness(d1' d2' d1' d2);                          break;                        case 4:                          double.TryParse(parts[0]' NumberStyles.Any' culture' out d1);                          double.TryParse(parts[1]' NumberStyles.Any' culture' out d2);                          double.TryParse(parts[2]' NumberStyles.Any' culture' out d3);                          double.TryParse(parts[3]' NumberStyles.Any' culture' out d4);                          result = new Thickness(d1' d2' d3' d4);                          break;                  }
