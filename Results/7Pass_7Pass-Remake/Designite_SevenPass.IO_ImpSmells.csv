Implementation smell,Namespace,Class,File,Method,Description
Complex Method,SevenPass.IO.Crypto,HashedBlockFileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedBlockFileFormat.cs,Read,Cyclomatic complexity of the method is 12
Complex Method,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,XorArray,Cyclomatic complexity of the method is 9
Long Parameter List,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,XorArray,The method has 5 parameters. Parameters: pbSource' nSourceOffset' pbBuffer' nBufferOffset' nLength
Magic Number,SevenPass.IO.Crypto,HashedBlockFileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedBlockFileFormat.cs,Read,The following statement contains a magic number: var hash = WindowsRuntimeBuffer.Create(32);
Magic Number,SevenPass.IO.Crypto,HashedBlockFileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedBlockFileFormat.cs,Read,The following statement contains a magic number: try              {                  while (true)                  {                      // Detect end of file                      var read = await reader.LoadAsync(4);                      if (read == 0)                          break;                        // Verify block index                      var index = reader.ReadInt32();                      if (index != blockIndex)                      {                          throw new InvalidDataException(string.Format(                              "Wrong block ID detected' expected: {0}' actual: {1}"'                              blockIndex' index));                      }                      blockIndex++;                        // Block hash                      hash = await input.ReadAsync(hash' 32);                      if (hash.Length != 32)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        read = await reader.LoadAsync(4);                      if (read != 4)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Validate block size (< 10MB)                      var blockSize = reader.ReadInt32();                      if (blockSize == 0)                      {                          // Terminator block                          var isTerminator = hash                              .ToArray()                              .All(x => x == 0);                            if (!isTerminator)                          {                              throw new InvalidDataException(                                  "Data corruption detected (invalid hash for terminator block)");                          }                            break;                      }                        if (0 > blockSize || blockSize > 10485760)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Check data truncate                      var loaded = await reader.LoadAsync((uint)blockSize);                      if (loaded < blockSize)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        var buffer = reader.ReadBuffer((uint)blockSize);                        // Verify block integrity                      var actual = sha.HashData(buffer);                      if (!CryptographicBuffer.Compare(hash' actual))                      {                          throw new InvalidDataException(                              "Data corruption detected (content corrupted)");                      }                        await result.WriteAsync(buffer.ToArray()'                          0' (int)buffer.Length);                  }                    result.Position = 0;                  return result;              }              catch              {                  result.Dispose();                  throw;              }
Magic Number,SevenPass.IO.Crypto,HashedBlockFileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedBlockFileFormat.cs,Read,The following statement contains a magic number: try              {                  while (true)                  {                      // Detect end of file                      var read = await reader.LoadAsync(4);                      if (read == 0)                          break;                        // Verify block index                      var index = reader.ReadInt32();                      if (index != blockIndex)                      {                          throw new InvalidDataException(string.Format(                              "Wrong block ID detected' expected: {0}' actual: {1}"'                              blockIndex' index));                      }                      blockIndex++;                        // Block hash                      hash = await input.ReadAsync(hash' 32);                      if (hash.Length != 32)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        read = await reader.LoadAsync(4);                      if (read != 4)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Validate block size (< 10MB)                      var blockSize = reader.ReadInt32();                      if (blockSize == 0)                      {                          // Terminator block                          var isTerminator = hash                              .ToArray()                              .All(x => x == 0);                            if (!isTerminator)                          {                              throw new InvalidDataException(                                  "Data corruption detected (invalid hash for terminator block)");                          }                            break;                      }                        if (0 > blockSize || blockSize > 10485760)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Check data truncate                      var loaded = await reader.LoadAsync((uint)blockSize);                      if (loaded < blockSize)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        var buffer = reader.ReadBuffer((uint)blockSize);                        // Verify block integrity                      var actual = sha.HashData(buffer);                      if (!CryptographicBuffer.Compare(hash' actual))                      {                          throw new InvalidDataException(                              "Data corruption detected (content corrupted)");                      }                        await result.WriteAsync(buffer.ToArray()'                          0' (int)buffer.Length);                  }                    result.Position = 0;                  return result;              }              catch              {                  result.Dispose();                  throw;              }
Magic Number,SevenPass.IO.Crypto,HashedBlockFileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedBlockFileFormat.cs,Read,The following statement contains a magic number: try              {                  while (true)                  {                      // Detect end of file                      var read = await reader.LoadAsync(4);                      if (read == 0)                          break;                        // Verify block index                      var index = reader.ReadInt32();                      if (index != blockIndex)                      {                          throw new InvalidDataException(string.Format(                              "Wrong block ID detected' expected: {0}' actual: {1}"'                              blockIndex' index));                      }                      blockIndex++;                        // Block hash                      hash = await input.ReadAsync(hash' 32);                      if (hash.Length != 32)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        read = await reader.LoadAsync(4);                      if (read != 4)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Validate block size (< 10MB)                      var blockSize = reader.ReadInt32();                      if (blockSize == 0)                      {                          // Terminator block                          var isTerminator = hash                              .ToArray()                              .All(x => x == 0);                            if (!isTerminator)                          {                              throw new InvalidDataException(                                  "Data corruption detected (invalid hash for terminator block)");                          }                            break;                      }                        if (0 > blockSize || blockSize > 10485760)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Check data truncate                      var loaded = await reader.LoadAsync((uint)blockSize);                      if (loaded < blockSize)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        var buffer = reader.ReadBuffer((uint)blockSize);                        // Verify block integrity                      var actual = sha.HashData(buffer);                      if (!CryptographicBuffer.Compare(hash' actual))                      {                          throw new InvalidDataException(                              "Data corruption detected (content corrupted)");                      }                        await result.WriteAsync(buffer.ToArray()'                          0' (int)buffer.Length);                  }                    result.Position = 0;                  return result;              }              catch              {                  result.Dispose();                  throw;              }
Magic Number,SevenPass.IO.Crypto,HashedBlockFileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedBlockFileFormat.cs,Read,The following statement contains a magic number: try              {                  while (true)                  {                      // Detect end of file                      var read = await reader.LoadAsync(4);                      if (read == 0)                          break;                        // Verify block index                      var index = reader.ReadInt32();                      if (index != blockIndex)                      {                          throw new InvalidDataException(string.Format(                              "Wrong block ID detected' expected: {0}' actual: {1}"'                              blockIndex' index));                      }                      blockIndex++;                        // Block hash                      hash = await input.ReadAsync(hash' 32);                      if (hash.Length != 32)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        read = await reader.LoadAsync(4);                      if (read != 4)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Validate block size (< 10MB)                      var blockSize = reader.ReadInt32();                      if (blockSize == 0)                      {                          // Terminator block                          var isTerminator = hash                              .ToArray()                              .All(x => x == 0);                            if (!isTerminator)                          {                              throw new InvalidDataException(                                  "Data corruption detected (invalid hash for terminator block)");                          }                            break;                      }                        if (0 > blockSize || blockSize > 10485760)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Check data truncate                      var loaded = await reader.LoadAsync((uint)blockSize);                      if (loaded < blockSize)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        var buffer = reader.ReadBuffer((uint)blockSize);                        // Verify block integrity                      var actual = sha.HashData(buffer);                      if (!CryptographicBuffer.Compare(hash' actual))                      {                          throw new InvalidDataException(                              "Data corruption detected (content corrupted)");                      }                        await result.WriteAsync(buffer.ToArray()'                          0' (int)buffer.Length);                  }                    result.Position = 0;                  return result;              }              catch              {                  result.Dispose();                  throw;              }
Magic Number,SevenPass.IO.Crypto,HashedBlockFileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedBlockFileFormat.cs,Read,The following statement contains a magic number: try              {                  while (true)                  {                      // Detect end of file                      var read = await reader.LoadAsync(4);                      if (read == 0)                          break;                        // Verify block index                      var index = reader.ReadInt32();                      if (index != blockIndex)                      {                          throw new InvalidDataException(string.Format(                              "Wrong block ID detected' expected: {0}' actual: {1}"'                              blockIndex' index));                      }                      blockIndex++;                        // Block hash                      hash = await input.ReadAsync(hash' 32);                      if (hash.Length != 32)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        read = await reader.LoadAsync(4);                      if (read != 4)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Validate block size (< 10MB)                      var blockSize = reader.ReadInt32();                      if (blockSize == 0)                      {                          // Terminator block                          var isTerminator = hash                              .ToArray()                              .All(x => x == 0);                            if (!isTerminator)                          {                              throw new InvalidDataException(                                  "Data corruption detected (invalid hash for terminator block)");                          }                            break;                      }                        if (0 > blockSize || blockSize > 10485760)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Check data truncate                      var loaded = await reader.LoadAsync((uint)blockSize);                      if (loaded < blockSize)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        var buffer = reader.ReadBuffer((uint)blockSize);                        // Verify block integrity                      var actual = sha.HashData(buffer);                      if (!CryptographicBuffer.Compare(hash' actual))                      {                          throw new InvalidDataException(                              "Data corruption detected (content corrupted)");                      }                        await result.WriteAsync(buffer.ToArray()'                          0' (int)buffer.Length);                  }                    result.Position = 0;                  return result;              }              catch              {                  result.Dispose();                  throw;              }
Magic Number,SevenPass.IO.Crypto,HashedBlockFileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedBlockFileFormat.cs,Read,The following statement contains a magic number: try              {                  while (true)                  {                      // Detect end of file                      var read = await reader.LoadAsync(4);                      if (read == 0)                          break;                        // Verify block index                      var index = reader.ReadInt32();                      if (index != blockIndex)                      {                          throw new InvalidDataException(string.Format(                              "Wrong block ID detected' expected: {0}' actual: {1}"'                              blockIndex' index));                      }                      blockIndex++;                        // Block hash                      hash = await input.ReadAsync(hash' 32);                      if (hash.Length != 32)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        read = await reader.LoadAsync(4);                      if (read != 4)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Validate block size (< 10MB)                      var blockSize = reader.ReadInt32();                      if (blockSize == 0)                      {                          // Terminator block                          var isTerminator = hash                              .ToArray()                              .All(x => x == 0);                            if (!isTerminator)                          {                              throw new InvalidDataException(                                  "Data corruption detected (invalid hash for terminator block)");                          }                            break;                      }                        if (0 > blockSize || blockSize > 10485760)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        // Check data truncate                      var loaded = await reader.LoadAsync((uint)blockSize);                      if (loaded < blockSize)                      {                          throw new InvalidDataException(                              "Data corruption detected (truncated data)");                      }                        var buffer = reader.ReadBuffer((uint)blockSize);                        // Verify block integrity                      var actual = sha.HashData(buffer);                      if (!CryptographicBuffer.Compare(hash' actual))                      {                          throw new InvalidDataException(                              "Data corruption detected (content corrupted)");                      }                        await result.WriteAsync(buffer.ToArray()'                          0' (int)buffer.Length);                  }                    result.Position = 0;                  return result;              }              catch              {                  result.Dispose();                  throw;              }
Magic Number,SevenPass.IO.Crypto,HashedInputStream,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedInputStream.cs,ReadPrivateAsync,The following statement contains a magic number: progress.Report(50);
Magic Number,SevenPass.IO.Crypto,HashedInputStream,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\HashedInputStream.cs,ReadPrivateAsync,The following statement contains a magic number: progress.Report(100);
Magic Number,SevenPass.IO.Crypto,Rc4RandomGenerator,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Rc4RandomGenerator.cs,Rc4RandomGenerator,The following statement contains a magic number: _state = new byte[256];
Magic Number,SevenPass.IO.Crypto,Rc4RandomGenerator,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Rc4RandomGenerator.cs,Rc4RandomGenerator,The following statement contains a magic number: for (uint w = 0; w < 256; ++w)                  _state[w] = (byte)w;
Magic Number,SevenPass.IO.Crypto,Rc4RandomGenerator,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Rc4RandomGenerator.cs,Rc4RandomGenerator,The following statement contains a magic number: unchecked              {                  byte j = 0;                  uint keyIndex = 0;                    for (uint w = 0; w < 256; ++w) // Key setup                  {                      j += (byte)(_state[w] + key.GetByte(keyIndex));                        var temp = _state[0];                      _state[0] = _state[j];                      _state[j] = temp;                        ++keyIndex;                      if (keyIndex >= keyLength)                          keyIndex = 0;                  }              }
Magic Number,SevenPass.IO.Crypto,Rc4RandomGenerator,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Rc4RandomGenerator.cs,Rc4RandomGenerator,The following statement contains a magic number: GetRandomBytes(512);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: if (x.Length < 16) throw new InvalidOperationException();
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: Array.Copy(m_state' x' 16);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,NextOutput,The following statement contains a magic number: unchecked              {                  for (int i = 0; i < 10; ++i) // (int i = 20; i > 0; i -= 2)                  {                      x[4] ^= Rotl32(x[0] + x[12]' 7);                      x[8] ^= Rotl32(x[4] + x[0]' 9);                      x[12] ^= Rotl32(x[8] + x[4]' 13);                      x[0] ^= Rotl32(x[12] + x[8]' 18);                      x[9] ^= Rotl32(x[5] + x[1]' 7);                      x[13] ^= Rotl32(x[9] + x[5]' 9);                      x[1] ^= Rotl32(x[13] + x[9]' 13);                      x[5] ^= Rotl32(x[1] + x[13]' 18);                      x[14] ^= Rotl32(x[10] + x[6]' 7);                      x[2] ^= Rotl32(x[14] + x[10]' 9);                      x[6] ^= Rotl32(x[2] + x[14]' 13);                      x[10] ^= Rotl32(x[6] + x[2]' 18);                      x[3] ^= Rotl32(x[15] + x[11]' 7);                      x[7] ^= Rotl32(x[3] + x[15]' 9);                      x[11] ^= Rotl32(x[7] + x[3]' 13);                      x[15] ^= Rotl32(x[11] + x[7]' 18);                      x[1] ^= Rotl32(x[0] + x[3]' 7);                      x[2] ^= Rotl32(x[1] + x[0]' 9);                      x[3] ^= Rotl32(x[2] + x[1]' 13);                      x[0] ^= Rotl32(x[3] + x[2]' 18);                      x[6] ^= Rotl32(x[5] + x[4]' 7);                      x[7] ^= Rotl32(x[6] + x[5]' 9);                      x[4] ^= Rotl32(x[7] + x[6]' 13);                      x[5] ^= Rotl32(x[4] + x[7]' 18);                      x[11] ^= Rotl32(x[10] + x[9]' 7);                      x[8] ^= Rotl32(x[11] + x[10]' 9);                      x[9] ^= Rotl32(x[8] + x[11]' 13);                      x[10] ^= Rotl32(x[9] + x[8]' 18);                      x[12] ^= Rotl32(x[15] + x[14]' 7);                      x[13] ^= Rotl32(x[12] + x[15]' 9);                      x[14] ^= Rotl32(x[13] + x[12]' 13);                      x[15] ^= Rotl32(x[14] + x[13]' 18);                  }                    for (int i = 0; i < 16; ++i)                      x[i] += m_state[i];                    for (int i = 0; i < 16; ++i)                  {                      m_output[i << 2] = (byte)x[i];                      m_output[(i << 2) + 1] = (byte)(x[i] >> 8);                      m_output[(i << 2) + 2] = (byte)(x[i] >> 16);                      m_output[(i << 2) + 3] = (byte)(x[i] >> 24);                  }                    m_outputPos = 0;                  ++m_state[8];                  if (m_state[8] == 0) ++m_state[9];              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,Rotl32,The following statement contains a magic number: unchecked              {                  return ((x << b) | (x >> (32 - b)));              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,U8To32Little,The following statement contains a magic number: unchecked              {                  return ((uint)pb[iOffset] | ((uint)pb[iOffset + 1] << 8) |                      ((uint)pb[iOffset + 2] << 16) | ((uint)pb[iOffset + 3] << 24));              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,U8To32Little,The following statement contains a magic number: unchecked              {                  return ((uint)pb[iOffset] | ((uint)pb[iOffset + 1] << 8) |                      ((uint)pb[iOffset + 2] << 16) | ((uint)pb[iOffset + 3] << 24));              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,U8To32Little,The following statement contains a magic number: unchecked              {                  return ((uint)pb[iOffset] | ((uint)pb[iOffset + 1] << 8) |                      ((uint)pb[iOffset + 2] << 16) | ((uint)pb[iOffset + 3] << 24));              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,U8To32Little,The following statement contains a magic number: unchecked              {                  return ((uint)pb[iOffset] | ((uint)pb[iOffset + 1] << 8) |                      ((uint)pb[iOffset + 2] << 16) | ((uint)pb[iOffset + 3] << 24));              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,U8To32Little,The following statement contains a magic number: unchecked              {                  return ((uint)pb[iOffset] | ((uint)pb[iOffset + 1] << 8) |                      ((uint)pb[iOffset + 2] << 16) | ((uint)pb[iOffset + 3] << 24));              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: if (k.Length != 32) throw new ArgumentException();
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[2] = U8To32Little(k' 4);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[2] = U8To32Little(k' 4);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[3] = U8To32Little(k' 8);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[3] = U8To32Little(k' 8);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[4] = U8To32Little(k' 12);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[4] = U8To32Little(k' 12);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[11] = U8To32Little(k' 16);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[11] = U8To32Little(k' 16);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[12] = U8To32Little(k' 20);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[12] = U8To32Little(k' 20);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[13] = U8To32Little(k' 24);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[13] = U8To32Little(k' 24);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[14] = U8To32Little(k' 28);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[14] = U8To32Little(k' 28);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[5] = m_sigma[1];
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[10] = m_sigma[2];
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[10] = m_sigma[2];
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[15] = m_sigma[3];
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,KeySetup,The following statement contains a magic number: m_state[15] = m_sigma[3];
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,IvSetup,The following statement contains a magic number: if (pbIV.Length != 8) throw new ArgumentException();
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,IvSetup,The following statement contains a magic number: m_state[6] = U8To32Little(pbIV' 0);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,IvSetup,The following statement contains a magic number: m_state[7] = U8To32Little(pbIV' 4);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,IvSetup,The following statement contains a magic number: m_state[7] = U8To32Little(pbIV' 4);
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,IvSetup,The following statement contains a magic number: m_state[8] = 0;
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,IvSetup,The following statement contains a magic number: m_state[9] = 0;
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,Encrypt,The following statement contains a magic number: while (nBytesRem > 0)              {                  Debug.Assert((m_outputPos >= 0) && (m_outputPos <= 64));                  if (m_outputPos == 64) NextOutput();                  Debug.Assert(m_outputPos < 64);                    int nCopy = Math.Min(64 - m_outputPos' nBytesRem);                    if (bXor) XorArray(m_output' m_outputPos' m' nOffset' nCopy);                  else Array.Copy(m_output' m_outputPos' m' nOffset' nCopy);                    m_outputPos += nCopy;                  nBytesRem -= nCopy;                  nOffset += nCopy;              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,Encrypt,The following statement contains a magic number: while (nBytesRem > 0)              {                  Debug.Assert((m_outputPos >= 0) && (m_outputPos <= 64));                  if (m_outputPos == 64) NextOutput();                  Debug.Assert(m_outputPos < 64);                    int nCopy = Math.Min(64 - m_outputPos' nBytesRem);                    if (bXor) XorArray(m_output' m_outputPos' m' nOffset' nCopy);                  else Array.Copy(m_output' m_outputPos' m' nOffset' nCopy);                    m_outputPos += nCopy;                  nBytesRem -= nCopy;                  nOffset += nCopy;              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,Encrypt,The following statement contains a magic number: while (nBytesRem > 0)              {                  Debug.Assert((m_outputPos >= 0) && (m_outputPos <= 64));                  if (m_outputPos == 64) NextOutput();                  Debug.Assert(m_outputPos < 64);                    int nCopy = Math.Min(64 - m_outputPos' nBytesRem);                    if (bXor) XorArray(m_output' m_outputPos' m' nOffset' nCopy);                  else Array.Copy(m_output' m_outputPos' m' nOffset' nCopy);                    m_outputPos += nCopy;                  nBytesRem -= nCopy;                  nOffset += nCopy;              }
Magic Number,KeePassLib.Cryptography.Cipher,Salsa20Cipher,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\Crypto\Salsa20Cipher.cs,Encrypt,The following statement contains a magic number: while (nBytesRem > 0)              {                  Debug.Assert((m_outputPos >= 0) && (m_outputPos <= 64));                  if (m_outputPos == 64) NextOutput();                  Debug.Assert(m_outputPos < 64);                    int nCopy = Math.Min(64 - m_outputPos' nBytesRem);                    if (bXor) XorArray(m_output' m_outputPos' m' nOffset' nCopy);                  else Array.Copy(m_output' m_outputPos' m' nOffset' nCopy);                    m_outputPos += nCopy;                  nBytesRem -= nCopy;                  nOffset += nCopy;              }
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,Headers,The following statement contains a magic number: var buffer = WindowsRuntimeBuffer.Create(128);
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,Headers,The following statement contains a magic number: buffer = await hash.ReadAsync(buffer' 8);
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,Headers,The following statement contains a magic number: buffer = await hash.ReadAsync(buffer' 4);
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,CheckCompatibility,The following statement contains a magic number: if (schema.Major < 3)                  return FileFormats.OldVersion;
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,CheckCompatibility,The following statement contains a magic number: if (schema.Major > 3)                  return FileFormats.NewVersion;
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,GetHeaders,The following statement contains a magic number: while (true)              {                  buffer = await input.ReadAsync(buffer' 3);                  var field = (HeaderFields)buffer.GetByte(0);                  var size = BitConverter.ToUInt16(buffer.ToArray(1' 2)' 0);                    if (size > 0)                      buffer = await input.ReadAsync(buffer' size);                    switch (field)                  {                      case HeaderFields.EndOfHeader:                          return result;                        case HeaderFields.CompressionFlags:                          result.UseGZip = buffer.GetByte(0) == 1;                          break;                        case HeaderFields.EncryptionIV:                          result.EncryptionIV = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.MasterSeed:                          result.MasterSeed = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.StreamStartBytes:                          result.StartBytes = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.TransformSeed:                          result.TransformSeed = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.TransformRounds:                          result.TransformRounds = BitConverter.ToUInt64(                              buffer.ToArray()' 0);                          break;                        case HeaderFields.ProtectedStreamKey:                          result.ProtectedStreamKey = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.InnerRandomStreamID:                          result.RandomAlgorithm = (CrsAlgorithm)                              BitConverter.ToUInt32(buffer.ToArray()' 0);                          break;                  }              }
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,GetHeaders,The following statement contains a magic number: while (true)              {                  buffer = await input.ReadAsync(buffer' 3);                  var field = (HeaderFields)buffer.GetByte(0);                  var size = BitConverter.ToUInt16(buffer.ToArray(1' 2)' 0);                    if (size > 0)                      buffer = await input.ReadAsync(buffer' size);                    switch (field)                  {                      case HeaderFields.EndOfHeader:                          return result;                        case HeaderFields.CompressionFlags:                          result.UseGZip = buffer.GetByte(0) == 1;                          break;                        case HeaderFields.EncryptionIV:                          result.EncryptionIV = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.MasterSeed:                          result.MasterSeed = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.StreamStartBytes:                          result.StartBytes = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.TransformSeed:                          result.TransformSeed = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.TransformRounds:                          result.TransformRounds = BitConverter.ToUInt64(                              buffer.ToArray()' 0);                          break;                        case HeaderFields.ProtectedStreamKey:                          result.ProtectedStreamKey = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.InnerRandomStreamID:                          result.RandomAlgorithm = (CrsAlgorithm)                              BitConverter.ToUInt32(buffer.ToArray()' 0);                          break;                  }              }
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,GetVersion,The following statement contains a magic number: var bytes = buffer.ToArray(0' 4);
Magic Number,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,GetVersion,The following statement contains a magic number: var major = BitConverter.ToUInt16(bytes' 2);
Magic Number,SevenPass.IO,PasswordData,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\PasswordData.cs,GetMasterKey,The following statement contains a magic number: return AsyncInfo.Run<IBuffer' uint>(                  (token' progress) => Task.Run(() =>                  {                      var transforms = 0UL;                      var master = GetMasterKey();                        // AES - ECB                      var aes = SymmetricKeyAlgorithmProvider                          .OpenAlgorithm(SymmetricAlgorithmNames.AesEcb);                      var key = aes.CreateSymmetricKey(seed);                          while (true)                      {                          // Report progress                          token.ThrowIfCancellationRequested();                          progress.Report((uint)Math.Round(                              transforms*100F/rounds));                            for (var i = 0; i < 1000; i++)                          {                              // Transform master key                              master = CryptographicEngine                                  .Encrypt(key' master' null);                                transforms++;                              if (transforms < rounds)                                  continue;                                // Completed                              progress.Report(100);                              master = HashAlgorithmProvider                                  .OpenAlgorithm(HashAlgorithmNames.Sha256)                                  .HashData(master);                                return master;                          }                      }                  }' token));
Magic Number,SevenPass.IO,PasswordData,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\PasswordData.cs,GetMasterKey,The following statement contains a magic number: return AsyncInfo.Run<IBuffer' uint>(                  (token' progress) => Task.Run(() =>                  {                      var transforms = 0UL;                      var master = GetMasterKey();                        // AES - ECB                      var aes = SymmetricKeyAlgorithmProvider                          .OpenAlgorithm(SymmetricAlgorithmNames.AesEcb);                      var key = aes.CreateSymmetricKey(seed);                          while (true)                      {                          // Report progress                          token.ThrowIfCancellationRequested();                          progress.Report((uint)Math.Round(                              transforms*100F/rounds));                            for (var i = 0; i < 1000; i++)                          {                              // Transform master key                              master = CryptographicEngine                                  .Encrypt(key' master' null);                                transforms++;                              if (transforms < rounds)                                  continue;                                // Completed                              progress.Report(100);                              master = HashAlgorithmProvider                                  .OpenAlgorithm(HashAlgorithmNames.Sha256)                                  .HashData(master);                                return master;                          }                      }                  }' token));
Magic Number,SevenPass.IO,PasswordData,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\PasswordData.cs,LoadKeyFile,The following statement contains a magic number: var buffer = WindowsRuntimeBuffer.Create(1024);
Magic Number,SevenPass.IO,PasswordData,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\PasswordData.cs,LoadKeyFile,The following statement contains a magic number: switch (input.Size)              {                  case 32: // Binary key file                      return await input.ReadAsync(buffer' 32);                    case 64: // Hex text key file                      buffer = await input.ReadAsync(buffer' 64);                      var hex = CryptographicBuffer.ConvertBinaryToString(                          BinaryStringEncoding.Utf8' buffer);                        if (IsHexString(hex))                          return CryptographicBuffer.DecodeFromHexString(hex);                      break;              }
Magic Number,SevenPass.IO,PasswordData,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\PasswordData.cs,LoadKeyFile,The following statement contains a magic number: switch (input.Size)              {                  case 32: // Binary key file                      return await input.ReadAsync(buffer' 32);                    case 64: // Hex text key file                      buffer = await input.ReadAsync(buffer' 64);                      var hex = CryptographicBuffer.ConvertBinaryToString(                          BinaryStringEncoding.Utf8' buffer);                        if (IsHexString(hex))                          return CryptographicBuffer.DecodeFromHexString(hex);                      break;              }
Magic Number,SevenPass.IO,PasswordData,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\PasswordData.cs,LoadKeyFile,The following statement contains a magic number: switch (input.Size)              {                  case 32: // Binary key file                      return await input.ReadAsync(buffer' 32);                    case 64: // Hex text key file                      buffer = await input.ReadAsync(buffer' 64);                      var hex = CryptographicBuffer.ConvertBinaryToString(                          BinaryStringEncoding.Utf8' buffer);                        if (IsHexString(hex))                          return CryptographicBuffer.DecodeFromHexString(hex);                      break;              }
Magic Number,SevenPass.IO,PasswordData,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\PasswordData.cs,LoadKeyFile,The following statement contains a magic number: switch (input.Size)              {                  case 32: // Binary key file                      return await input.ReadAsync(buffer' 32);                    case 64: // Hex text key file                      buffer = await input.ReadAsync(buffer' 64);                      var hex = CryptographicBuffer.ConvertBinaryToString(                          BinaryStringEncoding.Utf8' buffer);                        if (IsHexString(hex))                          return CryptographicBuffer.DecodeFromHexString(hex);                      break;              }
Missing Default,SevenPass.IO,FileFormat,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\FileFormat.cs,GetHeaders,The following switch statement is missing a default case: switch (field)                  {                      case HeaderFields.EndOfHeader:                          return result;                        case HeaderFields.CompressionFlags:                          result.UseGZip = buffer.GetByte(0) == 1;                          break;                        case HeaderFields.EncryptionIV:                          result.EncryptionIV = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.MasterSeed:                          result.MasterSeed = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.StreamStartBytes:                          result.StartBytes = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.TransformSeed:                          result.TransformSeed = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.TransformRounds:                          result.TransformRounds = BitConverter.ToUInt64(                              buffer.ToArray()' 0);                          break;                        case HeaderFields.ProtectedStreamKey:                          result.ProtectedStreamKey = buffer                              .ToArray().AsBuffer();                          break;                        case HeaderFields.InnerRandomStreamID:                          result.RandomAlgorithm = (CrsAlgorithm)                              BitConverter.ToUInt32(buffer.ToArray()' 0);                          break;                  }
Missing Default,SevenPass.IO,PasswordData,C:\repos\7Pass_7Pass-Remake\src\SevenPass\SevenPass.IO\PasswordData.cs,LoadKeyFile,The following switch statement is missing a default case: switch (input.Size)              {                  case 32: // Binary key file                      return await input.ReadAsync(buffer' 32);                    case 64: // Hex text key file                      buffer = await input.ReadAsync(buffer' 64);                      var hex = CryptographicBuffer.ConvertBinaryToString(                          BinaryStringEncoding.Utf8' buffer);                        if (IsHexString(hex))                          return CryptographicBuffer.DecodeFromHexString(hex);                      break;              }
