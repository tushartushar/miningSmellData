Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Akka.TestKit.Xunit.Internals,AkkaAssertEqualityComparer<T>,C:\research\architectureSmells\repos\rogeralsing_Pigeon\src\contrib\testkits\Akka.TestKit.Xunit\Internals\AkkaAssertEqualityComparer.cs,Equals,Cyclomatic complexity of the method is 11
Long Parameter List,Akka.TestKit.Xunit,XunitAssertions,C:\research\architectureSmells\repos\rogeralsing_Pigeon\src\contrib\testkits\Akka.TestKit.Xunit\XunitAssertions.cs,AssertEqual,The method has 5 parameters. Parameters: expected' actual' comparer' format' args
Long Statement,Akka.TestKit.Xunit.Internals,AkkaAssertEqualityComparer<T>,C:\research\architectureSmells\repos\rogeralsing_Pigeon\src\contrib\testkits\Akka.TestKit.Xunit\Internals\AkkaAssertEqualityComparer.cs,Equals,The length of the statement  "            if(!typeInfo.IsValueType || (typeInfo.IsGenericType && typeInfo.GetGenericTypeDefinition().GetTypeInfo().IsAssignableFrom(NullableTypeInfo))) " is 141.
Missing Default,Akka.TestKit.Xunit.Internals,AkkaAssertEqualityComparer<T>,C:\research\architectureSmells\repos\rogeralsing_Pigeon\src\contrib\testkits\Akka.TestKit.Xunit\Internals\AkkaAssertEqualityComparer.cs,Equals,The following switch statement is missing a default case: switch (x)              {                  case IEquatable<T> equatable:                      return equatable.Equals(y);                  case IComparable<T> comparableGeneric:                      return comparableGeneric.CompareTo(y) == 0;                  case IComparable comparable:                      return comparable.CompareTo(y) == 0;                  case IEnumerable enumerableX                      when y is IEnumerable enumerableY:                        var enumeratorX = enumerableX.GetEnumerator();                      var enumeratorY = enumerableY.GetEnumerator();                      var equalityComparer = _innerComparerFactory();                        while (true)                      {                          var hasNextX = enumeratorX.MoveNext();                          var hasNextY = enumeratorY.MoveNext();                            if (!hasNextX || !hasNextY)                              return hasNextX == hasNextY;                            if (!equalityComparer.Equals(enumeratorX.Current' enumeratorY.Current))                              return false;                      }              }
