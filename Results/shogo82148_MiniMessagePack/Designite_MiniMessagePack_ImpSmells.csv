Implementation smell,Namespace,Class,File,Method,Description
Long Method,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The method has 101 lines of code.
Long Statement,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The length of the statement  "				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32) " is 121.
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (count < 16) {  				s.WriteByte ((byte)(0x90 + count));  			} else if (count < 0x10000) {  				s.WriteByte (0xdc);  				Write (s' (ushort)count);  			} else {  				s.WriteByte (0xdd);  				Write (s' (uint)count);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (count < 16) {  				s.WriteByte ((byte)(0x80 + count));  			} else if (count < 0x10000) {  				s.WriteByte (0xde);  				Write (s' (ushort)count);  			} else {  				s.WriteByte (0xdf);  				Write (s' (uint)count);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: unchecked {  				if (val >= -32) {  					s.WriteByte ((byte)val);  				} else {  					tmp0 [0] = 0xd0;  					tmp0 [1] = (byte)val;  					s.Write (tmp0' 0' 2);  				}  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: unchecked {  				if (val >= -32) {  					s.WriteByte ((byte)val);  				} else {  					tmp0 [0] = 0xd0;  					tmp0 [1] = (byte)val;  					s.Write (tmp0' 0' 2);  				}  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (val <= 0x7f) {  				s.WriteByte (val);  			} else {  				tmp0 [0] = 0xcc;  				tmp0 [1] = val;  				s.Write (tmp0' 0' 2);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: unchecked {  				if (val >= 0) {  					Pack (s' (ushort)val);  				} else if (val >= -128) {  					Pack (s' (sbyte)val);  				} else {  					s.WriteByte (0xd1);  					Write (s' (ushort)val);  				}  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: unchecked {  				if (val >= 0) {  					Pack (s' (uint)val);  				} else if (val >= -128) {  					Pack (s' (sbyte)val);  				} else if (val >= -0x8000) {  					s.WriteByte (0xd1);  					Write (s' (ushort)val);  				} else {  					s.WriteByte (0xd2);  					Write (s' (uint)val);  				}  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: unchecked {  				if (val >= 0) {  					Pack (s' (ulong)val);  				} else if (val >= -128) {  					Pack (s' (sbyte)val);  				} else if (val >= -0x8000) {  					s.WriteByte (0xd1);  					Write (s' (ushort)val);  				} else if (val >= -0x80000000) {  					s.WriteByte (0xd2);  					Write (s' (uint)val);  				} else {  					s.WriteByte (0xd3);  					Write (s' (ulong)val);  				}  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [3];  				tmp0 [1] = bytes [2];  				tmp0 [2] = bytes [1];  				tmp0 [3] = bytes [0];  				s.Write (tmp0' 0' 4);  			} else {  				s.Write (bytes' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [3];  				tmp0 [1] = bytes [2];  				tmp0 [2] = bytes [1];  				tmp0 [3] = bytes [0];  				s.Write (tmp0' 0' 4);  			} else {  				s.Write (bytes' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [3];  				tmp0 [1] = bytes [2];  				tmp0 [2] = bytes [1];  				tmp0 [3] = bytes [0];  				s.Write (tmp0' 0' 4);  			} else {  				s.Write (bytes' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [3];  				tmp0 [1] = bytes [2];  				tmp0 [2] = bytes [1];  				tmp0 [3] = bytes [0];  				s.Write (tmp0' 0' 4);  			} else {  				s.Write (bytes' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [3];  				tmp0 [1] = bytes [2];  				tmp0 [2] = bytes [1];  				tmp0 [3] = bytes [0];  				s.Write (tmp0' 0' 4);  			} else {  				s.Write (bytes' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [3];  				tmp0 [1] = bytes [2];  				tmp0 [2] = bytes [1];  				tmp0 [3] = bytes [0];  				s.Write (tmp0' 0' 4);  			} else {  				s.Write (bytes' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				tmp0 [0] = bytes [7];  				tmp0 [1] = bytes [6];  				tmp0 [2] = bytes [5];  				tmp0 [3] = bytes [4];  				tmp0 [4] = bytes [3];  				tmp0 [5] = bytes [2];  				tmp0 [6] = bytes [1];  				tmp0 [7] = bytes [0];  				s.Write (tmp0' 0' 8);  			} else {  				s.Write (bytes' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 8);  				tmp0 [1] = (byte)val;  				s.Write (tmp0' 0' 2);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 8);  				tmp0 [1] = (byte)val;  				s.Write (tmp0' 0' 2);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 24);  				tmp0 [1] = (byte)(val >> 16);  				tmp0 [2] = (byte)(val >> 8);  				tmp0 [3] = (byte)val;  				s.Write (tmp0' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 24);  				tmp0 [1] = (byte)(val >> 16);  				tmp0 [2] = (byte)(val >> 8);  				tmp0 [3] = (byte)val;  				s.Write (tmp0' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 24);  				tmp0 [1] = (byte)(val >> 16);  				tmp0 [2] = (byte)(val >> 8);  				tmp0 [3] = (byte)val;  				s.Write (tmp0' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 24);  				tmp0 [1] = (byte)(val >> 16);  				tmp0 [2] = (byte)(val >> 8);  				tmp0 [3] = (byte)val;  				s.Write (tmp0' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 24);  				tmp0 [1] = (byte)(val >> 16);  				tmp0 [2] = (byte)(val >> 8);  				tmp0 [3] = (byte)val;  				s.Write (tmp0' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 24);  				tmp0 [1] = (byte)(val >> 16);  				tmp0 [2] = (byte)(val >> 8);  				tmp0 [3] = (byte)val;  				s.Write (tmp0' 0' 4);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: unchecked {  				tmp0 [0] = (byte)(val >> 56);  				tmp0 [1] = (byte)(val >> 48);  				tmp0 [2] = (byte)(val >> 40);  				tmp0 [3] = (byte)(val >> 32);  				tmp0 [4] = (byte)(val >> 24);  				tmp0 [5] = (byte)(val >> 16);  				tmp0 [6] = (byte)(val >> 8);  				tmp0 [7] = (byte)val;  				s.Write (tmp0' 0' 8);  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint16,The following statement contains a magic number: if (s.Read (tmp0' 0' 2) != 2) {   				throw new FormatException ();  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint16,The following statement contains a magic number: if (s.Read (tmp0' 0' 2) != 2) {   				throw new FormatException ();  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint16,The following statement contains a magic number: return (long)((tmp0[0] << 8) | tmp0[1]);
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: if (s.Read (tmp0' 0' 4) != 4) {   				throw new FormatException ();  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: if (s.Read (tmp0' 0' 4) != 4) {   				throw new FormatException ();  			}
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Magic Number,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Missing Default,MiniMessagePack,MiniMessagePacker,C:\repos\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following switch statement is missing a default case: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
