Implementation smell,Namespace,Class,File,Method,Description
Long Method,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The method has 101 lines of code.
Complex Method,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,Cyclomatic complexity of the method is 16
Complex Method,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,Cyclomatic complexity of the method is 35
Long Statement,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The length of the statement  "				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32) " is 121.
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: count < 16
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: count < 16
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: val >= -32
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [0] = bytes [3];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [1] = bytes [2];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [2] = bytes [1];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [3] = bytes [0];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: s.Write (tmp0' 0' 4);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [0] = bytes [7];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [1] = bytes [6];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [2] = bytes [5];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [2] = bytes [5];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [3] = bytes [4];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [3] = bytes [4];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [4] = bytes [3];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [4] = bytes [3];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [5] = bytes [2];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [5] = bytes [2];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [6] = bytes [1];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: tmp0 [7] = bytes [0];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Pack,The following statement contains a magic number: s.Write (tmp0' 0' 8);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [0] = (byte)(val >> 8);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: s.Write (tmp0' 0' 2);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [0] = (byte)(val >> 24);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [1] = (byte)(val >> 16);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [2] = (byte)(val >> 8);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [2] = (byte)(val >> 8);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [3] = (byte)val;
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: s.Write (tmp0' 0' 4);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [0] = (byte)(val >> 56);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [1] = (byte)(val >> 48);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [2] = (byte)(val >> 40);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [2] = (byte)(val >> 40);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [3] = (byte)(val >> 32);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [3] = (byte)(val >> 32);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [4] = (byte)(val >> 24);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [4] = (byte)(val >> 24);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [5] = (byte)(val >> 16);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [5] = (byte)(val >> 16);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [6] = (byte)(val >> 8);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [6] = (byte)(val >> 8);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: tmp0 [7] = (byte)val;
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Write,The following statement contains a magic number: s.Write (tmp0' 0' 8);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following statement contains a magic number: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint16,The following statement contains a magic number: s.Read (tmp0' 0' 2) != 2
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint16,The following statement contains a magic number: s.Read (tmp0' 0' 2) != 2
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint16,The following statement contains a magic number: return (long)((tmp0[0] << 8) | tmp0[1]);
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: s.Read (tmp0' 0' 4) != 4
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: s.Read (tmp0' 0' 4) != 4
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Magic Number,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,UnpackUint32,The following statement contains a magic number: return ((long)tmp0[0] << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];
Missing Default,MiniMessagePack,MiniMessagePacker,D:\research\architectureSmells\repos1\shogo82148_MiniMessagePack\MiniMessagePack\MiniMessagePacker.cs,Unpack,The following switch statement is missing a default case: switch (b) {  			case 0xc0:  				return null;  			case 0xc2:  				return false;  			case 0xc3:  				return true;  			case 0xcc: // uint8  				return (long)s.ReadByte ();  			case 0xcd: // uint16  				return UnpackUint16 (s);  			case 0xce: // uint32  				return UnpackUint32 (s);  			case 0xcf: // uint64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)tmp0 [0] << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xd0: // int8  				return (long)unchecked((sbyte)s.ReadByte ());  			case 0xd1: // int16  				if (s.Read (tmp0' 0' 2) != 2) {   					throw new FormatException ();  				}  				return (((long)unchecked((sbyte)tmp0[0])) << 8) | (long)tmp0[1];  			case 0xd2: // int32  				if (s.Read (tmp0' 0' 4) != 4) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 24) | ((long)tmp0[1] << 16) | ((long)tmp0[2] << 8) | (long)tmp0[3];  			case 0xd3: // int64  				if (s.Read (tmp0' 0' 8) != 8) {   					throw new FormatException ();  				}  				return ((long)unchecked((sbyte)tmp0[0]) << 56) | ((long)tmp0 [1] << 48) | ((long)tmp0 [2] << 40) | ((long)tmp0 [3] << 32)  					+ ((long)tmp0 [4] << 24) | ((long)tmp0 [5] << 16) | ((long)tmp0 [6] << 8) | (long)tmp0 [7];  			case 0xca: // float32  				s.Read (tmp0' 0' 4);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[3];  					tmp1[1] = tmp0[2];  					tmp1[2] = tmp0[1];  					tmp1[3] = tmp0[0];  					return (double)BitConverter.ToSingle (tmp1' 0);  				} else {  					return (double)BitConverter.ToSingle (tmp0' 0);  				}  			case 0xcb: // float64  				s.Read (tmp0' 0' 8);  				if (BitConverter.IsLittleEndian) {  					tmp1[0] = tmp0[7];  					tmp1[1] = tmp0[6];  					tmp1[2] = tmp0[5];  					tmp1[3] = tmp0[4];  					tmp1[4] = tmp0[3];  					tmp1[5] = tmp0[2];  					tmp1[6] = tmp0[1];  					tmp1[7] = tmp0[0];  					return BitConverter.ToDouble (tmp1' 0);  				} else {  					return BitConverter.ToDouble (tmp0' 0);  				}  			case 0xd9: // str8  				return UnpackString (s' s.ReadByte ());  			case 0xda: // str16  				return UnpackString (s' UnpackUint16 (s));  			case 0xdb: // str32  				return UnpackString (s' UnpackUint32 (s));    			case 0xc4: // bin8  				return UnpackBinary (s' s.ReadByte ());  			case 0xc5: // bin16  				return UnpackBinary (s' UnpackUint16 (s));  			case 0xc6: // bin32  				return UnpackBinary (s' UnpackUint32 (s));    			case 0xdc: // array16  				return UnpackArray (s' UnpackUint16 (s));  			case 0xdd: // array32  				return UnpackArray (s' UnpackUint32 (s));    			case 0xde: // map16  				return UnpackMap (s' UnpackUint16 (s));  			case 0xdf: // map32  				return UnpackMap (s' UnpackUint32 (s));  			}
