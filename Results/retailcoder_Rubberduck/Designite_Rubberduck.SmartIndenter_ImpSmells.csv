Implementation smell,Namespace,Class,File,Method,Description
Long Method,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The method has 114 lines of code.
Complex Method,Rubberduck.SmartIndenter,Indenter,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\Indenter.cs,GenerateCodeLineStrings,Cyclomatic complexity of the method is 8
Complex Method,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,Cyclomatic complexity of the method is 8
Long Identifier,Rubberduck.SmartIndenter,IndenterSettings,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\IndenterSettings.cs,,The length of the parameter MaximumEndOfLineCommentColumnSpaceAlignment is 43.
Long Statement,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,Indent,The length of the statement  "            var gap = Math.Max((absolute ? indents : _settings.IndentSpaces * indents) - number.Length - separator.Length' number.Length + separator.Length > 0 ? 1 : 0); " is 157.
Long Statement,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,Indent,The length of the statement  "                    return _escaper.UnescapeIndented(string.Format("{0}{1}{2}{3}"' code' new string(' '' Math.Max(position - code.Length' 1))' " is 122.
Long Statement,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,Indent,The length of the statement  "                    return _escaper.UnescapeIndented(string.Format("{0}{1}{2}{3}"' code' new string(' '' uncommented.Length - uncommented.TrimEnd().Length + 1)'  " is 140.
Long Statement,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,Indent,The length of the statement  "                    return _escaper.UnescapeIndented(string.Format("{0}{1}{2}{3}"' code' new string(' '' _settings.IndentSpaces * 2)' EndOfLineComment' " is 131.
Long Statement,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,Indent,The length of the statement  "                    return _escaper.UnescapeIndented(string.Format("{0}{1}{2}{3}"' code' new string(' '' Math.Max(align - 1' 1))' EndOfLineComment' " is 127.
Long Statement,Rubberduck.SmartIndenter,Indenter,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\Indenter.cs,Indent,The length of the statement  "                start = line.IsProcedureStart || (line.AtProcedureStart && line.IsDeclaration) || (line.AtProcedureStart && line.IsCommentBlock); " is 129.
Long Statement,Rubberduck.SmartIndenter,Indenter,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\Indenter.cs,GenerateCodeLineStrings,The length of the statement  "                            indent.Add(new LogicalCodeLine(Enumerable.Repeat(new AbsoluteCodeLine(string.Empty' settings)' settings.LinesBetweenProcedures)' settings)); " is 140.
Long Statement,Rubberduck.SmartIndenter,Indenter,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\Indenter.cs,GenerateCodeLineStrings,The length of the statement  "                        indent.Add(new LogicalCodeLine(Enumerable.Repeat(new AbsoluteCodeLine(string.Empty' settings)' Math.Max(settings.LinesBetweenProcedures' 1))' settings)); " is 153.
Long Statement,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,Indented,The length of the statement  "            var commentPos = string.IsNullOrEmpty(_lines.First().EndOfLineComment) ? 0 : current.Length - _lines.First().EndOfLineComment.Length; " is 133.
Complex Conditional,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,Indent,The conditional expression  "IsEmpty || (ContainsOnlyComment && !_settings.AlignCommentsWithCode && !absolute)"  is complex.
Complex Conditional,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,Indent,The conditional expression  "(IsPrecompilerDirective && _settings.ForceCompilerDirectivesInColumn1) ||                  (IsBareDebugStatement && _settings.ForceDebugStatementsInColumn1) ||                  (atProcStart && !_settings.IndentFirstCommentBlock && ContainsOnlyComment) ||                  (atProcStart && !_settings.IndentFirstDeclarationBlock && (IsDeclaration || IsDeclarationContinuation))"  is complex.
Empty Catch Block,Rubberduck.SmartIndenter,IndenterSettings,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\IndenterSettings.cs,IndenterSettings,The method has an empty catch block.
Empty Catch Block,Rubberduck.SmartIndenter,IndenterSettings,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\IndenterSettings.cs,LoadLegacyFromRegistry,The method has an empty catch block.
Empty Catch Block,Rubberduck.SmartIndenter,IndenterSettings,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\IndenterSettings.cs,GetSmartIndenterNumeric,The method has an empty catch block.
Magic Number,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,MultipleCaseAdjustment,The following statement contains a magic number: return (cases > 1 && _segments.Length % 2 != 0) ? cases - 1 : 0;
Magic Number,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,Indent,The following statement contains a magic number: switch (_settings.EndOfLineCommentStyle)              {                  case EndOfLineCommentStyle.Absolute:                      return _escaper.UnescapeIndented(string.Format("{0}{1}{2}{3}"' code' new string(' '' Math.Max(position - code.Length' 1))'                                                       EndOfLineComment' _stupidLineEnding ? StupidLineEnding : string.Empty));                  case EndOfLineCommentStyle.SameGap:                      var uncommented = Original.Substring(0' position - 1);                      return _escaper.UnescapeIndented(string.Format("{0}{1}{2}{3}"' code' new string(' '' uncommented.Length - uncommented.TrimEnd().Length + 1)'                                                        EndOfLineComment' _stupidLineEnding ? StupidLineEnding : string.Empty));                  case EndOfLineCommentStyle.StandardGap:                      return _escaper.UnescapeIndented(string.Format("{0}{1}{2}{3}"' code' new string(' '' _settings.IndentSpaces * 2)' EndOfLineComment'                                                       _stupidLineEnding ? StupidLineEnding : string.Empty));                  case EndOfLineCommentStyle.AlignInColumn:                      var align = _settings.EndOfLineCommentColumnSpaceAlignment - code.Length;                      return _escaper.UnescapeIndented(string.Format("{0}{1}{2}{3}"' code' new string(' '' Math.Max(align - 1' 1))' EndOfLineComment'                                                       _stupidLineEnding ? StupidLineEnding : string.Empty));                  default:                      throw new InvalidEnumArgumentException();              }
Magic Number,Rubberduck.SmartIndenter,AbsoluteCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\AbsoluteCodeLine.cs,AlignDims,The following statement contains a magic number: var gap = Math.Max(_settings.AlignDimColumn - postition - alignTokens[0].Length - 2' 0);
Magic Number,Rubberduck.SmartIndenter,IndenterSettings,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\IndenterSettings.cs,IndenterSettings,The following statement contains a magic number: var tabWidth = 4;
Magic Number,Rubberduck.SmartIndenter,IndenterSettings,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\IndenterSettings.cs,IndenterSettings,The following statement contains a magic number: AlignDimColumn = 15;
Magic Number,Rubberduck.SmartIndenter,IndenterSettings,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\IndenterSettings.cs,IndenterSettings,The following statement contains a magic number: EndOfLineCommentColumnSpaceAlignment = 50;
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,Indented,The following statement contains a magic number: for (var i = 1; i < _lines.Count; i++)              {                  var line = _lines[i];                  if (line.IsDeclarationContinuation && !line.IsProcedureStart)                  {                      output.Add(line.Indent(IndentationLevel' AtProcedureStart));                      continue;                  }                  if (line.ContainsOnlyComment)                  {                      commentPos = alignment;                  }                  if (commentPos > 0)                  {                      output.Add(line.Indent(commentPos' AtProcedureStart' true));                      continue;                  }                    var operatorAdjust = _settings.IgnoreOperatorsInContinuations && OperatorIgnoreRegex.IsMatch(line.Original) ? 2 : 0;                                current = line.Indent(Math.Max(alignment - operatorAdjust' 0)' AtProcedureStart' true);                  output.Add(current);                  alignment = FunctionAlign(current' i + 1 < _lines.Count && _lines[i + 1].Escaped.Trim().StartsWith(":="));                  commentPos = string.IsNullOrEmpty(line.EndOfLineComment) ? 0 : current.Length - line.EndOfLineComment.Length;              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: for (var index = StartIgnoreRegex.Match(line).Length + 1; index <= line.Length; index++)              {                  var character = line.Substring(index - 1' 1);                  switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }              }
Magic Number,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following statement contains a magic number: if (fallback == 0 || fallback >= line.Length - 1)              {                  fallback = !_alignment.Any() ? (_settings.IndentSpaces * 2) : 0;              }              else              {                  fallback = fallback + 1;              }
Missing Default,Rubberduck.SmartIndenter,IndenterSettings,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\IndenterSettings.cs,LoadLegacyFromRegistry,The following switch statement is missing a default case: switch (eolSytle)                      {                          case "Absolute":                              EndOfLineCommentStyle = EndOfLineCommentStyle.Absolute;                              break;                          case "SameGap":                              EndOfLineCommentStyle = EndOfLineCommentStyle.SameGap;                              break;                          case "StandardGap":                              EndOfLineCommentStyle = EndOfLineCommentStyle.StandardGap;                              break;                          case "AlignInCol":                              EndOfLineCommentStyle = EndOfLineCommentStyle.AlignInColumn;                              break;                      }
Missing Default,Rubberduck.SmartIndenter,LogicalCodeLine,C:\repos\retailcoder_Rubberduck\Rubberduck.SmartIndenter\LogicalCodeLine.cs,FunctionAlign,The following switch statement is missing a default case: switch (character)                  {                      case "\a":                      case "\x2":                          index++;                          break;                      case "(":                          //Start of another function => remember this position                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Function' index));                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ")":                          //Function finished => Remove back to the previous open bracket                          while (_alignment.Any())                          {                              var finished = _alignment.Count == stackPos + 1 || _alignment.Peek().Type == AlignmentTokenType.Function;                              _alignment.Pop();                              if (finished)                              {                                  break;                              }                          }                          break;                      case " ":                          if (index + 3 < line.Length && line.Substring(index - 1' 3).Equals(" = "))                          {                              //Space before an = sign => remember it to align to later                              if (!_alignment.Any(a => a.Type == AlignmentTokenType.Equals || a.Type == AlignmentTokenType.Variable))                              {                                  _alignment.Push(new AlignmentToken(AlignmentTokenType.Equals' index + 2));                              }                          }                          else if (!_alignment.Any() && index < line.Length - 2)                          {                              //Space after a name before the end of the line => remember it for later                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Variable' index));                          }                          else if (index > 5 && line.Substring(index - 6' 6).Equals(" Then "))                          {                              //Clear the collection if we find a Then in an If...Then and set the                              //indenting to align with the bit after the "If "                              while (_alignment.Count > 1)                              {                                  _alignment.Pop();                              }                          }                          break;                      case "'":                          //Start of a new parameter => remember it to align to                          _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 1));                          break;                      case ":":                          if (line.Substring(index - 1' 2).Equals(":="))                          {                              //A named paremeter => remember to align to after the name                              _alignment.Push(new AlignmentToken(AlignmentTokenType.Parameter' index + 3));                          }                          else if (line.Substring(index' 2).Equals(": "))                          {                              //A new line section' so clear the brackets                              _alignment.Clear();                              index++;                          }                          break;                  }
