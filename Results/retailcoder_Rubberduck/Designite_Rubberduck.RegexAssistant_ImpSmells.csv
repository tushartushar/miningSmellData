Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Rubberduck.RegexAssistant,Quantifier,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\Quantifier.cs,Quantifier,Cyclomatic complexity of the method is 9
Long Statement,Rubberduck.RegexAssistant,RegularExpression,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\IRegularExpression.cs,Parse,The length of the statement  "            // ByRef requires us to hack around here' because TryParseAsAtom doesn't fail when it doesn't consume the specifier anymore " is 123.
Long Statement,Rubberduck.RegexAssistant.Tests,LiteralTests,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\Tests\LiteralTests.cs,EverythingElseBlowsUp,The length of the statement  "            string[] allowedEscapes = { "("' ")"' "{"' "}"' "["' "]"' "."' "?"' "+"' "*"' "$"' "^"' "uFFFF"' "u0000"' "xFF"' "x00"' "777"' "000" }; " is 135.
Magic Number,Rubberduck.RegexAssistant,RegularExpression,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\IRegularExpression.cs,TryParseAsAtom,The following statement contains a magic number: if (m.Success)              {                  string atom = m.Groups["expression"].Value;                  string quantifier = m.Groups["quantifier"].Value;                  specifier = specifier.Substring(atom.Length + 2 + quantifier.Length);                  expression = new SingleAtomExpression(new Group("("+atom+")"' new Quantifier(quantifier)));                  return true;              }
Magic Number,Rubberduck.RegexAssistant,RegularExpression,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\IRegularExpression.cs,TryParseAsAtom,The following statement contains a magic number: if (m.Success)              {                  string atom = m.Groups["expression"].Value;                  string quantifier = m.Groups["quantifier"].Value;                  specifier = specifier.Substring(atom.Length + 2 + quantifier.Length);                  expression = new SingleAtomExpression(new CharacterClass("["+atom+"]"' new Quantifier(quantifier)));                  return true;              }
Magic Number,Rubberduck.RegexAssistant.Tests,QuantifierTests,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\Tests\QuantifierTests.cs,ExactQuantifier,The following statement contains a magic number: Assert.AreEqual(5' cut.MaximumMatches);
Magic Number,Rubberduck.RegexAssistant.Tests,QuantifierTests,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\Tests\QuantifierTests.cs,ExactQuantifier,The following statement contains a magic number: Assert.AreEqual(5' cut.MinimumMatches);
Magic Number,Rubberduck.RegexAssistant.Tests,QuantifierTests,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\Tests\QuantifierTests.cs,FullRangeQuantifier,The following statement contains a magic number: Assert.AreEqual(2' cut.MinimumMatches);
Magic Number,Rubberduck.RegexAssistant.Tests,QuantifierTests,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\Tests\QuantifierTests.cs,FullRangeQuantifier,The following statement contains a magic number: Assert.AreEqual(5' cut.MaximumMatches);
Magic Number,Rubberduck.RegexAssistant.Tests,QuantifierTests,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\Tests\QuantifierTests.cs,OpenRangeQuantifier,The following statement contains a magic number: Assert.AreEqual(3' cut.MinimumMatches);
Missing Default,Rubberduck.RegexAssistant,QuantifierExtensions,C:\repos\retailcoder_Rubberduck\Rubberduck.RegexAssistant\QuantifierExtensions.cs,HumanReadable,The following switch statement is missing a default case: switch (quant.Kind)              {                  case QuantifierKind.None:                      return AssistantResources.Quantifier_None;                  case QuantifierKind.Wildcard:                      if (quant.MaximumMatches == 1)                      {                          return AssistantResources.Quantifier_Optional;                      }                      if (quant.MinimumMatches == 0)                      {                          return AssistantResources.Quantifier_Asterisk;                      }                      return AssistantResources.Quantifer_Plus;                  case QuantifierKind.Expression:                      if (quant.MaximumMatches == quant.MinimumMatches)                      {                          return string.Format(AssistantResources.Quantifier_Exact' quant.MinimumMatches);                      }                      if (quant.MaximumMatches == int.MaxValue)                      {                          return string.Format(AssistantResources.Quantifier_OpenRange' quant.MinimumMatches);                      }                      return string.Format(AssistantResources.Quantifier_ClosedRange' quant.MinimumMatches' quant.MaximumMatches);              }
