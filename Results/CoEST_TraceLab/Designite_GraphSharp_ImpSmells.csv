Implementation smell,Namespace,Class,File,Method,Description
Long Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossCountingAndOptimization,The method has 109 lines of code.
Long Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,BiLayerCrossCount,The method has 118 lines of code.
Long Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The method has 147 lines of code.
Complex Method,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,RemoveTreeNodesFromRootGraph,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,InternalCompute,Cyclomatic complexity of the method is 10
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,BiLayerCrossCount,Cyclomatic complexity of the method is 18
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CreateLayerWHOptInfos,Cyclomatic complexity of the method is 8
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CreateInitialLayering,Cyclomatic complexity of the method is 8
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoAlignment,Cyclomatic complexity of the method is 12
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,PrepareForSugiyama,Cyclomatic complexity of the method is 10
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaLayout,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,Cyclomatic complexity of the method is 16
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,Cyclomatic complexity of the method is 10
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,VertexLayer,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.VertexLayer.cs,FindBestPermutation,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,Cyclomatic complexity of the method is 14
Complex Method,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,Cyclomatic complexity of the method is 12
Complex Method,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,Horizontal,Cyclomatic complexity of the method is 8
Complex Method,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,HorizontalImproved,Cyclomatic complexity of the method is 13
Complex Method,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,Vertical,Cyclomatic complexity of the method is 8
Complex Method,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,VerticalImproved,Cyclomatic complexity of the method is 13
Complex Method,GraphSharp.Algorithms.OverlapRemoval,OneWayFSAAlgorithm<TObject>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OneWayFSAAlgorithm.cs,HorizontalImproved,Cyclomatic complexity of the method is 14
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Tree,BalloonTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\BalloonTreeLayoutAlgorithm.cs,BalloonTreeLayoutAlgorithm,The method has 5 parameters. Parameters: visitedGraph' vertexPositions' vertexSizes' oldParameters' selectedVertex
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Tree,BalloonTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\BalloonTreeLayoutAlgorithm.cs,SecondWalk,The method has 6 parameters. Parameters: v' r' x' y' l' t
Long Parameter List,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetSpringForce,The method has 5 parameters. Parameters: idealLength' uPos' vPos' uSize' vSize
Long Parameter List,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The method has 5 parameters. Parameters: uPos' vPos' uSize' vSize' repulsionRange
Long Parameter List,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,CompoundFDPLayoutAlgorithm,The method has 6 parameters. Parameters: visitedGraph' vertexSizes' vertexBorders' layoutTypes' vertexPositions' oldParameters
Long Parameter List,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundVertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,CompoundVertexData,The method has 7 parameters. Parameters: vertex' movableParent' isFixedToParent' position' size' borders' innerVertexLayoutType
Long Parameter List,GraphSharp.Algorithms.Layout.Compound.FDP,SimpleVertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,SimpleVertexData,The method has 5 parameters. Parameters: vertex' movableParent' isFixed' position' size
Long Parameter List,GraphSharp.Algorithms.Layout.Compound,CompoundLayoutContext<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\CompoundLayoutContext.cs,CompoundLayoutContext,The method has 6 parameters. Parameters: graph' positions' sizes' mode' vertexBorders' layoutTypes
Long Parameter List,GraphSharp.Algorithms.Layout.Compound,CompoundLayoutIterationEventArgs<TVertex;TEdge>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\CompoundLayoutIterationEventArgs.cs,CompoundLayoutIterationEventArgs,The method has 5 parameters. Parameters: iteration' statusInPercent' message' vertexPositions' innerCanvasSizes
Long Parameter List,GraphSharp.Algorithms.Layout.Compound,TestingCompoundLayoutIterationEventArgs<TVertex;TEdge;TVertexInfo;TEdgeInfo>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\TestingCompoundLayoutIterationEventArgs.cs,TestingCompoundLayoutIterationEventArgs,The method has 7 parameters. Parameters: iteration' statusInPercent' message' vertexPositions' innerCanvasSizes' vertexInfos' gravitationCenter
Long Parameter List,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,DoubleTreeLayoutAlgorithm,The method has 5 parameters. Parameters: visitedGraph' vertexPositions' vertexSizes' oldParameters' selectedVertex
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,Sweeping,The method has 6 parameters. Parameters: startLayerIndex' endLayerIndex' step' enableSameMeasureOptimization' changed' phase
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CrossingMinimizationBetweenLayers,The method has 6 parameters. Parameters: alternatingLayer' actualLayerIndex' nextLayerIndex' enableSameMeasureOptimization' prevCrossCount' phase
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossCountingAndOptimization,The method has 6 parameters. Parameters: alternatingLayer' nextAlternatingLayer' straightSweep' enableSameMeasureOptimization' reverseVerticesWithSameMeasure' prevCrossCount
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaLayoutAlgorithm,The method has 5 parameters. Parameters: visitedGraph' vertexSizes' vertexPositions' parameters' edgePredicate
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1Sweep,The method has 6 parameters. Parameters: start' end' step' baryCenter' dirty' byRealPosition
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase2Sweep,The method has 5 parameters. Parameters: start' end' step' baryCenter' byRealPosition
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,VertexLayer,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.VertexLayer.cs,Measure,The method has 6 parameters. Parameters: vertex' computeUpBaryCenter' computeDownBaryCenter' computeSubBaryCenter' divCount' byRealPosition
Long Parameter List,GraphSharp.Algorithms.Layout,LayoutIterationEventArgs<TVertex;TEdge;TVertexInfo;TEdgeInfo>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutIterationEventArgs.cs,LayoutIterationEventArgs,The method has 6 parameters. Parameters: iteration' statusInPercent' message' vertexPositions' vertexInfos' edgeInfos
Long Parameter List,GraphSharp.Algorithms.Layout,LayoutState<TVertex;TEdge>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutState.cs,LayoutState,The method has 6 parameters. Parameters: positions' overlapRemovedPositions' routeInfos' computationTime' iteration' message
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.FDP,QuadTree,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.QuadTree.cs,QuadTree,The method has 5 parameters. Parameters: index' position' weight' minPos' maxPos
Long Identifier,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,,The length of the parameter _phaseDependentRepulsionMultiplier is 34.
Long Identifier,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutParameters,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutParameters.cs,,The length of the parameter _phase2TemperatureInitialMultiplier is 35.
Long Identifier,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutParameters,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutParameters.cs,,The length of the parameter _phase3TemperatureInitialMultiplier is 35.
Long Identifier,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AddAlternatingLayerToSparseCompactionGraph,The length of the parameter _sparseCompationGraphEdgesOfLayer is 33.
Long Identifier,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossCountingAndOptimization,The length of the parameter reverseVerticesWithSameMeasure is 30.
Long Identifier,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,,The length of the parameter _sparseCompactionByLayerBackup is 30.
Long Identifier,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,,The length of the parameter GeneralEdgesBetweenDifferentLayersTag is 37.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,GenerateSpanningTree,The length of the statement  "                    var bfsAlgo = new BreadthFirstSearchAlgorithm<TVertex' TEdge>( VisitedGraph' vb' new Dictionary<TVertex' GraphColor>() ); " is 121.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The length of the statement  "            bool changeCoordinates = ( Parameters.Direction == LayoutDirection.LeftToRight || Parameters.Direction == LayoutDirection.RightToLeft ); " is 136.
Long Statement,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InitCompoundVertices,The length of the statement  "                    var dataContainer = new CompoundVertexData(vertex' _rootCompoundVertex' false' position' vertexSize' border' layoutType); " is 121.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,ContextualLayoutAlgorithmFactory<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\ContextualLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "					return new DoubleTreeLayoutAlgorithm<TVertex' TEdge' TGraph>( layoutContext.Graph' layoutContext.Positions' layoutContext.Sizes' parameters as DoubleTreeLayoutParameters' layoutContext.SelectedVertex ); " is 202.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,ContextualLayoutAlgorithmFactory<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\ContextualLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "					return new BalloonTreeLayoutAlgorithm<TVertex' TEdge' TGraph>( layoutContext.Graph' layoutContext.Positions' layoutContext.Sizes' parameters as BalloonTreeLayoutParameters' layoutContext.SelectedVertex ); " is 204.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,ContextualLayoutAlgorithmFactory<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\ContextualLayoutAlgorithmFactory.cs,CreateParameters,The length of the statement  "					return !( oldParameters is DoubleTreeLayoutParameters ) ? new DoubleTreeLayoutParameters() : (DoubleTreeLayoutParameters)( oldParameters as DoubleTreeLayoutParameters ).Clone(); " is 177.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,ContextualLayoutAlgorithmFactory<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\ContextualLayoutAlgorithmFactory.cs,CreateParameters,The length of the statement  "					return !( oldParameters is BalloonTreeLayoutParameters ) ? new BalloonTreeLayoutParameters() : (BalloonTreeLayoutParameters)( oldParameters as BalloonTreeLayoutParameters ).Clone(); " is 181.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,Sweeping,The length of the statement  "                    prevCrossCount = DoCrossCountingAndOptimization(alternatingLayer' _alternatingLayers[i + step]' (i < i + step)' false' (phase == 2)' int.MaxValue); " is 147.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,Sweeping,The length of the statement  "                int crossCount = CrossingMinimizationBetweenLayers(ref alternatingLayer' i' i + step' enableSameMeasureOptimization' prevCrossCount' phase); " is 140.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CrossingMinimizationBetweenLayers,The length of the statement  "            int crossCount = DoCrossCountingAndOptimization(alternatingLayer' nextAlternatingLayer' straightSweep' enableSameMeasureOptimization' (phase == 2)' prevCrossCount); " is 164.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossCountingAndOptimization,The length of the statement  "            firstLayerSize = lastOnTopLayer.Position + (lastOnTopLayer is ISegmentContainer ? ((ISegmentContainer)lastOnTopLayer).Count : 1); " is 129.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossCountingAndOptimization,The length of the statement  "            secondLayerSize = lastOnBottomLayer.Position + (lastOnBottomLayer is ISegmentContainer ? ((ISegmentContainer)lastOnBottomLayer).Count : 1); " is 139.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossCountingAndOptimization,The length of the statement  "                var verticesWithSameMeasure = FindVerticesWithSameMeasure(nextAlternatingLayer' straightSweep' out ranges' out maxRangeLength); " is 127.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,InitialOrderingOfNextLayer,The length of the statement  "            var vertexStack = new Stack<SugiVertex>(nextLayer.Where(v => v.Type != ignorableVertexType).OrderBy(v => v.MeasuredPosition).Reverse()); " is 136.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CreateLayerWHOptInfos,The length of the statement  "                    if (!double.IsNaN(v.ValuePerCost) && !double.IsPositiveInfinity(v.ValuePerCost) && !double.IsNegativeInfinity(v.ValuePerCost)) " is 126.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CreateDummyVerticesAndSegments,The length of the statement  "                bool notReversed = edge.Source.OriginalVertex == edge.OriginalEdge.Source && edge.Target.OriginalVertex == edge.OriginalEdge.Target; " is 132.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculateVerticalPositions,The length of the statement  "                vertex.VerticalPosition = _layerPositions[vertex.LayerIndex] + (vertex.Size.Height <= 0 ? _layerHeights[vertex.LayerIndex] : vertex.Size.Height) / 2.0; " is 151.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,PlaceBlock,The length of the statement  "                        var xDelta = delta + ((wVertex != null ? wVertex.Size.Width : 0.0) + ((pred is SugiVertex) ? ((SugiVertex)pred).Size.Width : u.BlockWidths[modeIndex])) / 2.0; " is 158.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,PrepareForSugiyama,The length of the statement  "            _graph.UnhideEdgesIf( e => e.Type == EdgeTypes.General && _graph.ContainsVertex( e.Source ) && _graph.ContainsVertex( e.Target ) ); " is 131.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,PrepareForSugiyama,The length of the statement  "            _graph.HideEdgesIf( e => ( e.Type == EdgeTypes.General && e.Source.LayerIndex != e.Target.LayerIndex )' GeneralEdgesBetweenDifferentLayersTag ); " is 144.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1,The length of the statement  "                sweepDownOptimized = SugiyamaPhase1Sweep( startLayerIndex == -1 ? 1 : startLayerIndex' _layers.Count' 1' BaryCenter.Up' dirty' ByRealPosition ); " is 144.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1,The length of the statement  "            bool sweepUpOptimized = SugiyamaPhase1Sweep( startLayerIndex == -1 ? _layers.Count - 2 : startLayerIndex' -1' -1' BaryCenter.Down' dirty' ByRealPosition ); " is 155.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaLayout,The length of the statement  "            bool baryCenteringByRealPositions = Parameters.PositionCalculationMethod == PositionCalculationMethodTypes.PositionBased; " is 121.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CalculateOverlap,The length of the statement  "            return Math.Max( 0' ( ( b.Size.Width + a.Size.Width ) * 0.5 + plusGap + Parameters.HorizontalGap ) - ( b.RealPosition.X - a.RealPosition.X ) ); " is 143.
Long Statement,GraphSharp.Algorithms.Layout,ParameterizedLayoutAlgorithmBase<TVertex;TEdge;TGraph;TVertexInfo;TEdgeInfo;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\ParameterizedLayoutAlgorithmBase.cs,CreateLayoutIterationEventArgs,The length of the statement  "			return new LayoutIterationEventArgs<TVertex' TEdge' TVertexInfo' TEdgeInfo>( iteration' statusInPercent' message' vertexPositions' vertexInfos' edgeInfos ); " is 156.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,Report,The length of the statement  "            OnIterationEnded( currentIteration' (double)currentIteration / (double)Parameters.MaxIterations' "Iteration " + currentIteration + " finished."' true ); " is 152.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddGravitationDirection,The length of the statement  "			double tmp = Parameters.gravitationMultiplier * repulsionMultiplier * Math.Max( v.RepulsionWeight' 1 ) * Math.Pow( dist' Parameters.attractionExponent - 2 ); " is 157.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The length of the statement  "				return attractionSum / Math.Pow( repulsionSum' 2 ) * Math.Pow( repulsionSum' 0.5 * ( Parameters.attractionExponent - Parameters.repulsiveExponent ) ); " is 150.
Long Statement,GraphSharp.Contracts,ICompoundGraphContract<TVertex;TEdge>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Contracts\ICompoundGraphContract.cs,GetParent,The length of the statement  "            //Contract.Ensures( Contract.Result<TVertex>().Equals( default( TVertex ) ) || ithis.ContainsVertex( Contract.Result<TVertex>() ) ); " is 132.
Complex Conditional,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossingMinimizations,The conditional expression  "phase == 1 && (!changed || crossings >= prevCrossings) && phase2iterationLeft > 0"  is complex.
Complex Conditional,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AssignMeasuresOnNextLayer,The conditional expression  "(straightSweep && vertex.Type == VertexTypes.QVertex)                      || (!straightSweep && vertex.Type == VertexTypes.PVertex)"  is complex.
Complex Conditional,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,PlaceBlock,The conditional expression  "_sparseCompactionGraph.ContainsVertex(w) &&                      ((leftRightMode == LeftRightMode.Left && _sparseCompactionGraph.InDegree(w) > 0)                        || (leftRightMode == LeftRightMode.Right && _sparseCompactionGraph.OutDegree(w) > 0))"  is complex.
Complex Conditional,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoAlignment,The conditional expression  "vertex.Type == VertexTypes.Original                          || vertex.Type == VertexTypes.RVertex                          || (vertex.Type == VertexTypes.PVertex && upperLowerEdges == UpperLowerEdges.Upper)                          || (vertex.Type == VertexTypes.QVertex && upperLowerEdges == UpperLowerEdges.Lower)"  is complex.
Complex Conditional,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoAlignment,The conditional expression  "!edge.Marked &&                                  ((leftRightMode == LeftRightMode.Left && r < neighbour.Position)                                      || (leftRightMode == LeftRightMode.Right && r > neighbour.Position))"  is complex.
Complex Conditional,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,force,The conditional expression  "Gij >= gij && gij > 0 || -Gij <= gij && gij < 0 || gij == 0"  is complex.
Complex Conditional,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,force,The conditional expression  "Gij < gij && gij > 0 || -Gij > gij && gij < 0"  is complex.
Virtual Method Call from Constructor,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutParametersBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutParametersBase.cs,FRLayoutParametersBase,The constructor "FRLayoutParametersBase" calls a virtual method "UpdateParameters".
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,BalloonTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\BalloonTreeLayoutAlgorithm.cs,SetRadius,The following statement contains a magic number: data.r = (int)Math.Max( data.d / 2' Parameters.minRadius );
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,The following statement contains a magic number: layer.NextPosition += size.Width / 2.0;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,The following statement contains a magic number: if ( spanningTree.OutDegree( v ) == 0 )              {                  d.position = layer.NextPosition;              }              else              {                  double minPos = double.MaxValue;                  double maxPos = -double.MaxValue;                  //first put the children                  foreach ( var child in spanningTree.OutEdges( v ).Select( e => e.Target ) )                  {                      double childPos = CalculatePosition( child' v' l + 1 );                      if ( childPos >= 0 )                      {                          minPos = Math.Min( minPos' childPos );                          maxPos = Math.Max( maxPos' childPos );                      }                  }                  if ( minPos != double.MaxValue )                      d.position = ( minPos + maxPos ) / 2.0;                  else                      d.position = layer.NextPosition;                  d.translate = Math.Max( layer.NextPosition - d.position' 0 );                    layer.LastTranslate = d.translate;                  d.position += d.translate;                  layer.NextPosition = d.position;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,The following statement contains a magic number: layer.NextPosition += size.Width / 2.0 + Parameters.VertexGap;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: foreach ( var layer in layers )              {                  foreach ( var v in layer.Vertices )                  {                      Size size = sizes[v];                      var d = data[v];                      if ( d.parent != null )                      {                          d.position += data[d.parent].translate;                          d.translate += data[d.parent].translate;                      }                        VertexPositions[v] =                          changeCoordinates                              ? new Point( direction * ( layerSize + size.Height / 2.0 )' d.position )                              : new Point( d.position' direction * ( layerSize + size.Height / 2.0 ) );                  }                  layerSize += layer.Size;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: foreach ( var layer in layers )              {                  foreach ( var v in layer.Vertices )                  {                      Size size = sizes[v];                      var d = data[v];                      if ( d.parent != null )                      {                          d.position += data[d.parent].translate;                          d.translate += data[d.parent].translate;                      }                        VertexPositions[v] =                          changeCoordinates                              ? new Point( direction * ( layerSize + size.Height / 2.0 )' d.position )                              : new Point( d.position' direction * ( layerSize + size.Height / 2.0 ) );                  }                  layerSize += layer.Size;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach ( var v in VisitedGraph.Vertices )              {                  Size s = sizes[v];                  halfSize[i] = Math.Sqrt( s.Width * s.Width + s.Height * s.Height ) * 0.5;                  perimeter += halfSize[i] * 2;                  i++;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach ( var v in VisitedGraph.Vertices )              {                  Size s = sizes[v];                  halfSize[i] = Math.Sqrt( s.Width * s.Width + s.Height * s.Height ) * 0.5;                  perimeter += halfSize[i] * 2;                  i++;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: double radius = perimeter / ( 2 * Math.PI );
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach ( var v in VisitedGraph.Vertices )              {                  a = Math.Sin( halfSize[i] * 0.5 / radius ) * 2;                  angle += a;                  if ( ReportOnIterationEndNeeded )                      VertexPositions[v] = new Point( Math.Cos( angle ) * radius + radius' Math.Sin( angle ) * radius + radius );                  angle += a;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach ( var v in VisitedGraph.Vertices )              {                  a = Math.Sin( halfSize[i] * 0.5 / radius ) * 2;                  angle += a;                  if ( ReportOnIterationEndNeeded )                      VertexPositions[v] = new Point( Math.Cos( angle ) * radius + radius' Math.Sin( angle ) * radius + radius );                  angle += a;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if ( ReportOnIterationEndNeeded )                  OnIterationEnded( 0' 50' "Precalculation done."' false );
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: radius = angle / ( 2 * Math.PI ) * radius;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach ( var v in VisitedGraph.Vertices )              {                  a = Math.Sin( halfSize[i] * 0.5 / radius ) * 2;                  angle += a;                  VertexPositions[v] = new Point( Math.Cos( angle ) * radius + radius' Math.Sin( angle ) * radius + radius );                  angle += a;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach ( var v in VisitedGraph.Vertices )              {                  a = Math.Sin( halfSize[i] * 0.5 / radius ) * 2;                  angle += a;                  VertexPositions[v] = new Point( Math.Cos( angle ) * radius + radius' Math.Sin( angle ) * radius + radius );                  angle += a;              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: _maxIterationCounts = new int[3];
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: _maxIterationCounts[2] = Parameters.Phase3Iterations;
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: var _temperatureMultipliers = new double[3]                                                {                                                    1.0'                                                     Parameters.Phase2TemperatureInitialMultiplier'                                                    Parameters.Phase3TemperatureInitialMultiplier                                                };
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: double minimalTemperature = initialTemperature * 0.1;
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++)              {                  _temperature = initialTemperature * _temperatureMultipliers[_phase - 1];                  _phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;                  //TODO put back the error and its threshold                  /*double error = _errorThresholds[_phase] + 1;*/                  for (_step = _maxIterationCounts[_phase - 1];                       (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown);                       _step--)                  {                      /*error = 0;*/                        ApplySpringForces();                      ApplyRepulsionForces();                        if (_phase > 1)                      {                          ApplyGravitationForces();                          ApplyApplicationSpecificForces();                      }                        if (ReportOnIterationEndNeeded)                          SavePositions();                        CalcNodePositionsAndSizes();                        if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)                          GrowTreesOneLevel();                        _temperature *= _temperatureLambda;                      _temperature = Math.Max(_temperature' minimalTemperature);                  }                  if (!_gravityCenterCalculated)                  {                      _rootCompoundVertex.RecalculateBounds();                      _gravityCenterCalculated = true;                  }                  //if (_phase == 1)                  _temperature *= Parameters.TemperatureDecreasing;              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++)              {                  _temperature = initialTemperature * _temperatureMultipliers[_phase - 1];                  _phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;                  //TODO put back the error and its threshold                  /*double error = _errorThresholds[_phase] + 1;*/                  for (_step = _maxIterationCounts[_phase - 1];                       (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown);                       _step--)                  {                      /*error = 0;*/                        ApplySpringForces();                      ApplyRepulsionForces();                        if (_phase > 1)                      {                          ApplyGravitationForces();                          ApplyApplicationSpecificForces();                      }                        if (ReportOnIterationEndNeeded)                          SavePositions();                        CalcNodePositionsAndSizes();                        if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)                          GrowTreesOneLevel();                        _temperature *= _temperatureLambda;                      _temperature = Math.Max(_temperature' minimalTemperature);                  }                  if (!_gravityCenterCalculated)                  {                      _rootCompoundVertex.RecalculateBounds();                      _gravityCenterCalculated = true;                  }                  //if (_phase == 1)                  _temperature *= Parameters.TemperatureDecreasing;              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++)              {                  _temperature = initialTemperature * _temperatureMultipliers[_phase - 1];                  _phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;                  //TODO put back the error and its threshold                  /*double error = _errorThresholds[_phase] + 1;*/                  for (_step = _maxIterationCounts[_phase - 1];                       (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown);                       _step--)                  {                      /*error = 0;*/                        ApplySpringForces();                      ApplyRepulsionForces();                        if (_phase > 1)                      {                          ApplyGravitationForces();                          ApplyApplicationSpecificForces();                      }                        if (ReportOnIterationEndNeeded)                          SavePositions();                        CalcNodePositionsAndSizes();                        if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)                          GrowTreesOneLevel();                        _temperature *= _temperatureLambda;                      _temperature = Math.Max(_temperature' minimalTemperature);                  }                  if (!_gravityCenterCalculated)                  {                      _rootCompoundVertex.RecalculateBounds();                      _gravityCenterCalculated = true;                  }                  //if (_phase == 1)                  _temperature *= Parameters.TemperatureDecreasing;              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++)              {                  _temperature = initialTemperature * _temperatureMultipliers[_phase - 1];                  _phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;                  //TODO put back the error and its threshold                  /*double error = _errorThresholds[_phase] + 1;*/                  for (_step = _maxIterationCounts[_phase - 1];                       (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown);                       _step--)                  {                      /*error = 0;*/                        ApplySpringForces();                      ApplyRepulsionForces();                        if (_phase > 1)                      {                          ApplyGravitationForces();                          ApplyApplicationSpecificForces();                      }                        if (ReportOnIterationEndNeeded)                          SavePositions();                        CalcNodePositionsAndSizes();                        if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)                          GrowTreesOneLevel();                        _temperature *= _temperatureLambda;                      _temperature = Math.Max(_temperature' minimalTemperature);                  }                  if (!_gravityCenterCalculated)                  {                      _rootCompoundVertex.RecalculateBounds();                      _gravityCenterCalculated = true;                  }                  //if (_phase == 1)                  _temperature *= Parameters.TemperatureDecreasing;              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++)              {                  _temperature = initialTemperature * _temperatureMultipliers[_phase - 1];                  _phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;                  //TODO put back the error and its threshold                  /*double error = _errorThresholds[_phase] + 1;*/                  for (_step = _maxIterationCounts[_phase - 1];                       (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown);                       _step--)                  {                      /*error = 0;*/                        ApplySpringForces();                      ApplyRepulsionForces();                        if (_phase > 1)                      {                          ApplyGravitationForces();                          ApplyApplicationSpecificForces();                      }                        if (ReportOnIterationEndNeeded)                          SavePositions();                        CalcNodePositionsAndSizes();                        if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)                          GrowTreesOneLevel();                        _temperature *= _temperatureLambda;                      _temperature = Math.Max(_temperature' minimalTemperature);                  }                  if (!_gravityCenterCalculated)                  {                      _rootCompoundVertex.RecalculateBounds();                      _gravityCenterCalculated = true;                  }                  //if (_phase == 1)                  _temperature *= Parameters.TemperatureDecreasing;              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetSpringForce,The following statement contains a magic number: if (positionVector.Length == 0)              {                  var compensationVector = new Vector(rnd.NextDouble()' rnd.NextDouble());                  positionVector = compensationVector * 2;                  uPos += compensationVector;                  vPos -= compensationVector;              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetSpringForce,The following statement contains a magic number: var Fs = Math.Pow(length / (idealLength)' 2) / Parameters.ElasticConstant * F;
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The following statement contains a magic number: if (positionVector.Length == 0)              {                  var compensationVector = new Vector(rnd.NextDouble()' rnd.NextDouble());                  positionVector = compensationVector * 2;                  uPos += compensationVector;                  vPos -= compensationVector;              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The following statement contains a magic number: length = Math.Pow(isSameDirection ? length / (Parameters.IdealEdgeLength * 2.0) : 1 / length' 2);
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The following statement contains a magic number: length = Math.Pow(isSameDirection ? length / (Parameters.IdealEdgeLength * 2.0) : 1 / length' 2);
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplySpringForces,The following statement contains a magic number: foreach (var edge in VisitedGraph.Edges)              {                  if (!_allTreesGrown && (_removedRootTreeNodes.Contains(edge.Source) || _removedRootTreeNodes.Contains(edge.Target)))                      continue;                  //get the ideal edge length                  double idealLength = Parameters.IdealEdgeLength;                  var u = _vertexDatas[edge.Source];                  var v = _vertexDatas[edge.Target];                  var multiplier = (u.Level + v.Level) / 2.0 + 1;                  if (IsInterGraphEdge(edge))                  {                      //idealLength *= (u.Level + v.Level + 1) * Parameters.NestingFactor;                      idealLength *= 1 + (u.Level + v.Level + 1) * Parameters.NestingFactor;                      //multiplier = 1;                  }                    var Fs = GetSpringForce(idealLength' u.Position' v.Position' u.Size' v.Size) * multiplier;                    //aggregate the forces                  if ((u.IsFixedToParent && u.MovableParent == null) ^ (v.IsFixedToParent && v.MovableParent == null))                      Fs *= 2;                  if (!u.IsFixedToParent)                      u.SpringForce += Fs /* * u.Mass / (u.Mass + v.Mass)*/;                  else if (u.MovableParent != null)                  {                      u.MovableParent.SpringForce += Fs;                  }                  if (!v.IsFixedToParent)                      v.SpringForce -= Fs /* * v.Mass / (u.Mass + v.Mass)*/;                  else if (v.MovableParent != null)                  {                      v.MovableParent.SpringForce -= Fs;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplySpringForces,The following statement contains a magic number: foreach (var edge in VisitedGraph.Edges)              {                  if (!_allTreesGrown && (_removedRootTreeNodes.Contains(edge.Source) || _removedRootTreeNodes.Contains(edge.Target)))                      continue;                  //get the ideal edge length                  double idealLength = Parameters.IdealEdgeLength;                  var u = _vertexDatas[edge.Source];                  var v = _vertexDatas[edge.Target];                  var multiplier = (u.Level + v.Level) / 2.0 + 1;                  if (IsInterGraphEdge(edge))                  {                      //idealLength *= (u.Level + v.Level + 1) * Parameters.NestingFactor;                      idealLength *= 1 + (u.Level + v.Level + 1) * Parameters.NestingFactor;                      //multiplier = 1;                  }                    var Fs = GetSpringForce(idealLength' u.Position' v.Position' u.Size' v.Size) * multiplier;                    //aggregate the forces                  if ((u.IsFixedToParent && u.MovableParent == null) ^ (v.IsFixedToParent && v.MovableParent == null))                      Fs *= 2;                  if (!u.IsFixedToParent)                      u.SpringForce += Fs /* * u.Mass / (u.Mass + v.Mass)*/;                  else if (u.MovableParent != null)                  {                      u.MovableParent.SpringForce += Fs;                  }                  if (!v.IsFixedToParent)                      v.SpringForce -= Fs /* * v.Mass / (u.Mass + v.Mass)*/;                  else if (v.MovableParent != null)                  {                      v.MovableParent.SpringForce -= Fs;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--)              {                  var checkedVertices = new HashSet<TVertex>();                  foreach (var uVertex in _levels[i])                  {                      checkedVertices.Add(uVertex);                      var u = _vertexDatas[uVertex];                      foreach (var vVertex in _levels[i])                      {                          if (checkedVertices.Contains(vVertex))                              continue;                          var v = _vertexDatas[vVertex];                            if (u.Parent != v.Parent)                              continue; //the two vertex not in the same graph                            var Fr = GetRepulsionForce(u.Position' v.Position' u.Size' v.Size' repulsionRange) * Math.Pow(u.Level + 1'2);                            if (u.IsFixedToParent ^ v.IsFixedToParent)                              Fr *= 2;                          if (!u.IsFixedToParent)                              u.RepulsionForce += Fr /** u.Mass / (u.Mass + v.Mass)*/;                          if (!v.IsFixedToParent)                              v.RepulsionForce -= Fr /** v.Mass / (u.Mass + v.Mass)*/;                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--)              {                  var checkedVertices = new HashSet<TVertex>();                  foreach (var uVertex in _levels[i])                  {                      checkedVertices.Add(uVertex);                      var u = _vertexDatas[uVertex];                      foreach (var vVertex in _levels[i])                      {                          if (checkedVertices.Contains(vVertex))                              continue;                          var v = _vertexDatas[vVertex];                            if (u.Parent != v.Parent)                              continue; //the two vertex not in the same graph                            var Fr = GetRepulsionForce(u.Position' v.Position' u.Size' v.Size' repulsionRange) * Math.Pow(u.Level + 1'2);                            if (u.IsFixedToParent ^ v.IsFixedToParent)                              Fr *= 2;                          if (!u.IsFixedToParent)                              u.RepulsionForce += Fr /** u.Mass / (u.Mass + v.Mass)*/;                          if (!v.IsFixedToParent)                              v.RepulsionForce -= Fr /** v.Mass / (u.Mass + v.Mass)*/;                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--)              {                  foreach (var uVertex in _levels[i])                  {                      var u = _vertexDatas[uVertex];                      var center = u.Parent.InnerCanvasCenter;                        var Fg = center - u.Position;                      if (Fg.Length == 0)                          continue;                        double length = Math.Max(1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));                      Fg.Normalize();                      Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow(u.Level + 1'2) / Math.Pow(length' 0.25);                      u.GravitationForce += Fg;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--)              {                  foreach (var uVertex in _levels[i])                  {                      var u = _vertexDatas[uVertex];                      var center = u.Parent.InnerCanvasCenter;                        var Fg = center - u.Position;                      if (Fg.Length == 0)                          continue;                        double length = Math.Max(1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));                      Fg.Normalize();                      Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow(u.Level + 1'2) / Math.Pow(length' 0.25);                      u.GravitationForce += Fg;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--)              {                  foreach (var uVertex in _levels[i])                  {                      var u = _vertexDatas[uVertex];                      var center = u.Parent.InnerCanvasCenter;                        var Fg = center - u.Position;                      if (Fg.Length == 0)                          continue;                        double length = Math.Max(1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));                      Fg.Normalize();                      Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow(u.Level + 1'2) / Math.Pow(length' 0.25);                      u.GravitationForce += Fg;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,CalcNodePositionsAndSizes,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--)              {                  foreach (var uVertex in _levels[i])                  {                      var u = _vertexDatas[uVertex];                      var force = u.ApplyForce(_temperature * Math.Max(1' _step) / 100.0 * Parameters.DisplacementLimitMultiplier);                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,Init,The following statement contains a magic number: InitializeWithRandomPositions(100' 100);
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,Init,The following statement contains a magic number: InitializeWithRandomPositions(100' 100);
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundVertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,RecalculateBounds,The following statement contains a magic number: foreach (var child in _children)                  {                      topLeft.X = Math.Min(topLeft.X' child.Position.X - child.Size.Width / 2);                      topLeft.Y = Math.Min(topLeft.Y' child.Position.Y - child.Size.Height / 2);                        bottomRight.X = Math.Max(bottomRight.X' child.Position.X + child.Size.Width / 2);                      bottomRight.Y = Math.Max(bottomRight.Y' child.Position.Y + child.Size.Height / 2);                  }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundVertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,RecalculateBounds,The following statement contains a magic number: foreach (var child in _children)                  {                      topLeft.X = Math.Min(topLeft.X' child.Position.X - child.Size.Width / 2);                      topLeft.Y = Math.Min(topLeft.Y' child.Position.Y - child.Size.Height / 2);                        bottomRight.X = Math.Max(bottomRight.X' child.Position.X + child.Size.Width / 2);                      bottomRight.Y = Math.Max(bottomRight.Y' child.Position.Y + child.Size.Height / 2);                  }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundVertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,RecalculateBounds,The following statement contains a magic number: foreach (var child in _children)                  {                      topLeft.X = Math.Min(topLeft.X' child.Position.X - child.Size.Width / 2);                      topLeft.Y = Math.Min(topLeft.Y' child.Position.Y - child.Size.Height / 2);                        bottomRight.X = Math.Max(bottomRight.X' child.Position.X + child.Size.Width / 2);                      bottomRight.Y = Math.Max(bottomRight.Y' child.Position.Y + child.Size.Height / 2);                  }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundVertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,RecalculateBounds,The following statement contains a magic number: foreach (var child in _children)                  {                      topLeft.X = Math.Min(topLeft.X' child.Position.X - child.Size.Width / 2);                      topLeft.Y = Math.Min(topLeft.Y' child.Position.Y - child.Size.Height / 2);                        bottomRight.X = Math.Max(bottomRight.X' child.Position.X + child.Size.Width / 2);                      bottomRight.Y = Math.Max(bottomRight.Y' child.Position.Y + child.Size.Height / 2);                  }
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundVertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,RecalculateBounds,The following statement contains a magic number: InnerCanvasCenter = new Point((topLeft.X + bottomRight.X) / 2.0' (topLeft.Y + bottomRight.Y) / 2.0);
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundVertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,RecalculateBounds,The following statement contains a magic number: InnerCanvasCenter = new Point((topLeft.X + bottomRight.X) / 2.0' (topLeft.Y + bottomRight.Y) / 2.0);
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,VertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,ApplyForce,The following statement contains a magic number: var force = _springForce                      + _repulsionForce                      + _gravitationForce                      + _applicationForce                      + 0.5 * _childrenForce;
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,VertexData,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.Data.cs,ApplyForce,The following statement contains a magic number: force += 0.7 * _previousForce;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossingMinimizations,The following statement contains a magic number: int phase1iterationLeft = 100;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossingMinimizations,The following statement contains a magic number: do              {                  changed = false;                  prevCrossings = crossings;                  if (phase == 1)                      phase1iterationLeft--;                  else if (phase == 2)                      phase2iterationLeft--;                  wasPhase2 = (phase == 2);                    crossings = Sweeping(0' _layers.Count - 1' 1' enableSameMeasureOptimization' out c' ref phase);                  changed = changed || c;                  if (crossings == 0)                      break;                    crossings = Sweeping(_layers.Count - 1' 0' -1' enableSameMeasureOptimization' out c' ref phase);                  changed = changed || c;                  if (phase == 1 && (!changed || crossings >= prevCrossings) && phase2iterationLeft > 0)                      phase = 2;                  else if (phase == 2)                      phase = 1;              } while (crossings > 0                   && ((phase2iterationLeft > 0 || wasPhase2)                       || (phase1iterationLeft > 0 && (crossings < prevCrossings) && changed)));
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossingMinimizations,The following statement contains a magic number: do              {                  changed = false;                  prevCrossings = crossings;                  if (phase == 1)                      phase1iterationLeft--;                  else if (phase == 2)                      phase2iterationLeft--;                  wasPhase2 = (phase == 2);                    crossings = Sweeping(0' _layers.Count - 1' 1' enableSameMeasureOptimization' out c' ref phase);                  changed = changed || c;                  if (crossings == 0)                      break;                    crossings = Sweeping(_layers.Count - 1' 0' -1' enableSameMeasureOptimization' out c' ref phase);                  changed = changed || c;                  if (phase == 1 && (!changed || crossings >= prevCrossings) && phase2iterationLeft > 0)                      phase = 2;                  else if (phase == 2)                      phase = 1;              } while (crossings > 0                   && ((phase2iterationLeft > 0 || wasPhase2)                       || (phase1iterationLeft > 0 && (crossings < prevCrossings) && changed)));
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossingMinimizations,The following statement contains a magic number: do              {                  changed = false;                  prevCrossings = crossings;                  if (phase == 1)                      phase1iterationLeft--;                  else if (phase == 2)                      phase2iterationLeft--;                  wasPhase2 = (phase == 2);                    crossings = Sweeping(0' _layers.Count - 1' 1' enableSameMeasureOptimization' out c' ref phase);                  changed = changed || c;                  if (crossings == 0)                      break;                    crossings = Sweeping(_layers.Count - 1' 0' -1' enableSameMeasureOptimization' out c' ref phase);                  changed = changed || c;                  if (phase == 1 && (!changed || crossings >= prevCrossings) && phase2iterationLeft > 0)                      phase = 2;                  else if (phase == 2)                      phase = 1;              } while (crossings > 0                   && ((phase2iterationLeft > 0 || wasPhase2)                       || (phase1iterationLeft > 0 && (crossings < prevCrossings) && changed)));
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossingMinimizations,The following statement contains a magic number: do              {                  changed = false;                  prevCrossings = crossings;                  if (phase == 1)                      phase1iterationLeft--;                  else if (phase == 2)                      phase2iterationLeft--;                  wasPhase2 = (phase == 2);                    crossings = Sweeping(0' _layers.Count - 1' 1' enableSameMeasureOptimization' out c' ref phase);                  changed = changed || c;                  if (crossings == 0)                      break;                    crossings = Sweeping(_layers.Count - 1' 0' -1' enableSameMeasureOptimization' out c' ref phase);                  changed = changed || c;                  if (phase == 1 && (!changed || crossings >= prevCrossings) && phase2iterationLeft > 0)                      phase = 2;                  else if (phase == 2)                      phase = 1;              } while (crossings > 0                   && ((phase2iterationLeft > 0 || wasPhase2)                       || (phase1iterationLeft > 0 && (crossings < prevCrossings) && changed)));
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,Sweeping,The following statement contains a magic number: for (int i = startLayerIndex; i != endLayerIndex; i += step)              {                  int ci = Math.Min(i' i + step);                  int prevCrossCount = _crossCounts[ci];                    if (_alternatingLayers[i+step] != null)                   {                      alternatingLayer.SetPositions();                      _alternatingLayers[i + step].SetPositions();                      prevCrossCount = DoCrossCountingAndOptimization(alternatingLayer' _alternatingLayers[i + step]' (i < i + step)' false' (phase == 2)' int.MaxValue);                      _crossCounts[ci] = prevCrossCount;                  }                    int crossCount = CrossingMinimizationBetweenLayers(ref alternatingLayer' i' i + step' enableSameMeasureOptimization' prevCrossCount' phase);                    if (crossCount < prevCrossCount || phase == 2 || changed)                  {                      /* set the sparse compaction graph */                      AddAlternatingLayerToSparseCompactionGraph(alternatingLayer' i + step);                      ReplaceLayer(alternatingLayer' i + step);                      _alternatingLayers[i + step] = alternatingLayer;                      OutputAlternatingLayer(alternatingLayer' i + step' crossCount);                      _crossCounts[i] = crossCount;                      crossings += crossCount;                      changed = true;                      /*if (phase == 2)                      {                          Debug.WriteLine("Phase changed on layer " + (i + step));                          phase = 1;                      }*/                  }                  else                  {                      Debug.WriteLine("Layer " + (i + step) + " has not changed.");                      alternatingLayer = _alternatingLayers[i + step];                      crossings += prevCrossCount;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,Sweeping,The following statement contains a magic number: for (int i = startLayerIndex; i != endLayerIndex; i += step)              {                  int ci = Math.Min(i' i + step);                  int prevCrossCount = _crossCounts[ci];                    if (_alternatingLayers[i+step] != null)                   {                      alternatingLayer.SetPositions();                      _alternatingLayers[i + step].SetPositions();                      prevCrossCount = DoCrossCountingAndOptimization(alternatingLayer' _alternatingLayers[i + step]' (i < i + step)' false' (phase == 2)' int.MaxValue);                      _crossCounts[ci] = prevCrossCount;                  }                    int crossCount = CrossingMinimizationBetweenLayers(ref alternatingLayer' i' i + step' enableSameMeasureOptimization' prevCrossCount' phase);                    if (crossCount < prevCrossCount || phase == 2 || changed)                  {                      /* set the sparse compaction graph */                      AddAlternatingLayerToSparseCompactionGraph(alternatingLayer' i + step);                      ReplaceLayer(alternatingLayer' i + step);                      _alternatingLayers[i + step] = alternatingLayer;                      OutputAlternatingLayer(alternatingLayer' i + step' crossCount);                      _crossCounts[i] = crossCount;                      crossings += crossCount;                      changed = true;                      /*if (phase == 2)                      {                          Debug.WriteLine("Phase changed on layer " + (i + step));                          phase = 1;                      }*/                  }                  else                  {                      Debug.WriteLine("Layer " + (i + step) + " has not changed.");                      alternatingLayer = _alternatingLayers[i + step];                      crossings += prevCrossCount;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CrossingMinimizationBetweenLayers,The following statement contains a magic number: int crossCount = DoCrossCountingAndOptimization(alternatingLayer' nextAlternatingLayer' straightSweep' enableSameMeasureOptimization' (phase == 2)' prevCrossCount);
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AddAlternatingLayerToSparseCompactionGraph,The following statement contains a magic number: for (int i = 1; i < nextAlternatingLayer.Count; i += 2)              {                  vertex = nextAlternatingLayer[i] as SugiVertex;                  var prevContainer = nextAlternatingLayer[i - 1] as SegmentContainer;                  var nextContainer = nextAlternatingLayer[i + 1] as SegmentContainer;                  if (prevContainer != null && prevContainer.Count > 0)                  {                      var lastSegment = prevContainer[prevContainer.Count - 1];                      var edge = new Edge<Data>(lastSegment' vertex);                      _sparseCompationGraphEdgesOfLayer.Add(edge);                      _sparseCompactionGraph.AddVerticesAndEdge(edge);                  }                  else if (prevVertex != null)                  {                      var edge = new Edge<Data>(prevVertex' vertex);                      _sparseCompationGraphEdgesOfLayer.Add(edge);                      _sparseCompactionGraph.AddVerticesAndEdge(edge);                  }                    if (nextContainer != null && nextContainer.Count > 0)                  {                      var firstSegment = nextContainer[0];                      var edge = new Edge<Data>(vertex' firstSegment);                      _sparseCompationGraphEdgesOfLayer.Add(edge);                      _sparseCompactionGraph.AddVerticesAndEdge(edge);                  }                    if (vertex != null && !_sparseCompactionGraph.ContainsVertex(vertex))                      _sparseCompactionGraph.AddVertex(vertex);                  prevVertex = vertex;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoCrossCountingAndOptimization,The following statement contains a magic number: if (enableSameMeasureOptimization || reverseVerticesWithSameMeasure)              {                  IList<int> ranges;                  int maxRangeLength;                  var verticesWithSameMeasure = FindVerticesWithSameMeasure(nextAlternatingLayer' straightSweep' out ranges' out maxRangeLength);                  var verticesWithSameMeasureSet = new HashSet<SugiVertex>(verticesWithSameMeasure);                    //initialize permutation indices                  for (int i = 0; i < verticesWithSameMeasure.Count; i++)                      verticesWithSameMeasure[i].PermutationIndex = i;                    int bestCrossCount = prevCrossCount;                  foreach (var realEdge in realEdges)                      realEdge.SaveMarkedToTemp();                    List<SugiVertex> sortedVertexList = null;                  if (!reverseVerticesWithSameMeasure)                  {                      sortedVertexList = new List<SugiVertex>(verticesWithSameMeasure);                  }                  else                  {                      sortedVertexList = new List<SugiVertex>(verticesWithSameMeasure.Count);                      var stack = new Stack<SugiVertex>(verticesWithSameMeasure.Count);                      var rnd = new Random(DateTime.Now.Millisecond);                      foreach (var v in verticesWithSameMeasure)                      {                          if (stack.Count > 0 && (stack.Peek().MeasuredPosition != v.MeasuredPosition || rnd.NextDouble() > 0.8))                          {                              while (stack.Count > 0)                                  sortedVertexList.Add(stack.Pop());                          }                          stack.Push(v);                      }                      while (stack.Count > 0)                      {                          sortedVertexList.Add(stack.Pop());                      }                  }                    int maxPermutations = EfficientSugiyamaLayoutParameters.MaxPermutations;                  do                  {                      maxPermutations--;                      if (!reverseVerticesWithSameMeasure)                      {                          //sort by permutation index and measure                          sortedVertexList.Sort(new Comparison<SugiVertex>(                              (v1' v2) =>                              {                                  if (v1.MeasuredPosition != v2.MeasuredPosition)                                      return Math.Sign(v1.MeasuredPosition - v2.MeasuredPosition);                                  else                                      return v1.PermutationIndex - v2.PermutationIndex;                              }));                      }                        //reinsert the vertices into the layer                      ReinsertVerticesIntoLayer(nextAlternatingLayer' verticesWithSameMeasureSet' sortedVertexList);                        //set the positions                      nextAlternatingLayer.SetPositions();                      realEdgePairs = ConvertRealEdgesToCrossCounterPairs(realEdges' true);                        var edgePairs = new List<CrossCounterPair>();                      edgePairs.AddRange(virtualEdgePairs);                      edgePairs.AddRange(realEdgePairs);                        int crossCount = BiLayerCrossCount(edgePairs' firstLayerSize' secondLayerSize);                        if (reverseVerticesWithSameMeasure)                          return crossCount;                        //if the crosscount is better than the best known                      //save the actual state                      if (crossCount < bestCrossCount)                      {                          foreach (var vertex in verticesWithSameMeasure)                              vertex.SavePositionToTemp();                            foreach (var edge in realEdges)                              edge.SaveMarkedToTemp();                            bestCrossCount = crossCount;                      }                      if (crossCount == 0)                          break;                  } while (maxPermutations > 0 && Permutate(verticesWithSameMeasure' ranges));                    //reload the best solution                  foreach (var vertex in verticesWithSameMeasure)                      vertex.LoadPositionFromTemp();                    foreach (var edge in realEdges)                      edge.LoadMarkedFromTemp();                    //sort by permutation index and measure                  sortedVertexList.Sort(new Comparison<SugiVertex>((v1' v2) => v1.Position - v2.Position));                    //reinsert the vertices into the layer                  ReinsertVerticesIntoLayer(nextAlternatingLayer' verticesWithSameMeasureSet' sortedVertexList);                  nextAlternatingLayer.SetPositions();                    return bestCrossCount;              }              else              {                  realEdgePairs = ConvertRealEdgesToCrossCounterPairs(realEdges' true);                  var edgePairs = new List<CrossCounterPair>();                  edgePairs.AddRange(virtualEdgePairs);                  edgePairs.AddRange(realEdgePairs);                    return BiLayerCrossCount(edgePairs' firstLayerSize' secondLayerSize);              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,PermutateSomeHow,The following statement contains a magic number: if (count <= 4) {                  return Permutate(vertices' startIndex' count);              } else {                  return PermutateRandom(vertices' startIndex' count);              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,BiLayerCrossCount,The following statement contains a magic number: while (firstIndex < pairCount)                  firstIndex *= 2;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,BiLayerCrossCount,The following statement contains a magic number: int treeSize = 2 * firstIndex - 1;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,BiLayerCrossCount,The following statement contains a magic number: foreach (var list in radixByFirst)              {                  if (list == null)                      continue;                    foreach (var pair in list)                  {                      index = pair.Second + firstIndex;                      tree[index].Accumulator += pair.Weight;                      switch (pair.Type)                      {                          case EdgeTypes.InnerSegment:                              tree[index].InnerSegmentMarker = true;                              break;                          case EdgeTypes.NonInnerSegment:                              tree[index].NonInnerSegmentQueue.Enqueue(pair.NonInnerSegment);                              break;                          default:                              break;                      }                      while (index > 0)                      {                          if (index % 2 > 0)                          {                              crossCount += tree[index + 1].Accumulator * pair.Weight;                              switch (pair.Type)                              {                                  case EdgeTypes.InnerSegment:                                      var queue = tree[index + 1].NonInnerSegmentQueue;                                      while (queue.Count > 0)                                      {                                          queue.Dequeue().Marked = true;                                      }                                      break;                                  case EdgeTypes.NonInnerSegment:                                      if (tree[index + 1].InnerSegmentMarker)                                      {                                          pair.NonInnerSegment.Marked = true;                                      }                                      break;                                  default:                                      break;                              }                          }                          index = (index - 1) / 2;                          tree[index].Accumulator += pair.Weight;                          switch (pair.Type)                          {                              case EdgeTypes.InnerSegment:                                  tree[index].InnerSegmentMarker = true;                                  break;                              case EdgeTypes.NonInnerSegment:                                  tree[index].NonInnerSegmentQueue.Enqueue(pair.NonInnerSegment);                                  break;                              default:                                  break;                          }                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,BiLayerCrossCount,The following statement contains a magic number: foreach (var list in radixByFirst)              {                  if (list == null)                      continue;                    foreach (var pair in list)                  {                      index = pair.Second + firstIndex;                      tree[index].Accumulator += pair.Weight;                      switch (pair.Type)                      {                          case EdgeTypes.InnerSegment:                              tree[index].InnerSegmentMarker = true;                              break;                          case EdgeTypes.NonInnerSegment:                              tree[index].NonInnerSegmentQueue.Enqueue(pair.NonInnerSegment);                              break;                          default:                              break;                      }                      while (index > 0)                      {                          if (index % 2 > 0)                          {                              crossCount += tree[index + 1].Accumulator * pair.Weight;                              switch (pair.Type)                              {                                  case EdgeTypes.InnerSegment:                                      var queue = tree[index + 1].NonInnerSegmentQueue;                                      while (queue.Count > 0)                                      {                                          queue.Dequeue().Marked = true;                                      }                                      break;                                  case EdgeTypes.NonInnerSegment:                                      if (tree[index + 1].InnerSegmentMarker)                                      {                                          pair.NonInnerSegment.Marked = true;                                      }                                      break;                                  default:                                      break;                              }                          }                          index = (index - 1) / 2;                          tree[index].Accumulator += pair.Weight;                          switch (pair.Type)                          {                              case EdgeTypes.InnerSegment:                                  tree[index].InnerSegmentMarker = true;                                  break;                              case EdgeTypes.NonInnerSegment:                                  tree[index].NonInnerSegmentQueue.Enqueue(pair.NonInnerSegment);                                  break;                              default:                                  break;                          }                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,PlaceQVertices,The following statement contains a magic number: for (int i = 0; i < alternatingLayer.Count; i++)              {                  var segmentContainer = alternatingLayer[i] as SegmentContainer;                  if (segmentContainer == null)                      continue;                  for (int j = 0; j < segmentContainer.Count; j++)                  {                      var segment = segmentContainer[j];                      var vertex = straightSweep ? segment.QVertex : segment.PVertex;                      if (!qVertices.Contains(vertex))                          continue;                        alternatingLayer.RemoveAt(i);                      ISegmentContainer sc1' sc2;                      segmentContainer.Split(segment' out sc1' out sc2);                      sc1.Position = segmentContainer.Position;                      sc2.Position = segmentContainer.Position + sc1.Count + 1;                      alternatingLayer.Insert(i' sc1);                      alternatingLayer.Insert(i + 1' vertex);                      alternatingLayer.Insert(i + 2' sc2);                      i = i + 1;                      break;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AppendSegmentsToAlternatingLayer,The following statement contains a magic number: for (int i = 1; i < alternatingLayer.Count; i += 2)              {                  var vertex = alternatingLayer[i] as SugiVertex;                  if (vertex.Type == type)                  {                      var precedingContainer = alternatingLayer[i - 1] as SegmentContainer;                      var succeedingContainer = alternatingLayer[i + 1] as SegmentContainer;                      precedingContainer.Append(vertex.Segment);                      precedingContainer.Join(succeedingContainer);                        //remove the vertex and the succeeding container from the alternating layer                      alternatingLayer.RemoveRange(i' 2);                      i -= 2;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AppendSegmentsToAlternatingLayer,The following statement contains a magic number: for (int i = 1; i < alternatingLayer.Count; i += 2)              {                  var vertex = alternatingLayer[i] as SugiVertex;                  if (vertex.Type == type)                  {                      var precedingContainer = alternatingLayer[i - 1] as SegmentContainer;                      var succeedingContainer = alternatingLayer[i + 1] as SegmentContainer;                      precedingContainer.Append(vertex.Segment);                      precedingContainer.Join(succeedingContainer);                        //remove the vertex and the succeeding container from the alternating layer                      alternatingLayer.RemoveRange(i' 2);                      i -= 2;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AppendSegmentsToAlternatingLayer,The following statement contains a magic number: for (int i = 1; i < alternatingLayer.Count; i += 2)              {                  var vertex = alternatingLayer[i] as SugiVertex;                  if (vertex.Type == type)                  {                      var precedingContainer = alternatingLayer[i - 1] as SegmentContainer;                      var succeedingContainer = alternatingLayer[i + 1] as SegmentContainer;                      precedingContainer.Append(vertex.Segment);                      precedingContainer.Join(succeedingContainer);                        //remove the vertex and the succeeding container from the alternating layer                      alternatingLayer.RemoveRange(i' 2);                      i -= 2;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AssignPositionsOnActualLayer,The following statement contains a magic number: for (int i = 1; i < alternatingLayer.Count; i += 2)              {                  var precedingContainer = alternatingLayer[i - 1] as SegmentContainer;                  var vertex = alternatingLayer[i] as SugiVertex;                  if (i == 1)                  {                      vertex.Position = precedingContainer.Count;                  }                  else                  {                      var previousVertex = alternatingLayer[i - 2] as SugiVertex;                      vertex.Position = previousVertex.Position + precedingContainer.Count + 1;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AssignPositionsOnActualLayer,The following statement contains a magic number: for (int i = 1; i < alternatingLayer.Count; i += 2)              {                  var precedingContainer = alternatingLayer[i - 1] as SegmentContainer;                  var vertex = alternatingLayer[i] as SugiVertex;                  if (i == 1)                  {                      vertex.Position = precedingContainer.Count;                  }                  else                  {                      var previousVertex = alternatingLayer[i - 2] as SugiVertex;                      vertex.Position = previousVertex.Position + precedingContainer.Count + 1;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,AssignPositionsOnActualLayer,The following statement contains a magic number: for (int i = 0; i < alternatingLayer.Count; i += 2)              {                  var container = alternatingLayer[i] as SegmentContainer;                  if (i == 0)                  {                      container.Position = 0;                  }                  else                  {                      var precedingVertex = alternatingLayer[i - 1] as SugiVertex;                      container.Position = precedingVertex.Position + 1;                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CreateDummyVerticesAndSegments,The following statement contains a magic number: foreach (var edge in _graph.Edges.ToList())              {                  int sourceLayerIndex = edge.Source.LayerIndex;                  int targetLayerIndex = edge.Target.LayerIndex;                  int span = targetLayerIndex - sourceLayerIndex;                  if (span < 1)                      throw new ArgumentException("span cannot be lower than 1");                    if (span == 1)                      continue;                    _graph.RemoveEdge(edge);                  bool notReversed = edge.Source.OriginalVertex == edge.OriginalEdge.Source && edge.Target.OriginalVertex == edge.OriginalEdge.Target;                  var dummyVertexList = new List<SugiVertex>();                  _dummyVerticesOfEdges[edge.OriginalEdge] = dummyVertexList;                  if (span == 2)                  {                      //insert an R-vertex                      var rVertex = AddDummyVertex(VertexTypes.RVertex' sourceLayerIndex + 1);                      _graph.AddEdge(new SugiEdge(edge.OriginalEdge' edge.Source' rVertex));                      _graph.AddEdge(new SugiEdge(edge.OriginalEdge' rVertex' edge.Target));                      dummyVertexList.Add(rVertex);                  }                  else                  {                      //insert a P-vertex' a Q-vertex and a Segment                      var pVertex = AddDummyVertex(VertexTypes.PVertex' sourceLayerIndex + 1);                      var qVertex = AddDummyVertex(VertexTypes.QVertex' targetLayerIndex - 1);                      if (notReversed)                      {                          dummyVertexList.Add(pVertex);                          dummyVertexList.Add(qVertex);                      }                      else                      {                          dummyVertexList.Add(qVertex);                          dummyVertexList.Add(pVertex);                      }                      _graph.AddEdge(new SugiEdge(edge.OriginalEdge' edge.Source' pVertex));                      _graph.AddEdge(new SugiEdge(edge.OriginalEdge' qVertex' edge.Target));                      var segment = AddSegment(pVertex' qVertex' edge);                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculatePositions,The following statement contains a magic number: if (Parameters.PositionMode < 0 || Parameters.PositionMode == 2)                  CalculateHorizontalPositions(LeftRightMode.Left' UpperLowerEdges.Lower);
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculatePositions,The following statement contains a magic number: if (Parameters.PositionMode < 0 || Parameters.PositionMode == 3)                  CalculateHorizontalPositions(LeftRightMode.Right' UpperLowerEdges.Lower);
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var edge in VisitedGraph.Edges)              {                  Point[] orthoRoutePoints = new Point[2];                  var sourceVertex = _vertexMap[edge.Source];                  var targetVertex = _vertexMap[edge.Target];                  bool notSwitched = (sourceVertex.LayerIndex < targetVertex.LayerIndex);                  int sourceIndex = notSwitched ? 0 : 1;                  int targetIndex = notSwitched ? 1 : 0;                  orthoRoutePoints[sourceIndex] = new Point()                  {                      X = sourceVertex.HorizontalPosition'                      Y = _layerPositions[sourceVertex.LayerIndex] + _layerHeights[sourceVertex.LayerIndex] + Parameters.LayerDistance / 2.0                  };                  orthoRoutePoints[targetIndex] = new Point()                  {                      X = targetVertex.HorizontalPosition'                      Y = _layerPositions[targetVertex.LayerIndex] - Parameters.LayerDistance / 2.0                  };                  _edgeRoutingPoints[edge] = orthoRoutePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var edge in VisitedGraph.Edges)              {                  Point[] orthoRoutePoints = new Point[2];                  var sourceVertex = _vertexMap[edge.Source];                  var targetVertex = _vertexMap[edge.Target];                  bool notSwitched = (sourceVertex.LayerIndex < targetVertex.LayerIndex);                  int sourceIndex = notSwitched ? 0 : 1;                  int targetIndex = notSwitched ? 1 : 0;                  orthoRoutePoints[sourceIndex] = new Point()                  {                      X = sourceVertex.HorizontalPosition'                      Y = _layerPositions[sourceVertex.LayerIndex] + _layerHeights[sourceVertex.LayerIndex] + Parameters.LayerDistance / 2.0                  };                  orthoRoutePoints[targetIndex] = new Point()                  {                      X = targetVertex.HorizontalPosition'                      Y = _layerPositions[targetVertex.LayerIndex] - Parameters.LayerDistance / 2.0                  };                  _edgeRoutingPoints[edge] = orthoRoutePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var edge in VisitedGraph.Edges)              {                  Point[] orthoRoutePoints = new Point[2];                  var sourceVertex = _vertexMap[edge.Source];                  var targetVertex = _vertexMap[edge.Target];                  bool notSwitched = (sourceVertex.LayerIndex < targetVertex.LayerIndex);                  int sourceIndex = notSwitched ? 0 : 1;                  int targetIndex = notSwitched ? 1 : 0;                  orthoRoutePoints[sourceIndex] = new Point()                  {                      X = sourceVertex.HorizontalPosition'                      Y = _layerPositions[sourceVertex.LayerIndex] + _layerHeights[sourceVertex.LayerIndex] + Parameters.LayerDistance / 2.0                  };                  orthoRoutePoints[targetIndex] = new Point()                  {                      X = targetVertex.HorizontalPosition'                      Y = _layerPositions[targetVertex.LayerIndex] - Parameters.LayerDistance / 2.0                  };                  _edgeRoutingPoints[edge] = orthoRoutePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var kvp in _dummyVerticesOfEdges)              {                  Point[] orthoRoutePoints = _edgeRoutingPoints[kvp.Key];                    var routePoints = new Point[kvp.Value.Count + 4];                  routePoints[0] = orthoRoutePoints[0];                  routePoints[kvp.Value.Count + 3] = orthoRoutePoints[1];                  for (int i = 0; i < kvp.Value.Count; i++)                  {                      var vertex = kvp.Value[i];                      routePoints[i+2] = new Point(vertex.HorizontalPosition' vertex.VerticalPosition);                  }                  routePoints[1] = new Point(routePoints[2].X' routePoints[0].Y);                  routePoints[kvp.Value.Count + 2] = new Point(routePoints[kvp.Value.Count + 1].X' routePoints[kvp.Value.Count + 3].Y);                  _edgeRoutingPoints[kvp.Key] = routePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var kvp in _dummyVerticesOfEdges)              {                  Point[] orthoRoutePoints = _edgeRoutingPoints[kvp.Key];                    var routePoints = new Point[kvp.Value.Count + 4];                  routePoints[0] = orthoRoutePoints[0];                  routePoints[kvp.Value.Count + 3] = orthoRoutePoints[1];                  for (int i = 0; i < kvp.Value.Count; i++)                  {                      var vertex = kvp.Value[i];                      routePoints[i+2] = new Point(vertex.HorizontalPosition' vertex.VerticalPosition);                  }                  routePoints[1] = new Point(routePoints[2].X' routePoints[0].Y);                  routePoints[kvp.Value.Count + 2] = new Point(routePoints[kvp.Value.Count + 1].X' routePoints[kvp.Value.Count + 3].Y);                  _edgeRoutingPoints[kvp.Key] = routePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var kvp in _dummyVerticesOfEdges)              {                  Point[] orthoRoutePoints = _edgeRoutingPoints[kvp.Key];                    var routePoints = new Point[kvp.Value.Count + 4];                  routePoints[0] = orthoRoutePoints[0];                  routePoints[kvp.Value.Count + 3] = orthoRoutePoints[1];                  for (int i = 0; i < kvp.Value.Count; i++)                  {                      var vertex = kvp.Value[i];                      routePoints[i+2] = new Point(vertex.HorizontalPosition' vertex.VerticalPosition);                  }                  routePoints[1] = new Point(routePoints[2].X' routePoints[0].Y);                  routePoints[kvp.Value.Count + 2] = new Point(routePoints[kvp.Value.Count + 1].X' routePoints[kvp.Value.Count + 3].Y);                  _edgeRoutingPoints[kvp.Key] = routePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var kvp in _dummyVerticesOfEdges)              {                  Point[] orthoRoutePoints = _edgeRoutingPoints[kvp.Key];                    var routePoints = new Point[kvp.Value.Count + 4];                  routePoints[0] = orthoRoutePoints[0];                  routePoints[kvp.Value.Count + 3] = orthoRoutePoints[1];                  for (int i = 0; i < kvp.Value.Count; i++)                  {                      var vertex = kvp.Value[i];                      routePoints[i+2] = new Point(vertex.HorizontalPosition' vertex.VerticalPosition);                  }                  routePoints[1] = new Point(routePoints[2].X' routePoints[0].Y);                  routePoints[kvp.Value.Count + 2] = new Point(routePoints[kvp.Value.Count + 1].X' routePoints[kvp.Value.Count + 3].Y);                  _edgeRoutingPoints[kvp.Key] = routePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var kvp in _dummyVerticesOfEdges)              {                  Point[] orthoRoutePoints = _edgeRoutingPoints[kvp.Key];                    var routePoints = new Point[kvp.Value.Count + 4];                  routePoints[0] = orthoRoutePoints[0];                  routePoints[kvp.Value.Count + 3] = orthoRoutePoints[1];                  for (int i = 0; i < kvp.Value.Count; i++)                  {                      var vertex = kvp.Value[i];                      routePoints[i+2] = new Point(vertex.HorizontalPosition' vertex.VerticalPosition);                  }                  routePoints[1] = new Point(routePoints[2].X' routePoints[0].Y);                  routePoints[kvp.Value.Count + 2] = new Point(routePoints[kvp.Value.Count + 1].X' routePoints[kvp.Value.Count + 3].Y);                  _edgeRoutingPoints[kvp.Key] = routePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoOrthogonalEdgeRouting,The following statement contains a magic number: foreach (var kvp in _dummyVerticesOfEdges)              {                  Point[] orthoRoutePoints = _edgeRoutingPoints[kvp.Key];                    var routePoints = new Point[kvp.Value.Count + 4];                  routePoints[0] = orthoRoutePoints[0];                  routePoints[kvp.Value.Count + 3] = orthoRoutePoints[1];                  for (int i = 0; i < kvp.Value.Count; i++)                  {                      var vertex = kvp.Value[i];                      routePoints[i+2] = new Point(vertex.HorizontalPosition' vertex.VerticalPosition);                  }                  routePoints[1] = new Point(routePoints[2].X' routePoints[0].Y);                  routePoints[kvp.Value.Count + 2] = new Point(routePoints[kvp.Value.Count + 1].X' routePoints[kvp.Value.Count + 3].Y);                  _edgeRoutingPoints[kvp.Key] = routePoints;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculateRealPositions,The following statement contains a magic number: foreach (var vertex in _graph.Vertices)              {                  Debug.WriteLine(string.Format("{0}:\t{1}\t{2}\t{3}\t{4}"'                      vertex.OriginalVertex'                      vertex.HorizontalPositions[0]'                      vertex.HorizontalPositions[1]'                      vertex.HorizontalPositions[2]'                      vertex.HorizontalPositions[3]));                  if (Parameters.PositionMode < 0)                  {                      vertex.HorizontalPosition =                          (vertex.HorizontalPositions[0] + vertex.HorizontalPositions[1]                           + vertex.HorizontalPositions[2] + vertex.HorizontalPositions[3]) / 4.0;                  }                  else                  {                      vertex.HorizontalPosition = vertex.HorizontalPositions[Parameters.PositionMode];                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculateRealPositions,The following statement contains a magic number: foreach (var vertex in _graph.Vertices)              {                  Debug.WriteLine(string.Format("{0}:\t{1}\t{2}\t{3}\t{4}"'                      vertex.OriginalVertex'                      vertex.HorizontalPositions[0]'                      vertex.HorizontalPositions[1]'                      vertex.HorizontalPositions[2]'                      vertex.HorizontalPositions[3]));                  if (Parameters.PositionMode < 0)                  {                      vertex.HorizontalPosition =                          (vertex.HorizontalPositions[0] + vertex.HorizontalPositions[1]                           + vertex.HorizontalPositions[2] + vertex.HorizontalPositions[3]) / 4.0;                  }                  else                  {                      vertex.HorizontalPosition = vertex.HorizontalPositions[Parameters.PositionMode];                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculateRealPositions,The following statement contains a magic number: foreach (var vertex in _graph.Vertices)              {                  Debug.WriteLine(string.Format("{0}:\t{1}\t{2}\t{3}\t{4}"'                      vertex.OriginalVertex'                      vertex.HorizontalPositions[0]'                      vertex.HorizontalPositions[1]'                      vertex.HorizontalPositions[2]'                      vertex.HorizontalPositions[3]));                  if (Parameters.PositionMode < 0)                  {                      vertex.HorizontalPosition =                          (vertex.HorizontalPositions[0] + vertex.HorizontalPositions[1]                           + vertex.HorizontalPositions[2] + vertex.HorizontalPositions[3]) / 4.0;                  }                  else                  {                      vertex.HorizontalPosition = vertex.HorizontalPositions[Parameters.PositionMode];                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculateRealPositions,The following statement contains a magic number: foreach (var vertex in _graph.Vertices)              {                  Debug.WriteLine(string.Format("{0}:\t{1}\t{2}\t{3}\t{4}"'                      vertex.OriginalVertex'                      vertex.HorizontalPositions[0]'                      vertex.HorizontalPositions[1]'                      vertex.HorizontalPositions[2]'                      vertex.HorizontalPositions[3]));                  if (Parameters.PositionMode < 0)                  {                      vertex.HorizontalPosition =                          (vertex.HorizontalPositions[0] + vertex.HorizontalPositions[1]                           + vertex.HorizontalPositions[2] + vertex.HorizontalPositions[3]) / 4.0;                  }                  else                  {                      vertex.HorizontalPosition = vertex.HorizontalPositions[Parameters.PositionMode];                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculateRealPositions,The following statement contains a magic number: foreach (var vertex in _graph.Vertices)              {                  Debug.WriteLine(string.Format("{0}:\t{1}\t{2}\t{3}\t{4}"'                      vertex.OriginalVertex'                      vertex.HorizontalPositions[0]'                      vertex.HorizontalPositions[1]'                      vertex.HorizontalPositions[2]'                      vertex.HorizontalPositions[3]));                  if (Parameters.PositionMode < 0)                  {                      vertex.HorizontalPosition =                          (vertex.HorizontalPositions[0] + vertex.HorizontalPositions[1]                           + vertex.HorizontalPositions[2] + vertex.HorizontalPositions[3]) / 4.0;                  }                  else                  {                      vertex.HorizontalPosition = vertex.HorizontalPositions[Parameters.PositionMode];                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculateVerticalPositions,The following statement contains a magic number: foreach (var vertex in _graph.Vertices)                  vertex.VerticalPosition = _layerPositions[vertex.LayerIndex] + (vertex.Size.Height <= 0 ? _layerHeights[vertex.LayerIndex] : vertex.Size.Height) / 2.0;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,CalculateHorizontalPositions,The following statement contains a magic number: int modeIndex = (byte)upperLowerEdges * 2 + (byte)leftRightMode;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,PlaceBlock,The following statement contains a magic number: do              {                  SugiVertex wVertex = w as SugiVertex;                  Segment wSegment = w as Segment;                  if (_sparseCompactionGraph.ContainsVertex(w) &&                      ((leftRightMode == LeftRightMode.Left && _sparseCompactionGraph.InDegree(w) > 0)                        || (leftRightMode == LeftRightMode.Right && _sparseCompactionGraph.OutDegree(w) > 0)))                  {                      var edges = leftRightMode == LeftRightMode.Left                          ? _sparseCompactionGraph.InEdges(w)                          : _sparseCompactionGraph.OutEdges(w);                      foreach (var edge in edges)                      {                          SugiVertex u = null;                          Data pred = leftRightMode == LeftRightMode.Left ? edge.Source : edge.Target;                          if (pred is SugiVertex)                              u = ((SugiVertex)pred).Roots[modeIndex];                          else                          {                              var segment = (Segment)pred;                              u = upperLowerEdges == UpperLowerEdges.Upper ? segment.PVertex.Roots[modeIndex] : segment.QVertex.Roots[modeIndex];                          }                          PlaceBlock(modeIndex' leftRightMode' upperLowerEdges' u);                          if (v.Sinks[modeIndex] == v)                              v.Sinks[modeIndex] = u.Sinks[modeIndex];                          //var xDelta = delta + (v.Roots[modeIndex].BlockWidths[modeIndex] + u.BlockWidths[modeIndex]) / 2.0;                          var xDelta = delta + ((wVertex != null ? wVertex.Size.Width : 0.0) + ((pred is SugiVertex) ? ((SugiVertex)pred).Size.Width : u.BlockWidths[modeIndex])) / 2.0;                          if (v.Sinks[modeIndex] != u.Sinks[modeIndex])                          {                              var s = leftRightMode == LeftRightMode.Left                                  ? v.HorizontalPositions[modeIndex] - u.HorizontalPositions[modeIndex] - xDelta                                  : u.HorizontalPositions[modeIndex] - v.HorizontalPositions[modeIndex] - xDelta;                                u.Sinks[modeIndex].Shifts[modeIndex] = leftRightMode == LeftRightMode.Left                                  ? Math.Min(u.Sinks[modeIndex].Shifts[modeIndex]' s)                                  : Math.Max(u.Sinks[modeIndex].Shifts[modeIndex]' s);                          }                          else                          {                              v.HorizontalPositions[modeIndex] =                                  leftRightMode == LeftRightMode.Left                                      ? Math.Max(v.HorizontalPositions[modeIndex]' u.HorizontalPositions[modeIndex] + xDelta)                                      : Math.Min(v.HorizontalPositions[modeIndex]' u.HorizontalPositions[modeIndex] - xDelta);                          }                      }                  }                  if (wSegment != null)                      w = (upperLowerEdges == UpperLowerEdges.Upper) ? wSegment.QVertex : wSegment.PVertex;                  else if (wVertex.Type == VertexTypes.PVertex && upperLowerEdges == UpperLowerEdges.Upper)                      w = wVertex.Segment;                  else if (wVertex.Type == VertexTypes.QVertex && upperLowerEdges == UpperLowerEdges.Lower)                      w = wVertex.Segment;                  else                      w = wVertex.Aligns[modeIndex];              } while (w != v);
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoAlignment,The following statement contains a magic number: for (int i = layerStart; i != layerEnd; i += layerStep)              {                  int r = leftRightMode == LeftRightMode.Left ? int.MinValue : int.MaxValue;                  var layer = _layers[i];                  int vertexStart' vertexEnd' vertexStep;                  if (leftRightMode == LeftRightMode.Left)                  {                      vertexStart = 0;                      vertexEnd = layer.Count;                      vertexStep = 1;                  }                  else                  {                      vertexStart = layer.Count - 1;                      vertexEnd = -1;                      vertexStep = -1;                  }                  for (int j = vertexStart; j != vertexEnd; j += vertexStep)                  {                      var vertex = layer[j];                      if (vertex.Type == VertexTypes.Original                          || vertex.Type == VertexTypes.RVertex                          || (vertex.Type == VertexTypes.PVertex && upperLowerEdges == UpperLowerEdges.Upper)                          || (vertex.Type == VertexTypes.QVertex && upperLowerEdges == UpperLowerEdges.Lower))                      {                          List<SugiEdge> neighbourEdges = null;                          neighbourEdges = upperLowerEdges == UpperLowerEdges.Upper                              ? _graph.InEdges(vertex).OrderBy(e => e.Source.Position).ToList()                              : _graph.OutEdges(vertex).OrderBy(e => e.Target.Position).ToList();                          if (neighbourEdges.Count <= 0)                              continue;                            int c1 = (int)Math.Floor((neighbourEdges.Count + 1) / 2.0) - 1;                          int c2 = (int)Math.Ceiling((neighbourEdges.Count + 1) / 2.0) - 1;                          int[] medians = null;                          if (c1 == c2)                          {                              medians = new int[1] { c1 };                          }                          else                          {                              medians = leftRightMode == LeftRightMode.Left                                  ? new int[2] { c1' c2 }                                  : new int[2] { c2' c1 };                          }                          for (int m = 0; m < medians.Length; m++)                          {                              if (vertex.Aligns[modeIndex] != vertex)                                  continue;                              var edge = neighbourEdges[medians[m]];                              if (edge.Marked)                                  Debug.WriteLine("Edge marked: " + edge.Source.OriginalVertex + "' " + edge.Target.OriginalVertex);                              var neighbour = edge.OtherVertex(vertex);                              if (!edge.Marked &&                                  ((leftRightMode == LeftRightMode.Left && r < neighbour.Position)                                      || (leftRightMode == LeftRightMode.Right && r > neighbour.Position)))                              {                                  neighbour.Aligns[modeIndex] = vertex;                                  neighbour.BlockWidths[modeIndex] = Math.Max(neighbour.BlockWidths[modeIndex]' vertex.Size.Width);                                  vertex.Roots[modeIndex] = neighbour.Roots[modeIndex];                                  vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                                  r = neighbour.Position;                              }                          }                      }                      else if (vertex.Type == VertexTypes.PVertex /*&& upperLowerEdges == UpperLowerEdges.Lower*/)                      {                          //align the segment of the PVertex                          vertex.Roots[modeIndex] = vertex.Segment.QVertex.Roots[modeIndex];                          vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                          r = vertex.Segment.Position;                      }                      else if (vertex.Type == VertexTypes.QVertex /*&& upperLowerEdges == UpperLowerEdges.Upper*/)                      {                          //align the segment of the QVertex                          vertex.Roots[modeIndex] = vertex.Segment.PVertex.Roots[modeIndex];                          vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                          r = vertex.Segment.Position;                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoAlignment,The following statement contains a magic number: for (int i = layerStart; i != layerEnd; i += layerStep)              {                  int r = leftRightMode == LeftRightMode.Left ? int.MinValue : int.MaxValue;                  var layer = _layers[i];                  int vertexStart' vertexEnd' vertexStep;                  if (leftRightMode == LeftRightMode.Left)                  {                      vertexStart = 0;                      vertexEnd = layer.Count;                      vertexStep = 1;                  }                  else                  {                      vertexStart = layer.Count - 1;                      vertexEnd = -1;                      vertexStep = -1;                  }                  for (int j = vertexStart; j != vertexEnd; j += vertexStep)                  {                      var vertex = layer[j];                      if (vertex.Type == VertexTypes.Original                          || vertex.Type == VertexTypes.RVertex                          || (vertex.Type == VertexTypes.PVertex && upperLowerEdges == UpperLowerEdges.Upper)                          || (vertex.Type == VertexTypes.QVertex && upperLowerEdges == UpperLowerEdges.Lower))                      {                          List<SugiEdge> neighbourEdges = null;                          neighbourEdges = upperLowerEdges == UpperLowerEdges.Upper                              ? _graph.InEdges(vertex).OrderBy(e => e.Source.Position).ToList()                              : _graph.OutEdges(vertex).OrderBy(e => e.Target.Position).ToList();                          if (neighbourEdges.Count <= 0)                              continue;                            int c1 = (int)Math.Floor((neighbourEdges.Count + 1) / 2.0) - 1;                          int c2 = (int)Math.Ceiling((neighbourEdges.Count + 1) / 2.0) - 1;                          int[] medians = null;                          if (c1 == c2)                          {                              medians = new int[1] { c1 };                          }                          else                          {                              medians = leftRightMode == LeftRightMode.Left                                  ? new int[2] { c1' c2 }                                  : new int[2] { c2' c1 };                          }                          for (int m = 0; m < medians.Length; m++)                          {                              if (vertex.Aligns[modeIndex] != vertex)                                  continue;                              var edge = neighbourEdges[medians[m]];                              if (edge.Marked)                                  Debug.WriteLine("Edge marked: " + edge.Source.OriginalVertex + "' " + edge.Target.OriginalVertex);                              var neighbour = edge.OtherVertex(vertex);                              if (!edge.Marked &&                                  ((leftRightMode == LeftRightMode.Left && r < neighbour.Position)                                      || (leftRightMode == LeftRightMode.Right && r > neighbour.Position)))                              {                                  neighbour.Aligns[modeIndex] = vertex;                                  neighbour.BlockWidths[modeIndex] = Math.Max(neighbour.BlockWidths[modeIndex]' vertex.Size.Width);                                  vertex.Roots[modeIndex] = neighbour.Roots[modeIndex];                                  vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                                  r = neighbour.Position;                              }                          }                      }                      else if (vertex.Type == VertexTypes.PVertex /*&& upperLowerEdges == UpperLowerEdges.Lower*/)                      {                          //align the segment of the PVertex                          vertex.Roots[modeIndex] = vertex.Segment.QVertex.Roots[modeIndex];                          vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                          r = vertex.Segment.Position;                      }                      else if (vertex.Type == VertexTypes.QVertex /*&& upperLowerEdges == UpperLowerEdges.Upper*/)                      {                          //align the segment of the QVertex                          vertex.Roots[modeIndex] = vertex.Segment.PVertex.Roots[modeIndex];                          vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                          r = vertex.Segment.Position;                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoAlignment,The following statement contains a magic number: for (int i = layerStart; i != layerEnd; i += layerStep)              {                  int r = leftRightMode == LeftRightMode.Left ? int.MinValue : int.MaxValue;                  var layer = _layers[i];                  int vertexStart' vertexEnd' vertexStep;                  if (leftRightMode == LeftRightMode.Left)                  {                      vertexStart = 0;                      vertexEnd = layer.Count;                      vertexStep = 1;                  }                  else                  {                      vertexStart = layer.Count - 1;                      vertexEnd = -1;                      vertexStep = -1;                  }                  for (int j = vertexStart; j != vertexEnd; j += vertexStep)                  {                      var vertex = layer[j];                      if (vertex.Type == VertexTypes.Original                          || vertex.Type == VertexTypes.RVertex                          || (vertex.Type == VertexTypes.PVertex && upperLowerEdges == UpperLowerEdges.Upper)                          || (vertex.Type == VertexTypes.QVertex && upperLowerEdges == UpperLowerEdges.Lower))                      {                          List<SugiEdge> neighbourEdges = null;                          neighbourEdges = upperLowerEdges == UpperLowerEdges.Upper                              ? _graph.InEdges(vertex).OrderBy(e => e.Source.Position).ToList()                              : _graph.OutEdges(vertex).OrderBy(e => e.Target.Position).ToList();                          if (neighbourEdges.Count <= 0)                              continue;                            int c1 = (int)Math.Floor((neighbourEdges.Count + 1) / 2.0) - 1;                          int c2 = (int)Math.Ceiling((neighbourEdges.Count + 1) / 2.0) - 1;                          int[] medians = null;                          if (c1 == c2)                          {                              medians = new int[1] { c1 };                          }                          else                          {                              medians = leftRightMode == LeftRightMode.Left                                  ? new int[2] { c1' c2 }                                  : new int[2] { c2' c1 };                          }                          for (int m = 0; m < medians.Length; m++)                          {                              if (vertex.Aligns[modeIndex] != vertex)                                  continue;                              var edge = neighbourEdges[medians[m]];                              if (edge.Marked)                                  Debug.WriteLine("Edge marked: " + edge.Source.OriginalVertex + "' " + edge.Target.OriginalVertex);                              var neighbour = edge.OtherVertex(vertex);                              if (!edge.Marked &&                                  ((leftRightMode == LeftRightMode.Left && r < neighbour.Position)                                      || (leftRightMode == LeftRightMode.Right && r > neighbour.Position)))                              {                                  neighbour.Aligns[modeIndex] = vertex;                                  neighbour.BlockWidths[modeIndex] = Math.Max(neighbour.BlockWidths[modeIndex]' vertex.Size.Width);                                  vertex.Roots[modeIndex] = neighbour.Roots[modeIndex];                                  vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                                  r = neighbour.Position;                              }                          }                      }                      else if (vertex.Type == VertexTypes.PVertex /*&& upperLowerEdges == UpperLowerEdges.Lower*/)                      {                          //align the segment of the PVertex                          vertex.Roots[modeIndex] = vertex.Segment.QVertex.Roots[modeIndex];                          vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                          r = vertex.Segment.Position;                      }                      else if (vertex.Type == VertexTypes.QVertex /*&& upperLowerEdges == UpperLowerEdges.Upper*/)                      {                          //align the segment of the QVertex                          vertex.Roots[modeIndex] = vertex.Segment.PVertex.Roots[modeIndex];                          vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                          r = vertex.Segment.Position;                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,DoAlignment,The following statement contains a magic number: for (int i = layerStart; i != layerEnd; i += layerStep)              {                  int r = leftRightMode == LeftRightMode.Left ? int.MinValue : int.MaxValue;                  var layer = _layers[i];                  int vertexStart' vertexEnd' vertexStep;                  if (leftRightMode == LeftRightMode.Left)                  {                      vertexStart = 0;                      vertexEnd = layer.Count;                      vertexStep = 1;                  }                  else                  {                      vertexStart = layer.Count - 1;                      vertexEnd = -1;                      vertexStep = -1;                  }                  for (int j = vertexStart; j != vertexEnd; j += vertexStep)                  {                      var vertex = layer[j];                      if (vertex.Type == VertexTypes.Original                          || vertex.Type == VertexTypes.RVertex                          || (vertex.Type == VertexTypes.PVertex && upperLowerEdges == UpperLowerEdges.Upper)                          || (vertex.Type == VertexTypes.QVertex && upperLowerEdges == UpperLowerEdges.Lower))                      {                          List<SugiEdge> neighbourEdges = null;                          neighbourEdges = upperLowerEdges == UpperLowerEdges.Upper                              ? _graph.InEdges(vertex).OrderBy(e => e.Source.Position).ToList()                              : _graph.OutEdges(vertex).OrderBy(e => e.Target.Position).ToList();                          if (neighbourEdges.Count <= 0)                              continue;                            int c1 = (int)Math.Floor((neighbourEdges.Count + 1) / 2.0) - 1;                          int c2 = (int)Math.Ceiling((neighbourEdges.Count + 1) / 2.0) - 1;                          int[] medians = null;                          if (c1 == c2)                          {                              medians = new int[1] { c1 };                          }                          else                          {                              medians = leftRightMode == LeftRightMode.Left                                  ? new int[2] { c1' c2 }                                  : new int[2] { c2' c1 };                          }                          for (int m = 0; m < medians.Length; m++)                          {                              if (vertex.Aligns[modeIndex] != vertex)                                  continue;                              var edge = neighbourEdges[medians[m]];                              if (edge.Marked)                                  Debug.WriteLine("Edge marked: " + edge.Source.OriginalVertex + "' " + edge.Target.OriginalVertex);                              var neighbour = edge.OtherVertex(vertex);                              if (!edge.Marked &&                                  ((leftRightMode == LeftRightMode.Left && r < neighbour.Position)                                      || (leftRightMode == LeftRightMode.Right && r > neighbour.Position)))                              {                                  neighbour.Aligns[modeIndex] = vertex;                                  neighbour.BlockWidths[modeIndex] = Math.Max(neighbour.BlockWidths[modeIndex]' vertex.Size.Width);                                  vertex.Roots[modeIndex] = neighbour.Roots[modeIndex];                                  vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                                  r = neighbour.Position;                              }                          }                      }                      else if (vertex.Type == VertexTypes.PVertex /*&& upperLowerEdges == UpperLowerEdges.Lower*/)                      {                          //align the segment of the PVertex                          vertex.Roots[modeIndex] = vertex.Segment.QVertex.Roots[modeIndex];                          vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                          r = vertex.Segment.Position;                      }                      else if (vertex.Type == VertexTypes.QVertex /*&& upperLowerEdges == UpperLowerEdges.Upper*/)                      {                          //align the segment of the QVertex                          vertex.Roots[modeIndex] = vertex.Segment.PVertex.Roots[modeIndex];                          vertex.Aligns[modeIndex] = vertex.Roots[modeIndex];                          r = vertex.Segment.Position;                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaDirtyPhase,The following statement contains a magic number: if ( _layers.Count < 2 )                  return;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaDirtyPhase,The following statement contains a magic number: SugiyamaPhase1Sweep( _layers.Count - 2' -1' -1' BaryCenter.Down' dirty' byRealPosition );
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1,The following statement contains a magic number: if ( _layers.Count < 2 ) return false;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1,The following statement contains a magic number: bool sweepUpOptimized = SugiyamaPhase1Sweep( startLayerIndex == -1 ? _layers.Count - 2 : startLayerIndex' -1' -1' BaryCenter.Down' dirty' ByRealPosition );
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase2,The following statement contains a magic number: unorderedLayerIndex = SugiyamaPhase2Sweep( _layers.Count - 2' -1' -1' BaryCenter.Down' byRealPosition );
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CalculateOverlap,The following statement contains a magic number: return Math.Max( 0' ( ( b.Size.Width + a.Size.Width ) * 0.5 + plusGap + Parameters.HorizontalGap ) - ( b.RealPosition.X - a.RealPosition.X ) );
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach ( var v in from vertex in layer                                 orderby vertex.Priority ascending' vertex.SubPriority ascending                                 select vertex )              {                  //first set the new position                  v.RealPosition.X = v.Measure;                    //check if there's any overlap between the actual vertex and the vertices which position has already been set                  SugiVertex v1 = v;                  var alreadySetVertices = layer.Where( vertex => ( !double.IsNaN( vertex.RealPosition.X ) && vertex != v1 ) ).ToArray();                    if ( alreadySetVertices.Length == 0 )                  {                      //there can't be any overlap                      continue;                  }                    //get the index of the 'v' vertex between the vertices which position has already been set                  int indexOfV;                  for ( indexOfV = 0;                        indexOfV < alreadySetVertices.Length && alreadySetVertices[indexOfV].Position < v.Position;                        indexOfV++ ) { }                    SugiVertex leftNeighbor = null' rightNeighbor = null;                  double leftOverlap = 0' rightOverlap = 0;                    //check the overlap with vertex on the left                  if ( indexOfV > 0 )                  {                      leftNeighbor = alreadySetVertices[indexOfV - 1];                      leftOverlap = CalculateOverlap( leftNeighbor' v );                  }                  if ( indexOfV < alreadySetVertices.Length )                  {                      rightNeighbor = alreadySetVertices[indexOfV];                      rightOverlap = CalculateOverlap( v' rightNeighbor );                  }                    // ReSharper disable PossibleNullReferenceException                  //only one neighbor overlaps                  if ( leftOverlap > 0 && rightOverlap == 0 )                  {                      if ( leftNeighbor.Priority == v.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          if ( rightNeighbor != null )                              rightOverlap = CalculateOverlap( v' rightNeighbor' leftMove );                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          if ( rightOverlap > 0 )                          {                              if ( v.Priority == rightNeighbor.Priority )                              {                                  double rightMove = rightOverlap * 0.5;                                  rightNeighbor.RealPosition.X += rightMove;                                  v.RealPosition.X -= rightMove;                                  leftNeighbor.RealPosition.X -= rightMove;                              }                              else                              {                                  rightNeighbor.RealPosition.X += rightOverlap;                              }                          }                      }                      else                      {                          leftNeighbor.RealPosition.X -= leftOverlap;                      }                  }                  else if ( leftOverlap == 0 && rightOverlap > 0 )                  {                      if ( v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          if ( leftNeighbor != null )                              leftOverlap = CalculateOverlap( leftNeighbor' v' rightMove );                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          if ( leftOverlap > 0 )                          {                              if ( leftNeighbor.Priority == v.Priority )                              {                                  double leftMove = leftOverlap * 0.5;                                  leftNeighbor.RealPosition.X -= leftMove;                                  v.RealPosition.X += leftMove;                                  rightNeighbor.RealPosition.X += leftMove;                              }                              else                              {                                  leftNeighbor.RealPosition.X -= leftOverlap;                              }                          }                      }                      else                      {                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  else if ( leftOverlap > 0 && rightOverlap > 0 )                  {                      //if both neighbor overlapped                      //priorities equals' 1 priority lower' 2 priority lower                      if ( leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          leftNeighbor.RealPosition.X -= ( leftOverlap + rightMove );                      }                      else if ( leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          rightNeighbor.RealPosition.X = ( rightOverlap + leftMove );                      }                      else                      {                          //priorities of the neighbors are lower' or equal                          leftNeighbor.RealPosition.X -= leftOverlap;                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  // ReSharper restore PossibleNullReferenceException                    //the vertices on the left side of the leftNeighbor will be moved' if they overlap                  if ( leftOverlap > 0 )                      for ( int index = indexOfV - 1;                            index > 0                            && ( leftOverlap = CalculateOverlap( alreadySetVertices[index - 1]' alreadySetVertices[index] ) ) > 0;                            index-- )                      {                          alreadySetVertices[index - 1].RealPosition.X -= leftOverlap;                      }                    //the vertices on the right side of the rightNeighbor will be moved' if they overlap                  if ( rightOverlap > 0 )                      for ( int index = indexOfV;                            index < alreadySetVertices.Length - 1                            && ( rightOverlap = CalculateOverlap( alreadySetVertices[index]' alreadySetVertices[index + 1] ) ) > 0;                            index++ )                      {                          alreadySetVertices[index + 1].RealPosition.X += rightOverlap;                      }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach ( var v in from vertex in layer                                 orderby vertex.Priority ascending' vertex.SubPriority ascending                                 select vertex )              {                  //first set the new position                  v.RealPosition.X = v.Measure;                    //check if there's any overlap between the actual vertex and the vertices which position has already been set                  SugiVertex v1 = v;                  var alreadySetVertices = layer.Where( vertex => ( !double.IsNaN( vertex.RealPosition.X ) && vertex != v1 ) ).ToArray();                    if ( alreadySetVertices.Length == 0 )                  {                      //there can't be any overlap                      continue;                  }                    //get the index of the 'v' vertex between the vertices which position has already been set                  int indexOfV;                  for ( indexOfV = 0;                        indexOfV < alreadySetVertices.Length && alreadySetVertices[indexOfV].Position < v.Position;                        indexOfV++ ) { }                    SugiVertex leftNeighbor = null' rightNeighbor = null;                  double leftOverlap = 0' rightOverlap = 0;                    //check the overlap with vertex on the left                  if ( indexOfV > 0 )                  {                      leftNeighbor = alreadySetVertices[indexOfV - 1];                      leftOverlap = CalculateOverlap( leftNeighbor' v );                  }                  if ( indexOfV < alreadySetVertices.Length )                  {                      rightNeighbor = alreadySetVertices[indexOfV];                      rightOverlap = CalculateOverlap( v' rightNeighbor );                  }                    // ReSharper disable PossibleNullReferenceException                  //only one neighbor overlaps                  if ( leftOverlap > 0 && rightOverlap == 0 )                  {                      if ( leftNeighbor.Priority == v.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          if ( rightNeighbor != null )                              rightOverlap = CalculateOverlap( v' rightNeighbor' leftMove );                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          if ( rightOverlap > 0 )                          {                              if ( v.Priority == rightNeighbor.Priority )                              {                                  double rightMove = rightOverlap * 0.5;                                  rightNeighbor.RealPosition.X += rightMove;                                  v.RealPosition.X -= rightMove;                                  leftNeighbor.RealPosition.X -= rightMove;                              }                              else                              {                                  rightNeighbor.RealPosition.X += rightOverlap;                              }                          }                      }                      else                      {                          leftNeighbor.RealPosition.X -= leftOverlap;                      }                  }                  else if ( leftOverlap == 0 && rightOverlap > 0 )                  {                      if ( v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          if ( leftNeighbor != null )                              leftOverlap = CalculateOverlap( leftNeighbor' v' rightMove );                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          if ( leftOverlap > 0 )                          {                              if ( leftNeighbor.Priority == v.Priority )                              {                                  double leftMove = leftOverlap * 0.5;                                  leftNeighbor.RealPosition.X -= leftMove;                                  v.RealPosition.X += leftMove;                                  rightNeighbor.RealPosition.X += leftMove;                              }                              else                              {                                  leftNeighbor.RealPosition.X -= leftOverlap;                              }                          }                      }                      else                      {                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  else if ( leftOverlap > 0 && rightOverlap > 0 )                  {                      //if both neighbor overlapped                      //priorities equals' 1 priority lower' 2 priority lower                      if ( leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          leftNeighbor.RealPosition.X -= ( leftOverlap + rightMove );                      }                      else if ( leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          rightNeighbor.RealPosition.X = ( rightOverlap + leftMove );                      }                      else                      {                          //priorities of the neighbors are lower' or equal                          leftNeighbor.RealPosition.X -= leftOverlap;                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  // ReSharper restore PossibleNullReferenceException                    //the vertices on the left side of the leftNeighbor will be moved' if they overlap                  if ( leftOverlap > 0 )                      for ( int index = indexOfV - 1;                            index > 0                            && ( leftOverlap = CalculateOverlap( alreadySetVertices[index - 1]' alreadySetVertices[index] ) ) > 0;                            index-- )                      {                          alreadySetVertices[index - 1].RealPosition.X -= leftOverlap;                      }                    //the vertices on the right side of the rightNeighbor will be moved' if they overlap                  if ( rightOverlap > 0 )                      for ( int index = indexOfV;                            index < alreadySetVertices.Length - 1                            && ( rightOverlap = CalculateOverlap( alreadySetVertices[index]' alreadySetVertices[index + 1] ) ) > 0;                            index++ )                      {                          alreadySetVertices[index + 1].RealPosition.X += rightOverlap;                      }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach ( var v in from vertex in layer                                 orderby vertex.Priority ascending' vertex.SubPriority ascending                                 select vertex )              {                  //first set the new position                  v.RealPosition.X = v.Measure;                    //check if there's any overlap between the actual vertex and the vertices which position has already been set                  SugiVertex v1 = v;                  var alreadySetVertices = layer.Where( vertex => ( !double.IsNaN( vertex.RealPosition.X ) && vertex != v1 ) ).ToArray();                    if ( alreadySetVertices.Length == 0 )                  {                      //there can't be any overlap                      continue;                  }                    //get the index of the 'v' vertex between the vertices which position has already been set                  int indexOfV;                  for ( indexOfV = 0;                        indexOfV < alreadySetVertices.Length && alreadySetVertices[indexOfV].Position < v.Position;                        indexOfV++ ) { }                    SugiVertex leftNeighbor = null' rightNeighbor = null;                  double leftOverlap = 0' rightOverlap = 0;                    //check the overlap with vertex on the left                  if ( indexOfV > 0 )                  {                      leftNeighbor = alreadySetVertices[indexOfV - 1];                      leftOverlap = CalculateOverlap( leftNeighbor' v );                  }                  if ( indexOfV < alreadySetVertices.Length )                  {                      rightNeighbor = alreadySetVertices[indexOfV];                      rightOverlap = CalculateOverlap( v' rightNeighbor );                  }                    // ReSharper disable PossibleNullReferenceException                  //only one neighbor overlaps                  if ( leftOverlap > 0 && rightOverlap == 0 )                  {                      if ( leftNeighbor.Priority == v.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          if ( rightNeighbor != null )                              rightOverlap = CalculateOverlap( v' rightNeighbor' leftMove );                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          if ( rightOverlap > 0 )                          {                              if ( v.Priority == rightNeighbor.Priority )                              {                                  double rightMove = rightOverlap * 0.5;                                  rightNeighbor.RealPosition.X += rightMove;                                  v.RealPosition.X -= rightMove;                                  leftNeighbor.RealPosition.X -= rightMove;                              }                              else                              {                                  rightNeighbor.RealPosition.X += rightOverlap;                              }                          }                      }                      else                      {                          leftNeighbor.RealPosition.X -= leftOverlap;                      }                  }                  else if ( leftOverlap == 0 && rightOverlap > 0 )                  {                      if ( v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          if ( leftNeighbor != null )                              leftOverlap = CalculateOverlap( leftNeighbor' v' rightMove );                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          if ( leftOverlap > 0 )                          {                              if ( leftNeighbor.Priority == v.Priority )                              {                                  double leftMove = leftOverlap * 0.5;                                  leftNeighbor.RealPosition.X -= leftMove;                                  v.RealPosition.X += leftMove;                                  rightNeighbor.RealPosition.X += leftMove;                              }                              else                              {                                  leftNeighbor.RealPosition.X -= leftOverlap;                              }                          }                      }                      else                      {                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  else if ( leftOverlap > 0 && rightOverlap > 0 )                  {                      //if both neighbor overlapped                      //priorities equals' 1 priority lower' 2 priority lower                      if ( leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          leftNeighbor.RealPosition.X -= ( leftOverlap + rightMove );                      }                      else if ( leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          rightNeighbor.RealPosition.X = ( rightOverlap + leftMove );                      }                      else                      {                          //priorities of the neighbors are lower' or equal                          leftNeighbor.RealPosition.X -= leftOverlap;                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  // ReSharper restore PossibleNullReferenceException                    //the vertices on the left side of the leftNeighbor will be moved' if they overlap                  if ( leftOverlap > 0 )                      for ( int index = indexOfV - 1;                            index > 0                            && ( leftOverlap = CalculateOverlap( alreadySetVertices[index - 1]' alreadySetVertices[index] ) ) > 0;                            index-- )                      {                          alreadySetVertices[index - 1].RealPosition.X -= leftOverlap;                      }                    //the vertices on the right side of the rightNeighbor will be moved' if they overlap                  if ( rightOverlap > 0 )                      for ( int index = indexOfV;                            index < alreadySetVertices.Length - 1                            && ( rightOverlap = CalculateOverlap( alreadySetVertices[index]' alreadySetVertices[index + 1] ) ) > 0;                            index++ )                      {                          alreadySetVertices[index + 1].RealPosition.X += rightOverlap;                      }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach ( var v in from vertex in layer                                 orderby vertex.Priority ascending' vertex.SubPriority ascending                                 select vertex )              {                  //first set the new position                  v.RealPosition.X = v.Measure;                    //check if there's any overlap between the actual vertex and the vertices which position has already been set                  SugiVertex v1 = v;                  var alreadySetVertices = layer.Where( vertex => ( !double.IsNaN( vertex.RealPosition.X ) && vertex != v1 ) ).ToArray();                    if ( alreadySetVertices.Length == 0 )                  {                      //there can't be any overlap                      continue;                  }                    //get the index of the 'v' vertex between the vertices which position has already been set                  int indexOfV;                  for ( indexOfV = 0;                        indexOfV < alreadySetVertices.Length && alreadySetVertices[indexOfV].Position < v.Position;                        indexOfV++ ) { }                    SugiVertex leftNeighbor = null' rightNeighbor = null;                  double leftOverlap = 0' rightOverlap = 0;                    //check the overlap with vertex on the left                  if ( indexOfV > 0 )                  {                      leftNeighbor = alreadySetVertices[indexOfV - 1];                      leftOverlap = CalculateOverlap( leftNeighbor' v );                  }                  if ( indexOfV < alreadySetVertices.Length )                  {                      rightNeighbor = alreadySetVertices[indexOfV];                      rightOverlap = CalculateOverlap( v' rightNeighbor );                  }                    // ReSharper disable PossibleNullReferenceException                  //only one neighbor overlaps                  if ( leftOverlap > 0 && rightOverlap == 0 )                  {                      if ( leftNeighbor.Priority == v.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          if ( rightNeighbor != null )                              rightOverlap = CalculateOverlap( v' rightNeighbor' leftMove );                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          if ( rightOverlap > 0 )                          {                              if ( v.Priority == rightNeighbor.Priority )                              {                                  double rightMove = rightOverlap * 0.5;                                  rightNeighbor.RealPosition.X += rightMove;                                  v.RealPosition.X -= rightMove;                                  leftNeighbor.RealPosition.X -= rightMove;                              }                              else                              {                                  rightNeighbor.RealPosition.X += rightOverlap;                              }                          }                      }                      else                      {                          leftNeighbor.RealPosition.X -= leftOverlap;                      }                  }                  else if ( leftOverlap == 0 && rightOverlap > 0 )                  {                      if ( v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          if ( leftNeighbor != null )                              leftOverlap = CalculateOverlap( leftNeighbor' v' rightMove );                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          if ( leftOverlap > 0 )                          {                              if ( leftNeighbor.Priority == v.Priority )                              {                                  double leftMove = leftOverlap * 0.5;                                  leftNeighbor.RealPosition.X -= leftMove;                                  v.RealPosition.X += leftMove;                                  rightNeighbor.RealPosition.X += leftMove;                              }                              else                              {                                  leftNeighbor.RealPosition.X -= leftOverlap;                              }                          }                      }                      else                      {                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  else if ( leftOverlap > 0 && rightOverlap > 0 )                  {                      //if both neighbor overlapped                      //priorities equals' 1 priority lower' 2 priority lower                      if ( leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          leftNeighbor.RealPosition.X -= ( leftOverlap + rightMove );                      }                      else if ( leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          rightNeighbor.RealPosition.X = ( rightOverlap + leftMove );                      }                      else                      {                          //priorities of the neighbors are lower' or equal                          leftNeighbor.RealPosition.X -= leftOverlap;                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  // ReSharper restore PossibleNullReferenceException                    //the vertices on the left side of the leftNeighbor will be moved' if they overlap                  if ( leftOverlap > 0 )                      for ( int index = indexOfV - 1;                            index > 0                            && ( leftOverlap = CalculateOverlap( alreadySetVertices[index - 1]' alreadySetVertices[index] ) ) > 0;                            index-- )                      {                          alreadySetVertices[index - 1].RealPosition.X -= leftOverlap;                      }                    //the vertices on the right side of the rightNeighbor will be moved' if they overlap                  if ( rightOverlap > 0 )                      for ( int index = indexOfV;                            index < alreadySetVertices.Length - 1                            && ( rightOverlap = CalculateOverlap( alreadySetVertices[index]' alreadySetVertices[index + 1] ) ) > 0;                            index++ )                      {                          alreadySetVertices[index + 1].RealPosition.X += rightOverlap;                      }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach ( var v in from vertex in layer                                 orderby vertex.Priority ascending' vertex.SubPriority ascending                                 select vertex )              {                  //first set the new position                  v.RealPosition.X = v.Measure;                    //check if there's any overlap between the actual vertex and the vertices which position has already been set                  SugiVertex v1 = v;                  var alreadySetVertices = layer.Where( vertex => ( !double.IsNaN( vertex.RealPosition.X ) && vertex != v1 ) ).ToArray();                    if ( alreadySetVertices.Length == 0 )                  {                      //there can't be any overlap                      continue;                  }                    //get the index of the 'v' vertex between the vertices which position has already been set                  int indexOfV;                  for ( indexOfV = 0;                        indexOfV < alreadySetVertices.Length && alreadySetVertices[indexOfV].Position < v.Position;                        indexOfV++ ) { }                    SugiVertex leftNeighbor = null' rightNeighbor = null;                  double leftOverlap = 0' rightOverlap = 0;                    //check the overlap with vertex on the left                  if ( indexOfV > 0 )                  {                      leftNeighbor = alreadySetVertices[indexOfV - 1];                      leftOverlap = CalculateOverlap( leftNeighbor' v );                  }                  if ( indexOfV < alreadySetVertices.Length )                  {                      rightNeighbor = alreadySetVertices[indexOfV];                      rightOverlap = CalculateOverlap( v' rightNeighbor );                  }                    // ReSharper disable PossibleNullReferenceException                  //only one neighbor overlaps                  if ( leftOverlap > 0 && rightOverlap == 0 )                  {                      if ( leftNeighbor.Priority == v.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          if ( rightNeighbor != null )                              rightOverlap = CalculateOverlap( v' rightNeighbor' leftMove );                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          if ( rightOverlap > 0 )                          {                              if ( v.Priority == rightNeighbor.Priority )                              {                                  double rightMove = rightOverlap * 0.5;                                  rightNeighbor.RealPosition.X += rightMove;                                  v.RealPosition.X -= rightMove;                                  leftNeighbor.RealPosition.X -= rightMove;                              }                              else                              {                                  rightNeighbor.RealPosition.X += rightOverlap;                              }                          }                      }                      else                      {                          leftNeighbor.RealPosition.X -= leftOverlap;                      }                  }                  else if ( leftOverlap == 0 && rightOverlap > 0 )                  {                      if ( v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          if ( leftNeighbor != null )                              leftOverlap = CalculateOverlap( leftNeighbor' v' rightMove );                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          if ( leftOverlap > 0 )                          {                              if ( leftNeighbor.Priority == v.Priority )                              {                                  double leftMove = leftOverlap * 0.5;                                  leftNeighbor.RealPosition.X -= leftMove;                                  v.RealPosition.X += leftMove;                                  rightNeighbor.RealPosition.X += leftMove;                              }                              else                              {                                  leftNeighbor.RealPosition.X -= leftOverlap;                              }                          }                      }                      else                      {                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  else if ( leftOverlap > 0 && rightOverlap > 0 )                  {                      //if both neighbor overlapped                      //priorities equals' 1 priority lower' 2 priority lower                      if ( leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          leftNeighbor.RealPosition.X -= ( leftOverlap + rightMove );                      }                      else if ( leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          rightNeighbor.RealPosition.X = ( rightOverlap + leftMove );                      }                      else                      {                          //priorities of the neighbors are lower' or equal                          leftNeighbor.RealPosition.X -= leftOverlap;                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  // ReSharper restore PossibleNullReferenceException                    //the vertices on the left side of the leftNeighbor will be moved' if they overlap                  if ( leftOverlap > 0 )                      for ( int index = indexOfV - 1;                            index > 0                            && ( leftOverlap = CalculateOverlap( alreadySetVertices[index - 1]' alreadySetVertices[index] ) ) > 0;                            index-- )                      {                          alreadySetVertices[index - 1].RealPosition.X -= leftOverlap;                      }                    //the vertices on the right side of the rightNeighbor will be moved' if they overlap                  if ( rightOverlap > 0 )                      for ( int index = indexOfV;                            index < alreadySetVertices.Length - 1                            && ( rightOverlap = CalculateOverlap( alreadySetVertices[index]' alreadySetVertices[index + 1] ) ) > 0;                            index++ )                      {                          alreadySetVertices[index + 1].RealPosition.X += rightOverlap;                      }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach ( var v in from vertex in layer                                 orderby vertex.Priority ascending' vertex.SubPriority ascending                                 select vertex )              {                  //first set the new position                  v.RealPosition.X = v.Measure;                    //check if there's any overlap between the actual vertex and the vertices which position has already been set                  SugiVertex v1 = v;                  var alreadySetVertices = layer.Where( vertex => ( !double.IsNaN( vertex.RealPosition.X ) && vertex != v1 ) ).ToArray();                    if ( alreadySetVertices.Length == 0 )                  {                      //there can't be any overlap                      continue;                  }                    //get the index of the 'v' vertex between the vertices which position has already been set                  int indexOfV;                  for ( indexOfV = 0;                        indexOfV < alreadySetVertices.Length && alreadySetVertices[indexOfV].Position < v.Position;                        indexOfV++ ) { }                    SugiVertex leftNeighbor = null' rightNeighbor = null;                  double leftOverlap = 0' rightOverlap = 0;                    //check the overlap with vertex on the left                  if ( indexOfV > 0 )                  {                      leftNeighbor = alreadySetVertices[indexOfV - 1];                      leftOverlap = CalculateOverlap( leftNeighbor' v );                  }                  if ( indexOfV < alreadySetVertices.Length )                  {                      rightNeighbor = alreadySetVertices[indexOfV];                      rightOverlap = CalculateOverlap( v' rightNeighbor );                  }                    // ReSharper disable PossibleNullReferenceException                  //only one neighbor overlaps                  if ( leftOverlap > 0 && rightOverlap == 0 )                  {                      if ( leftNeighbor.Priority == v.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          if ( rightNeighbor != null )                              rightOverlap = CalculateOverlap( v' rightNeighbor' leftMove );                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          if ( rightOverlap > 0 )                          {                              if ( v.Priority == rightNeighbor.Priority )                              {                                  double rightMove = rightOverlap * 0.5;                                  rightNeighbor.RealPosition.X += rightMove;                                  v.RealPosition.X -= rightMove;                                  leftNeighbor.RealPosition.X -= rightMove;                              }                              else                              {                                  rightNeighbor.RealPosition.X += rightOverlap;                              }                          }                      }                      else                      {                          leftNeighbor.RealPosition.X -= leftOverlap;                      }                  }                  else if ( leftOverlap == 0 && rightOverlap > 0 )                  {                      if ( v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          if ( leftNeighbor != null )                              leftOverlap = CalculateOverlap( leftNeighbor' v' rightMove );                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          if ( leftOverlap > 0 )                          {                              if ( leftNeighbor.Priority == v.Priority )                              {                                  double leftMove = leftOverlap * 0.5;                                  leftNeighbor.RealPosition.X -= leftMove;                                  v.RealPosition.X += leftMove;                                  rightNeighbor.RealPosition.X += leftMove;                              }                              else                              {                                  leftNeighbor.RealPosition.X -= leftOverlap;                              }                          }                      }                      else                      {                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  else if ( leftOverlap > 0 && rightOverlap > 0 )                  {                      //if both neighbor overlapped                      //priorities equals' 1 priority lower' 2 priority lower                      if ( leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority )                      {                          double rightMove = rightOverlap * 0.5;                          rightNeighbor.RealPosition.X += rightMove;                          v.RealPosition.X -= rightMove;                          leftNeighbor.RealPosition.X -= ( leftOverlap + rightMove );                      }                      else if ( leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority )                      {                          double leftMove = leftOverlap * 0.5;                          leftNeighbor.RealPosition.X -= leftMove;                          v.RealPosition.X += leftMove;                          rightNeighbor.RealPosition.X = ( rightOverlap + leftMove );                      }                      else                      {                          //priorities of the neighbors are lower' or equal                          leftNeighbor.RealPosition.X -= leftOverlap;                          rightNeighbor.RealPosition.X += rightOverlap;                      }                  }                  // ReSharper restore PossibleNullReferenceException                    //the vertices on the left side of the leftNeighbor will be moved' if they overlap                  if ( leftOverlap > 0 )                      for ( int index = indexOfV - 1;                            index > 0                            && ( leftOverlap = CalculateOverlap( alreadySetVertices[index - 1]' alreadySetVertices[index] ) ) > 0;                            index-- )                      {                          alreadySetVertices[index - 1].RealPosition.X -= leftOverlap;                      }                    //the vertices on the right side of the rightNeighbor will be moved' if they overlap                  if ( rightOverlap > 0 )                      for ( int index = indexOfV;                            index < alreadySetVertices.Length - 1                            && ( rightOverlap = CalculateOverlap( alreadySetVertices[index]' alreadySetVertices[index + 1] ) ) > 0;                            index++ )                      {                          alreadySetVertices[index + 1].RealPosition.X += rightOverlap;                      }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignment,The following statement contains a magic number: if ( _layers.Count > 1 )              {                  HorizontalPositionAssignmentSweep( 1' _layers.Count' 1' BaryCenter.Up );                  HorizontalPositionAssignmentSweep( _layers.Count - 2' -1' -1' BaryCenter.Down );              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: for ( int i = 0; i < _layers.Count; i++ )              {                  double pos = 0;                  double layerHeight = _layers[i].Height;                  foreach ( var v in _layers[i] )                  {                      v.RealPosition.X = pos;                      v.RealPosition.Y =                          ( ( i == 0 )                              ? ( layerHeight - v.Size.Height )                              : verticalPos + layerHeight * (float)0.5 );                        pos += v.Size.Width + Parameters.HorizontalGap;                  }                  verticalPos += layerHeight + Parameters.VerticalGap;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: if ( shouldTranslate )              {                  foreach ( var v in _graph.Vertices )                  {                      if ( double.IsNaN( v.RealPosition.X ) || double.IsNaN( v.RealPosition.Y ) )                          continue;                        translation.X = Math.Min( v.RealPosition.X' translation.X );                      translation.Y = Math.Min( v.RealPosition.Y' translation.Y );                  }                  translation *= -1;                  translation.X += Parameters.VerticalGap / 2;                  translation.Y += Parameters.HorizontalGap / 2;                    //translate with the topLeft position                  foreach ( var v in _graph.Vertices )                      v.RealPosition += translation;              }              else              {                  translation = new Vector( 0' 0 );              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: if ( shouldTranslate )              {                  foreach ( var v in _graph.Vertices )                  {                      if ( double.IsNaN( v.RealPosition.X ) || double.IsNaN( v.RealPosition.Y ) )                          continue;                        translation.X = Math.Min( v.RealPosition.X' translation.X );                      translation.Y = Math.Min( v.RealPosition.Y' translation.Y );                  }                  translation *= -1;                  translation.X += Parameters.VerticalGap / 2;                  translation.Y += Parameters.HorizontalGap / 2;                    //translate with the topLeft position                  foreach ( var v in _graph.Vertices )                      v.RealPosition += translation;              }              else              {                  translation = new Vector( 0' 0 );              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: foreach ( var v in _graph.Vertices )              {                  if ( v.IsDummyVertex )                      continue;                    Point pos = v.RealPosition;                  if ( !shouldTranslate )                  {                      pos.X += v.Size.Width * 0.5 + translation.X;                      pos.Y += v.Size.Height * 0.5 + translation.Y;                  }                  VertexPositions[v.Original] = pos;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: foreach ( var v in _graph.Vertices )              {                  if ( v.IsDummyVertex )                      continue;                    Point pos = v.RealPosition;                  if ( !shouldTranslate )                  {                      pos.X += v.Size.Width * 0.5 + translation.X;                      pos.Y += v.Size.Height * 0.5 + translation.Y;                  }                  VertexPositions[v.Original] = pos;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: _statusInPercent = 100;
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,VertexLayer,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.VertexLayer.cs,CalculateSubPriorities,The following statement contains a magic number: while ( startIndex < orderedVertices.Length )  				{  					int endIndex = startIndex + 1;    					//get the vertices with the same priorities and measure  					while ( endIndex < orderedVertices.Length  							&& orderedVertices[startIndex].Priority == orderedVertices[endIndex].Priority  							&& orderedVertices[startIndex].Measure == orderedVertices[endIndex].Measure )  						endIndex++;  					endIndex--;    					//set the subpriorities  					int count = endIndex - startIndex + 1;  					var border = (int)Math.Ceiling( count / (float)2.0 );  					int subPriority = count - border;  					for ( int i = 0; i < count; i++ )  					{  						orderedVertices[startIndex + i].SubPriority = count - Math.Abs( subPriority );  						subPriority--;  					}    					//go to the next group of vertices with the same priorities  					startIndex = endIndex + 1;  				}
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,AlternatingLayer,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.AlternatingLayer.cs,EnsurePositions,The following statement contains a magic number: for (int i = 1; i < this.Count; i += 2)                  {                      var precedingContainer = this[i - 1] as SegmentContainer;                      var vertex = this[i] as SugiVertex;                      if (i == 1)                      {                          vertex.Position = precedingContainer.Count;                      }                      else                      {                          var previousVertex = this[i - 2] as SugiVertex;                          vertex.Position = previousVertex.Position + precedingContainer.Count + 1;                      }                  }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,AlternatingLayer,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.AlternatingLayer.cs,EnsurePositions,The following statement contains a magic number: for (int i = 1; i < this.Count; i += 2)                  {                      var precedingContainer = this[i - 1] as SegmentContainer;                      var vertex = this[i] as SugiVertex;                      if (i == 1)                      {                          vertex.Position = precedingContainer.Count;                      }                      else                      {                          var previousVertex = this[i - 2] as SugiVertex;                          vertex.Position = previousVertex.Position + precedingContainer.Count + 1;                      }                  }
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,AlternatingLayer,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.AlternatingLayer.cs,EnsurePositions,The following statement contains a magic number: for (int i = 0; i < this.Count; i += 2)                  {                      var container = this[i] as SegmentContainer;                      if (i == 0)                      {                          container.Position = 0;                      }                      else                      {                          var precedingVertex = this[i - 1] as SugiVertex;                          container.Position = precedingVertex.Position + 1;                      }                  }
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: while (firstIndex < pairCount)                  firstIndex *= 2;
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: int treeSize = 2 * firstIndex - 1;
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: foreach (var list in radixByFirst)              {                  if (list == null)                      continue;                    foreach (var pair in list)                  {                      index = pair.Second + firstIndex;                      tree[index] += pair.Weight;                      while (index > 0)                      {                          if (index % 2 > 0)                              crossCount += tree[index + 1] * pair.Weight;                          index = (index - 1) / 2;                          tree[index] += pair.Weight;                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: foreach (var list in radixByFirst)              {                  if (list == null)                      continue;                    foreach (var pair in list)                  {                      index = pair.Second + firstIndex;                      tree[index] += pair.Weight;                      while (index > 0)                      {                          if (index % 2 > 0)                              crossCount += tree[index + 1] * pair.Weight;                          index = (index - 1) / 2;                          tree[index] += pair.Weight;                      }                  }              }
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: double[] sides = new double[4];
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides[0] = (s.X - size.Width / 2.0 - t.X) / (s.X - t.X);
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides[1] = (s.Y - size.Height / 2.0 - t.Y) / (s.Y - t.Y);
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides[2] = (s.X + size.Width / 2.0 - t.X) / (s.X - t.X);
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides[2] = (s.X + size.Width / 2.0 - t.X) / (s.X - t.X);
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides[3] = (s.Y + size.Height / 2.0 - t.Y) / (s.Y - t.Y);
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides[3] = (s.Y + size.Height / 2.0 - t.Y) / (s.Y - t.Y);
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  if (sides[i] <= 1)                      fi = Math.Max(fi' sides[i]);              }
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: if (fi == 0)              {                  fi = double.PositiveInfinity;                  for (int i = 0; i < 4; i++)                      fi = Math.Min(fi' Math.Abs(sides[i]));                  fi *= -1;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters is BoundedFRLayoutParameters)              {                  var param = Parameters as BoundedFRLayoutParameters;                  InitializeWithRandomPositions(param.Width' param.Height);                  _maxWidth = param.Width;                  _maxHeight = param.Height;              }              else              {                  InitializeWithRandomPositions(10.0' 10.0);              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters is BoundedFRLayoutParameters)              {                  var param = Parameters as BoundedFRLayoutParameters;                  InitializeWithRandomPositions(param.Width' param.Height);                  _maxWidth = param.Width;                  _maxHeight = param.Height;              }              else              {                  InitializeWithRandomPositions(10.0' 10.0);              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: var minimalTemperature = Parameters.InitialTemperature*0.01;
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,IterateOne,The following statement contains a magic number: foreach (Edge e in VisitedGraph.Edges)              {                  Vertex source = e.Source;                  Vertex target = e.Target;                    //vonzσerυ szαmνtαsa a kιt pont kφzt                  Vector delta = VertexPositions[source] - VertexPositions[target];                  double length = Math.Max(delta.Length' double.Epsilon);                  delta = delta / length * Math.Pow(length' 2) / Parameters.ConstantOfAttraction;                    forces[source] -= delta;                  forces[target] += delta;              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int epoch = 0; epoch < Parameters.MaxEpoch; epoch++ )  			{  				Adjust();    				//Update Parameters  				double factor = Math.Exp( -1 * Parameters.CoolingFactor * ( 1.0 * epoch / Parameters.MaxEpoch ) );  				adaptation = Math.Max( Parameters.MinAdaption' factor * Parameters.InitialAdaption );  				if ( radius > Parameters.MinRadius && epoch % Parameters.RadiusConstantTime == 0 )  				{  					radius--;  				}    				//report  				if ( ReportOnIterationEndNeeded )  					OnIterationEnded( epoch' (double)epoch / (double)Parameters.MaxEpoch' "Iteration " + epoch + " finished."' true );                  else if (ReportOnProgressChangedNeeded)                      OnProgressChanged( (double)epoch / (double)Parameters.MaxEpoch * 100 );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,Adjust,The following statement contains a magic number: _tempPos.X = 0.1 * Parameters.Width + ( _rnd.NextDouble() * 0.8 * Parameters.Width );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,Adjust,The following statement contains a magic number: _tempPos.X = 0.1 * Parameters.Width + ( _rnd.NextDouble() * 0.8 * Parameters.Width );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,Adjust,The following statement contains a magic number: _tempPos.Y = 0.1 * Parameters.Height + ( _rnd.NextDouble() * 0.8 * Parameters.Height );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,Adjust,The following statement contains a magic number: _tempPos.Y = 0.1 * Parameters.Height + ( _rnd.NextDouble() * 0.8 * Parameters.Height );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,AdjustVertex,The following statement contains a magic number: while ( _queue.Count > 0 )  			{  				TVertex current = _queue.Dequeue();  				ISOMData currentVid = _isomDataDict[current];  				Point pos = VertexPositions[current];    				Vector force = _tempPos - pos;  				double factor = adaptation / Math.Pow( 2' currentVid.Distance );    				pos += factor * force;  				VertexPositions[current] = pos;    				//ha mιg a hatσkφrφn belόl van  				if ( currentVid.Distance < radius )  				{  					//akkor a szomszedokra is hatassal vagyunk  					foreach ( TVertex neighbour in VisitedGraph.GetNeighbours<TVertex' TEdge>( current ) )  					{  						ISOMData nvid = _isomDataDict[neighbour];  						if ( !nvid.Visited )  						{  							nvid.Visited = true;  							nvid.Distance = currentVid.Distance + 1;  							_queue.Enqueue( neighbour );  						}  					}  				}  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergyIfExchanged,The following statement contains a magic number: for ( int i = 0; i < vertices.Length - 1; i++ )              {                  for ( int j = i + 1; j < vertices.Length; j++ )                  {                      int ii = ( i == p ) ? q : i;                      int jj = ( j == q ) ? p : j;                        double l_ij = edgeLengths[i' j];                      double k_ij = springConstants[i' j];                      double dx = positions[ii].X - positions[jj].X;                      double dy = positions[ii].Y - positions[jj].Y;                        energy += k_ij / 2 * ( dx * dx + dy * dy + l_ij * l_ij -                                             2 * l_ij * Math.Sqrt( dx * dx + dy * dy ) );                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergyIfExchanged,The following statement contains a magic number: for ( int i = 0; i < vertices.Length - 1; i++ )              {                  for ( int j = i + 1; j < vertices.Length; j++ )                  {                      int ii = ( i == p ) ? q : i;                      int jj = ( j == q ) ? p : j;                        double l_ij = edgeLengths[i' j];                      double k_ij = springConstants[i' j];                      double dx = positions[ii].X - positions[jj].X;                      double dy = positions[ii].Y - positions[jj].Y;                        energy += k_ij / 2 * ( dx * dx + dy * dy + l_ij * l_ij -                                             2 * l_ij * Math.Sqrt( dx * dx + dy * dy ) );                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergy,The following statement contains a magic number: for ( int i = 0; i < vertices.Length - 1; i++ )              {                  for ( int j = i + 1; j < vertices.Length; j++ )                  {                      dist = distances[i' j];                      l_ij = edgeLengths[i' j];                      k_ij = springConstants[i' j];                        dx = positions[i].X - positions[j].X;                      dy = positions[i].Y - positions[j].Y;                        energy += k_ij / 2 * ( dx * dx + dy * dy + l_ij * l_ij -                                             2 * l_ij * Math.Sqrt( dx * dx + dy * dy ) );                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergy,The following statement contains a magic number: for ( int i = 0; i < vertices.Length - 1; i++ )              {                  for ( int j = i + 1; j < vertices.Length; j++ )                  {                      dist = distances[i' j];                      l_ij = edgeLengths[i' j];                      k_ij = springConstants[i' j];                        dx = positions[i].X - positions[j].X;                      dy = positions[i].Y - positions[j].Y;                        energy += k_ij / 2 * ( dx * dx + dy * dy + l_ij * l_ij -                                             2 * l_ij * Math.Sqrt( dx * dx + dy * dy ) );                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: for ( int i = 0; i < vertices.Length; i++ )              {                  if ( i != m )                  {                      //common things                      l = edgeLengths[m' i];                      k = springConstants[m' i];                      dx = positions[m].X - positions[i].X;                      dy = positions[m].Y - positions[i].Y;                        //distance between the points                      d = Math.Sqrt( dx * dx + dy * dy );                      ddd = Math.Pow( d' 3 );                        dxm += k * ( 1 - l / d ) * dx;                      dym += k * ( 1 - l / d ) * dy;                      //TODO isn't it wrong?                      d2xm += k * ( 1 - l * Math.Pow( dy' 2 ) / ddd );                      //d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );                      dxmdym += k * l * dx * dy / ddd;                      //d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );                      //TODO isn't it wrong?                      d2ym += k * ( 1 - l * Math.Pow( dx' 2 ) / ddd );                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: for ( int i = 0; i < vertices.Length; i++ )              {                  if ( i != m )                  {                      //common things                      l = edgeLengths[m' i];                      k = springConstants[m' i];                      dx = positions[m].X - positions[i].X;                      dy = positions[m].Y - positions[i].Y;                        //distance between the points                      d = Math.Sqrt( dx * dx + dy * dy );                      ddd = Math.Pow( d' 3 );                        dxm += k * ( 1 - l / d ) * dx;                      dym += k * ( 1 - l / d ) * dy;                      //TODO isn't it wrong?                      d2xm += k * ( 1 - l * Math.Pow( dy' 2 ) / ddd );                      //d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );                      dxmdym += k * l * dx * dy / ddd;                      //d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );                      //TODO isn't it wrong?                      d2ym += k * ( 1 - l * Math.Pow( dx' 2 ) / ddd );                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: for ( int i = 0; i < vertices.Length; i++ )              {                  if ( i != m )                  {                      //common things                      l = edgeLengths[m' i];                      k = springConstants[m' i];                      dx = positions[m].X - positions[i].X;                      dy = positions[m].Y - positions[i].Y;                        //distance between the points                      d = Math.Sqrt( dx * dx + dy * dy );                      ddd = Math.Pow( d' 3 );                        dxm += k * ( 1 - l / d ) * dx;                      dym += k * ( 1 - l / d ) * dy;                      //TODO isn't it wrong?                      d2xm += k * ( 1 - l * Math.Pow( dy' 2 ) / ddd );                      //d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );                      dxmdym += k * l * dx * dy / ddd;                      //d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );                      //TODO isn't it wrong?                      d2ym += k * ( 1 - l * Math.Pow( dx' 2 ) / ddd );                  }              }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: InitializeWithRandomPositions( 1' 1' -0.5' -0.5 );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: InitializeWithRandomPositions( 1' 1' -0.5' -0.5 );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for ( int step = 1; step <= Parameters.iterationCount; step++ )  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa  				if ( Parameters.iterationCount >= 50 && finalRepuExponent < 1.0 )  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if ( step <= 0.6 * Parameters.iterationCount )  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * ( 1.0 - finalRepuExponent );  						Parameters.repulsiveExponent += 0.9 * ( 1.0 - finalRepuExponent );  					}  					else if ( step <= 0.9 * Parameters.iterationCount )  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * ( 1.0 - finalRepuExponent ) * ( 0.9 - step / (double)Parameters.iterationCount ) / 0.3;  					}  				}  				#endregion    				#region Move each node  				for ( int i = 0; i < vertices.Length; i++ )  				{  					var v = vertices[i];  					double oldEnergy = GetEnergy( i' quadTree );    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection( i' quadTree' out bestDir );    					// line search: compute length of the move  					Point oldPos = v.Position;    					double bestEnergy = oldEnergy;  					int bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for ( int multiple = 32;  					      multiple >= 1 && ( bestMultiple == 0 || bestMultiple / 2 == multiple );  					      multiple /= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for ( int multiple = 64;  					      multiple <= 128 && bestMultiple == multiple / 2;  					      multiple *= 2 )  					{  						v.Position = oldPos + bestDir * multiple;  						double curEnergy = GetEnergy( i' quadTree );  						if ( curEnergy < bestEnergy )  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if ( bestMultiple > 0 )  					{  						quadTree.MoveNode( oldPos' v.Position' v.RepulsionWeight );  					}  				}  				#endregion    				if ( ReportOnIterationEndNeeded )  					Report( step );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,Report,The following statement contains a magic number: OnIterationEnded( step' step / (double)Parameters.iterationCount * 100' "Iteration " + step + " finished."' true );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: if ( dir2 != 0.0 )  			{  				dir /= dir2;    				double length = dir.Length;  				if ( length > quadTree.Width / 8 )  				{  					length /= quadTree.Width / 8;  					dir /= length;  				}  			}  			else { dir = new Vector( 0' 0 ); }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: if ( dir2 != 0.0 )  			{  				dir /= dir2;    				double length = dir.Length;  				if ( length > quadTree.Width / 8 )  				{  					length /= quadTree.Width / 8;  					dir /= length;  				}  			}  			else { dir = new Vector( 0' 0 ); }
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddGravitationDirection,The following statement contains a magic number: double tmp = Parameters.gravitationMultiplier * repulsionMultiplier * Math.Max( v.RepulsionWeight' 1 ) * Math.Pow( dist' Parameters.attractionExponent - 2 );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddAttractionDirection,The following statement contains a magic number: foreach ( var e in v.Attractions )  			{  				//onhurkok elhagyasa  				if ( e.Target == v )  					continue;    				Vector attractionVector = ( e.Target.Position - v.Position );  				double dist = attractionVector.Length;  				if ( dist <= 0 )  					continue;    				double tmp = e.AttractionWeight * Math.Pow( dist' Parameters.attractionExponent - 2 );  				dir2 += tmp * Math.Abs( Parameters.attractionExponent - 1 );    				dir += ( e.Target.Position - v.Position ) * tmp;  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddRepulsionDirection,The following statement contains a magic number: if ( quadTree.Index < 0 && dist < 2.0 * quadTree.Width )  			{  				double dir2 = 0.0;  				for ( int i = 0; i < quadTree.Children.Length; i++ )  					dir2 += AddRepulsionDirection( index' quadTree.Children[i]' ref dir );  				return dir2;  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddRepulsionDirection,The following statement contains a magic number: if ( dist != 0.0 )  			{  				double tmp = repulsionMultiplier * v.RepulsionWeight * quadTree.Weight  				             * Math.Pow( dist' Parameters.repulsiveExponent - 2 );  				dir -= repulsionVector * tmp;  				return tmp * Math.Abs( Parameters.repulsiveExponent - 1 );  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetRepulsionEnergy,The following statement contains a magic number: if ( tree.Index < 0 && dist < ( 2 * tree.Width ) )  			{  				double energy = 0.0;  				for ( int i = 0; i < tree.Children.Length; i++ )  					energy += GetRepulsionEnergy( index' tree.Children[i] );    				return energy;  			}
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The following statement contains a magic number: if ( repulsionSum > 0 && attractionSum > 0 )  				return attractionSum / Math.Pow( repulsionSum' 2 ) * Math.Pow( repulsionSum' 0.5 * ( Parameters.attractionExponent - Parameters.repulsiveExponent ) );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The following statement contains a magic number: if ( repulsionSum > 0 && attractionSum > 0 )  				return attractionSum / Math.Pow( repulsionSum' 2 ) * Math.Pow( repulsionSum' 0.5 * ( Parameters.attractionExponent - Parameters.repulsiveExponent ) );
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,QuadTree,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.QuadTree.cs,AddNode2,The following statement contains a magic number: double middleX = ( minPos.X + maxPos.X ) / 2;
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,QuadTree,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.QuadTree.cs,AddNode2,The following statement contains a magic number: double middleY = ( minPos.Y + maxPos.Y ) / 2;
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,QuadTree,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.QuadTree.cs,AddNode2,The following statement contains a magic number: if ( nodePos.Y > middleY )  					childIndex += 2;
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,QuadTree,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.QuadTree.cs,MoveNode,The following statement contains a magic number: double middleX = ( minPos.X + maxPos.X ) / 2;
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,QuadTree,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.QuadTree.cs,MoveNode,The following statement contains a magic number: double middleY = ( minPos.Y + maxPos.Y ) / 2;
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutParametersBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutParametersBase.cs,CalculateConstantOfRepulsion,The following statement contains a magic number: ConstantOfRepulsion = Math.Pow( K * _repulsiveMultiplier' 2 );
Magic Number,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,force,The following statement contains a magic number: if ( Gij >= gij && gij > 0 || -Gij <= gij && gij < 0 || gij == 0 )              {                  // vi and vj touch with y-direction boundaries                  f.X = d.X / adx * ( ( vi.Width + vj.Width ) / 2.0 - adx );                  f.Y = f.X * gij;              }
Magic Number,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,force,The following statement contains a magic number: if ( Gij < gij && gij > 0 || -Gij > gij && gij < 0 )              {                  // vi and vj touch with x-direction boundaries                  f.Y = d.Y / ady * ( ( vi.Height + vj.Height ) / 2.0 - ady );                  f.X = f.Y / gij;              }
Magic Number,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,force2,The following statement contains a magic number: if ( vi.IntersectsWith( vj ) )              {                  f.X = ( vi.Width + vj.Width ) / 2.0 - d.X;                  f.Y = ( vi.Height + vj.Height ) / 2.0 - d.Y;                  // in the x dimension                  if ( f.X > f.Y && gij != 0 )                  {                      f.X = f.Y / gij;                  }                  f.X = Math.Max( f.X' 0 );                  f.Y = Math.Max( f.Y' 0 );              }
Magic Number,GraphSharp.Algorithms.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\FSAAlgorithm.cs,force2,The following statement contains a magic number: if ( vi.IntersectsWith( vj ) )              {                  f.X = ( vi.Width + vj.Width ) / 2.0 - d.X;                  f.Y = ( vi.Height + vj.Height ) / 2.0 - d.Y;                  // in the x dimension                  if ( f.X > f.Y && gij != 0 )                  {                      f.X = f.Y / gij;                  }                  f.X = Math.Max( f.X' 0 );                  f.Y = Math.Max( f.Y' 0 );              }
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OneWayFSAAlgorithm<TObject>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OneWayFSAAlgorithm.cs,HorizontalImproved,The following statement contains a magic number: while ( i < n )              {                  var u = wrappedRectangles[i];                    //i-vel azonos középponttal rendelkező téglalapok meghatározása                  int k = i;                  for ( int j = i + 1; j < n; j++ )                  {                      var v = wrappedRectangles[j];                      if ( u.CenterX == v.CenterX )                      {                          u = v;                          k = j;                      }                      else                      {                          break;                      }                  }                  double g = 0;                    //ne legyenek ugyanabban a pontban                  for ( int z = i + 1; z <= k; z++ )                  {                      var v = wrappedRectangles[z];                      v.Rectangle.X += ( z - i ) * 0.0001;                  }                    //i-k intervallumban lévő téglalapokra erőszámítás a tőlük balra lévőkkel                  if ( u.CenterX > x0 )                  {                      for ( int m = i; m <= k; m++ )                      {                          double ggg = 0;                          for ( int j = 0; j < i; j++ )                          {                              var f = force( wrappedRectangles[j].Rectangle' wrappedRectangles[m].Rectangle );                              ggg = Math.Max( f.X + gamma[j]' ggg );                          }                          var v = wrappedRectangles[m];                          double gg = v.Rectangle.Left + ggg < lmin.Rectangle.Left ? sigma : ggg;                          g = Math.Max( g' gg );                      }                  }                  //megjegyezzük az elemek eltolásást x tömbbe                  //bal szélő elemet újra meghatározzuk                  for ( int m = i; m <= k; m++ )                  {                      gamma[m] = g;                      var r = wrappedRectangles[m];                      x[m] = r.Rectangle.Left + g;                      if ( r.Rectangle.Left < lmin.Rectangle.Left )                      {                          lmin = r;                      }                  }                    //az i-k intervallum négyzeteitől jobbra lévőkkel erőszámítás' legnagyobb erő tárolása                  // delta = max(0' max{f.x(m'j)|i<=m<=k<j<n})                  double delta = 0;                  for ( int m = i; m <= k; m++ )                  {                      for ( int j = k + 1; j < n; j++ )                      {                          var f = force( wrappedRectangles[m].Rectangle' wrappedRectangles[j].Rectangle );                          if ( f.X > delta )                          {                              delta = f.X;                          }                      }                  }                  sigma += delta;                  i = k + 1;              }
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,AddGaps,The following statement contains a magic number: foreach ( var r in wrappedRectangles )  			{  				r.Rectangle.Width += Parameters.HorizontalGap;  				r.Rectangle.Height += Parameters.VerticalGap;  				r.Rectangle.Offset( -Parameters.HorizontalGap / 2' -Parameters.VerticalGap / 2 );  			}
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,AddGaps,The following statement contains a magic number: foreach ( var r in wrappedRectangles )  			{  				r.Rectangle.Width += Parameters.HorizontalGap;  				r.Rectangle.Height += Parameters.VerticalGap;  				r.Rectangle.Offset( -Parameters.HorizontalGap / 2' -Parameters.VerticalGap / 2 );  			}
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,RemoveGaps,The following statement contains a magic number: foreach ( var r in wrappedRectangles )  			{  				r.Rectangle.Width -= Parameters.HorizontalGap;  				r.Rectangle.Height -= Parameters.VerticalGap;  				r.Rectangle.Offset( Parameters.HorizontalGap / 2' Parameters.VerticalGap / 2 );  			}
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase<TObject;TParam>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,RemoveGaps,The following statement contains a magic number: foreach ( var r in wrappedRectangles )  			{  				r.Rectangle.Width -= Parameters.HorizontalGap;  				r.Rectangle.Height -= Parameters.VerticalGap;  				r.Rectangle.Offset( Parameters.HorizontalGap / 2' Parameters.VerticalGap / 2 );  			}
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalHelper.cs,GetCenter,The following statement contains a magic number: return new Point( r.Left + r.Width / 2' r.Top + r.Height / 2 );
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalHelper.cs,GetCenter,The following statement contains a magic number: return new Point( r.Left + r.Width / 2' r.Top + r.Height / 2 );
Missing Default,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,GenerateSpanningTree,The following switch statement is missing a default case: switch ( Parameters.SpanningTreeGeneration )              {                  case SpanningTreeGeneration.BFS:                      var bfsAlgo = new BreadthFirstSearchAlgorithm<TVertex' TEdge>( VisitedGraph' vb' new Dictionary<TVertex' GraphColor>() );                      bfsAlgo.TreeEdge += e => spanningTree.AddEdge( new Edge<TVertex>( e.Source' e.Target ) );                      bfsAlgo.Compute();                      break;                  case SpanningTreeGeneration.DFS:                      var dfsAlgo = new DepthFirstSearchAlgorithm<TVertex' TEdge>( VisitedGraph );                      dfsAlgo.TreeEdge += e => spanningTree.AddEdge( new Edge<TVertex>( e.Source' e.Target ) );                      dfsAlgo.Compute();                      break;              }
Missing Default,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,InternalCompute,The following switch statement is missing a default case: switch ( side2Direction )              {                  case LayoutDirection.BottomToTop:                      side1Direction = LayoutDirection.TopToBottom;                      break;                  case LayoutDirection.LeftToRight:                      side1Direction = LayoutDirection.RightToLeft;                      break;                  case LayoutDirection.RightToLeft:                      side1Direction = LayoutDirection.LeftToRight;                      break;                  case LayoutDirection.TopToBottom:                      side1Direction = LayoutDirection.BottomToTop;                      break;              }
Missing Default,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm<Vertex;Edge;Graph>,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following switch statement is missing a default case: switch (Parameters._coolingFunction)                  {                      case FRCoolingFunction.Linear:                          _temperature *= (1.0 - (double)i / (double)Parameters._iterationLimit);                          break;                      case FRCoolingFunction.Exponential:                          _temperature *= Parameters._lambda;                          break;                  }
