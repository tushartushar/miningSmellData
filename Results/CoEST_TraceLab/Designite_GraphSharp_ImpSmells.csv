Implementation smell,Namespace,Class,File,Method,Description
Long Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The method has 118 lines of code.
Complex Method,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,InternalCompute,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,GenerateSpanningTree,Cyclomatic complexity of the method is 10
Complex Method,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,Cyclomatic complexity of the method is 8
Complex Method,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplySpringForces,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,InternalCompute,Cyclomatic complexity of the method is 22
Complex Method,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,SeparateSides,Cyclomatic complexity of the method is 8
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,PrepareForSugiyama,Cyclomatic complexity of the method is 10
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaLayout,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,Cyclomatic complexity of the method is 25
Complex Method,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,Cyclomatic complexity of the method is 11
Complex Method,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,Cyclomatic complexity of the method is 14
Complex Method,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,Cyclomatic complexity of the method is 14
Complex Method,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateParameters,Cyclomatic complexity of the method is 11
Complex Method,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,Cyclomatic complexity of the method is 9
Complex Method,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,Cyclomatic complexity of the method is 12
Complex Method,GraphSharp.Algorithms.OverlapRemoval,OneWayFSAAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OneWayFSAAlgorithm.cs,RemoveOverlap,Cyclomatic complexity of the method is 8
Complex Method,GraphSharp.Algorithms.OverlapRemoval,OneWayFSAAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OneWayFSAAlgorithm.cs,HorizontalImproved,Cyclomatic complexity of the method is 14
Complex Method,GraphSharp,HierarchicalGraph,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\HierarchicalGraph.cs,RemoveVertex,Cyclomatic complexity of the method is 10
Complex Method,GraphSharp,HierarchicalGraph,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\HierarchicalGraph.cs,AddEdge,Cyclomatic complexity of the method is 16
Complex Method,GraphSharp,HierarchicalGraph,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\HierarchicalGraph.cs,RemoveEdge,Cyclomatic complexity of the method is 16
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Tree,BalloonTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\BalloonTreeLayoutAlgorithm.cs,BalloonTreeLayoutAlgorithm,The method has 5 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Tree,BalloonTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\BalloonTreeLayoutAlgorithm.cs,SecondWalk,The method has 6 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetSpringForce,The method has 5 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The method has 5 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Compound,CompoundLayoutContext,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\CompoundLayoutContext.cs,CompoundLayoutContext,The method has 6 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Compound,CompoundLayoutIterationEventArgs,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\CompoundLayoutIterationEventArgs.cs,CompoundLayoutIterationEventArgs,The method has 5 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Compound,TestingCompoundLayoutIterationEventArgs,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\TestingCompoundLayoutIterationEventArgs.cs,TestingCompoundLayoutIterationEventArgs,The method has 7 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,DoubleTreeLayoutAlgorithm,The method has 5 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaLayoutAlgorithm,The method has 5 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1Sweep,The method has 6 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase2Sweep,The method has 5 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout,LayoutIterationEventArgs,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutIterationEventArgs.cs,LayoutIterationEventArgs,The method has 6 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout,LayoutState,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutState.cs,LayoutState,The method has 6 parameters.
Long Parameter List,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The method has 5 parameters.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,GenerateSpanningTree,The length of the statement  "		var bfsAlgo = new BreadthFirstSearchAlgorithm<TVertex' TEdge> (VisitedGraph' vb' new Dictionary<TVertex' GraphColor> ()); " is 121.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The length of the statement  "	bool changeCoordinates = (Parameters.Direction == LayoutDirection.LeftToRight || Parameters.Direction == LayoutDirection.RightToLeft); " is 134.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The length of the statement  "			VertexPositions [v] = changeCoordinates ? new Point (direction * (layerSize + size.Height / 2.0)' d.position) : new Point (d.position' direction * (layerSize + size.Height / 2.0)); " is 180.
Long Statement,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The length of the statement  "		/*double error = _errorThresholds[_phase] + 1;*/for (_step = _maxIterationCounts [_phase - 1]; (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown); _step--) { " is 203.
Long Statement,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,SavePositions,The length of the statement  "	var vertexInfos = _vertexDatas.ToDictionary (kvp => kvp.Key' kvp => new TestingCompoundVertexInfo (kvp.Value.SpringForce' kvp.Value.RepulsionForce' kvp.Value.GravitationForce' kvp.Value.ApplicationForce)); " is 205.
Long Statement,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,SavePositions,The length of the statement  "	var iterationEndedArgs = new TestingCompoundLayoutIterationEventArgs<TVertex' TEdge' TestingCompoundVertexInfo' object> (0' 0' string.Format ("Phase: {0}' Steps: {1}"' _phase' _step)' VertexPositions' InnerCanvasSizes' vertexInfos' _rootCompoundVertex.InnerCanvasCenter); " is 271.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,InternalCompute,The length of the statement  "	var side1LayoutAlg = new SimpleTreeLayoutAlgorithm<TVertex' Edge<TVertex>' BidirectionalGraph<TVertex' Edge<TVertex>>> (graph1' VertexPositions' vertexSizes' new SimpleTreeLayoutParameters { " is 190.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,InternalCompute,The length of the statement  "	var side2LayoutAlg = new SimpleTreeLayoutAlgorithm<TVertex' TEdge' BidirectionalGraph<TVertex' TEdge>> (graph2' VertexPositions' vertexSizes' new SimpleTreeLayoutParameters { " is 174.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,ContextualLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\ContextualLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "		return new DoubleTreeLayoutAlgorithm<TVertex' TEdge' TGraph> (layoutContext.Graph' layoutContext.Positions' layoutContext.Sizes' parameters as DoubleTreeLayoutParameters' layoutContext.SelectedVertex); " is 201.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,ContextualLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\ContextualLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "		return new BalloonTreeLayoutAlgorithm<TVertex' TEdge' TGraph> (layoutContext.Graph' layoutContext.Positions' layoutContext.Sizes' parameters as BalloonTreeLayoutParameters' layoutContext.SelectedVertex); " is 203.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,ContextualLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\ContextualLayoutAlgorithmFactory.cs,CreateParameters,The length of the statement  "		return !(oldParameters is DoubleTreeLayoutParameters) ? new DoubleTreeLayoutParameters () : (DoubleTreeLayoutParameters)(oldParameters as DoubleTreeLayoutParameters).Clone (); " is 175.
Long Statement,GraphSharp.Algorithms.Layout.Contextual,ContextualLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\ContextualLayoutAlgorithmFactory.cs,CreateParameters,The length of the statement  "		return !(oldParameters is BalloonTreeLayoutParameters) ? new BalloonTreeLayoutParameters () : (BalloonTreeLayoutParameters)(oldParameters as BalloonTreeLayoutParameters).Clone (); " is 179.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,EfficientSugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\EfficientSugiyamaLayoutAlgorithm.cs,InvariantMethod,The length of the statement  "	Contract.Invariant (State != QuickGraph.Algorithms.ComputationState.Running || _graph != null' "If the algorithm is running the _graph should not be null."); " is 157.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,PrepareForSugiyama,The length of the statement  "	_graph.UnhideEdgesIf (e => e.Type == EdgeTypes.General && _graph.ContainsVertex (e.Source) && _graph.ContainsVertex (e.Target)); " is 128.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,PrepareForSugiyama,The length of the statement  "	_graph.HideEdgesIf (e => (e.Type == EdgeTypes.General && e.Source.LayerIndex != e.Target.LayerIndex)' GeneralEdgesBetweenDifferentLayersTag); " is 141.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1,The length of the statement  "		sweepDownOptimized = SugiyamaPhase1Sweep (startLayerIndex == -1 ? 1 : startLayerIndex' _layers.Count' 1' BaryCenter.Up' dirty' ByRealPosition); " is 143.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1,The length of the statement  "	bool sweepUpOptimized = SugiyamaPhase1Sweep (startLayerIndex == -1 ? _layers.Count - 2 : startLayerIndex' -1' -1' BaryCenter.Down' dirty' ByRealPosition); " is 154.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaLayout,The length of the statement  "	bool baryCenteringByRealPositions = Parameters.PositionCalculationMethod == PositionCalculationMethodTypes.PositionBased; " is 121.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CalculateOverlap,The length of the statement  "	return Math.Max (0' ((b.Size.Width + a.Size.Width) * 0.5 + plusGap + Parameters.HorizontalGap) - (b.RealPosition.X - a.RealPosition.X)); " is 136.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The length of the statement  "		for (indexOfV = 0; indexOfV < alreadySetVertices.Length && alreadySetVertices [indexOfV].Position < v.Position; indexOfV++) { " is 125.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The length of the statement  "			for (int index = indexOfV - 1; index > 0 && (leftOverlap = CalculateOverlap (alreadySetVertices [index - 1]' alreadySetVertices [index])) > 0; index--) { " is 153.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The length of the statement  "			for (int index = indexOfV; index < alreadySetVertices.Length - 1 && (rightOverlap = CalculateOverlap (alreadySetVertices [index]' alreadySetVertices [index + 1])) > 0; index++) { " is 178.
Long Statement,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The length of the statement  "		EdgeRoutes [e.Original] = e.IsReverted ? e.DummyVertices.Reverse ().Select (dv => dv.RealPosition).ToArray () : e.DummyVertices.Select (dv => dv.RealPosition).ToArray (); " is 170.
Long Statement,GraphSharp.Algorithms.Layout,ParameterizedLayoutAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\ParameterizedLayoutAlgorithmBase.cs,CreateLayoutIterationEventArgs,The length of the statement  "	return new LayoutIterationEventArgs<TVertex' TEdge' TVertexInfo' TEdgeInfo> (iteration' statusInPercent' message' vertexPositions' vertexInfos' edgeInfos); " is 155.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new SimpleTreeLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Positions' context.Sizes' parameters as SimpleTreeLayoutParameters); " is 153.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new CircularLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Positions' context.Sizes' parameters as CircularLayoutParameters); " is 149.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new FRLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Positions' parameters as FRLayoutParametersBase); " is 126.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new FRLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Positions' parameters as BoundedFRLayoutParameters); " is 129.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new KKLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Positions' parameters as KKLayoutParameters); " is 122.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new ISOMLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Positions' parameters as ISOMLayoutParameters); " is 126.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new LinLogLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Positions' parameters as LinLogLayoutParameters); " is 130.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new EfficientSugiyamaLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' parameters as EfficientSugiyamaLayoutParameters' context.Positions' context.Sizes); " is 167.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new SugiyamaLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Sizes' context.Positions' parameters as SugiyamaLayoutParameters' e => (e is TypedEdge<TVertex> ? (e as TypedEdge<TVertex>).Type : EdgeTypes.Hierarchical)); " is 239.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new CompoundFDPLayoutAlgorithm<TVertex' TEdge' TGraph> (context.Graph' context.Sizes' new Dictionary<TVertex' Thickness> ()' new Dictionary<TVertex' CompoundVertexInnerLayoutType> ()' context.Positions' parameters as CompoundFDPLayoutParameters); " is 253.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "			return new CompoundFDPLayoutAlgorithm<TVertex' TEdge' TGraph> (compoundContext.Graph' compoundContext.Sizes' compoundContext.VertexBorders' compoundContext.LayoutTypes' compoundContext.Positions' parameters as CompoundFDPLayoutParameters); " is 239.
Long Statement,GraphSharp.Algorithms.Layout,StandardLayoutAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\StandardLayoutAlgorithmFactory.cs,NeedOverlapRemoval,The length of the statement  "	return (algorithmType != "Sugiyama" && algorithmType != "EfficientSugiyama" && algorithmType != "Circular" && algorithmType != "Tree" && algorithmType != "CompoundFDP"); " is 169.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The length of the statement  "	for (int i = 0; i < Parameters._iterationLimit && _temperature > minimalTemperature && State != QuickGraph.Algorithms.ComputationState.PendingAbortion; i++) { " is 158.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,Report,The length of the statement  "	OnIterationEnded (currentIteration' (double)currentIteration / (double)Parameters.MaxIterations' "Iteration " + currentIteration + " finished."' true); " is 151.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The length of the statement  "				Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3; " is 122.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The length of the statement  "				Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3; " is 121.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddGravitationDirection,The length of the statement  "	double tmp = Parameters.gravitationMultiplier * repulsionMultiplier * Math.Max (v.RepulsionWeight' 1) * Math.Pow (dist' Parameters.attractionExponent - 2); " is 155.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddRepulsionDirection,The length of the statement  "		double tmp = repulsionMultiplier * v.RepulsionWeight * quadTree.Weight * Math.Pow (dist' Parameters.repulsiveExponent - 2); " is 123.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetGravitationEnergy,The length of the statement  "	return Parameters.gravitationMultiplier * repulsionMultiplier * Math.Max (v.RepulsionWeight' 1) * Math.Pow (dist' Parameters.attractionExponent) / Parameters.attractionExponent; " is 177.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetRepulsionEnergy,The length of the statement  "	return -repulsionMultiplier * v.RepulsionWeight * tree.Weight * Math.Pow (dist' Parameters.repulsiveExponent) / Parameters.repulsiveExponent; " is 141.
Long Statement,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The length of the statement  "		return attractionSum / Math.Pow (repulsionSum' 2) * Math.Pow (repulsionSum' 0.5 * (Parameters.attractionExponent - Parameters.repulsiveExponent)); " is 146.
Long Statement,GraphSharp.Algorithms.OverlapRemoval,StandardOverlapRemovalAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\StandardOverlapRemovalAlgorithmFactory.cs,CreateParameters,The length of the statement  "		return oldParameters as OverlapRemovalParameters == null ? new OverlapRemovalParameters () : (IOverlapRemovalParameters)(oldParameters as OverlapRemovalParameters).Clone (); " is 173.
Long Statement,GraphSharp.Algorithms.OverlapRemoval,StandardOverlapRemovalAlgorithmFactory,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\StandardOverlapRemovalAlgorithmFactory.cs,CreateParameters,The length of the statement  "		return (oldParameters as OneWayFSAParameters) == null ? new OneWayFSAParameters () : (IOverlapRemovalParameters)oldParameters.Clone (); " is 135.
Long Statement,GraphSharp,GraphHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\GraphHelper.cs,Convert,The length of the statement  "	return oldGraph.Convert (new BidirectionalGraph<TNewVertex' TNewEdge> (oldGraph.AllowParallelEdges' oldGraph.VertexCount)' vertexMapperFunc' edgeMapperFunc); " is 157.
Long Statement,GraphSharp.Contracts,ICompoundGraphContract,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Contracts\ICompoundGraphContract.cs,GetParent,The length of the statement  "	//Contract.Ensures( Contract.Result<TVertex>().Equals( default( TVertex ) ) || ithis.ContainsVertex( Contract.Result<TVertex>() ) ); " is 132.
Virtual Method Call from Constructor,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutParametersBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutParametersBase.cs,FRLayoutParametersBase,The constructor "FRLayoutParametersBase" calls a virtual method "UpdateParameters".
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,BalloonTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\BalloonTreeLayoutAlgorithm.cs,SetRadius,The following statement contains a magic number: data.r = (int)Math.Max (data.d / 2' Parameters.minRadius);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,The following statement contains a magic number: layer.NextPosition += size.Width / 2.0;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,The following statement contains a magic number: if (spanningTree.OutDegree (v) == 0) {  	d.position = layer.NextPosition;  }  else {  	double minPos = double.MaxValue;  	double maxPos = -double.MaxValue;  	//first put the children  	foreach (var child in spanningTree.OutEdges (v).Select (e => e.Target)) {  		double childPos = CalculatePosition (child' v' l + 1);  		if (childPos >= 0) {  			minPos = Math.Min (minPos' childPos);  			maxPos = Math.Max (maxPos' childPos);  		}  	}  	if (minPos != double.MaxValue)  		d.position = (minPos + maxPos) / 2.0;  	else  		d.position = layer.NextPosition;  	d.translate = Math.Max (layer.NextPosition - d.position' 0);  	layer.LastTranslate = d.translate;  	d.position += d.translate;  	layer.NextPosition = d.position;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,The following statement contains a magic number: if (minPos != double.MaxValue)  	d.position = (minPos + maxPos) / 2.0;  else  	d.position = layer.NextPosition;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,The following statement contains a magic number: d.position = (minPos + maxPos) / 2.0;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,CalculatePosition,The following statement contains a magic number: layer.NextPosition += size.Width / 2.0 + Parameters.VertexGap;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: foreach (var layer in layers) {  	foreach (var v in layer.Vertices) {  		Size size = sizes [v];  		var d = data [v];  		if (d.parent != null) {  			d.position += data [d.parent].translate;  			d.translate += data [d.parent].translate;  		}  		VertexPositions [v] = changeCoordinates ? new Point (direction * (layerSize + size.Height / 2.0)' d.position) : new Point (d.position' direction * (layerSize + size.Height / 2.0));  	}  	layerSize += layer.Size;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: foreach (var layer in layers) {  	foreach (var v in layer.Vertices) {  		Size size = sizes [v];  		var d = data [v];  		if (d.parent != null) {  			d.position += data [d.parent].translate;  			d.translate += data [d.parent].translate;  		}  		VertexPositions [v] = changeCoordinates ? new Point (direction * (layerSize + size.Height / 2.0)' d.position) : new Point (d.position' direction * (layerSize + size.Height / 2.0));  	}  	layerSize += layer.Size;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: foreach (var v in layer.Vertices) {  	Size size = sizes [v];  	var d = data [v];  	if (d.parent != null) {  		d.position += data [d.parent].translate;  		d.translate += data [d.parent].translate;  	}  	VertexPositions [v] = changeCoordinates ? new Point (direction * (layerSize + size.Height / 2.0)' d.position) : new Point (d.position' direction * (layerSize + size.Height / 2.0));  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: foreach (var v in layer.Vertices) {  	Size size = sizes [v];  	var d = data [v];  	if (d.parent != null) {  		d.position += data [d.parent].translate;  		d.translate += data [d.parent].translate;  	}  	VertexPositions [v] = changeCoordinates ? new Point (direction * (layerSize + size.Height / 2.0)' d.position) : new Point (d.position' direction * (layerSize + size.Height / 2.0));  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: VertexPositions [v] = changeCoordinates ? new Point (direction * (layerSize + size.Height / 2.0)' d.position) : new Point (d.position' direction * (layerSize + size.Height / 2.0));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: VertexPositions [v] = changeCoordinates ? new Point (direction * (layerSize + size.Height / 2.0)' d.position) : new Point (d.position' direction * (layerSize + size.Height / 2.0));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach (var v in VisitedGraph.Vertices) {  	Size s = sizes [v];  	halfSize [i] = Math.Sqrt (s.Width * s.Width + s.Height * s.Height) * 0.5;  	perimeter += halfSize [i] * 2;  	i++;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach (var v in VisitedGraph.Vertices) {  	Size s = sizes [v];  	halfSize [i] = Math.Sqrt (s.Width * s.Width + s.Height * s.Height) * 0.5;  	perimeter += halfSize [i] * 2;  	i++;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: halfSize [i] = Math.Sqrt (s.Width * s.Width + s.Height * s.Height) * 0.5;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: perimeter += halfSize [i] * 2;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach (var v in VisitedGraph.Vertices) {  	a = Math.Sin (halfSize [i] * 0.5 / radius) * 2;  	angle += a;  	if (ReportOnIterationEndNeeded)  		VertexPositions [v] = new Point (Math.Cos (angle) * radius + radius' Math.Sin (angle) * radius + radius);  	angle += a;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach (var v in VisitedGraph.Vertices) {  	a = Math.Sin (halfSize [i] * 0.5 / radius) * 2;  	angle += a;  	if (ReportOnIterationEndNeeded)  		VertexPositions [v] = new Point (Math.Cos (angle) * radius + radius' Math.Sin (angle) * radius + radius);  	angle += a;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: a = Math.Sin (halfSize [i] * 0.5 / radius) * 2;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: a = Math.Sin (halfSize [i] * 0.5 / radius) * 2;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (ReportOnIterationEndNeeded)  	OnIterationEnded (0' 50' "Precalculation done."' false);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: OnIterationEnded (0' 50' "Precalculation done."' false);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: radius = angle / (2 * Math.PI) * radius;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach (var v in VisitedGraph.Vertices) {  	a = Math.Sin (halfSize [i] * 0.5 / radius) * 2;  	angle += a;  	VertexPositions [v] = new Point (Math.Cos (angle) * radius + radius' Math.Sin (angle) * radius + radius);  	angle += a;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: foreach (var v in VisitedGraph.Vertices) {  	a = Math.Sin (halfSize [i] * 0.5 / radius) * 2;  	angle += a;  	VertexPositions [v] = new Point (Math.Cos (angle) * radius + radius' Math.Sin (angle) * radius + radius);  	angle += a;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: a = Math.Sin (halfSize [i] * 0.5 / radius) * 2;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Circular,CircularLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Circular\CircularLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: a = Math.Sin (halfSize [i] * 0.5 / radius) * 2;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: _maxIterationCounts = new int[3];  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: _maxIterationCounts [2] = Parameters.Phase3Iterations;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++) {  	_temperature = initialTemperature * _temperatureMultipliers [_phase - 1];  	_phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;  	//TODO put back the error and its threshold  	/*double error = _errorThresholds[_phase] + 1;*/for (_step = _maxIterationCounts [_phase - 1]; (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown); _step--) {  		/*error = 0;*/ApplySpringForces ();  		ApplyRepulsionForces ();  		if (_phase > 1) {  			ApplyGravitationForces ();  			ApplyApplicationSpecificForces ();  		}  		if (ReportOnIterationEndNeeded)  			SavePositions ();  		CalcNodePositionsAndSizes ();  		if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)  			GrowTreesOneLevel ();  		_temperature *= _temperatureLambda;  		_temperature = Math.Max (_temperature' minimalTemperature);  	}  	if (!_gravityCenterCalculated) {  		_rootCompoundVertex.RecalculateBounds ();  		_gravityCenterCalculated = true;  	}  	//if (_phase == 1)  	_temperature *= Parameters.TemperatureDecreasing;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++) {  	_temperature = initialTemperature * _temperatureMultipliers [_phase - 1];  	_phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;  	//TODO put back the error and its threshold  	/*double error = _errorThresholds[_phase] + 1;*/for (_step = _maxIterationCounts [_phase - 1]; (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown); _step--) {  		/*error = 0;*/ApplySpringForces ();  		ApplyRepulsionForces ();  		if (_phase > 1) {  			ApplyGravitationForces ();  			ApplyApplicationSpecificForces ();  		}  		if (ReportOnIterationEndNeeded)  			SavePositions ();  		CalcNodePositionsAndSizes ();  		if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)  			GrowTreesOneLevel ();  		_temperature *= _temperatureLambda;  		_temperature = Math.Max (_temperature' minimalTemperature);  	}  	if (!_gravityCenterCalculated) {  		_rootCompoundVertex.RecalculateBounds ();  		_gravityCenterCalculated = true;  	}  	//if (_phase == 1)  	_temperature *= Parameters.TemperatureDecreasing;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++) {  	_temperature = initialTemperature * _temperatureMultipliers [_phase - 1];  	_phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;  	//TODO put back the error and its threshold  	/*double error = _errorThresholds[_phase] + 1;*/for (_step = _maxIterationCounts [_phase - 1]; (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown); _step--) {  		/*error = 0;*/ApplySpringForces ();  		ApplyRepulsionForces ();  		if (_phase > 1) {  			ApplyGravitationForces ();  			ApplyApplicationSpecificForces ();  		}  		if (ReportOnIterationEndNeeded)  			SavePositions ();  		CalcNodePositionsAndSizes ();  		if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)  			GrowTreesOneLevel ();  		_temperature *= _temperatureLambda;  		_temperature = Math.Max (_temperature' minimalTemperature);  	}  	if (!_gravityCenterCalculated) {  		_rootCompoundVertex.RecalculateBounds ();  		_gravityCenterCalculated = true;  	}  	//if (_phase == 1)  	_temperature *= Parameters.TemperatureDecreasing;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++) {  	_temperature = initialTemperature * _temperatureMultipliers [_phase - 1];  	_phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;  	//TODO put back the error and its threshold  	/*double error = _errorThresholds[_phase] + 1;*/for (_step = _maxIterationCounts [_phase - 1]; (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown); _step--) {  		/*error = 0;*/ApplySpringForces ();  		ApplyRepulsionForces ();  		if (_phase > 1) {  			ApplyGravitationForces ();  			ApplyApplicationSpecificForces ();  		}  		if (ReportOnIterationEndNeeded)  			SavePositions ();  		CalcNodePositionsAndSizes ();  		if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)  			GrowTreesOneLevel ();  		_temperature *= _temperatureLambda;  		_temperature = Math.Max (_temperature' minimalTemperature);  	}  	if (!_gravityCenterCalculated) {  		_rootCompoundVertex.RecalculateBounds ();  		_gravityCenterCalculated = true;  	}  	//if (_phase == 1)  	_temperature *= Parameters.TemperatureDecreasing;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_phase = 1; _phase <= 3; _phase++) {  	_temperature = initialTemperature * _temperatureMultipliers [_phase - 1];  	_phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;  	//TODO put back the error and its threshold  	/*double error = _errorThresholds[_phase] + 1;*/for (_step = _maxIterationCounts [_phase - 1]; (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown); _step--) {  		/*error = 0;*/ApplySpringForces ();  		ApplyRepulsionForces ();  		if (_phase > 1) {  			ApplyGravitationForces ();  			ApplyApplicationSpecificForces ();  		}  		if (ReportOnIterationEndNeeded)  			SavePositions ();  		CalcNodePositionsAndSizes ();  		if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)  			GrowTreesOneLevel ();  		_temperature *= _temperatureLambda;  		_temperature = Math.Max (_temperature' minimalTemperature);  	}  	if (!_gravityCenterCalculated) {  		_rootCompoundVertex.RecalculateBounds ();  		_gravityCenterCalculated = true;  	}  	//if (_phase == 1)  	_temperature *= Parameters.TemperatureDecreasing;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: _phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: _phaseDependentRepulsionMultiplier = _phase < 2 ? 0.5 : 1.0;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_step = _maxIterationCounts [_phase - 1]; (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown); _step--) {  	/*error = 0;*/ApplySpringForces ();  	ApplyRepulsionForces ();  	if (_phase > 1) {  		ApplyGravitationForces ();  		ApplyApplicationSpecificForces ();  	}  	if (ReportOnIterationEndNeeded)  		SavePositions ();  	CalcNodePositionsAndSizes ();  	if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)  		GrowTreesOneLevel ();  	_temperature *= _temperatureLambda;  	_temperature = Math.Max (_temperature' minimalTemperature);  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (_step = _maxIterationCounts [_phase - 1]; (_step > 0 && true/*error > _errorThresholds[_phase - 1] */) || (_phase == 2 && !_allTreesGrown); _step--) {  	/*error = 0;*/ApplySpringForces ();  	ApplyRepulsionForces ();  	if (_phase > 1) {  		ApplyGravitationForces ();  		ApplyApplicationSpecificForces ();  	}  	if (ReportOnIterationEndNeeded)  		SavePositions ();  	CalcNodePositionsAndSizes ();  	if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)  		GrowTreesOneLevel ();  	_temperature *= _temperatureLambda;  	_temperature = Math.Max (_temperature' minimalTemperature);  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (_phase == 2 && !_allTreesGrown && _step % _treeGrowingStep == 0)  	GrowTreesOneLevel ();  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetSpringForce,The following statement contains a magic number: if (positionVector.Length == 0) {  	var compensationVector = new Vector (rnd.NextDouble ()' rnd.NextDouble ());  	positionVector = compensationVector * 2;  	uPos += compensationVector;  	vPos -= compensationVector;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetSpringForce,The following statement contains a magic number: positionVector = compensationVector * 2;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The following statement contains a magic number: if (positionVector.Length == 0) {  	var compensationVector = new Vector (rnd.NextDouble ()' rnd.NextDouble ());  	positionVector = compensationVector * 2;  	uPos += compensationVector;  	vPos -= compensationVector;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The following statement contains a magic number: positionVector = compensationVector * 2;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The following statement contains a magic number: length = Math.Pow (isSameDirection ? length / (Parameters.IdealEdgeLength * 2.0) : 1 / length' 2);  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,GetRepulsionForce,The following statement contains a magic number: length = Math.Pow (isSameDirection ? length / (Parameters.IdealEdgeLength * 2.0) : 1 / length' 2);  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplySpringForces,The following statement contains a magic number: foreach (var edge in VisitedGraph.Edges) {  	if (!_allTreesGrown && (_removedRootTreeNodes.Contains (edge.Source) || _removedRootTreeNodes.Contains (edge.Target)))  		continue;  	//get the ideal edge length  	double idealLength = Parameters.IdealEdgeLength;  	var u = _vertexDatas [edge.Source];  	var v = _vertexDatas [edge.Target];  	var multiplier = (u.Level + v.Level) / 2.0 + 1;  	if (IsInterGraphEdge (edge)) {  		//idealLength *= (u.Level + v.Level + 1) * Parameters.NestingFactor;  		idealLength *= 1 + (u.Level + v.Level + 1) * Parameters.NestingFactor;  		//multiplier = 1;  	}  	var Fs = GetSpringForce (idealLength' u.Position' v.Position' u.Size' v.Size) * multiplier;  	//aggregate the forces  	if ((u.IsFixedToParent && u.MovableParent == null) ^ (v.IsFixedToParent && v.MovableParent == null))  		Fs *= 2;  	if (!u.IsFixedToParent)  		u.SpringForce += Fs/* * u.Mass / (u.Mass + v.Mass)*/;  	else if (u.MovableParent != null) {  		u.MovableParent.SpringForce += Fs;  	}  	if (!v.IsFixedToParent)  		v.SpringForce -= Fs/* * v.Mass / (u.Mass + v.Mass)*/;  	else if (v.MovableParent != null) {  		v.MovableParent.SpringForce -= Fs;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplySpringForces,The following statement contains a magic number: foreach (var edge in VisitedGraph.Edges) {  	if (!_allTreesGrown && (_removedRootTreeNodes.Contains (edge.Source) || _removedRootTreeNodes.Contains (edge.Target)))  		continue;  	//get the ideal edge length  	double idealLength = Parameters.IdealEdgeLength;  	var u = _vertexDatas [edge.Source];  	var v = _vertexDatas [edge.Target];  	var multiplier = (u.Level + v.Level) / 2.0 + 1;  	if (IsInterGraphEdge (edge)) {  		//idealLength *= (u.Level + v.Level + 1) * Parameters.NestingFactor;  		idealLength *= 1 + (u.Level + v.Level + 1) * Parameters.NestingFactor;  		//multiplier = 1;  	}  	var Fs = GetSpringForce (idealLength' u.Position' v.Position' u.Size' v.Size) * multiplier;  	//aggregate the forces  	if ((u.IsFixedToParent && u.MovableParent == null) ^ (v.IsFixedToParent && v.MovableParent == null))  		Fs *= 2;  	if (!u.IsFixedToParent)  		u.SpringForce += Fs/* * u.Mass / (u.Mass + v.Mass)*/;  	else if (u.MovableParent != null) {  		u.MovableParent.SpringForce += Fs;  	}  	if (!v.IsFixedToParent)  		v.SpringForce -= Fs/* * v.Mass / (u.Mass + v.Mass)*/;  	else if (v.MovableParent != null) {  		v.MovableParent.SpringForce -= Fs;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplySpringForces,The following statement contains a magic number: if ((u.IsFixedToParent && u.MovableParent == null) ^ (v.IsFixedToParent && v.MovableParent == null))  	Fs *= 2;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplySpringForces,The following statement contains a magic number: Fs *= 2;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--) {  	var checkedVertices = new HashSet<TVertex> ();  	foreach (var uVertex in _levels [i]) {  		checkedVertices.Add (uVertex);  		var u = _vertexDatas [uVertex];  		foreach (var vVertex in _levels [i]) {  			if (checkedVertices.Contains (vVertex))  				continue;  			var v = _vertexDatas [vVertex];  			if (u.Parent != v.Parent)  				continue;  			//the two vertex not in the same graph  			var Fr = GetRepulsionForce (u.Position' v.Position' u.Size' v.Size' repulsionRange) * Math.Pow (u.Level + 1' 2);  			if (u.IsFixedToParent ^ v.IsFixedToParent)  				Fr *= 2;  			if (!u.IsFixedToParent)  				u.RepulsionForce += Fr/** u.Mass / (u.Mass + v.Mass)*/;  			if (!v.IsFixedToParent)  				v.RepulsionForce -= Fr/** v.Mass / (u.Mass + v.Mass)*/;  		}  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--) {  	var checkedVertices = new HashSet<TVertex> ();  	foreach (var uVertex in _levels [i]) {  		checkedVertices.Add (uVertex);  		var u = _vertexDatas [uVertex];  		foreach (var vVertex in _levels [i]) {  			if (checkedVertices.Contains (vVertex))  				continue;  			var v = _vertexDatas [vVertex];  			if (u.Parent != v.Parent)  				continue;  			//the two vertex not in the same graph  			var Fr = GetRepulsionForce (u.Position' v.Position' u.Size' v.Size' repulsionRange) * Math.Pow (u.Level + 1' 2);  			if (u.IsFixedToParent ^ v.IsFixedToParent)  				Fr *= 2;  			if (!u.IsFixedToParent)  				u.RepulsionForce += Fr/** u.Mass / (u.Mass + v.Mass)*/;  			if (!v.IsFixedToParent)  				v.RepulsionForce -= Fr/** v.Mass / (u.Mass + v.Mass)*/;  		}  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: foreach (var uVertex in _levels [i]) {  	checkedVertices.Add (uVertex);  	var u = _vertexDatas [uVertex];  	foreach (var vVertex in _levels [i]) {  		if (checkedVertices.Contains (vVertex))  			continue;  		var v = _vertexDatas [vVertex];  		if (u.Parent != v.Parent)  			continue;  		//the two vertex not in the same graph  		var Fr = GetRepulsionForce (u.Position' v.Position' u.Size' v.Size' repulsionRange) * Math.Pow (u.Level + 1' 2);  		if (u.IsFixedToParent ^ v.IsFixedToParent)  			Fr *= 2;  		if (!u.IsFixedToParent)  			u.RepulsionForce += Fr/** u.Mass / (u.Mass + v.Mass)*/;  		if (!v.IsFixedToParent)  			v.RepulsionForce -= Fr/** v.Mass / (u.Mass + v.Mass)*/;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: foreach (var uVertex in _levels [i]) {  	checkedVertices.Add (uVertex);  	var u = _vertexDatas [uVertex];  	foreach (var vVertex in _levels [i]) {  		if (checkedVertices.Contains (vVertex))  			continue;  		var v = _vertexDatas [vVertex];  		if (u.Parent != v.Parent)  			continue;  		//the two vertex not in the same graph  		var Fr = GetRepulsionForce (u.Position' v.Position' u.Size' v.Size' repulsionRange) * Math.Pow (u.Level + 1' 2);  		if (u.IsFixedToParent ^ v.IsFixedToParent)  			Fr *= 2;  		if (!u.IsFixedToParent)  			u.RepulsionForce += Fr/** u.Mass / (u.Mass + v.Mass)*/;  		if (!v.IsFixedToParent)  			v.RepulsionForce -= Fr/** v.Mass / (u.Mass + v.Mass)*/;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: foreach (var vVertex in _levels [i]) {  	if (checkedVertices.Contains (vVertex))  		continue;  	var v = _vertexDatas [vVertex];  	if (u.Parent != v.Parent)  		continue;  	//the two vertex not in the same graph  	var Fr = GetRepulsionForce (u.Position' v.Position' u.Size' v.Size' repulsionRange) * Math.Pow (u.Level + 1' 2);  	if (u.IsFixedToParent ^ v.IsFixedToParent)  		Fr *= 2;  	if (!u.IsFixedToParent)  		u.RepulsionForce += Fr/** u.Mass / (u.Mass + v.Mass)*/;  	if (!v.IsFixedToParent)  		v.RepulsionForce -= Fr/** v.Mass / (u.Mass + v.Mass)*/;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: foreach (var vVertex in _levels [i]) {  	if (checkedVertices.Contains (vVertex))  		continue;  	var v = _vertexDatas [vVertex];  	if (u.Parent != v.Parent)  		continue;  	//the two vertex not in the same graph  	var Fr = GetRepulsionForce (u.Position' v.Position' u.Size' v.Size' repulsionRange) * Math.Pow (u.Level + 1' 2);  	if (u.IsFixedToParent ^ v.IsFixedToParent)  		Fr *= 2;  	if (!u.IsFixedToParent)  		u.RepulsionForce += Fr/** u.Mass / (u.Mass + v.Mass)*/;  	if (!v.IsFixedToParent)  		v.RepulsionForce -= Fr/** v.Mass / (u.Mass + v.Mass)*/;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: if (u.IsFixedToParent ^ v.IsFixedToParent)  	Fr *= 2;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyRepulsionForces,The following statement contains a magic number: Fr *= 2;  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--) {  	foreach (var uVertex in _levels [i]) {  		var u = _vertexDatas [uVertex];  		var center = u.Parent.InnerCanvasCenter;  		var Fg = center - u.Position;  		if (Fg.Length == 0)  			continue;  		double length = Math.Max (1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));  		Fg.Normalize ();  		Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow (u.Level + 1' 2) / Math.Pow (length' 0.25);  		u.GravitationForce += Fg;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--) {  	foreach (var uVertex in _levels [i]) {  		var u = _vertexDatas [uVertex];  		var center = u.Parent.InnerCanvasCenter;  		var Fg = center - u.Position;  		if (Fg.Length == 0)  			continue;  		double length = Math.Max (1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));  		Fg.Normalize ();  		Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow (u.Level + 1' 2) / Math.Pow (length' 0.25);  		u.GravitationForce += Fg;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--) {  	foreach (var uVertex in _levels [i]) {  		var u = _vertexDatas [uVertex];  		var center = u.Parent.InnerCanvasCenter;  		var Fg = center - u.Position;  		if (Fg.Length == 0)  			continue;  		double length = Math.Max (1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));  		Fg.Normalize ();  		Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow (u.Level + 1' 2) / Math.Pow (length' 0.25);  		u.GravitationForce += Fg;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: foreach (var uVertex in _levels [i]) {  	var u = _vertexDatas [uVertex];  	var center = u.Parent.InnerCanvasCenter;  	var Fg = center - u.Position;  	if (Fg.Length == 0)  		continue;  	double length = Math.Max (1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));  	Fg.Normalize ();  	Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow (u.Level + 1' 2) / Math.Pow (length' 0.25);  	u.GravitationForce += Fg;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: foreach (var uVertex in _levels [i]) {  	var u = _vertexDatas [uVertex];  	var center = u.Parent.InnerCanvasCenter;  	var Fg = center - u.Position;  	if (Fg.Length == 0)  		continue;  	double length = Math.Max (1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));  	Fg.Normalize ();  	Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow (u.Level + 1' 2) / Math.Pow (length' 0.25);  	u.GravitationForce += Fg;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: foreach (var uVertex in _levels [i]) {  	var u = _vertexDatas [uVertex];  	var center = u.Parent.InnerCanvasCenter;  	var Fg = center - u.Position;  	if (Fg.Length == 0)  		continue;  	double length = Math.Max (1' Fg.Length / (Parameters.IdealEdgeLength * 2.0));  	Fg.Normalize ();  	Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow (u.Level + 1' 2) / Math.Pow (length' 0.25);  	u.GravitationForce += Fg;  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow (u.Level + 1' 2) / Math.Pow (length' 0.25);  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,ApplyGravitationForces,The following statement contains a magic number: Fg *= Parameters.GravitationFactor * _gravityForceMagnitude * Math.Pow (u.Level + 1' 2) / Math.Pow (length' 0.25);  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,CalcNodePositionsAndSizes,The following statement contains a magic number: for (int i = _levels.Count - 1; i >= 0; i--) {  	foreach (var uVertex in _levels [i]) {  		var u = _vertexDatas [uVertex];  		var force = u.ApplyForce (_temperature * Math.Max (1' _step) / 100.0 * Parameters.DisplacementLimitMultiplier);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Compound.FDP,CompoundFDPLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Compound\FDP\CompoundFDPLayoutAlgorithm.cs,CalcNodePositionsAndSizes,The following statement contains a magic number: foreach (var uVertex in _levels [i]) {  	var u = _vertexDatas [uVertex];  	var force = u.ApplyForce (_temperature * Math.Max (1' _step) / 100.0 * Parameters.DisplacementLimitMultiplier);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaDirtyPhase,The following statement contains a magic number: if (_layers.Count < 2)  	return;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaDirtyPhase,The following statement contains a magic number: SugiyamaPhase1Sweep (_layers.Count - 2' -1' -1' BaryCenter.Down' dirty' byRealPosition);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase1,The following statement contains a magic number: if (_layers.Count < 2)  	return false;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,SugiyamaPhase2,The following statement contains a magic number: unorderedLayerIndex = SugiyamaPhase2Sweep (_layers.Count - 2' -1' -1' BaryCenter.Down' byRealPosition);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CalculateOverlap,The following statement contains a magic number: return Math.Max (0' ((b.Size.Width + a.Size.Width) * 0.5 + plusGap + Parameters.HorizontalGap) - (b.RealPosition.X - a.RealPosition.X));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach (var v in from vertex in layer  orderby vertex.Priority ascending' vertex.SubPriority ascending  select vertex) {  	//first set the new position  	v.RealPosition.X = v.Measure;  	//check if there's any overlap between the actual vertex and the vertices which position has already been set  	SugiVertex v1 = v;  	var alreadySetVertices = layer.Where (vertex => (!double.IsNaN (vertex.RealPosition.X) && vertex != v1)).ToArray ();  	if (alreadySetVertices.Length == 0) {  		//there can't be any overlap  		continue;  	}  	//get the index of the 'v' vertex between the vertices which position has already been set  	int indexOfV;  	for (indexOfV = 0; indexOfV < alreadySetVertices.Length && alreadySetVertices [indexOfV].Position < v.Position; indexOfV++) {  	}  	SugiVertex leftNeighbor = null' rightNeighbor = null;  	double leftOverlap = 0' rightOverlap = 0;  	//check the overlap with vertex on the left  	if (indexOfV > 0) {  		leftNeighbor = alreadySetVertices [indexOfV - 1];  		leftOverlap = CalculateOverlap (leftNeighbor' v);  	}  	if (indexOfV < alreadySetVertices.Length) {  		rightNeighbor = alreadySetVertices [indexOfV];  		rightOverlap = CalculateOverlap (v' rightNeighbor);  	}  	// ReSharper disable PossibleNullReferenceException  	//only one neighbor overlaps  	if (leftOverlap > 0 && rightOverlap == 0) {  		if (leftNeighbor.Priority == v.Priority) {  			double leftMove = leftOverlap * 0.5;  			if (rightNeighbor != null)  				rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			if (rightOverlap > 0) {  				if (v.Priority == rightNeighbor.Priority) {  					double rightMove = rightOverlap * 0.5;  					rightNeighbor.RealPosition.X += rightMove;  					v.RealPosition.X -= rightMove;  					leftNeighbor.RealPosition.X -= rightMove;  				}  				else {  					rightNeighbor.RealPosition.X += rightOverlap;  				}  			}  		}  		else {  			leftNeighbor.RealPosition.X -= leftOverlap;  		}  	}  	else if (leftOverlap == 0 && rightOverlap > 0) {  		if (v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			if (leftNeighbor != null)  				leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			if (leftOverlap > 0) {  				if (leftNeighbor.Priority == v.Priority) {  					double leftMove = leftOverlap * 0.5;  					leftNeighbor.RealPosition.X -= leftMove;  					v.RealPosition.X += leftMove;  					rightNeighbor.RealPosition.X += leftMove;  				}  				else {  					leftNeighbor.RealPosition.X -= leftOverlap;  				}  			}  		}  		else {  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	else if (leftOverlap > 0 && rightOverlap > 0) {  		//if both neighbor overlapped  		//priorities equals' 1 priority lower' 2 priority lower  		if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  		}  		else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  			double leftMove = leftOverlap * 0.5;  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  		}  		else {  			//priorities of the neighbors are lower' or equal  			leftNeighbor.RealPosition.X -= leftOverlap;  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	// ReSharper restore PossibleNullReferenceException  	//the vertices on the left side of the leftNeighbor will be moved' if they overlap  	if (leftOverlap > 0)  		for (int index = indexOfV - 1; index > 0 && (leftOverlap = CalculateOverlap (alreadySetVertices [index - 1]' alreadySetVertices [index])) > 0; index--) {  			alreadySetVertices [index - 1].RealPosition.X -= leftOverlap;  		}  	//the vertices on the right side of the rightNeighbor will be moved' if they overlap  	if (rightOverlap > 0)  		for (int index = indexOfV; index < alreadySetVertices.Length - 1 && (rightOverlap = CalculateOverlap (alreadySetVertices [index]' alreadySetVertices [index + 1])) > 0; index++) {  			alreadySetVertices [index + 1].RealPosition.X += rightOverlap;  		}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach (var v in from vertex in layer  orderby vertex.Priority ascending' vertex.SubPriority ascending  select vertex) {  	//first set the new position  	v.RealPosition.X = v.Measure;  	//check if there's any overlap between the actual vertex and the vertices which position has already been set  	SugiVertex v1 = v;  	var alreadySetVertices = layer.Where (vertex => (!double.IsNaN (vertex.RealPosition.X) && vertex != v1)).ToArray ();  	if (alreadySetVertices.Length == 0) {  		//there can't be any overlap  		continue;  	}  	//get the index of the 'v' vertex between the vertices which position has already been set  	int indexOfV;  	for (indexOfV = 0; indexOfV < alreadySetVertices.Length && alreadySetVertices [indexOfV].Position < v.Position; indexOfV++) {  	}  	SugiVertex leftNeighbor = null' rightNeighbor = null;  	double leftOverlap = 0' rightOverlap = 0;  	//check the overlap with vertex on the left  	if (indexOfV > 0) {  		leftNeighbor = alreadySetVertices [indexOfV - 1];  		leftOverlap = CalculateOverlap (leftNeighbor' v);  	}  	if (indexOfV < alreadySetVertices.Length) {  		rightNeighbor = alreadySetVertices [indexOfV];  		rightOverlap = CalculateOverlap (v' rightNeighbor);  	}  	// ReSharper disable PossibleNullReferenceException  	//only one neighbor overlaps  	if (leftOverlap > 0 && rightOverlap == 0) {  		if (leftNeighbor.Priority == v.Priority) {  			double leftMove = leftOverlap * 0.5;  			if (rightNeighbor != null)  				rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			if (rightOverlap > 0) {  				if (v.Priority == rightNeighbor.Priority) {  					double rightMove = rightOverlap * 0.5;  					rightNeighbor.RealPosition.X += rightMove;  					v.RealPosition.X -= rightMove;  					leftNeighbor.RealPosition.X -= rightMove;  				}  				else {  					rightNeighbor.RealPosition.X += rightOverlap;  				}  			}  		}  		else {  			leftNeighbor.RealPosition.X -= leftOverlap;  		}  	}  	else if (leftOverlap == 0 && rightOverlap > 0) {  		if (v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			if (leftNeighbor != null)  				leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			if (leftOverlap > 0) {  				if (leftNeighbor.Priority == v.Priority) {  					double leftMove = leftOverlap * 0.5;  					leftNeighbor.RealPosition.X -= leftMove;  					v.RealPosition.X += leftMove;  					rightNeighbor.RealPosition.X += leftMove;  				}  				else {  					leftNeighbor.RealPosition.X -= leftOverlap;  				}  			}  		}  		else {  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	else if (leftOverlap > 0 && rightOverlap > 0) {  		//if both neighbor overlapped  		//priorities equals' 1 priority lower' 2 priority lower  		if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  		}  		else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  			double leftMove = leftOverlap * 0.5;  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  		}  		else {  			//priorities of the neighbors are lower' or equal  			leftNeighbor.RealPosition.X -= leftOverlap;  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	// ReSharper restore PossibleNullReferenceException  	//the vertices on the left side of the leftNeighbor will be moved' if they overlap  	if (leftOverlap > 0)  		for (int index = indexOfV - 1; index > 0 && (leftOverlap = CalculateOverlap (alreadySetVertices [index - 1]' alreadySetVertices [index])) > 0; index--) {  			alreadySetVertices [index - 1].RealPosition.X -= leftOverlap;  		}  	//the vertices on the right side of the rightNeighbor will be moved' if they overlap  	if (rightOverlap > 0)  		for (int index = indexOfV; index < alreadySetVertices.Length - 1 && (rightOverlap = CalculateOverlap (alreadySetVertices [index]' alreadySetVertices [index + 1])) > 0; index++) {  			alreadySetVertices [index + 1].RealPosition.X += rightOverlap;  		}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach (var v in from vertex in layer  orderby vertex.Priority ascending' vertex.SubPriority ascending  select vertex) {  	//first set the new position  	v.RealPosition.X = v.Measure;  	//check if there's any overlap between the actual vertex and the vertices which position has already been set  	SugiVertex v1 = v;  	var alreadySetVertices = layer.Where (vertex => (!double.IsNaN (vertex.RealPosition.X) && vertex != v1)).ToArray ();  	if (alreadySetVertices.Length == 0) {  		//there can't be any overlap  		continue;  	}  	//get the index of the 'v' vertex between the vertices which position has already been set  	int indexOfV;  	for (indexOfV = 0; indexOfV < alreadySetVertices.Length && alreadySetVertices [indexOfV].Position < v.Position; indexOfV++) {  	}  	SugiVertex leftNeighbor = null' rightNeighbor = null;  	double leftOverlap = 0' rightOverlap = 0;  	//check the overlap with vertex on the left  	if (indexOfV > 0) {  		leftNeighbor = alreadySetVertices [indexOfV - 1];  		leftOverlap = CalculateOverlap (leftNeighbor' v);  	}  	if (indexOfV < alreadySetVertices.Length) {  		rightNeighbor = alreadySetVertices [indexOfV];  		rightOverlap = CalculateOverlap (v' rightNeighbor);  	}  	// ReSharper disable PossibleNullReferenceException  	//only one neighbor overlaps  	if (leftOverlap > 0 && rightOverlap == 0) {  		if (leftNeighbor.Priority == v.Priority) {  			double leftMove = leftOverlap * 0.5;  			if (rightNeighbor != null)  				rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			if (rightOverlap > 0) {  				if (v.Priority == rightNeighbor.Priority) {  					double rightMove = rightOverlap * 0.5;  					rightNeighbor.RealPosition.X += rightMove;  					v.RealPosition.X -= rightMove;  					leftNeighbor.RealPosition.X -= rightMove;  				}  				else {  					rightNeighbor.RealPosition.X += rightOverlap;  				}  			}  		}  		else {  			leftNeighbor.RealPosition.X -= leftOverlap;  		}  	}  	else if (leftOverlap == 0 && rightOverlap > 0) {  		if (v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			if (leftNeighbor != null)  				leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			if (leftOverlap > 0) {  				if (leftNeighbor.Priority == v.Priority) {  					double leftMove = leftOverlap * 0.5;  					leftNeighbor.RealPosition.X -= leftMove;  					v.RealPosition.X += leftMove;  					rightNeighbor.RealPosition.X += leftMove;  				}  				else {  					leftNeighbor.RealPosition.X -= leftOverlap;  				}  			}  		}  		else {  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	else if (leftOverlap > 0 && rightOverlap > 0) {  		//if both neighbor overlapped  		//priorities equals' 1 priority lower' 2 priority lower  		if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  		}  		else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  			double leftMove = leftOverlap * 0.5;  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  		}  		else {  			//priorities of the neighbors are lower' or equal  			leftNeighbor.RealPosition.X -= leftOverlap;  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	// ReSharper restore PossibleNullReferenceException  	//the vertices on the left side of the leftNeighbor will be moved' if they overlap  	if (leftOverlap > 0)  		for (int index = indexOfV - 1; index > 0 && (leftOverlap = CalculateOverlap (alreadySetVertices [index - 1]' alreadySetVertices [index])) > 0; index--) {  			alreadySetVertices [index - 1].RealPosition.X -= leftOverlap;  		}  	//the vertices on the right side of the rightNeighbor will be moved' if they overlap  	if (rightOverlap > 0)  		for (int index = indexOfV; index < alreadySetVertices.Length - 1 && (rightOverlap = CalculateOverlap (alreadySetVertices [index]' alreadySetVertices [index + 1])) > 0; index++) {  			alreadySetVertices [index + 1].RealPosition.X += rightOverlap;  		}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach (var v in from vertex in layer  orderby vertex.Priority ascending' vertex.SubPriority ascending  select vertex) {  	//first set the new position  	v.RealPosition.X = v.Measure;  	//check if there's any overlap between the actual vertex and the vertices which position has already been set  	SugiVertex v1 = v;  	var alreadySetVertices = layer.Where (vertex => (!double.IsNaN (vertex.RealPosition.X) && vertex != v1)).ToArray ();  	if (alreadySetVertices.Length == 0) {  		//there can't be any overlap  		continue;  	}  	//get the index of the 'v' vertex between the vertices which position has already been set  	int indexOfV;  	for (indexOfV = 0; indexOfV < alreadySetVertices.Length && alreadySetVertices [indexOfV].Position < v.Position; indexOfV++) {  	}  	SugiVertex leftNeighbor = null' rightNeighbor = null;  	double leftOverlap = 0' rightOverlap = 0;  	//check the overlap with vertex on the left  	if (indexOfV > 0) {  		leftNeighbor = alreadySetVertices [indexOfV - 1];  		leftOverlap = CalculateOverlap (leftNeighbor' v);  	}  	if (indexOfV < alreadySetVertices.Length) {  		rightNeighbor = alreadySetVertices [indexOfV];  		rightOverlap = CalculateOverlap (v' rightNeighbor);  	}  	// ReSharper disable PossibleNullReferenceException  	//only one neighbor overlaps  	if (leftOverlap > 0 && rightOverlap == 0) {  		if (leftNeighbor.Priority == v.Priority) {  			double leftMove = leftOverlap * 0.5;  			if (rightNeighbor != null)  				rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			if (rightOverlap > 0) {  				if (v.Priority == rightNeighbor.Priority) {  					double rightMove = rightOverlap * 0.5;  					rightNeighbor.RealPosition.X += rightMove;  					v.RealPosition.X -= rightMove;  					leftNeighbor.RealPosition.X -= rightMove;  				}  				else {  					rightNeighbor.RealPosition.X += rightOverlap;  				}  			}  		}  		else {  			leftNeighbor.RealPosition.X -= leftOverlap;  		}  	}  	else if (leftOverlap == 0 && rightOverlap > 0) {  		if (v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			if (leftNeighbor != null)  				leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			if (leftOverlap > 0) {  				if (leftNeighbor.Priority == v.Priority) {  					double leftMove = leftOverlap * 0.5;  					leftNeighbor.RealPosition.X -= leftMove;  					v.RealPosition.X += leftMove;  					rightNeighbor.RealPosition.X += leftMove;  				}  				else {  					leftNeighbor.RealPosition.X -= leftOverlap;  				}  			}  		}  		else {  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	else if (leftOverlap > 0 && rightOverlap > 0) {  		//if both neighbor overlapped  		//priorities equals' 1 priority lower' 2 priority lower  		if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  		}  		else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  			double leftMove = leftOverlap * 0.5;  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  		}  		else {  			//priorities of the neighbors are lower' or equal  			leftNeighbor.RealPosition.X -= leftOverlap;  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	// ReSharper restore PossibleNullReferenceException  	//the vertices on the left side of the leftNeighbor will be moved' if they overlap  	if (leftOverlap > 0)  		for (int index = indexOfV - 1; index > 0 && (leftOverlap = CalculateOverlap (alreadySetVertices [index - 1]' alreadySetVertices [index])) > 0; index--) {  			alreadySetVertices [index - 1].RealPosition.X -= leftOverlap;  		}  	//the vertices on the right side of the rightNeighbor will be moved' if they overlap  	if (rightOverlap > 0)  		for (int index = indexOfV; index < alreadySetVertices.Length - 1 && (rightOverlap = CalculateOverlap (alreadySetVertices [index]' alreadySetVertices [index + 1])) > 0; index++) {  			alreadySetVertices [index + 1].RealPosition.X += rightOverlap;  		}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach (var v in from vertex in layer  orderby vertex.Priority ascending' vertex.SubPriority ascending  select vertex) {  	//first set the new position  	v.RealPosition.X = v.Measure;  	//check if there's any overlap between the actual vertex and the vertices which position has already been set  	SugiVertex v1 = v;  	var alreadySetVertices = layer.Where (vertex => (!double.IsNaN (vertex.RealPosition.X) && vertex != v1)).ToArray ();  	if (alreadySetVertices.Length == 0) {  		//there can't be any overlap  		continue;  	}  	//get the index of the 'v' vertex between the vertices which position has already been set  	int indexOfV;  	for (indexOfV = 0; indexOfV < alreadySetVertices.Length && alreadySetVertices [indexOfV].Position < v.Position; indexOfV++) {  	}  	SugiVertex leftNeighbor = null' rightNeighbor = null;  	double leftOverlap = 0' rightOverlap = 0;  	//check the overlap with vertex on the left  	if (indexOfV > 0) {  		leftNeighbor = alreadySetVertices [indexOfV - 1];  		leftOverlap = CalculateOverlap (leftNeighbor' v);  	}  	if (indexOfV < alreadySetVertices.Length) {  		rightNeighbor = alreadySetVertices [indexOfV];  		rightOverlap = CalculateOverlap (v' rightNeighbor);  	}  	// ReSharper disable PossibleNullReferenceException  	//only one neighbor overlaps  	if (leftOverlap > 0 && rightOverlap == 0) {  		if (leftNeighbor.Priority == v.Priority) {  			double leftMove = leftOverlap * 0.5;  			if (rightNeighbor != null)  				rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			if (rightOverlap > 0) {  				if (v.Priority == rightNeighbor.Priority) {  					double rightMove = rightOverlap * 0.5;  					rightNeighbor.RealPosition.X += rightMove;  					v.RealPosition.X -= rightMove;  					leftNeighbor.RealPosition.X -= rightMove;  				}  				else {  					rightNeighbor.RealPosition.X += rightOverlap;  				}  			}  		}  		else {  			leftNeighbor.RealPosition.X -= leftOverlap;  		}  	}  	else if (leftOverlap == 0 && rightOverlap > 0) {  		if (v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			if (leftNeighbor != null)  				leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			if (leftOverlap > 0) {  				if (leftNeighbor.Priority == v.Priority) {  					double leftMove = leftOverlap * 0.5;  					leftNeighbor.RealPosition.X -= leftMove;  					v.RealPosition.X += leftMove;  					rightNeighbor.RealPosition.X += leftMove;  				}  				else {  					leftNeighbor.RealPosition.X -= leftOverlap;  				}  			}  		}  		else {  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	else if (leftOverlap > 0 && rightOverlap > 0) {  		//if both neighbor overlapped  		//priorities equals' 1 priority lower' 2 priority lower  		if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  		}  		else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  			double leftMove = leftOverlap * 0.5;  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  		}  		else {  			//priorities of the neighbors are lower' or equal  			leftNeighbor.RealPosition.X -= leftOverlap;  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	// ReSharper restore PossibleNullReferenceException  	//the vertices on the left side of the leftNeighbor will be moved' if they overlap  	if (leftOverlap > 0)  		for (int index = indexOfV - 1; index > 0 && (leftOverlap = CalculateOverlap (alreadySetVertices [index - 1]' alreadySetVertices [index])) > 0; index--) {  			alreadySetVertices [index - 1].RealPosition.X -= leftOverlap;  		}  	//the vertices on the right side of the rightNeighbor will be moved' if they overlap  	if (rightOverlap > 0)  		for (int index = indexOfV; index < alreadySetVertices.Length - 1 && (rightOverlap = CalculateOverlap (alreadySetVertices [index]' alreadySetVertices [index + 1])) > 0; index++) {  			alreadySetVertices [index + 1].RealPosition.X += rightOverlap;  		}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: foreach (var v in from vertex in layer  orderby vertex.Priority ascending' vertex.SubPriority ascending  select vertex) {  	//first set the new position  	v.RealPosition.X = v.Measure;  	//check if there's any overlap between the actual vertex and the vertices which position has already been set  	SugiVertex v1 = v;  	var alreadySetVertices = layer.Where (vertex => (!double.IsNaN (vertex.RealPosition.X) && vertex != v1)).ToArray ();  	if (alreadySetVertices.Length == 0) {  		//there can't be any overlap  		continue;  	}  	//get the index of the 'v' vertex between the vertices which position has already been set  	int indexOfV;  	for (indexOfV = 0; indexOfV < alreadySetVertices.Length && alreadySetVertices [indexOfV].Position < v.Position; indexOfV++) {  	}  	SugiVertex leftNeighbor = null' rightNeighbor = null;  	double leftOverlap = 0' rightOverlap = 0;  	//check the overlap with vertex on the left  	if (indexOfV > 0) {  		leftNeighbor = alreadySetVertices [indexOfV - 1];  		leftOverlap = CalculateOverlap (leftNeighbor' v);  	}  	if (indexOfV < alreadySetVertices.Length) {  		rightNeighbor = alreadySetVertices [indexOfV];  		rightOverlap = CalculateOverlap (v' rightNeighbor);  	}  	// ReSharper disable PossibleNullReferenceException  	//only one neighbor overlaps  	if (leftOverlap > 0 && rightOverlap == 0) {  		if (leftNeighbor.Priority == v.Priority) {  			double leftMove = leftOverlap * 0.5;  			if (rightNeighbor != null)  				rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			if (rightOverlap > 0) {  				if (v.Priority == rightNeighbor.Priority) {  					double rightMove = rightOverlap * 0.5;  					rightNeighbor.RealPosition.X += rightMove;  					v.RealPosition.X -= rightMove;  					leftNeighbor.RealPosition.X -= rightMove;  				}  				else {  					rightNeighbor.RealPosition.X += rightOverlap;  				}  			}  		}  		else {  			leftNeighbor.RealPosition.X -= leftOverlap;  		}  	}  	else if (leftOverlap == 0 && rightOverlap > 0) {  		if (v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			if (leftNeighbor != null)  				leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			if (leftOverlap > 0) {  				if (leftNeighbor.Priority == v.Priority) {  					double leftMove = leftOverlap * 0.5;  					leftNeighbor.RealPosition.X -= leftMove;  					v.RealPosition.X += leftMove;  					rightNeighbor.RealPosition.X += leftMove;  				}  				else {  					leftNeighbor.RealPosition.X -= leftOverlap;  				}  			}  		}  		else {  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	else if (leftOverlap > 0 && rightOverlap > 0) {  		//if both neighbor overlapped  		//priorities equals' 1 priority lower' 2 priority lower  		if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  		}  		else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  			double leftMove = leftOverlap * 0.5;  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  		}  		else {  			//priorities of the neighbors are lower' or equal  			leftNeighbor.RealPosition.X -= leftOverlap;  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  	// ReSharper restore PossibleNullReferenceException  	//the vertices on the left side of the leftNeighbor will be moved' if they overlap  	if (leftOverlap > 0)  		for (int index = indexOfV - 1; index > 0 && (leftOverlap = CalculateOverlap (alreadySetVertices [index - 1]' alreadySetVertices [index])) > 0; index--) {  			alreadySetVertices [index - 1].RealPosition.X -= leftOverlap;  		}  	//the vertices on the right side of the rightNeighbor will be moved' if they overlap  	if (rightOverlap > 0)  		for (int index = indexOfV; index < alreadySetVertices.Length - 1 && (rightOverlap = CalculateOverlap (alreadySetVertices [index]' alreadySetVertices [index + 1])) > 0; index++) {  			alreadySetVertices [index + 1].RealPosition.X += rightOverlap;  		}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0 && rightOverlap == 0) {  	if (leftNeighbor.Priority == v.Priority) {  		double leftMove = leftOverlap * 0.5;  		if (rightNeighbor != null)  			rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		if (rightOverlap > 0) {  			if (v.Priority == rightNeighbor.Priority) {  				double rightMove = rightOverlap * 0.5;  				rightNeighbor.RealPosition.X += rightMove;  				v.RealPosition.X -= rightMove;  				leftNeighbor.RealPosition.X -= rightMove;  			}  			else {  				rightNeighbor.RealPosition.X += rightOverlap;  			}  		}  	}  	else {  		leftNeighbor.RealPosition.X -= leftOverlap;  	}  }  else if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0 && rightOverlap == 0) {  	if (leftNeighbor.Priority == v.Priority) {  		double leftMove = leftOverlap * 0.5;  		if (rightNeighbor != null)  			rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		if (rightOverlap > 0) {  			if (v.Priority == rightNeighbor.Priority) {  				double rightMove = rightOverlap * 0.5;  				rightNeighbor.RealPosition.X += rightMove;  				v.RealPosition.X -= rightMove;  				leftNeighbor.RealPosition.X -= rightMove;  			}  			else {  				rightNeighbor.RealPosition.X += rightOverlap;  			}  		}  	}  	else {  		leftNeighbor.RealPosition.X -= leftOverlap;  	}  }  else if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0 && rightOverlap == 0) {  	if (leftNeighbor.Priority == v.Priority) {  		double leftMove = leftOverlap * 0.5;  		if (rightNeighbor != null)  			rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		if (rightOverlap > 0) {  			if (v.Priority == rightNeighbor.Priority) {  				double rightMove = rightOverlap * 0.5;  				rightNeighbor.RealPosition.X += rightMove;  				v.RealPosition.X -= rightMove;  				leftNeighbor.RealPosition.X -= rightMove;  			}  			else {  				rightNeighbor.RealPosition.X += rightOverlap;  			}  		}  	}  	else {  		leftNeighbor.RealPosition.X -= leftOverlap;  	}  }  else if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0 && rightOverlap == 0) {  	if (leftNeighbor.Priority == v.Priority) {  		double leftMove = leftOverlap * 0.5;  		if (rightNeighbor != null)  			rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		if (rightOverlap > 0) {  			if (v.Priority == rightNeighbor.Priority) {  				double rightMove = rightOverlap * 0.5;  				rightNeighbor.RealPosition.X += rightMove;  				v.RealPosition.X -= rightMove;  				leftNeighbor.RealPosition.X -= rightMove;  			}  			else {  				rightNeighbor.RealPosition.X += rightOverlap;  			}  		}  	}  	else {  		leftNeighbor.RealPosition.X -= leftOverlap;  	}  }  else if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0 && rightOverlap == 0) {  	if (leftNeighbor.Priority == v.Priority) {  		double leftMove = leftOverlap * 0.5;  		if (rightNeighbor != null)  			rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		if (rightOverlap > 0) {  			if (v.Priority == rightNeighbor.Priority) {  				double rightMove = rightOverlap * 0.5;  				rightNeighbor.RealPosition.X += rightMove;  				v.RealPosition.X -= rightMove;  				leftNeighbor.RealPosition.X -= rightMove;  			}  			else {  				rightNeighbor.RealPosition.X += rightOverlap;  			}  		}  	}  	else {  		leftNeighbor.RealPosition.X -= leftOverlap;  	}  }  else if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0 && rightOverlap == 0) {  	if (leftNeighbor.Priority == v.Priority) {  		double leftMove = leftOverlap * 0.5;  		if (rightNeighbor != null)  			rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		if (rightOverlap > 0) {  			if (v.Priority == rightNeighbor.Priority) {  				double rightMove = rightOverlap * 0.5;  				rightNeighbor.RealPosition.X += rightMove;  				v.RealPosition.X -= rightMove;  				leftNeighbor.RealPosition.X -= rightMove;  			}  			else {  				rightNeighbor.RealPosition.X += rightOverlap;  			}  		}  	}  	else {  		leftNeighbor.RealPosition.X -= leftOverlap;  	}  }  else if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftNeighbor.Priority == v.Priority) {  	double leftMove = leftOverlap * 0.5;  	if (rightNeighbor != null)  		rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  	leftNeighbor.RealPosition.X -= leftMove;  	v.RealPosition.X += leftMove;  	if (rightOverlap > 0) {  		if (v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			leftNeighbor.RealPosition.X -= rightMove;  		}  		else {  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  }  else {  	leftNeighbor.RealPosition.X -= leftOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftNeighbor.Priority == v.Priority) {  	double leftMove = leftOverlap * 0.5;  	if (rightNeighbor != null)  		rightOverlap = CalculateOverlap (v' rightNeighbor' leftMove);  	leftNeighbor.RealPosition.X -= leftMove;  	v.RealPosition.X += leftMove;  	if (rightOverlap > 0) {  		if (v.Priority == rightNeighbor.Priority) {  			double rightMove = rightOverlap * 0.5;  			rightNeighbor.RealPosition.X += rightMove;  			v.RealPosition.X -= rightMove;  			leftNeighbor.RealPosition.X -= rightMove;  		}  		else {  			rightNeighbor.RealPosition.X += rightOverlap;  		}  	}  }  else {  	leftNeighbor.RealPosition.X -= leftOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= rightMove;  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (v.Priority == rightNeighbor.Priority) {  	double rightMove = rightOverlap * 0.5;  	rightNeighbor.RealPosition.X += rightMove;  	v.RealPosition.X -= rightMove;  	leftNeighbor.RealPosition.X -= rightMove;  }  else {  	rightNeighbor.RealPosition.X += rightOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap == 0 && rightOverlap > 0) {  	if (v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		if (leftNeighbor != null)  			leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		if (leftOverlap > 0) {  			if (leftNeighbor.Priority == v.Priority) {  				double leftMove = leftOverlap * 0.5;  				leftNeighbor.RealPosition.X -= leftMove;  				v.RealPosition.X += leftMove;  				rightNeighbor.RealPosition.X += leftMove;  			}  			else {  				leftNeighbor.RealPosition.X -= leftOverlap;  			}  		}  	}  	else {  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  else if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (v.Priority == rightNeighbor.Priority) {  	double rightMove = rightOverlap * 0.5;  	if (leftNeighbor != null)  		leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  	rightNeighbor.RealPosition.X += rightMove;  	v.RealPosition.X -= rightMove;  	if (leftOverlap > 0) {  		if (leftNeighbor.Priority == v.Priority) {  			double leftMove = leftOverlap * 0.5;  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			rightNeighbor.RealPosition.X += leftMove;  		}  		else {  			leftNeighbor.RealPosition.X -= leftOverlap;  		}  	}  }  else {  	rightNeighbor.RealPosition.X += rightOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (v.Priority == rightNeighbor.Priority) {  	double rightMove = rightOverlap * 0.5;  	if (leftNeighbor != null)  		leftOverlap = CalculateOverlap (leftNeighbor' v' rightMove);  	rightNeighbor.RealPosition.X += rightMove;  	v.RealPosition.X -= rightMove;  	if (leftOverlap > 0) {  		if (leftNeighbor.Priority == v.Priority) {  			double leftMove = leftOverlap * 0.5;  			leftNeighbor.RealPosition.X -= leftMove;  			v.RealPosition.X += leftMove;  			rightNeighbor.RealPosition.X += leftMove;  		}  		else {  			leftNeighbor.RealPosition.X -= leftOverlap;  		}  	}  }  else {  	rightNeighbor.RealPosition.X += rightOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0) {  	if (leftNeighbor.Priority == v.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X += leftMove;  	}  	else {  		leftNeighbor.RealPosition.X -= leftOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftNeighbor.Priority == v.Priority) {  	double leftMove = leftOverlap * 0.5;  	leftNeighbor.RealPosition.X -= leftMove;  	v.RealPosition.X += leftMove;  	rightNeighbor.RealPosition.X += leftMove;  }  else {  	leftNeighbor.RealPosition.X -= leftOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftOverlap > 0 && rightOverlap > 0) {  	//if both neighbor overlapped  	//priorities equals' 1 priority lower' 2 priority lower  	if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  		double rightMove = rightOverlap * 0.5;  		rightNeighbor.RealPosition.X += rightMove;  		v.RealPosition.X -= rightMove;  		leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  	}  	else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  		double leftMove = leftOverlap * 0.5;  		leftNeighbor.RealPosition.X -= leftMove;  		v.RealPosition.X += leftMove;  		rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  	}  	else {  		//priorities of the neighbors are lower' or equal  		leftNeighbor.RealPosition.X -= leftOverlap;  		rightNeighbor.RealPosition.X += rightOverlap;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  	double rightMove = rightOverlap * 0.5;  	rightNeighbor.RealPosition.X += rightMove;  	v.RealPosition.X -= rightMove;  	leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  }  else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  	double leftMove = leftOverlap * 0.5;  	leftNeighbor.RealPosition.X -= leftMove;  	v.RealPosition.X += leftMove;  	rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  }  else {  	//priorities of the neighbors are lower' or equal  	leftNeighbor.RealPosition.X -= leftOverlap;  	rightNeighbor.RealPosition.X += rightOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftNeighbor.Priority < v.Priority && v.Priority == rightNeighbor.Priority) {  	double rightMove = rightOverlap * 0.5;  	rightNeighbor.RealPosition.X += rightMove;  	v.RealPosition.X -= rightMove;  	leftNeighbor.RealPosition.X -= (leftOverlap + rightMove);  }  else if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  	double leftMove = leftOverlap * 0.5;  	leftNeighbor.RealPosition.X -= leftMove;  	v.RealPosition.X += leftMove;  	rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  }  else {  	//priorities of the neighbors are lower' or equal  	leftNeighbor.RealPosition.X -= leftOverlap;  	rightNeighbor.RealPosition.X += rightOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignmentOnLayer,The following statement contains a magic number: if (leftNeighbor.Priority == v.Priority && v.Priority > rightNeighbor.Priority) {  	double leftMove = leftOverlap * 0.5;  	leftNeighbor.RealPosition.X -= leftMove;  	v.RealPosition.X += leftMove;  	rightNeighbor.RealPosition.X = (rightOverlap + leftMove);  }  else {  	//priorities of the neighbors are lower' or equal  	leftNeighbor.RealPosition.X -= leftOverlap;  	rightNeighbor.RealPosition.X += rightOverlap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignment,The following statement contains a magic number: if (_layers.Count > 1) {  	HorizontalPositionAssignmentSweep (1' _layers.Count' 1' BaryCenter.Up);  	HorizontalPositionAssignmentSweep (_layers.Count - 2' -1' -1' BaryCenter.Down);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,HorizontalPositionAssignment,The following statement contains a magic number: HorizontalPositionAssignmentSweep (_layers.Count - 2' -1' -1' BaryCenter.Down);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: for (int i = 0; i < _layers.Count; i++) {  	double pos = 0;  	double layerHeight = _layers [i].Height;  	foreach (var v in _layers [i]) {  		v.RealPosition.X = pos;  		v.RealPosition.Y = ((i == 0) ? (layerHeight - v.Size.Height) : verticalPos + layerHeight * (float)0.5);  		pos += v.Size.Width + Parameters.HorizontalGap;  	}  	verticalPos += layerHeight + Parameters.VerticalGap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: foreach (var v in _layers [i]) {  	v.RealPosition.X = pos;  	v.RealPosition.Y = ((i == 0) ? (layerHeight - v.Size.Height) : verticalPos + layerHeight * (float)0.5);  	pos += v.Size.Width + Parameters.HorizontalGap;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,AssignPositions,The following statement contains a magic number: v.RealPosition.Y = ((i == 0) ? (layerHeight - v.Size.Height) : verticalPos + layerHeight * (float)0.5);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: if (shouldTranslate) {  	foreach (var v in _graph.Vertices) {  		if (double.IsNaN (v.RealPosition.X) || double.IsNaN (v.RealPosition.Y))  			continue;  		translation.X = Math.Min (v.RealPosition.X' translation.X);  		translation.Y = Math.Min (v.RealPosition.Y' translation.Y);  	}  	translation *= -1;  	translation.X += Parameters.VerticalGap / 2;  	translation.Y += Parameters.HorizontalGap / 2;  	//translate with the topLeft position  	foreach (var v in _graph.Vertices)  		v.RealPosition += translation;  }  else {  	translation = new Vector (0' 0);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: if (shouldTranslate) {  	foreach (var v in _graph.Vertices) {  		if (double.IsNaN (v.RealPosition.X) || double.IsNaN (v.RealPosition.Y))  			continue;  		translation.X = Math.Min (v.RealPosition.X' translation.X);  		translation.Y = Math.Min (v.RealPosition.Y' translation.Y);  	}  	translation *= -1;  	translation.X += Parameters.VerticalGap / 2;  	translation.Y += Parameters.HorizontalGap / 2;  	//translate with the topLeft position  	foreach (var v in _graph.Vertices)  		v.RealPosition += translation;  }  else {  	translation = new Vector (0' 0);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: translation.X += Parameters.VerticalGap / 2;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: translation.Y += Parameters.HorizontalGap / 2;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: foreach (var v in _graph.Vertices) {  	if (v.IsDummyVertex)  		continue;  	Point pos = v.RealPosition;  	if (!shouldTranslate) {  		pos.X += v.Size.Width * 0.5 + translation.X;  		pos.Y += v.Size.Height * 0.5 + translation.Y;  	}  	VertexPositions [v.Original] = pos;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: foreach (var v in _graph.Vertices) {  	if (v.IsDummyVertex)  		continue;  	Point pos = v.RealPosition;  	if (!shouldTranslate) {  		pos.X += v.Size.Width * 0.5 + translation.X;  		pos.Y += v.Size.Height * 0.5 + translation.Y;  	}  	VertexPositions [v.Original] = pos;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: if (!shouldTranslate) {  	pos.X += v.Size.Width * 0.5 + translation.X;  	pos.Y += v.Size.Height * 0.5 + translation.Y;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: if (!shouldTranslate) {  	pos.X += v.Size.Width * 0.5 + translation.X;  	pos.Y += v.Size.Height * 0.5 + translation.Y;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: pos.X += v.Size.Width * 0.5 + translation.X;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,CopyPositionsSilent,The following statement contains a magic number: pos.Y += v.Size.Height * 0.5 + translation.Y;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.Hierarchical,SugiyamaLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Hierarchical\SugiyamaLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: _statusInPercent = 100;  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: while (firstIndex < pairCount)  	firstIndex *= 2;  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: firstIndex *= 2;  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: foreach (var list in radixByFirst) {  	if (list == null)  		continue;  	foreach (var pair in list) {  		index = pair.Second + firstIndex;  		tree [index] += pair.Weight;  		while (index > 0) {  			if (index % 2 > 0)  				crossCount += tree [index + 1] * pair.Weight;  			index = (index - 1) / 2;  			tree [index] += pair.Weight;  		}  	}  }  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: foreach (var list in radixByFirst) {  	if (list == null)  		continue;  	foreach (var pair in list) {  		index = pair.Second + firstIndex;  		tree [index] += pair.Weight;  		while (index > 0) {  			if (index % 2 > 0)  				crossCount += tree [index + 1] * pair.Weight;  			index = (index - 1) / 2;  			tree [index] += pair.Weight;  		}  	}  }  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: foreach (var pair in list) {  	index = pair.Second + firstIndex;  	tree [index] += pair.Weight;  	while (index > 0) {  		if (index % 2 > 0)  			crossCount += tree [index + 1] * pair.Weight;  		index = (index - 1) / 2;  		tree [index] += pair.Weight;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: foreach (var pair in list) {  	index = pair.Second + firstIndex;  	tree [index] += pair.Weight;  	while (index > 0) {  		if (index % 2 > 0)  			crossCount += tree [index + 1] * pair.Weight;  		index = (index - 1) / 2;  		tree [index] += pair.Weight;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: while (index > 0) {  	if (index % 2 > 0)  		crossCount += tree [index + 1] * pair.Weight;  	index = (index - 1) / 2;  	tree [index] += pair.Weight;  }  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: while (index > 0) {  	if (index % 2 > 0)  		crossCount += tree [index + 1] * pair.Weight;  	index = (index - 1) / 2;  	tree [index] += pair.Weight;  }  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: if (index % 2 > 0)  	crossCount += tree [index + 1] * pair.Weight;  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,BiLayerCrossCount,The following statement contains a magic number: index = (index - 1) / 2;  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides [0] = (s.X - size.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides [1] = (s.Y - size.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides [2] = (s.X + size.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides [2] = (s.X + size.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides [3] = (s.Y + size.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: sides [3] = (s.Y + size.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (sides [i] <= 1)  		fi = Math.Max (fi' sides [i]);  }  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: if (fi == 0) {  	fi = double.PositiveInfinity;  	for (int i = 0; i < 4; i++)  		fi = Math.Min (fi' Math.Abs (sides [i]));  	fi *= -1;  }  
Magic Number,GraphSharp.Algorithms.Layout,LayoutUtil,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\LayoutUtil.cs,GetClippingPoint,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	fi = Math.Min (fi' Math.Abs (sides [i]));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters is BoundedFRLayoutParameters) {  	var param = Parameters as BoundedFRLayoutParameters;  	InitializeWithRandomPositions (param.Width' param.Height);  	_maxWidth = param.Width;  	_maxHeight = param.Height;  }  else {  	InitializeWithRandomPositions (10.0' 10.0);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters is BoundedFRLayoutParameters) {  	var param = Parameters as BoundedFRLayoutParameters;  	InitializeWithRandomPositions (param.Width' param.Height);  	_maxWidth = param.Width;  	_maxHeight = param.Height;  }  else {  	InitializeWithRandomPositions (10.0' 10.0);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: InitializeWithRandomPositions (10.0' 10.0);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: InitializeWithRandomPositions (10.0' 10.0);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,IterateOne,The following statement contains a magic number: foreach (Edge e in VisitedGraph.Edges) {  	Vertex source = e.Source;  	Vertex target = e.Target;  	//vonz�er� sz�m�t�sa a k�t pont k�zt  	Vector delta = VertexPositions [source] - VertexPositions [target];  	double length = Math.Max (delta.Length' double.Epsilon);  	delta = delta / length * Math.Pow (length' 2) / Parameters.ConstantOfAttraction;  	forces [source] -= delta;  	forces [target] += delta;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,IterateOne,The following statement contains a magic number: delta = delta / length * Math.Pow (length' 2) / Parameters.ConstantOfAttraction;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int epoch = 0; epoch < Parameters.MaxEpoch; epoch++) {  	Adjust ();  	//Update Parameters  	double factor = Math.Exp (-1 * Parameters.CoolingFactor * (1.0 * epoch / Parameters.MaxEpoch));  	adaptation = Math.Max (Parameters.MinAdaption' factor * Parameters.InitialAdaption);  	if (radius > Parameters.MinRadius && epoch % Parameters.RadiusConstantTime == 0) {  		radius--;  	}  	//report  	if (ReportOnIterationEndNeeded)  		OnIterationEnded (epoch' (double)epoch / (double)Parameters.MaxEpoch' "Iteration " + epoch + " finished."' true);  	else if (ReportOnProgressChangedNeeded)  		OnProgressChanged ((double)epoch / (double)Parameters.MaxEpoch * 100);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (ReportOnIterationEndNeeded)  	OnIterationEnded (epoch' (double)epoch / (double)Parameters.MaxEpoch' "Iteration " + epoch + " finished."' true);  else if (ReportOnProgressChangedNeeded)  	OnProgressChanged ((double)epoch / (double)Parameters.MaxEpoch * 100);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (ReportOnProgressChangedNeeded)  	OnProgressChanged ((double)epoch / (double)Parameters.MaxEpoch * 100);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: OnProgressChanged ((double)epoch / (double)Parameters.MaxEpoch * 100);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,Adjust,The following statement contains a magic number: _tempPos.X = 0.1 * Parameters.Width + (_rnd.NextDouble () * 0.8 * Parameters.Width);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,Adjust,The following statement contains a magic number: _tempPos.X = 0.1 * Parameters.Width + (_rnd.NextDouble () * 0.8 * Parameters.Width);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,Adjust,The following statement contains a magic number: _tempPos.Y = 0.1 * Parameters.Height + (_rnd.NextDouble () * 0.8 * Parameters.Height);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,Adjust,The following statement contains a magic number: _tempPos.Y = 0.1 * Parameters.Height + (_rnd.NextDouble () * 0.8 * Parameters.Height);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,ISOMLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\ISOMLayoutAlgorithm.cs,AdjustVertex,The following statement contains a magic number: while (_queue.Count > 0) {  	TVertex current = _queue.Dequeue ();  	ISOMData currentVid = _isomDataDict [current];  	Point pos = VertexPositions [current];  	Vector force = _tempPos - pos;  	double factor = adaptation / Math.Pow (2' currentVid.Distance);  	pos += factor * force;  	VertexPositions [current] = pos;  	//ha m�g a hat�k�r�n bel�l van  	if (currentVid.Distance < radius) {  		//akkor a szomszedokra is hatassal vagyunk  		foreach (TVertex neighbour in VisitedGraph.GetNeighbours<TVertex' TEdge> (current)) {  			ISOMData nvid = _isomDataDict [neighbour];  			if (!nvid.Visited) {  				nvid.Visited = true;  				nvid.Distance = currentVid.Distance + 1;  				_queue.Enqueue (neighbour);  			}  		}  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergyIfExchanged,The following statement contains a magic number: for (int i = 0; i < vertices.Length - 1; i++) {  	for (int j = i + 1; j < vertices.Length; j++) {  		int ii = (i == p) ? q : i;  		int jj = (j == q) ? p : j;  		double l_ij = edgeLengths [i' j];  		double k_ij = springConstants [i' j];  		double dx = positions [ii].X - positions [jj].X;  		double dy = positions [ii].Y - positions [jj].Y;  		energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergyIfExchanged,The following statement contains a magic number: for (int i = 0; i < vertices.Length - 1; i++) {  	for (int j = i + 1; j < vertices.Length; j++) {  		int ii = (i == p) ? q : i;  		int jj = (j == q) ? p : j;  		double l_ij = edgeLengths [i' j];  		double k_ij = springConstants [i' j];  		double dx = positions [ii].X - positions [jj].X;  		double dy = positions [ii].Y - positions [jj].Y;  		energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergyIfExchanged,The following statement contains a magic number: for (int j = i + 1; j < vertices.Length; j++) {  	int ii = (i == p) ? q : i;  	int jj = (j == q) ? p : j;  	double l_ij = edgeLengths [i' j];  	double k_ij = springConstants [i' j];  	double dx = positions [ii].X - positions [jj].X;  	double dy = positions [ii].Y - positions [jj].Y;  	energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergyIfExchanged,The following statement contains a magic number: for (int j = i + 1; j < vertices.Length; j++) {  	int ii = (i == p) ? q : i;  	int jj = (j == q) ? p : j;  	double l_ij = edgeLengths [i' j];  	double k_ij = springConstants [i' j];  	double dx = positions [ii].X - positions [jj].X;  	double dy = positions [ii].Y - positions [jj].Y;  	energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergyIfExchanged,The following statement contains a magic number: energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergyIfExchanged,The following statement contains a magic number: energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergy,The following statement contains a magic number: for (int i = 0; i < vertices.Length - 1; i++) {  	for (int j = i + 1; j < vertices.Length; j++) {  		dist = distances [i' j];  		l_ij = edgeLengths [i' j];  		k_ij = springConstants [i' j];  		dx = positions [i].X - positions [j].X;  		dy = positions [i].Y - positions [j].Y;  		energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergy,The following statement contains a magic number: for (int i = 0; i < vertices.Length - 1; i++) {  	for (int j = i + 1; j < vertices.Length; j++) {  		dist = distances [i' j];  		l_ij = edgeLengths [i' j];  		k_ij = springConstants [i' j];  		dx = positions [i].X - positions [j].X;  		dy = positions [i].Y - positions [j].Y;  		energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergy,The following statement contains a magic number: for (int j = i + 1; j < vertices.Length; j++) {  	dist = distances [i' j];  	l_ij = edgeLengths [i' j];  	k_ij = springConstants [i' j];  	dx = positions [i].X - positions [j].X;  	dy = positions [i].Y - positions [j].Y;  	energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergy,The following statement contains a magic number: for (int j = i + 1; j < vertices.Length; j++) {  	dist = distances [i' j];  	l_ij = edgeLengths [i' j];  	k_ij = springConstants [i' j];  	dx = positions [i].X - positions [j].X;  	dy = positions [i].Y - positions [j].Y;  	energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergy,The following statement contains a magic number: energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcEnergy,The following statement contains a magic number: energy += k_ij / 2 * (dx * dx + dy * dy + l_ij * l_ij - 2 * l_ij * Math.Sqrt (dx * dx + dy * dy));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	if (i != m) {  		//common things  		l = edgeLengths [m' i];  		k = springConstants [m' i];  		dx = positions [m].X - positions [i].X;  		dy = positions [m].Y - positions [i].Y;  		//distance between the points  		d = Math.Sqrt (dx * dx + dy * dy);  		ddd = Math.Pow (d' 3);  		dxm += k * (1 - l / d) * dx;  		dym += k * (1 - l / d) * dy;  		//TODO isn't it wrong?  		d2xm += k * (1 - l * Math.Pow (dy' 2) / ddd);  		//d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );  		dxmdym += k * l * dx * dy / ddd;  		//d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );  		//TODO isn't it wrong?  		d2ym += k * (1 - l * Math.Pow (dx' 2) / ddd);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	if (i != m) {  		//common things  		l = edgeLengths [m' i];  		k = springConstants [m' i];  		dx = positions [m].X - positions [i].X;  		dy = positions [m].Y - positions [i].Y;  		//distance between the points  		d = Math.Sqrt (dx * dx + dy * dy);  		ddd = Math.Pow (d' 3);  		dxm += k * (1 - l / d) * dx;  		dym += k * (1 - l / d) * dy;  		//TODO isn't it wrong?  		d2xm += k * (1 - l * Math.Pow (dy' 2) / ddd);  		//d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );  		dxmdym += k * l * dx * dy / ddd;  		//d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );  		//TODO isn't it wrong?  		d2ym += k * (1 - l * Math.Pow (dx' 2) / ddd);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	if (i != m) {  		//common things  		l = edgeLengths [m' i];  		k = springConstants [m' i];  		dx = positions [m].X - positions [i].X;  		dy = positions [m].Y - positions [i].Y;  		//distance between the points  		d = Math.Sqrt (dx * dx + dy * dy);  		ddd = Math.Pow (d' 3);  		dxm += k * (1 - l / d) * dx;  		dym += k * (1 - l / d) * dy;  		//TODO isn't it wrong?  		d2xm += k * (1 - l * Math.Pow (dy' 2) / ddd);  		//d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );  		dxmdym += k * l * dx * dy / ddd;  		//d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );  		//TODO isn't it wrong?  		d2ym += k * (1 - l * Math.Pow (dx' 2) / ddd);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: if (i != m) {  	//common things  	l = edgeLengths [m' i];  	k = springConstants [m' i];  	dx = positions [m].X - positions [i].X;  	dy = positions [m].Y - positions [i].Y;  	//distance between the points  	d = Math.Sqrt (dx * dx + dy * dy);  	ddd = Math.Pow (d' 3);  	dxm += k * (1 - l / d) * dx;  	dym += k * (1 - l / d) * dy;  	//TODO isn't it wrong?  	d2xm += k * (1 - l * Math.Pow (dy' 2) / ddd);  	//d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );  	dxmdym += k * l * dx * dy / ddd;  	//d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );  	//TODO isn't it wrong?  	d2ym += k * (1 - l * Math.Pow (dx' 2) / ddd);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: if (i != m) {  	//common things  	l = edgeLengths [m' i];  	k = springConstants [m' i];  	dx = positions [m].X - positions [i].X;  	dy = positions [m].Y - positions [i].Y;  	//distance between the points  	d = Math.Sqrt (dx * dx + dy * dy);  	ddd = Math.Pow (d' 3);  	dxm += k * (1 - l / d) * dx;  	dym += k * (1 - l / d) * dy;  	//TODO isn't it wrong?  	d2xm += k * (1 - l * Math.Pow (dy' 2) / ddd);  	//d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );  	dxmdym += k * l * dx * dy / ddd;  	//d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );  	//TODO isn't it wrong?  	d2ym += k * (1 - l * Math.Pow (dx' 2) / ddd);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: if (i != m) {  	//common things  	l = edgeLengths [m' i];  	k = springConstants [m' i];  	dx = positions [m].X - positions [i].X;  	dy = positions [m].Y - positions [i].Y;  	//distance between the points  	d = Math.Sqrt (dx * dx + dy * dy);  	ddd = Math.Pow (d' 3);  	dxm += k * (1 - l / d) * dx;  	dym += k * (1 - l / d) * dy;  	//TODO isn't it wrong?  	d2xm += k * (1 - l * Math.Pow (dy' 2) / ddd);  	//d2E_d2xm += k_mi * ( 1 - l_mi / d + l_mi * dx * dx / ddd );  	dxmdym += k * l * dx * dy / ddd;  	//d2E_d2ym += k_mi * ( 1 - l_mi / d + l_mi * dy * dy / ddd );  	//TODO isn't it wrong?  	d2ym += k * (1 - l * Math.Pow (dx' 2) / ddd);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: ddd = Math.Pow (d' 3);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: d2xm += k * (1 - l * Math.Pow (dy' 2) / ddd);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,KKLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\KKLayoutAlgorithm.cs,CalcDeltaXY,The following statement contains a magic number: d2ym += k * (1 - l * Math.Pow (dx' 2) / ddd);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: InitializeWithRandomPositions (1' 1' -0.5' -0.5);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: InitializeWithRandomPositions (1' 1' -0.5' -0.5);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int step = 1; step <= Parameters.iterationCount; step++) {  	ComputeBaryCenter ();  	quadTree = BuildQuadTree ();  	#region h�l�si f�ggv�ny meghat�roz�sa  	if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  		Parameters.attractionExponent = finalAttrExponent;  		Parameters.repulsiveExponent = finalRepuExponent;  		if (step <= 0.6 * Parameters.iterationCount) {  			// use energy model with few local minima   			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  		}  		else if (step <= 0.9 * Parameters.iterationCount) {  			// gradually move to final energy model  			Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  			Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		}  	}  	#endregion  	#region Move each node  	for (int i = 0; i < vertices.Length; i++) {  		var v = vertices [i];  		double oldEnergy = GetEnergy (i' quadTree);  		// compute direction of the move of the node  		Vector bestDir;  		GetDirection (i' quadTree' out bestDir);  		// line search: compute length of the move  		Point oldPos = v.Position;  		double bestEnergy = oldEnergy;  		int bestMultiple = 0;  		bestDir /= 32;  		//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  		for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//nagyobb mozgat�s eset�n van-e jobb megold�s?  		for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  			v.Position = oldPos + bestDir * multiple;  			double curEnergy = GetEnergy (i' quadTree);  			if (curEnergy < bestEnergy) {  				bestEnergy = curEnergy;  				bestMultiple = multiple;  			}  		}  		//legjobb megold�ssal mozgat�s  		v.Position = oldPos + bestDir * bestMultiple;  		if (bestMultiple > 0) {  			quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  		}  	}  	#endregion  	if (ReportOnIterationEndNeeded)  		Report (step);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0) {  	Parameters.attractionExponent = finalAttrExponent;  	Parameters.repulsiveExponent = finalRepuExponent;  	if (step <= 0.6 * Parameters.iterationCount) {  		// use energy model with few local minima   		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  	}  	else if (step <= 0.9 * Parameters.iterationCount) {  		// gradually move to final energy model  		Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  		Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.6 * Parameters.iterationCount) {  	// use energy model with few local minima   	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  }  else if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: if (step <= 0.9 * Parameters.iterationCount) {  	// gradually move to final energy model  	Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  	Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double)Parameters.iterationCount) / 0.3;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	var v = vertices [i];  	double oldEnergy = GetEnergy (i' quadTree);  	// compute direction of the move of the node  	Vector bestDir;  	GetDirection (i' quadTree' out bestDir);  	// line search: compute length of the move  	Point oldPos = v.Position;  	double bestEnergy = oldEnergy;  	int bestMultiple = 0;  	bestDir /= 32;  	//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  	for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//nagyobb mozgat�s eset�n van-e jobb megold�s?  	for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//legjobb megold�ssal mozgat�s  	v.Position = oldPos + bestDir * bestMultiple;  	if (bestMultiple > 0) {  		quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	var v = vertices [i];  	double oldEnergy = GetEnergy (i' quadTree);  	// compute direction of the move of the node  	Vector bestDir;  	GetDirection (i' quadTree' out bestDir);  	// line search: compute length of the move  	Point oldPos = v.Position;  	double bestEnergy = oldEnergy;  	int bestMultiple = 0;  	bestDir /= 32;  	//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  	for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//nagyobb mozgat�s eset�n van-e jobb megold�s?  	for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//legjobb megold�ssal mozgat�s  	v.Position = oldPos + bestDir * bestMultiple;  	if (bestMultiple > 0) {  		quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	var v = vertices [i];  	double oldEnergy = GetEnergy (i' quadTree);  	// compute direction of the move of the node  	Vector bestDir;  	GetDirection (i' quadTree' out bestDir);  	// line search: compute length of the move  	Point oldPos = v.Position;  	double bestEnergy = oldEnergy;  	int bestMultiple = 0;  	bestDir /= 32;  	//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  	for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//nagyobb mozgat�s eset�n van-e jobb megold�s?  	for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//legjobb megold�ssal mozgat�s  	v.Position = oldPos + bestDir * bestMultiple;  	if (bestMultiple > 0) {  		quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	var v = vertices [i];  	double oldEnergy = GetEnergy (i' quadTree);  	// compute direction of the move of the node  	Vector bestDir;  	GetDirection (i' quadTree' out bestDir);  	// line search: compute length of the move  	Point oldPos = v.Position;  	double bestEnergy = oldEnergy;  	int bestMultiple = 0;  	bestDir /= 32;  	//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  	for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//nagyobb mozgat�s eset�n van-e jobb megold�s?  	for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//legjobb megold�ssal mozgat�s  	v.Position = oldPos + bestDir * bestMultiple;  	if (bestMultiple > 0) {  		quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	var v = vertices [i];  	double oldEnergy = GetEnergy (i' quadTree);  	// compute direction of the move of the node  	Vector bestDir;  	GetDirection (i' quadTree' out bestDir);  	// line search: compute length of the move  	Point oldPos = v.Position;  	double bestEnergy = oldEnergy;  	int bestMultiple = 0;  	bestDir /= 32;  	//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  	for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//nagyobb mozgat�s eset�n van-e jobb megold�s?  	for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//legjobb megold�ssal mozgat�s  	v.Position = oldPos + bestDir * bestMultiple;  	if (bestMultiple > 0) {  		quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	var v = vertices [i];  	double oldEnergy = GetEnergy (i' quadTree);  	// compute direction of the move of the node  	Vector bestDir;  	GetDirection (i' quadTree' out bestDir);  	// line search: compute length of the move  	Point oldPos = v.Position;  	double bestEnergy = oldEnergy;  	int bestMultiple = 0;  	bestDir /= 32;  	//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  	for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//nagyobb mozgat�s eset�n van-e jobb megold�s?  	for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//legjobb megold�ssal mozgat�s  	v.Position = oldPos + bestDir * bestMultiple;  	if (bestMultiple > 0) {  		quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	var v = vertices [i];  	double oldEnergy = GetEnergy (i' quadTree);  	// compute direction of the move of the node  	Vector bestDir;  	GetDirection (i' quadTree' out bestDir);  	// line search: compute length of the move  	Point oldPos = v.Position;  	double bestEnergy = oldEnergy;  	int bestMultiple = 0;  	bestDir /= 32;  	//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  	for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//nagyobb mozgat�s eset�n van-e jobb megold�s?  	for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//legjobb megold�ssal mozgat�s  	v.Position = oldPos + bestDir * bestMultiple;  	if (bestMultiple > 0) {  		quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int i = 0; i < vertices.Length; i++) {  	var v = vertices [i];  	double oldEnergy = GetEnergy (i' quadTree);  	// compute direction of the move of the node  	Vector bestDir;  	GetDirection (i' quadTree' out bestDir);  	// line search: compute length of the move  	Point oldPos = v.Position;  	double bestEnergy = oldEnergy;  	int bestMultiple = 0;  	bestDir /= 32;  	//kisebb mozgat�sok eset�n a legjobb eset meghat�roz�sa  	for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//nagyobb mozgat�s eset�n van-e jobb megold�s?  	for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  		v.Position = oldPos + bestDir * multiple;  		double curEnergy = GetEnergy (i' quadTree);  		if (curEnergy < bestEnergy) {  			bestEnergy = curEnergy;  			bestMultiple = multiple;  		}  	}  	//legjobb megold�ssal mozgat�s  	v.Position = oldPos + bestDir * bestMultiple;  	if (bestMultiple > 0) {  		quadTree.MoveNode (oldPos' v.Position' v.RepulsionWeight);  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: bestDir /= 32;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  	v.Position = oldPos + bestDir * multiple;  	double curEnergy = GetEnergy (i' quadTree);  	if (curEnergy < bestEnergy) {  		bestEnergy = curEnergy;  		bestMultiple = multiple;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  	v.Position = oldPos + bestDir * multiple;  	double curEnergy = GetEnergy (i' quadTree);  	if (curEnergy < bestEnergy) {  		bestEnergy = curEnergy;  		bestMultiple = multiple;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int multiple = 32; multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple); multiple /= 2) {  	v.Position = oldPos + bestDir * multiple;  	double curEnergy = GetEnergy (i' quadTree);  	if (curEnergy < bestEnergy) {  		bestEnergy = curEnergy;  		bestMultiple = multiple;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: multiple /= 2
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  	v.Position = oldPos + bestDir * multiple;  	double curEnergy = GetEnergy (i' quadTree);  	if (curEnergy < bestEnergy) {  		bestEnergy = curEnergy;  		bestMultiple = multiple;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  	v.Position = oldPos + bestDir * multiple;  	double curEnergy = GetEnergy (i' quadTree);  	if (curEnergy < bestEnergy) {  		bestEnergy = curEnergy;  		bestMultiple = multiple;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  	v.Position = oldPos + bestDir * multiple;  	double curEnergy = GetEnergy (i' quadTree);  	if (curEnergy < bestEnergy) {  		bestEnergy = curEnergy;  		bestMultiple = multiple;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (int multiple = 64; multiple <= 128 && bestMultiple == multiple / 2; multiple *= 2) {  	v.Position = oldPos + bestDir * multiple;  	double curEnergy = GetEnergy (i' quadTree);  	if (curEnergy < bestEnergy) {  		bestEnergy = curEnergy;  		bestMultiple = multiple;  	}  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: multiple *= 2
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,Report,The following statement contains a magic number: OnIterationEnded (step' step / (double)Parameters.iterationCount * 100' "Iteration " + step + " finished."' true);  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: if (dir2 != 0.0) {  	dir /= dir2;  	double length = dir.Length;  	if (length > quadTree.Width / 8) {  		length /= quadTree.Width / 8;  		dir /= length;  	}  }  else {  	dir = new Vector (0' 0);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: if (dir2 != 0.0) {  	dir /= dir2;  	double length = dir.Length;  	if (length > quadTree.Width / 8) {  		length /= quadTree.Width / 8;  		dir /= length;  	}  }  else {  	dir = new Vector (0' 0);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: if (length > quadTree.Width / 8) {  	length /= quadTree.Width / 8;  	dir /= length;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: if (length > quadTree.Width / 8) {  	length /= quadTree.Width / 8;  	dir /= length;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: length /= quadTree.Width / 8;  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddAttractionDirection,The following statement contains a magic number: foreach (var e in v.Attractions) {  	//onhurkok elhagyasa  	if (e.Target == v)  		continue;  	Vector attractionVector = (e.Target.Position - v.Position);  	double dist = attractionVector.Length;  	if (dist <= 0)  		continue;  	double tmp = e.AttractionWeight * Math.Pow (dist' Parameters.attractionExponent - 2);  	dir2 += tmp * Math.Abs (Parameters.attractionExponent - 1);  	dir += (e.Target.Position - v.Position) * tmp;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddRepulsionDirection,The following statement contains a magic number: if (quadTree.Index < 0 && dist < 2.0 * quadTree.Width) {  	double dir2 = 0.0;  	for (int i = 0; i < quadTree.Children.Length; i++)  		dir2 += AddRepulsionDirection (index' quadTree.Children [i]' ref dir);  	return dir2;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,AddRepulsionDirection,The following statement contains a magic number: if (dist != 0.0) {  	double tmp = repulsionMultiplier * v.RepulsionWeight * quadTree.Weight * Math.Pow (dist' Parameters.repulsiveExponent - 2);  	dir -= repulsionVector * tmp;  	return tmp * Math.Abs (Parameters.repulsiveExponent - 1);  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,GetRepulsionEnergy,The following statement contains a magic number: if (tree.Index < 0 && dist < (2 * tree.Width)) {  	double energy = 0.0;  	for (int i = 0; i < tree.Children.Length; i++)  		energy += GetRepulsionEnergy (index' tree.Children [i]);  	return energy;  }  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The following statement contains a magic number: if (repulsionSum > 0 && attractionSum > 0)  	return attractionSum / Math.Pow (repulsionSum' 2) * Math.Pow (repulsionSum' 0.5 * (Parameters.attractionExponent - Parameters.repulsiveExponent));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The following statement contains a magic number: if (repulsionSum > 0 && attractionSum > 0)  	return attractionSum / Math.Pow (repulsionSum' 2) * Math.Pow (repulsionSum' 0.5 * (Parameters.attractionExponent - Parameters.repulsiveExponent));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The following statement contains a magic number: return attractionSum / Math.Pow (repulsionSum' 2) * Math.Pow (repulsionSum' 0.5 * (Parameters.attractionExponent - Parameters.repulsiveExponent));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,LinLogLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The following statement contains a magic number: return attractionSum / Math.Pow (repulsionSum' 2) * Math.Pow (repulsionSum' 0.5 * (Parameters.attractionExponent - Parameters.repulsiveExponent));  
Magic Number,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutParametersBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutParametersBase.cs,CalculateConstantOfRepulsion,The following statement contains a magic number: ConstantOfRepulsion = Math.Pow (K * _repulsiveMultiplier' 2);  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OneWayFSAAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OneWayFSAAlgorithm.cs,HorizontalImproved,The following statement contains a magic number: while (i < n) {  	var u = wrappedRectangles [i];  	//i-vel azonos középponttal rendelkező téglalapok meghatározása  	int k = i;  	for (int j = i + 1; j < n; j++) {  		var v = wrappedRectangles [j];  		if (u.CenterX == v.CenterX) {  			u = v;  			k = j;  		}  		else {  			break;  		}  	}  	double g = 0;  	//ne legyenek ugyanabban a pontban  	for (int z = i + 1; z <= k; z++) {  		var v = wrappedRectangles [z];  		v.Rectangle.X += (z - i) * 0.0001;  	}  	//i-k intervallumban lévő téglalapokra erőszámítás a tőlük balra lévőkkel  	if (u.CenterX > x0) {  		for (int m = i; m <= k; m++) {  			double ggg = 0;  			for (int j = 0; j < i; j++) {  				var f = force (wrappedRectangles [j].Rectangle' wrappedRectangles [m].Rectangle);  				ggg = Math.Max (f.X + gamma [j]' ggg);  			}  			var v = wrappedRectangles [m];  			double gg = v.Rectangle.Left + ggg < lmin.Rectangle.Left ? sigma : ggg;  			g = Math.Max (g' gg);  		}  	}  	//megjegyezzük az elemek eltolásást x tömbbe  	//bal szélő elemet újra meghatározzuk  	for (int m = i; m <= k; m++) {  		gamma [m] = g;  		var r = wrappedRectangles [m];  		x [m] = r.Rectangle.Left + g;  		if (r.Rectangle.Left < lmin.Rectangle.Left) {  			lmin = r;  		}  	}  	//az i-k intervallum négyzeteitől jobbra lévőkkel erőszámítás' legnagyobb erő tárolása  	// delta = max(0' max{f.x(m'j)|i<=m<=k<j<n})  	double delta = 0;  	for (int m = i; m <= k; m++) {  		for (int j = k + 1; j < n; j++) {  			var f = force (wrappedRectangles [m].Rectangle' wrappedRectangles [j].Rectangle);  			if (f.X > delta) {  				delta = f.X;  			}  		}  	}  	sigma += delta;  	i = k + 1;  }  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OneWayFSAAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OneWayFSAAlgorithm.cs,HorizontalImproved,The following statement contains a magic number: for (int z = i + 1; z <= k; z++) {  	var v = wrappedRectangles [z];  	v.Rectangle.X += (z - i) * 0.0001;  }  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OneWayFSAAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OneWayFSAAlgorithm.cs,HorizontalImproved,The following statement contains a magic number: v.Rectangle.X += (z - i) * 0.0001;  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,AddGaps,The following statement contains a magic number: foreach (var r in wrappedRectangles) {  	r.Rectangle.Width += Parameters.HorizontalGap;  	r.Rectangle.Height += Parameters.VerticalGap;  	r.Rectangle.Offset (-Parameters.HorizontalGap / 2' -Parameters.VerticalGap / 2);  }  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,AddGaps,The following statement contains a magic number: foreach (var r in wrappedRectangles) {  	r.Rectangle.Width += Parameters.HorizontalGap;  	r.Rectangle.Height += Parameters.VerticalGap;  	r.Rectangle.Offset (-Parameters.HorizontalGap / 2' -Parameters.VerticalGap / 2);  }  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,AddGaps,The following statement contains a magic number: r.Rectangle.Offset (-Parameters.HorizontalGap / 2' -Parameters.VerticalGap / 2);  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,AddGaps,The following statement contains a magic number: r.Rectangle.Offset (-Parameters.HorizontalGap / 2' -Parameters.VerticalGap / 2);  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,RemoveGaps,The following statement contains a magic number: foreach (var r in wrappedRectangles) {  	r.Rectangle.Width -= Parameters.HorizontalGap;  	r.Rectangle.Height -= Parameters.VerticalGap;  	r.Rectangle.Offset (Parameters.HorizontalGap / 2' Parameters.VerticalGap / 2);  }  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,RemoveGaps,The following statement contains a magic number: foreach (var r in wrappedRectangles) {  	r.Rectangle.Width -= Parameters.HorizontalGap;  	r.Rectangle.Height -= Parameters.VerticalGap;  	r.Rectangle.Offset (Parameters.HorizontalGap / 2' Parameters.VerticalGap / 2);  }  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,RemoveGaps,The following statement contains a magic number: r.Rectangle.Offset (Parameters.HorizontalGap / 2' Parameters.VerticalGap / 2);  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalAlgorithmBase,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,RemoveGaps,The following statement contains a magic number: r.Rectangle.Offset (Parameters.HorizontalGap / 2' Parameters.VerticalGap / 2);  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalHelper.cs,GetCenter,The following statement contains a magic number: return new Point (r.Left + r.Width / 2' r.Top + r.Height / 2);  
Magic Number,GraphSharp.Algorithms.OverlapRemoval,OverlapRemovalHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\OverlapRemoval\OverlapRemovalHelper.cs,GetCenter,The following statement contains a magic number: return new Point (r.Left + r.Width / 2' r.Top + r.Height / 2);  
Missing Default,GraphSharp.Algorithms.Layout.Simple.Tree,SimpleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\Tree\SimpleTreeLayoutAlgorithm.cs,GenerateSpanningTree,The following switch statement is missing a default case: switch (Parameters.SpanningTreeGeneration) {  case SpanningTreeGeneration.BFS:  	var bfsAlgo = new BreadthFirstSearchAlgorithm<TVertex' TEdge> (VisitedGraph' vb' new Dictionary<TVertex' GraphColor> ());  	bfsAlgo.TreeEdge += e => spanningTree.AddEdge (new Edge<TVertex> (e.Source' e.Target));  	bfsAlgo.Compute ();  	break;  case SpanningTreeGeneration.DFS:  	var dfsAlgo = new DepthFirstSearchAlgorithm<TVertex' TEdge> (VisitedGraph);  	dfsAlgo.TreeEdge += e => spanningTree.AddEdge (new Edge<TVertex> (e.Source' e.Target));  	dfsAlgo.Compute ();  	break;  }  
Missing Default,GraphSharp.Algorithms.Layout.Contextual,DoubleTreeLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Contextual\DoubleTreeLayoutAlgorithm.cs,InternalCompute,The following switch statement is missing a default case: switch (side2Direction) {  case LayoutDirection.BottomToTop:  	side1Direction = LayoutDirection.TopToBottom;  	break;  case LayoutDirection.LeftToRight:  	side1Direction = LayoutDirection.RightToLeft;  	break;  case LayoutDirection.RightToLeft:  	side1Direction = LayoutDirection.LeftToRight;  	break;  case LayoutDirection.TopToBottom:  	side1Direction = LayoutDirection.BottomToTop;  	break;  }  
Missing Default,GraphSharp.Algorithms.Layout.Simple.FDP,FRLayoutAlgorithm,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp\Algorithms\Layout\Simple\FDP\FRLayoutAlgorithm.cs,InternalCompute,The following switch statement is missing a default case: switch (Parameters._coolingFunction) {  case FRCoolingFunction.Linear:  	_temperature *= (1.0 - (double)i / (double)Parameters._iterationLimit);  	break;  case FRCoolingFunction.Exponential:  	_temperature *= Parameters._lambda;  	break;  }  
